<appendix id="migration">
 <title>Migrating von PHP/FI 2.0 zu PHP 3.0</title>

 <sect1 id="migration-about">
  <title>Über die Inkompatbilitäten in 3.0</title>
  <simpara>
   PHP 3.0 wurde komplett neu geschrieben. Es hat einen korrekten Parser,
   der robuster und konsequenter ist, als der in 2.0.  3.0 ist auch
   wesentlich schneller und benötigt weniger Speicher.  Wie auch immer, manche
   dieser Verbesserungen wären ohne Änderungen der Kompatibilität
   nicht möglich gewesen, sowohl in der Syntax, als auch in der Funktionalität.</simpara>

  <simpara>
   Außerdem haben die PHP-Entwickler versucht, sowohl die Syntax, als auch
   die Semantik von PHP in Version 3.0 zu säubern, was einige zusätzliche
   Inkompatbilitäten nach sich zog.  Auf lange Sicht glauben wir, daß diese
   Änderungen von Vorteil sind.</simpara>

  <simpara>
   Dieses Kapitel wird versuchen, Sie durch die Inkompatbilitäten,
   die beim Umstieg von PHP/FI 2.0 zu PHP 3.0 vorkommen können, zu geleiten 
   und helfen, diese zu lösen. Neue Merkmale werden nicht berücksichtigt, außer
   dies ist unbedingt notwendig.</simpara>

  <simpara>
   Ein Konvertierungsprogramm, welches Ihre PHP/FI 2.0 Scripts konvertieren kann, steht zur Verfügung.  
   Zu finden ist es im <filename class="directory">convertor</filename> Verzeichnis der    PHP 3.0 Distribution. Dieses Programm berücksichtigt nur Syntaxänderungen,
   also sollten Sie dieses Kapitel aufmerksam lesen.</simpara></sect1>

 <sect1 id="migration-startendtags">
  <title>Start-/End-Tags</title>

  <para>
   Das Erste, was Sie vermutlich feststellen werden ist, daß sich die Start- und End-Tags von PHP
   geändert haben. Die alte Form <literal>&lt;? &gt;</literal> wurde durch drei
   neue Möglichkeiten ersetzt:
   <example>
    <title>Migration: Alte Start-/End-Tags</title>
    <programlisting>
&lt;? echo "Das ist PHP/FI 2.0 Code.\n"; &gt;
</programlisting></example>

   Ab Version 2.0 unterstützt PHP/FI auch diese Möglichkeit:

   <example><title>Migration: Erste neue Start-/End-Tags</title>
    <programlisting>
&lt;? echo "Das ist PHP 3.0 Ccode!\n"; ?&gt;
</programlisting></example>

   Beachten Sie, daß das End-Tag jetzt ein Fragzeichen und ein "Größer-als"-Zeichen beinhaltet anstatt
   nur ein "Größer-als"-Zeichen.  Wie auch immer, wenn Sie vor haben,
   XML auf Ihrem Server zu verwenden, werden Sie Probleme mit der
   ersten neuen Möglichkeit bekommen, weil PHP versuchen wird, das XML 
   in XML-Dokumenten als PHP-Code auszuführen. Deshalb wurde die 
   folgende Variante eingeführt:

   <example><title>Migration: Zweite neue Start-/End-Tags</title>
    <programlisting>
&lt;?php echo "Das ist PHP 3.0 Code!\n"; ?&gt;
</programlisting></example>

   Manche Leute hatten Probleme mit Editoren, die die Tags gar nicht
   verstanden haben.  Microsoft FrontPage ist ein solcher Editor
   und als Workaround wurde zusätzlich die folgende Variante
   eingeführt:

   <example><title>Migration: third new start/end tags</title>
    <programlisting>
&lt;script language="php"&gt;

  echo "Das ist PHP 3.0 Code!\n";

&lt;/script&gt;
</programlisting></example></para></sect1>


 <sect1 id="migration-if-endif">
  <title>if..endif Syntax</title>

  <para>
   Der `alternative' Weg, if/elseif/else Statements mittels if();
   elseif(); else; endif; zu schreiben, kann nicht effizient eingebaut werden, ohne
   eine große Komplexität zum 3.0 Parser hinzuzufügen. Deshalb
   wurde die Syntax geändert:
   <example>
    <title>Migration: Alte if..endif Syntax</title>
    <programlisting>
if ($foo);
    echo "jau\n";
elseif ($bar);
    echo "fast\n";
else;
    echo "nö\n";
endif;
</programlisting></example>
   <example>
    <title>Migration: Neue if..endif Syntax</title>
    <programlisting>
if ($foo):
    echo "jau\n";
elseif ($bar):
    echo "fast\n";
else:
    echo "nö\n";
endif;
</programlisting></example>

   Beachten Sie, daß Semikolons in allen Anweisungen durch Doppelpunkte
   ersetz wurden außer in der, welche die Anweisung schließt (endif).</para></sect1>

 <sect1 id="migration-while">
  <title>while Syntax</title>
  <para>
   wie auch bei if..endif hat sich auch die Syntax von while..endwhile
   geändert:
   <example><title>Migration: Alte while..endwhile Syntax</title>
   <programlisting>
while ($noch_mehr);
    ...
endwhile;
</programlisting></example>
   <example><title>Migration: Neue while..endwhile Syntax</title>
   <programlisting>
while ($noch_mehr):
    ...
endwhile;
</programlisting></example>
  </para>
  <warning>
   <simpara>
    Wenn Sie die alte while..endwhile Syntax in PHP 3.0 benutzen werden Sie
    eine nicht endende Schleife erhalten.
   </simpara>
  </warning></sect1>

 <sect1 id="migration-expr">
  <title>Ausdruckstypen</title>
  <simpara>
   PHP/FI 2.0 benutzte die linke Seite von Ausdrücken, um herauszufinden, wie das
   Ergebnis aussehen soll.  PHP 3.0 zieht beide Seiten in Betracht um den Ergebnistypen
   zu bestimmen. Dies kann bei 2.0 Scripts dazu führen, sich in 3.0 unerwartet zu 
   verhalten.</simpara>
  <simpara></simpara>

  <para>
   Betrachten Sie dieses Beispiel:
   <informalexample><programlisting>
$a[0]=5;
$a[1]=7;

$key = key($a);
while ("" != $key) {
    echo "$keyn";
    next($a);
}
</programlisting></informalexample>

   In PHP/FI 2.0 würde dies beide Kennziffern von $a anzeigen. In PHP
   3.0 würde gar nichts angezeigt werden.  Der Grund ist, daß in PHP 2.0,
   aufgrund des "linken" Arguments des Strings, ein Vergleich des Strings
   gemacht wurde, <literal>""</literal> ist in der Tat nicht das selbe
   wie <literal>"0"</literal>, was dazu führt, das die Schleife durchläuft.
   In PHP 3.0, when a string is compared with an integer, an integer comparison is
   made (the string is converted to an integer).  This results in
   comparing <literal>atoi("")</literal> which is
   <literal>0</literal>, and <literal>variablelist</literal> which is
   also <literal>0</literal>, and since <literal>0==0</literal>, the
   loop doesn't go through even once.

  </para>
  <para>
   Dies zu reparieren ist einfach. Ersetzen Sie das While-Statement mit:
   <informalexample><programlisting>
while ((string)$key != "") {
</programlisting></informalexample></para></sect1>


 <sect1 id="migration-errors">
  <title>Änderung der Fehlermeldungen</title>
  <simpara>
   Die Fehlermeldungen von PHP 3.0 sind für gwöhnlich genauer als die in 2.0,
   allerdings sehen Sie nicht mehr das Codefragment, welches den Fehler erzeugt.
   Obwohl Sie den Dateinamen und die Zeilennummer des Fehlers angezeigt
   bekommen.
  </simpara></sect1>


 <sect1 id="migration-booleval">
  <title>Short-circuited boolean evaluation</title>
  <simpara>
   In PHP 3.0 boolean evaluation is short-circuited.  This means that
   in an expression like <literal>(1 || test_me())</literal>, the
   function <function>test_me</function> would not be executed since
   nothing can change the result of the expression after the
   <literal>1</literal>.</simpara>
    
  <simpara>
   This is a minor compatibility issue, but may cause unexpected
   side-effects.</simpara></sect1>


 <sect1 id="migration-truefalse">
  <title>Function true/false return values</title>
  <simpara>
   Most internal functions have been rewritten so they return TRUE
   when successful and FALSE when failing, as opposed to 0 and -1 in
   PHP/FI 2.0, respectively.  The new behaviour allows for more
   logical code, like <literal>$fp = fopen("/your/file") or
    fail("darn!");</literal>.  Because PHP/FI 2.0 had no clear rules
   for what functions should return when they failed, most such
   scripts will probably have to be checked manually after using the
   2.0 to 3.0 convertor.</simpara>
  <para>
   <example>
    <title>Migration von 2.0: Rückgabewerte, alter Code</title>
    <programlisting>
$fp = fopen($file, "r");
if ($fp == -1);
    echo("Konnte $file zum lesen nicht &ouml;ffnen&lt;br&gt;\n");
endif;
</programlisting>
   </example>
   <example>
    <title>Migration von 2.0: Rückgabewerte, neuer Code</title>
    <programlisting>
$fp = @fopen($file, "r") or print("Konnte $file zum lesen nicht &ouml;ffnen&lt;br&gt;\n");
</programlisting>
   </example></para></sect1>

   
 <sect1 id="migration-other">
  <title>Andere Inkompatibilitäten</title>

   <itemizedlist>
    <listitem><simpara>
      Das PHP 3.0 Apache Modul unterstützt keine Apache Versionen mehr, die älter als
      1.2 sind.  Apache 1.2 oder neuer wird benötigt.</simpara></listitem>

    <listitem><simpara> <function>echo</function> no longer
    supports a format string.  Use the
    <function>printf</function> function instead.</simpara></listitem>

    <listitem><simpara>
      In PHP/FI 2.0, an implementation side-effect caused
      <literal>$foo[0]</literal> to have the same effect as
      <literal>$foo</literal>.  This is not true for PHP 3.0.</simpara></listitem>

    <listitem><simpara>
      Das Auslesen von Arrays mit <literal>$array[]</literal> wird nicht 
      mehr unterstützt</simpara>

     <simpara>
      That is, you cannot traverse an array by having a loop that does
      <literal>$data = $array[]</literal>.  Use
      <function>current</function> and <function>next</function>
      instead.</simpara>
     <simpara>
      Also, <literal>$array1[] = $array2</literal> does not append the
      values of <literal>$array2</literal> to <literal>$array1</literal>,
      but appends <literal>$array2</literal> as the last entry of
      <literal>$array1</literal>.  See also multidimensional array
      support.</simpara></listitem>

    <listitem>
     <simpara> <literal>"+"</literal> is no longer overloaded as a
     concatenation operator for strings, instead it converts it's
     arguments to numbers and performs numeric addition. Use
     <literal>"."</literal> instead.</simpara></listitem>
   </itemizedlist>

        <example>
          <title>Migration from 2.0: concatenation for strings</title>
          <programlisting>
echo "1" + "1";
</programlisting>

         <para> 
          In PHP 2.0 this would echo 11, in PHP 3.0 it would echo 2. Instead
          use:

          <programlisting>
echo "1"."1";
</programlisting>

          <programlisting>
$a = 1;
$b = 1;
echo $a + $b;
</programlisting></para>

         <para>  
          This would echo 2 in both PHP 2.0 and 3.0.

          <programlisting>
$a = 1;
$b = 1;
echo $a.$b;
</programlisting>
          This will echo 11 in PHP 3.0.</para>
	</example></sect1>

 </appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
