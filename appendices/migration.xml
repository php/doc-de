<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.9 $ -->
<!-- EN-Revision: 1.10 Maintainer: mk Status: working -->
<appendix id="migration">
 <title>Migration von PHP/FI 2.0 zu PHP 3.0</title>

 <sect1 id="migration-about">
  <title>Über die Inkompatbilitäten in 3.0</title>
  <simpara>
   PHP 3.0 wurde komplett neu geschrieben. Es hat einen korrekten Parser,
   der robuster und konsequenter ist, als der in 2.0.  3.0 ist auch
   wesentlich schneller und benötigt weniger Speicher.  Wie auch immer, manche
   dieser Verbesserungen wären ohne Änderungen der Kompatibilität
   nicht möglich gewesen, sowohl in der Syntax, als auch in der Funktionalität.</simpara>

  <simpara>
   Außerdem haben die PHP-Entwickler versucht, sowohl die Syntax, als auch
   die Semantik von PHP in Version 3.0 zu säubern, was einige zusätzliche
   Inkompatbilitäten nach sich zog.  Auf lange Sicht glauben wir, dass diese
   Änderungen von Vorteil sind.</simpara>

  <simpara>
   Dieses Kapitel wird versuchen, Sie durch die Inkompatbilitäten,
   die beim Umstieg von PHP/FI 2.0 zu PHP 3.0 vorkommen können, zu geleiten 
   und helfen, diese zu lösen. Neue Merkmale werden nicht berücksichtigt, außer
   dies ist unbedingt notwendig.</simpara>

  <simpara>
   Ein Konvertierungsprogramm, welches Ihre PHP/FI 2.0 Scripts konvertieren kann, steht zur Verfügung.  
   Zu finden ist es im <filename class="directory">convertor</filename> Verzeichnis der    PHP 3.0 Distribution. Dieses Programm berücksichtigt nur Syntaxänderungen,
   also sollten Sie dieses Kapitel aufmerksam lesen.
  </simpara>
 </sect1>

 <sect1 id="migration-startendtags">
  <title>Start-/End-Tags</title>

  <para>
   Das Erste, was Sie vermutlich feststellen werden ist, dass sich die Start- und End-Tags von PHP
   geändert haben. Die alte Form <literal>&lt;? &gt;</literal> wurde durch drei
   neue Möglichkeiten ersetzt:
   <example>
    <title>Migration: Alte Start-/End-Tags</title>
    <programlisting role="php">
<![CDATA[
<? echo "Das ist PHP/FI 2.0 Code.\n"; ?>
]]>
</programlisting>
</example>

   Ab Version 2.0 unterstützt PHP/FI auch diese Möglichkeit:

   <example><title>Migration: Erste neue Start-/End-Tags</title>
    <programlisting role="php">
<![CDATA[
<? echo "Das ist PHP 3.0 Ccode!\n"; ?>
]]>
</programlisting></example>

   Beachten Sie, dass das End-Tag jetzt ein Fragzeichen und ein "Größer-als"-Zeichen beinhaltet anstatt
   nur ein "Größer-als"-Zeichen.  Wie auch immer, wenn Sie vor haben,
   XML auf Ihrem Server zu verwenden, werden Sie Probleme mit der
   ersten neuen Möglichkeit bekommen, weil PHP versuchen wird, das XML 
   in XML-Dokumenten als PHP-Code auszuführen. Deshalb wurde die 
   folgende Variante eingeführt:

   <example><title>Migration: Zweite neue Start-/End-Tags</title>
    <programlisting role="php">
<![CDATA[
<?php echo "Das ist PHP 3.0 Code!\n"; ?>
]]>
</programlisting></example>

   Manche Leute hatten Probleme mit Editoren, die die Tags gar nicht
   verstanden haben.  Microsoft FrontPage ist ein solcher Editor
   und als Workaround wurde zusätzlich die folgende Variante
   eingeführt:

   <example><title>Migration: third new start/end tags</title>
    <programlisting role="php">
<![CDATA[
<script language="php">

  echo "Das ist PHP 3.0 Code!\n";

</script>
]]>
</programlisting></example></para></sect1>


 <sect1 id="migration-if-endif">
  <title>if..endif Syntax</title>

  <para>
   Der `alternative' Weg, if/elseif/else Statements mittels if();
   elseif(); else; endif; zu schreiben, kann nicht effizient eingebaut werden, ohne
   eine große Komplexität zum 3.0 Parser hinzuzufügen. Deshalb
   wurde die Syntax geändert:
   <example>
    <title>Migration: Alte if..endif Syntax</title>
    <programlisting role="php">
<![CDATA[
if ($foo);
    echo "jau\n";
elseif ($bar);
    echo "fast\n";
else;
    echo "nö\n";
endif;
]]>
</programlisting></example>
   <example>
    <title>Migration: Neue if..endif Syntax</title>
    <programlisting role="php">
<![CDATA[
if ($foo):
    echo "jau\n";
elseif ($bar):
    echo "fast\n";
else:
    echo "nö\n";
endif;
]]>
</programlisting></example>

   Beachten Sie, dass Semikolons in allen Anweisungen durch Doppelpunkte
   ersetz wurden außer in der, welche die Anweisung schließt (endif).</para></sect1>

 <sect1 id="migration-while">
  <title>while Syntax</title>
  <para>
   wie auch bei if..endif hat sich auch die Syntax von while..endwhile
   geändert:
   <example><title>Migration: Alte while..endwhile Syntax</title>
    <programlisting role="php">
<![CDATA[
while ($noch_mehr);
    ...
endwhile;
]]>
</programlisting></example>
   <example><title>Migration: Neue while..endwhile Syntax</title>
    <programlisting role="php">
<![CDATA[
while ($noch_mehr):
    ...
endwhile;
]]>
</programlisting></example>
  </para>
  <warning>
   <simpara>
    Wenn Sie die alte while..endwhile Syntax in PHP 3.0 benutzen werden Sie
    eine nicht endende Schleife erhalten.
   </simpara>
  </warning></sect1>

 <sect1 id="migration-expr">
  <title>Ausdruckstypen</title>
  <simpara>
   PHP/FI 2.0 benutzte die linke Seite von Ausdrücken, um herauszufinden, wie das
   Ergebnis aussehen soll.  PHP 3.0 zieht beide Seiten in Betracht um den Ergebnistypen
   zu bestimmen. Dies kann bei 2.0 Scripts dazu führen, sich in 3.0 unerwartet zu 
   verhalten.</simpara>
  <simpara></simpara>

  <para>
   Betrachten Sie dieses Beispiel:
   <informalexample>
    <programlisting role="php">
<![CDATA[
$a[0]=5;
$a[1]=7;

$key = key($a);
while ("" != $key) {
    echo "$keyn";
    next($a);
}
]]>
</programlisting></informalexample>

   In PHP/FI 2.0 würde dies beide Kennziffern von $a anzeigen. In PHP
   3.0 würde gar nichts angezeigt werden.  Der Grund ist, dass in PHP 2.0,
   aufgrund des "linken" Arguments des Strings, ein Vergleich des Strings
   gemacht wurde, <literal>""</literal> ist in der Tat nicht das selbe
   wie <literal>"0"</literal>, was dazu führt, das die Schleife durchläuft.
   Wenn man in PHP 3.0 einen String mit einem Integer vergleicht, so wird ein Vergleich zweier Interger vorgenommen
   (der String wir in einen Integer umgewandelt).  Dies führt dazu, dass
    <literal>atoi("")</literal>, was 
   <literal>0</literal> ist, und <literal>variablelist</literal>, was genauso
    <literal>0</literal> ist, vergleichen werden. Und weil <literal>0==0</literal>, würde die
   Schleife nicht ein einziges Mal durchlaufen.

  </para>
  <para>
   Dies zu reparieren ist einfach. Ersetzen Sie das While-Statement mit:
   <informalexample>
    <programlisting role="php">
<![CDATA[
while ((string)$key != "") {
]]>
</programlisting></informalexample></para></sect1>


 <sect1 id="migration-errors">
  <title>Änderung der Fehlermeldungen</title>
  <simpara>
   Die Fehlermeldungen von PHP 3.0 sind für gwöhnlich genauer als die in 2.0,
   allerdings sehen Sie nicht mehr das Codefragment, welches den Fehler erzeugt.
   Obwohl Sie den Dateinamen und die Zeilennummer des Fehlers angezeigt
   bekommen.
  </simpara></sect1>


 <sect1 id="migration-booleval">
  <title>Short-circuited boolean evaluation</title>
  <simpara>
   In PHP 3.0 boolean evaluation is short-circuited.  This means that
   in an expression like <literal>(1 || test_me())</literal>, the
   function <function>test_me</function> would not be executed since
   nothing can change the result of the expression after the
   <literal>1</literal>.</simpara>
    
  <simpara>
   This is a minor compatibility issue, but may cause unexpected
   side-effects.</simpara></sect1>


 <sect1 id="migration-truefalse">
  <title>Function &true;/false return values</title>
  <simpara>
   Most internal functions have been rewritten so they return &true;
   when successful and &false; when failing, as opposed to 0 and -1 in
   PHP/FI 2.0, respectively.  The new behaviour allows for more
   logical code, like <literal>$fp = fopen("/your/file") or
    fail("darn!");</literal>.  Because PHP/FI 2.0 had no clear rules
   for what functions should return when they failed, most such
   scripts will probably have to be checked manually after using the
   2.0 to 3.0 convertor.</simpara>
  <para>
   <example>
    <title>Migration von 2.0: Rückgabewerte, alter Code</title>
    <programlisting role="php">
<![CDATA[
$fp = fopen($file, "r");
if ($fp == -1);
    echo("Konnte $file zum lesen nicht &ouml;ffnen&lt;br&gt;\n");
endif;
]]>
</programlisting>
   </example>
   <example>
    <title>Migration von 2.0: Rückgabewerte, neuer Code</title>
    <programlisting role="php">
<![CDATA[
$fp = @fopen($file, "r") or print("Konnte $file zum lesen nicht &ouml;ffnen<br>;\n");
]]>
</programlisting>
   </example></para></sect1>

   
 <sect1 id="migration-other">
  <title>Andere Inkompatibilitäten</title>

   <itemizedlist>
    <listitem><simpara>
      Das PHP 3.0 Apache Modul unterstützt keine Apache Versionen mehr, die älter als
      1.2 sind.  Apache 1.2 oder neuer wird benötigt.</simpara></listitem>

    <listitem><simpara> <function>echo</function> no longer
    supports a format string.  Use the
    <function>printf</function> function instead.</simpara></listitem>

    <listitem><simpara>
      In PHP/FI 2.0, an implementation side-effect caused
      <literal>$foo[0]</literal> to have the same effect as
      <literal>$foo</literal>.  This is not &true; for PHP 3.0.</simpara></listitem>

    <listitem><simpara>
      Das Auslesen von Arrays mit <literal>$array[]</literal> wird nicht 
      mehr unterstützt</simpara>

     <simpara>
      That is, you cannot traverse an array by having a loop that does
      <literal>$data = $array[]</literal>.  Use
      <function>current</function> and <function>next</function>
      instead.</simpara>
     <simpara>
      Also, <literal>$array1[] = $array2</literal> does not append the
      values of <literal>$array2</literal> to <literal>$array1</literal>,
      but appends <literal>$array2</literal> as the last entry of
      <literal>$array1</literal>.  See also multidimensional array
      support.</simpara></listitem>

    <listitem>
     <simpara> <literal>"+"</literal> is no longer overloaded as a
     concatenation operator for strings, instead it converts it's
     arguments to numbers and performs numeric addition. Use
     <literal>"."</literal> instead.</simpara></listitem>
   </itemizedlist>

        <example>
          <title>Migration from 2.0: concatenation for strings</title>
    <programlisting role="php">
<![CDATA[
echo "1" + "1";
]]>
</programlisting>

         <para> 
          In PHP 2.0 würde dies 11 ausgeben, in PHP 3.0 2. Verwenden Sie stattdessen:

    <programlisting role="php">
<![CDATA[
echo "1"."1";
]]>
</programlisting>

    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a + $b;
]]>
</programlisting></para>

         <para>  
          Dies würde sowohl in PHP 2.0 als auch in 3.0 2 ausgeben.

    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a.$b;
]]>
</programlisting>
          Dies gibt in PHP 3.0 11 aus.</para>
	</example></sect1>

 </appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
