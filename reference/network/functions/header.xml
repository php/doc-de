<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.3 $ -->
<!-- EN-Revision: 1.1 Maintainer: sammywg Status: ready -->
  <refentry xml:id="function.header" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
   <refnamediv>
    <refname>header</refname>
    <refpurpose>Sendet einen HTTP-Header in Rohform</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Beschreibung</title>
     <methodsynopsis>
      <type>void</type><methodname>header</methodname>
      <methodparam><type>string</type><parameter>string</parameter></methodparam>
      <methodparam choice="opt"><type>bool</type><parameter>replace</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>http_response_code</parameter></methodparam>
     </methodsynopsis>
     <para>
      <function>header</function> wird zum Senden von
      <acronym>HTTP</acronym> Anfangsinformationen (Headern) im Rohformat
      benutzt. Weitere Informationen über die <acronym>HTTP</acronym> Header
      finden Sie in der <link xlink:href="&url.rfc;2616">HTTP/1.1 Spezifikation</link>.
     </para>
     <note>
      <para>
       Seit PHP 4.4.2 und PHP 5.1.2 unterbindet die Funktion das gleichzeitige
       Versenden mehrerer Header zum Schutz gegen Header Injection Angriffe.
      </para>
     </note>
     <para>
      Der optionale Parameter <parameter>replace</parameter> gibt an, ob der
      Header einen vorhergehenden gleichartigen Header ersetzten soll, oder ob
      ein zweiter Header des selben Typs hinzugefügt werden soll. Standardmäßig
      wird ersetzt, wenn Sie als zweites Argument &false; übergeben, können Sie
      so mehrere Header desselben Typs erzwingen. Zum Beispiel:
     </para>
     <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
header('WWW-Authenticate: Negotiate');
header('WWW-Authenticate: NTLM', false);
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Der zweite optionale Parameter <parameter>http_response_code</parameter>
     spezifiziert den HTTP Response Code des angegebenen Wertes. (Dieser
     Parameter ist in PHP 4.3.0 und höher verfügbar.)
    </para>
    <para>
     Es gibt zwei Spezialfälle von Header-Aufrufen. Der erste ist ein
     Header, der mit "<literal>HTTP/</literal>" beginnt (ob Groß- oder
     Kleinschreibung ist nicht relevant) und zum Herausfinden des zu
     sendenden HTTP Statuscodes verwendet wird. Wenn Sie zum Beispiel
     Apache konfiguriert haben, um ein PHP Skript zum Bearbeiten von
     Anforderungen fehlender Dateien (mittels der
     <literal>ErrorDocument</literal> Direktive) zu verwenden, möchten
     Sie bestimmt sicherstellen, dass Ihr Skript den passenden Statuscode
     generiert.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
header("HTTP/1.0 404 Not Found");
?>
]]>
      </programlisting>
     </informalexample>
    </para>
     <note>
      <para>
       Die HTTP Status Header Zeile wird immer die erste zum Client gesendete
       sein, egal ob der aktuelle <function>header</function>-Aufruf der erste
       ist oder nicht. Der Status kann mittels <function>header</function>
       jederzeit mit einer neuen Statuszeile überschrieben werden, sofern die
       HTTP Header noch nicht gesendet wurden.
      </para>
     </note>
     <para>
      Der zweite Spezialfall ist der "Location:" Header. Es wird nicht nur
      der Header an den Browser geschickt, sondern auch ein
      <literal>REDIRECT</literal> (302) Statuscode, wenn nicht bereits ein
      <literal>3xx</literal> Statuscode gesendet wurde.
     </para>
     <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
header("Location: http://www.example.com/"); /* Browser umleiten */

/* Stellen Sie sicher, dass der nachfolgende Code nicht ausgefuehrt wird, wenn
   eine Umleitung stattfindet. */
exit;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      HTTP/1.1 verlangt einen absoluten <acronym>URI</acronym> inklusive dem
      Schema, Hostnamen und absoluten Pfad als Argument
      von <link xlink:href="&spec.http1.1;-sec14.html#sec14.30">Location:</link>,
      aber manche Clients akzeptieren auch relative URIs. Gewöhnlich können
      Sie mittels <literal>$_SERVER['HTTP_HOST']</literal>,
      <literal>$_SERVER['PHP_SELF']</literal> und <function>dirname</function>
      aus einem relativen Link einen absoluten URI selbst erstellen:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
/* Redirect auf eine andere Seite im aktuell angeforderten Verzeichnis */
$host  = $_SERVER['HTTP_HOST'];
$uri   = rtrim(dirname($_SERVER['PHP_SELF']), '/\\');
$extra = 'mypage.php';
header("Location: http://$host$uri/$extra");
exit;
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </note>
    <note>
     <para>
      Die Session-ID wird nicht mit dem Location-Header übermittelt, außer Sie
      haben <link linkend="ini.session.use-trans-sid">session.use_trans_sid</link>
      eingeschaltet. Sie muss daher manuell durch Verwendung der
      <constant>SID</constant>-Konstante hinzugefügt werden.
     </para>
    </note>
    <para>
     PHP-Skripte erzeugen oft dynamische Inhalte, die weder vom Browser
     noch von irgendeinem Proxy zwischen Web-Server und Client-Browser
     gepuffert ("gecached") werden sollen bzw. dürfen. Bei vielen Proxies
     und Browsern kann das Cachen wie folgt unterbunden werden:
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
header("Cache-Control: no-cache, must-revalidate"); // HTTP/1.1
header("Expires: Mon, 26 Jul 1997 05:00:00 GMT"); // Datum in der Vergangenheit
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      Es könnte auch sein, dass Ihre Seiten nicht zwischengespeichert werden,
      auch wenn Sie obigen Header nicht ausgeben. Es gibt eine Anzahl Optionen,
      welche die Benutzer in ihren Browser einstellen können, um das
      standardmäßige Caching-Verhalten zu verändern. Durch das Senden obiger
      Header sollten Sie jedwede Einstellungen, die die Ausgabe Ihres Skriptes
      zwischenspeichern würden, außer Kraft setzen.
     </para>
     <para>
      Weiterhin können Sie <function>session_cache_limiter</function> und
      die Konfigurationsoption <literal>session.cache_limiter</literal>
      verwenden, um die korrekten Header bezüglich Caching automatisch
      generieren zu lassen, sollten Sie Sessions benutzen.
     </para>
    </note>
    <para>
     Beachten Sie, dass <function>header</function> aufgerufen werden muss,
     bevor eine Ausgabe gesendet wurde, egal ob dies normale HTML Tags, leere
     Zeilen in einer Datei oder von PHP sind. Ein weit verbreiteter Fehler ist,
     mittels <function>include</function>, <function>require</function> oder
     anderen Dateizugriffsfunktionen Code zu lesen, und so unbewusst
     Leerzeichen oder Leerzeilen auszugeben, bevor <function>header</function>
     aufgerufen wird. Das gleiche Problem besteht auch bei Verwendung einer
     einzigen PHP/HTML Datei.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<html>
<?php
/* Dies funktioniert nicht. Beachten Sie die
// obige Ausgabe noch vor dem header()-Aufruf
header('Location: http://www.example.com/');
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      Seit PHP 4 können Sie dieses Problem umgehen, indem Sie Output
      Buffering benutzen, mit dem Overhead, dass alle Ihre Ausgaben an
      den Browser gepuffert werden, bis Sie diese senden. Um dies zu tun,
      verwenden Sie in Ihrem Skript <function>ob_start</function> und
      <function>ob_end_flush</function> oder setzen Sie die
      Konfigurationsdirektive <literal>output_buffering</literal> in der
      &php.ini; bzw. in den Server-Konfigurationsdateien auf On.
     </para>
    </note>
    <para>
     Wollen Sie den Benutzer auffordern, die von Ihnen gesendeten Daten
     wie z.B. eine generierte PDF Datei zu speichern, können Sie den
     Header <link xlink:href="&url.rfc;2183">Content-Disposition</link> verwenden,
     um einen empfohlenen Dateinamen anzubieten und den Browser zu zwingen,
     den Dialog zum Speichern anzuzeigen.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// Wir werden eine PDF Datei ausgeben
header('Content-type: application/pdf');

// Es wird downloaded.pdf benannt
header('Content-Disposition: attachment; filename="downloaded.pdf"');

// Die originale PDF Datei heißt original.pdf
readfile('original.pdf');
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      Der Microsoft Internet Explorer 4.01 hat einen Bug, der diese
      Funktionalität verhindert, und es gibt keinen Workaround. Auch
      im Microsoft Internet Explorer 5.5 existiert ein Bug, der dies
      behindert, dieser kann jedoch mittels eines Upgrades auf Service
      Pack 2 oder höher behoben werden.
     </para>
    </note>
    <note>
     <simpara>
      Ist <link linkend="ini.safe-mode">safe mode</link> aktiviert, wird
      die UID des Skriptes dem <literal>realm</literal> Teil des Headers
      <literal>WWW-Authenticate</literal> (für HTTP Authentifizierung
      verwendet) hinzugefügt, sollten Sie diesen Header setzen.
     </simpara>
    </note>
    <para>
     Siehe auch <function>headers_sent</function>,
     <function>setcookie</function> und den Teil
     <link linkend="features.http-auth">HTTP Authentifizierung</link>.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
