<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 329077 Maintainer: fa Status: ready -->

<chapter xml:id="pdo.error-handling" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Fehler und Fehlerbehandlung</title>
 <para>
  PDO bietet Ihnen die Wahl unter 3 verschiedenen Strategien zur Fehlerbehandlung,
  um Ihrem Stil der Anwendungsentwicklung gerecht zu werden.
 </para>
 <itemizedlist>
  <listitem>
   <para>
    <constant>PDO::ERRMODE_SILENT</constant>
   </para>
   <para>
    Das ist die Standardmethode. PDO setzt einfach den Fehler-Code, damit Sie ihn mit
    den Methoden <function>PDO::errorCode</function> und 
    <function>PDO::errorInfo</function> sowohl im Statement- als auch im 
    Datenbank-Objekt überprüfen können. Wenn der Fehler aus einem Aufruf eines 
    Statement-Objekts hervorging, würden Sie die Methoden
    <function>PDOStatement::errorCode</function> oder
    <function>PDOStatement::errorInfo</function> des Objekts aufrufen. Wenn der
    Fehler aus einem Aufruf des Datenbank-Objekts hervorging, würden Sie diese
    Methoden des Datenbank-Objekts aufrufen.
   </para>
  </listitem>
  <listitem>
   <para>
    <constant>PDO::ERRMODE_WARNING</constant>
   </para>
   <para>
    Zusätzlich zum Setzen des Fehler-Codes wird PDO eine traditionelle
    E_WARNING-Nachricht ausgeben. Diese Einstellung ist nützlich während des
    Debuggens/Testens, wenn Sie sehen wollen, welche Probleme aufgetreten sind, ohne
    den Ablauf der Anwendung zu unterbrechen.
   </para>
  </listitem>
  <listitem>
   <para>
    <constant>PDO::ERRMODE_EXCEPTION</constant>
   </para>
   <para>
    Zusätzlich zum Setzen des Fehler-Codes wirft PDO eine
    <classname>PDOException</classname> und setzt deren Eigenschaften so, dass sie
    den Fehler-Code und Fehlerinformationen widergeben. Diese Einstellung ist auch
    nützlich während des Debuggens, da sie das Script am Ort des Fehlers
    gewissermaßen "sprengt" und sehr schnell mögliche Problemstellen in Ihrem Code
    aufzeigt. (Zur Erinnerung: Transaktionen bekommen automatisch einen Rollback,
    wenn eine Ausnahme das Script beendet.)
   </para>
   <para>
    Diese Einstellung ist auch nützlich, da Sie ihre Fehlerbehandlung klarer als
    mit traditionellen PHP-Warnungen strukturireren können und mit weniger Code und
    Verschachtelung als im stillen Modus mit expliziter Überprüfung des
    Rückgabewertes jedes einzelnen Datenbankaufrufes.
   </para>
   <para>
    Unter <link linkend="language.exceptions">Ausnahmen</link> finden Sie weitere
    Informationen über Ausnahmen in PHP.
   </para>
  </listitem>
 </itemizedlist>
 <para>
  PDO benutzt Fehler-Codes nach SQL-92 SQLSTATE. Individuelle PDO-Treiber sind selbst
  verantwortlich, ihre nativen Fehler-Codes in die entsprechenden SQLSTATE-Pendants
  umzuwandeln. Die Methode <function>PDO::errorCode</function> gibt einen einzelnen 
  SQLSTATE-Code zurück. Wenn Sie genauere Informationen über einen Fehler benötigen,
  bietet PDO auch die Methode <function>PDO::errorInfo</function>, die ein Array 
  zurückgibt, das den SQLSTATE-Code, den treiberspezifischen Fehler-Code und die
  treiberspezifische Fehlermeldung enthält.
 </para>
 
 <para>
  <example>
   <title>Eine PDO Instanz erstellen und den Error Mode setzen</title>
   <programlisting role="php">
<![CDATA[
<?php
$dsn = 'mysql:dbname=testdb;host=127.0.0.1';
$user = 'dbuser';
$password = 'dbpass';

try {
    $dbh = new PDO($dsn, $user, $password);
    $dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
} catch (PDOException $e) {
    echo 'Verbindung fehlgeschlagen: ' . $e->getMessage();
}

?>
]]>
   </programlisting>
  </example>
 </para>
 <note>
  <para>
   <function>PDO::__construct</function> wirft immer eine
   <classname>PDOException</classname> wenn die Verbindung fehlschlägt
   unabhängig davon welcher <constant>PDO::ATTR_ERRMODE</constant> gerade
   eingestellt ist. Nicht abgefangene Exceptions sind fatal.
  </para>
 </note>
 <para>
  <example>
   <title>Erzeugen eines PDO Exemplars und setzen des Fehlermodus per Konstruktor</title>
   <programlisting role="php">
<![CDATA[
<?php
$dsn = 'mysql:dbname=test;host=127.0.0.1';
$user = 'googleguy';
$password = 'googleguy';

/*
    Die Verwendung von try/catch um den Konstruktor ist berechtigt, auch wenn
    wir ERRMODE auf WARNING setzen, da PDO::__construct immer eine PDOException
    auslöst, wenn die Verbindung fehlschlägt.
*/
try {
    $dbh = new PDO($dsn, $user, $password, array(PDO::ATTR_ERRMODE => PDO::ERRMODE_WARNING));
} catch (PDOException $e) {
    echo 'Verbindung fehlgeschlagen: ' . $e->getMessage();
    exit;
}

// Dies wird PDO veranlassen einen Fehler der Stufe E_WARNING anstelle einer
// Exception auszulösen (falls die Tabelle nicht existiert)
$dbh->query("SELECT wrongcolumn FROM wrongtable");
?>
]]>
   </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Warning: PDO::query(): SQLSTATE[42S02]: Base table or view not found: 1146 Table 'test.wrongtable' doesn't exist in
/tmp/pdo_test.php on line 18
]]>
    </screen>
  </example>
 </para>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

