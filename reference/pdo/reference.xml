<?xml version='1.0' encoding='iso-8859-1'?>
<!-- $Revision: 1.5 $ -->
<!-- EN-Revision: 1.49 Maintainer: fa Status: ready -->
<!-- Purpose: database.abstract -->
<!-- Membership: pecl, bundled -->

 <reference xml:id="ref.pdo" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>PDO-Funktionen</title>
  <titleabbrev>PDO</titleabbrev>

  <partintro>
   <section xml:id="pdo.intro">
   &reftitle.intro;
    <para>
     Die PHP Data Objects(PDO)-Erweiterung stellt eine leichte, konsistente
     Schnittstelle bereit, um mit PHP auf Datenbanken zuzugreifen. Jeder
     Datenbanktreiber, der die PDO-Schnittstelle implementiert, kann
     spezifische Features als reguläre Funktionen der Erweiterung bereitstellen.
     Beachten Sie, dass Sie keine Funktionen der Datenbank mit PDO allein benutzen
     können. Sie müssen einen <link linkend="pdo.drivers">datenbankspezifischen
     PDO-Treiber</link> benutzen, um auf eine Datenbank zuzugreifen.
    </para>
    <para>
     PDO  bietet eine Abstraktionsschicht für den <emphasis>Datenzugriff</emphasis>,
     das bedeutet, dass Sie, egal welche Datenbank Sie benutzen, dieselben
     Funktionen verwenden können, um Abfragen zu erstellen und Daten zu lesen.
     PDO bietet keine Abstraktion für <emphasis>Datenbanken</emphasis>. Es schreibt keine
     SQL-Abfragen um oder emuliert fehlende Features. Sie sollten eine komplette
     Abstraktionsschicht verwenden, wenn Sie diese Funktionalität benötigen.
    </para>
    <para>
     PDO wird mit PHP 5.1 ausgeliefert und ist als PECL-Erweiterung für PHP 5.0 verfügbar.
     PDO benötigt die neuen OO-Features im Kern von PHP 5 und wird deswegen nicht mit
     früheren Versionen von PHP funktionieren.
    </para>
   </section>
   <section xml:id="pdo.installation">
   &reftitle.install;
    <procedure xml:id='pdo.install.unix51up'>
     <title>PHP 5.1 und höher auf Unix-Systemen</title>
     <step>
      <para>
       Wenn Sie ein PHP 5.1-Release verwenden, ist PDO bereits enthalten.
       Es wird automatisch angeschaltet, wenn Sie configure ausführen. Es wird empfohlen,
       PDO als shared module zu kompilieren, da Sie so die durch PECL bereitgestellen
       Updates nutzen können. Das empfohlene configure-Kommando, um PHP
       mit PDO zu kompilieren, sollte auch die zlib-Unterstützung (für den 
       PEAR-Installer) aktivieren. Sie müssen eventuell auch den PDO-Treiber für die
       Datenbank Ihrer Wahl aktivieren. Ziehen Sie die Dokumentation für <link 
       linkend="pdo.drivers">datenbankspezifische PDO-Treiber</link> zu Rate, um mehr
       darüber herauszufinden, aber beachten Sie, dass Sie, wenn Sie PDO als Shared
       Extension bauen, auch die PDO-Treiber als Shared Extensions bauen müssen.
       <screen>
<![CDATA[
 ./configure --with-zlib --enable-pdo=shared
]]>
       </screen>
      </para>
     </step>
     <step>
      <para>
       Nach der Installation von PDA als shared module müssen sie Ihre &php.ini;-Datei
       bearbeiten, damit die PDO-Erweiterung automatisch geladen wird, wenn PHP 
       ausgeführt wird. Sie müssen dort auch alle datenbankspezifischen Treiber 
       aktivieren. Versichern Sie sich, dass diese nach der Zeile mit pdo.so stehen,
       da PDO initialisiert werden muss, bevor die datenbankspezifischen Erweiterungen
       geladen werden können. Wenn Sie PDO und die datenbankspezifischen Erweiterungen
       statisch kompiliert haben, können Sie diesen Schritt überspringen.
       <screen>
<![CDATA[
extension=pdo.so
]]>
       </screen>
      </para>
     </step>
     <step>
      <para>
       PDO als shared module zu benutzen erlaubt Ihnen, <command>pear
       upgrade pdo</command> auszuführen, wenn neue Versionen von PDO veröffentlicht
       werden, ohne dass Sie PHP komplett neu kompilieren müssen. Beachten Sie, dass Sie
       auch die datenbankspezifischen Treiber zur gleichen Zeit aktualisieren müssen.
      </para>
     </step>
    </procedure>
    <procedure xml:id='pdo.install.pecl'>
     <title>PHP 5.0 und höher auf Unix-Systemen</title>
     <step>
      <para>
       PDO ist als PECL-Erweiterung verfügbar auf
       <link xlink:href='&url.pecl.package;pdo'>&url.pecl.package;pdo</link>.
       Die Installation kann mit Hilfe des <command>pear</command>-Tools durchgeführt
       werden. Dies ist standardmäßig aktiviert, wenn sie PHP konfigurieren. Sie
       sollten sich vergewissern, dass PHP mit <option 
       role="configure">--with-zlib</option> erstellt wurde, damit
       <command>pear</command> mit der komprimierten Paketdatei umgehen kann.
      </para>
     </step>
     <step>
      <para>
       Führen Sie den folgenden Befehl aus, um die neueste stabile Version von PDO
       herunterzuladen, zu kompilieren und zu installieren:
       <screen>
<![CDATA[
pear install pdo
]]>
       </screen>
      </para>
     </step>
     <step>
      <para>
       Wenn PDO sich noch in der Beta-Phase befindet (und zur Zeit, wenn diese Zeilen
       geschrieben werden, ist es das noch), werden Sie dem <command>pear</command>-Tool
       explizit mitteilen müssen, dass es in Ordnung ist, das Beta-Paket zu benutzen.
       Statt des oben genannten Befehls benutzen Sie einfach:
       <screen>
<![CDATA[
pear install pdo-beta
]]>
       </screen>
      </para>
     </step>
     <step>
      <para>
       Der <command>pear</command>-Befehl installiert das PDO-Modul automatisch in Ihr
       PHP-<link linkend="ini.extension-dir">extensions</link>-Verzeichnis. Um die 
       PDO-Erweiterung unter Linux oder Unix zu aktivieren, müssen Sie die folgende
       Zeile zur &php.ini; hinzufügen:
       <screen>
<![CDATA[
extension=pdo.so
]]>
       </screen>
      </para>
      <para>
       Für weitere Informationen über das Erstellen von PECL-Paketen lesen Sie am besten
       das Kapitel <link linkend="install.pecl">PECL-Installation</link> im Handbuch.
      </para>
     </step>
    </procedure>
    <procedure xml:id='pdo.install.win32php51'>
     <title>PHP 5.1 und höher unter Windows</title>
     <step>
      <para>
       PDO und alle gängigen Treiber werden mit PHP als shared module mitgeliefert und
       müssen nur durch Bearbeiten der Datei &php.ini; aktiviert werden:
       <screen>
<![CDATA[
extension=php_pdo.dll
]]>
       </screen>
      </para>
     </step>
     <step>
      <para>
       Als nächstes wählen sie die datenbankspezifischen DLL-Dateien und laden sie
       entweder per <function>dl</function> zur Laufzeit oder aktivieren sie in der
       Datei &php.ini; unterhalb von <filename>php_pdo.dll</filename>. Zum Beispiel:
       <screen>
<![CDATA[
extension=php_pdo.dll
extension=php_pdo_firebird.dll
extension=php_pdo_informix.dll
extension=php_pdo_mssql.dll
extension=php_pdo_mysql.dll
extension=php_pdo_oci.dll
extension=php_pdo_oci8.dll
extension=php_pdo_odbc.dll
extension=php_pdo_pgsql.dll
extension=php_pdo_sqlite.dll  
]]>
       </screen>
      </para>
      <para>
       Diese DLLs sollten im <link linkend="ini.extension-dir">extension_dir</link>
       des Systems vorhanden sein. Beachten Sie bitte, dass <link 
       linkend="ref.pdo-informix">PDO_INFORMIX</link> nur als PECL-Erweiterung verfügbar
       ist.
      </para>
     </step>
    </procedure>
   </section>

   &reference.pdo.ini;

   <section xml:id="pdo.drivers">
    <title>PDO-Treiber</title>
    <para>
     Die folgenden Treiber implementieren momentan die PDO-Schnittstelle:
     <informaltable>
      <tgroup cols='2'>
       <thead>
        <row>
         <entry>Treibername</entry>
         <entry>Unterstützte Datenbanken</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><link linkend="ref.pdo-dblib">PDO_DBLIB</link></entry>
         <entry>FreeTDS / Microsoft SQL Server / Sybase</entry>
        </row>
        <row>
         <entry><link linkend="ref.pdo-firebird">PDO_FIREBIRD</link></entry>
         <entry>Firebird/Interbase 6</entry>
        </row>
        <row>
         <entry><link linkend="ref.pdo-informix">PDO_INFORMIX</link></entry>
         <entry>IBM Informix Dynamic Server</entry>
        </row>
        <row>
         <entry><link linkend="ref.pdo-mysql">PDO_MYSQL</link></entry>
         <entry>MySQL 3.x/4.x</entry>
        </row>
        <row>
         <entry><link linkend="ref.pdo-oci">PDO_OCI</link></entry>
         <entry>Oracle Call Interface</entry>
        </row>
        <row>
         <entry><link linkend="ref.pdo-odbc">PDO_ODBC</link></entry>
         <entry>ODBC v3 (IBM DB2, unixODBC und win32 ODBC)</entry>
        </row>
        <row>
         <entry><link linkend="ref.pdo-pgsql">PDO_PGSQL</link></entry>
         <entry>PostgreSQL</entry>
        </row>
        <row>
         <entry><link linkend="ref.pdo-sqlite">PDO_SQLITE</link></entry>
         <entry>SQLite 3 und SQLite 2</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </section>

   <section xml:id='pdo.connections'>
    <title>Verbindungen und Verwaltung der Verbindungen</title>
    <para>
     Verbindungen werden durch das Erstellen von Instanzen der PDO-Basisklase erzeugt.
     Es ist unerheblich, welchen Treiber Sie benutzen wollen. Sie benutzen immer den
     PDO-Klassennamen. Der Konstruktor erwartet Parameter zur Angabe der 
     Datenbankquelle (auch bekannt als DSN) und optional für Benutzername und Passwort
     (falls vorhanden).
    </para>
    <para>
     <example><title>Mit MySQL verbinden</title>
      <programlisting role='php'>
<![CDATA[
<?php
$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass);
?>
]]> 
      </programlisting>
     </example>
    </para>
    <para>
     Wenn es Fehler bei der Verbindung gibt, wird eine Ausnahme vom Typ
     <literal>PDOException</literal> geworfen. Sie können die Ausnahme abfangen, wenn
     Sie sich selbst um die Fehlerbedingung kümmern wollen, oder Sie können es einer
     globalen Routine zur Ausnahmebehandlung überlassen, die Sie mit
     <function>set_exception_handler</function> konfigurieren.
    </para>
    <para>
     <example><title>Verbindungsfehler behandeln</title>
      <programlisting role='php'>
<![CDATA[
<?php
try {
   $dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass);
   foreach ($dbh->query('SELECT * from FOO') as $row) {
      print_r($row);
   }
   $dbh = null;
} catch (PDOException $e) {
   print "Error!: " . $e->getMessage() . "<br/>";
   die();
}
?>
]]>
      </programlisting>
     </example>
    </para>
    <warning>
     <para>
      Wenn Ihre Anwendung die vom PDO-Konstruktor geworfene Ausnahme nicht auffängt,
      ist die normale Vorgehnsweise der Zend Engine, das Script zu terminieren und einen
      Backtrace anzuzeigen. Dieser Backtrace wird wahrscheinlich alle Details der
      Datenbankverbindung enthüllen, inklusive Benutzername und Passwort. Sie sind also
      verantwortlich, diese Ausnahme aufzufangen, entweder explizit (mit einem
      <literal>catch</literal>-Block) oder implizit mit 
      <function>set_exception_handler</function>.
     </para>
    </warning>
    <para>
     Bei erfolgreicher Verbindung zur Datenbank wird eine Instanz der PDO-Klasse an Ihr
     Script zurückgegeben. Die Verbindung bleibt während der Lebensdauer des PDO-Objekts
     aktiv. Um die Verbindung zu beenden, müssen Sie das Objekt löschen, indem Sie 
     sicherstellen, dass alle Referenzen darauf gelöscht werden - das erreichen Sie,
     indem Sie der Variable, die das Objekt beinhaltet, &null; zuweisen. Wenn Sie das
     nicht explizit tun, schließt PHP die verbindung automatisch, wenn Ihr Script endet.
    </para>
    <para>
     <example><title>Eine Verbindung schließen</title>
     <programlisting role='php'>
<![CDATA[
<?php
$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass);
// use the connection here


// and now we're done; close it
$dbh = null;
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Viele Webanwendungen profitieren von persistenten Verbindungen zum Datenbankserver.
    Persistente Verbindungen werden nicht am Ende des Scripts geschlossen, sondern
    werden gecachet und wieder benutzt, wenn ein anderes Script eine Verbindung mit
    denselben Daten anfordert. Der Cache an persistenten Verbindungen erlaubt Ihnen,
    den Overhead zu vermeiden, wenn jedes mal eine neue Verbindung geöffnet wird,
    sobald ein Script mit der Datenbank kommunizieren muss, was sich in einer schnelleren
    Anwendung widerspiegelt.
   </para>
   <para>
    <example><title>Persistente Verbindungen</title>
     <programlisting role='php'>
<![CDATA[
<?php
$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass, array(
  PDO::ATTR_PERSISTENT => true
));
?>
]]>
     </programlisting>
     </example>
    </para>
    <note>
     <para>
      Wenn Sie den PDO-ODBC-Treiber benutzen und Ihre ODBC-Bibliotheken ODBC Connection
      Pooling unterstützen (unixODBC und Windows etwa, es könnte auch andere geben), dann
      wird empfohlen, dass sie keine persistenten PDO-Verbindungen benutzen, sondern das
      Cachen der Verbindungen der ODBC Connection Pooling-Schicht überlassen. Der ODBC
      Connection Pool wird mit anderen Modulen im Prozess geteilt. Wenn PDO also
      angewiesen wird die Verbindung zu cachen, wird diese Verbindung nie dem ODBC
      Connection Pool zurückgegeben, was darin resultiert, dass zusätzliche Verbindungen
      aufgebaut werden, um jene anderen Module zu bedienen.
     </para>
    </note>
   </section>

   <section xml:id='pdo.transactions'>
    <title>Transaktionen und auto-commit</title>
    <para>
     Jetzt, wo Sie via PDO verbunden sind, müssen Sie sich bewusst machen, wie PDO
     Transaktionen verwaltet, bevor Sie anfangen, Abfragen auszuführen. Falls Sie noch 
     niemit Transaktionen zu tun hatten, diese bieten 4 wichtige Features: Atomizität, 
     Konsistenz (Consistency), Isolation und Dauerhaftigkeit (Durability) (ACID).
     Einfach gesagt wird alles in einer Transaktion, auch wenn es in Einzelschritten
     ausgeführt wird, garantiert in sicherer Weise in die Datenbank eingetragen, ohne
     Beeinträchtigung durch andere Verbindungen, wenn es abgeschickt wird. Aktivitäten in
     Transaktionen können auch automatisch annulliert werden (wenn Sie es noch nicht 
     abgeschickt haben), was Fehlerbehandlung in Ihren Scripts einfacher macht.
    </para>
    <para>
     Transaktionen werden typischerweise implementiert, indem Ihre Menge an Änderungen
     "aufgespart" wird und dann in einem Rutsch abgearbeitet werden. Das hat den netten
     Nebeneffekt, dass die Effizienz der Aktualisierungen drastisch erhöht wird. In 
     anderen Worten können Transaktionen Ihre Scripts schneller und möglicherweise auch
     robuster machen. Aber Sie müssen sie korrekt verwenden, um davon zu profitieren.
    </para>
    <para>
     Unglücklicherweise unterstützt nicht jede Datenbank Transaktionen, deswegen muss PDO
     in einem "auto-commit" genannten Modus laufen, wenn Sie die Verbindung zum ersten 
     Mal öffnen. "Auto-commit" bedeutet, dass jede Abfrage, die Sie ausführen ihre eigene
     implizite Transaktion besitzt, wenn die Datenbank das unterstützt, oder keine
     Transaktion, wenn die Datenbank keine Transaktionen unterstützt. Wenn Sie eine
     Transaktion benötigen, müssen Sie eine mit der Methode 
     <function>PDO::beginTransaction</function> initiieren. Wenn der zu Grunde liegende
     Treiber keine Transaktionen unterstützt, wird eine <literal>PDOException</literal>
     geworfen (unbeachtet Ihrer Einstellungen zur Fehlerbehandlung: dies ist immer eine
     ernste Fehlerbedingung). Wenn Sie dann in einer Transaktion sind, können Sie
     <function>PDO::commit</function> oder <function>PDO::rollBack</function> benutzen,
     um die Transaktion abzuschließen, abhängig vom Erfolg des Codes, den Sie während der
     Transaktion ausgeführt haben.
    </para>
    <para>
     Wenn das Script endet oder die Verbindung im Begriff ist, geschlossen zu werden und
     Sie eine Transaktion ausstehen haben, wird PDO automatisch einen Rollback 
     durchführen. Dies ist eine Sicherheitsmaßnahme, um Inkonsistenzen in dem Fall, wo
     das Script unerwartet beendet wird, zu vermeiden - wenn Sie die Transaktion nicht
     explizit ausgeführt haben, wird angenommen, dass etwas schiefgegangen ist, deswegen
     wird zur Sicherheit ein Rollback durchgeführt.
    </para>
    <warning>
     <para>
      Der automatische Rollback wird nur durchgeführt, wenn Sie die Transaktion per
      <function>PDO::beginTransaction</function> starten. Wenn Sie manuell eine Abfrage
      ausführen, die eine Transaktion startet, kann PDO nichts davon wissen und kann
      deswegen auch keinen Rollback durchführen, wenn etwas schiefgeht.
     </para>
    </warning>
    <para>
     <example><title>Mehrere Abfragen in einer Transaktion</title>
      <para>
       Im folgenden Beispiel nehmen wir an, dass wir einen Satz von Einträgen für einen
       neuen Angestellten eintragen wollen, dem die ID-Nummer 23 zugeordnet wurde.
       Zusätzlich zur Angabe der Basisdaten für diese Person müssen wir auch ihr Gehalt
       festhalten. Es ist ziemlich einfach, zwei getrennte Aktualisierungen 
       durchzuführen, aber indem wir sie in <function>PDO::beginTransaction</function>
       und <function>PDO::commit</function> einschließen, garantieren wir, dass niemand
       anderes diese Änderungen sieht, bis sie komplett sind. Wenn etwas schiefgeht, wird
       der <literal>catch</literal>-Block alle seit Beginn der Transaktion durchgeführten
       Änderungen rückgängig machen und dann eine Fehlermeldung ausgeben.
      </para>
      <programlisting role='php'>
<![CDATA[
<?php
try {
  $dbh = new PDO('odbc:SAMPLE', 'db2inst1', 'ibmdb2', 
      array(PDO::ATTR_PERSISTENT => true));
  echo "Connected\n";
  $dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

  $dbh->beginTransaction();
  $dbh->exec("insert into staff (id, first, last) values (23, 'Joe', 'Bloggs')");
  $dbh->exec("insert into salarychange (id, amount, changedate) 
      values (23, 50000, NOW())");
  $dbh->commit();
  
} catch (Exception $e) {
  $dbh->rollBack();
  echo "Failed: " . $e->getMessage();
}
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Sie sind nicht darauf beschränkt, Änderungen in einer Transaktion durchzuführen. Sie
     können auch komplexe Abfragen ausführen um Daten zu erhalten, und diese
     Informationen etwa dazu benutzen, mehr Änderungen und Abfragen zu erzeugen. Während
     die Transaktion aktiv ist, kann garantiert niemand anderes Änderungen durchführen,
     während Sie bei der Arbeit sind. Um ehrlich zu sein, stimmt das nicht 100%, aber es
     ist für den Anfang ausreichend, falls Sie noch nie von Transaktionen gehört haben.
    </para>
   </section>

   <section xml:id='pdo.prepared-statements'>
    <title>Prepared Statements und Stored Procedures</title>
    <para>
     Viele der ausgereifteren Datenbanken unterstützen das Konzept der Prepared 
     Statements. Was ist das? Sie können sie sich als eine Art von kompiliertem Template
     für SQL vorstellen, das durch variable Parameter angepasst werden kann. Prepared
     Statements haben zwei wichtige Vorteile:
    </para>
    <itemizedlist>
     <listitem>
      <simpara>
       Die Abfrage muss nur einmal geparset (oder vorbereitet) werden, kann dann aber
       mehrere Male mit denselben oder anderen Parametern ausgeführt werden. Wenn die
       Abfrage vorbereitet wird, kann die Datenbank ihre Vorgehensweise zur Ausführung
       der Abfrage analysieren, kompilieren und optimieren. Für komplexe Abfragen kann
       dieser Vorgang genug Zeit benötigen, dass es Ihre Anwendung merklich 
       verlangsamt, wenn Sie dieselbe Abfrage oft mit verschiedenen Parametern
       wiederholen. Mit einem Prepared Statement vermeiden Sie den Zyklus der
       Analyse/Kompilierung/Optimierung. Kurz gesagt benötigen Prepared Statements
       weniger Ressourcen und laufen deswegen schneller.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Die Parameter für Prepared Statements müssen nicht maskiert werden. Der Treiber
       übernimmt das für Sie. Wenn Ihre Anwendung ausschließlich Prepared Statements
       benutzt, können Sie sicher sein, dass keine SQL-Injection auftreten wird. (Wenn
       Sie aber trotzdem andere Teile der Abfrage aus nicht zuverlässigen Eingaben
       generieren, sind Sie immer noch gefährdet.)
      </simpara>
     </listitem>
    </itemizedlist>
    <para>
     Prepared Statements sind so nützlich, dass sie das einzige Feature sind, das PDO
     auch für Treiber emulieren wird, die diese nicht unterstützen. Das garantiert, dass
     Sie unabhängig von den Möglichkeiten der Datenbank dieselbe Art des Datenzugriffs
     nutzen können.
    </para>
    <para>
     <example><title>Wiederholte Inserts mit Prepared Statements</title>
     <simpara>
      Dieses Beispiel führt eine INSERT-Abfrage durch, indem ein <literal>name</literal>
      und ein <literal>value</literal> für die benannten Platzhalter eingesetzt werden.
     </simpara>
     <programlisting role='php'>
<![CDATA[
<?php
$stmt = $dbh->prepare("INSERT INTO REGISTRY (name, value) VALUES (:name, :value)");
$stmt->bindParam(':name', $name);
$stmt->bindParam(':value', $value);

// insert one row
$name = 'one';
$value = 1;
$stmt->execute();

// insert another row with different values
$name = 'two';
$value = 2;
$stmt->execute();
?>
]]>
     </programlisting>
    </example>
   </para>
    <para>
     <example><title>Wiederholte Inserts mit Prepared Statements</title>
     <simpara>
      Dieses Beispiel führt eine INSERT-Abfrage durch, indem ein <literal>name</literal>
      und ein <literal>value</literal> für die positionsabhängigen 
      <literal>?</literal>-Platzhalter eingesetzt werden.
     </simpara>
     <programlisting role='php'>
<![CDATA[
<?php
$stmt = $dbh->prepare("INSERT INTO REGISTRY (name, value) VALUES (?, ?)");
$stmt->bindParam(1, $name);
$stmt->bindParam(2, $value);

// insert one row
$name = 'one';
$value = 1;
$stmt->execute();

// insert another row with different values
$name = 'two';
$value = 2;
$stmt->execute();
?>
]]>
     </programlisting>
    </example>
   </para>
    <para>
     <example><title>Abfragen von Daten mit Prepared Statements</title>
     <simpara>
      Dieses Beispiel ruft Daten basierend auf einem Schlüsselwert ab, der von einem
      Formular geliefert wird. Die Benutzereingabe wird automatisch maskiert, deswegen
      gibt es kein Risiko eines SQL-Injection-Angriffs.
     </simpara>
     <programlisting role='php'>
<![CDATA[
<?php
$stmt = $dbh->prepare("SELECT * FROM REGISTRY where name = ?");
if ($stmt->execute(array($_GET['name']))) {
  while ($row = $stmt->fetch()) {
    print_r($row);
  }
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Wenn es der Datenbanktreiber unterstützt, können Sie auch Parameter für die Ausgabe
    einführen, ähnlich der Eingabe. Ausgabeparameter werden typischerweise benutzt,
    um Werte von Stored Procedures abzurufen. Ausgabeparameter sind etwas komplexer in
    der Verwendung als Eingabeparameter, weil Sie wissen müssen, wie groß ein gegebener
    Parameter sein könnte, wenn Sie ihn einführen. Wenn der Wert sich als größer
    herausstellt als die vorgeschlagene Größe, wird ein Fehler ausgelöst.
   </para>

   <para>
    <example><title>Eine Stored Procedure mit einem Ausgabeparameter aufrufen</title>
     <programlisting role='php'>
<![CDATA[
<?php
$stmt = $dbh->prepare("CALL sp_returns_string(?)");
$stmt->bindParam(1, $return_value, PDO::PARAM_STR, 4000); 

// call the stored procedure
$stmt->execute();

print "procedure returned $return_value\n";
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Sie können auch Parameter angeben, die Werte für Eingabe und Ausgabe enthalten.
    Die Syntax ist ähnlich den Ausgabeparametern. In diesem nächsten Beispiel wird die
    Zeichenkette 'hello' der Stored Procedure übergeben und wenn diese etwas zurückgibt,
    wird 'hello' durch den Rückgabewert der Stored procedure ersetzt.
   </para>

   <para>
    <example><title>Eine Stored Procedure mit einem Eingabe-/Ausgabe-Parameter
    aufrufen</title>
     <programlisting role='php'>
<![CDATA[
<?php
$stmt = $dbh->prepare("CALL sp_takes_string_returns_string(?)");
$value = 'hello';
$stmt->bindParam(1, $value, PDO::PARAM_STR|PDO::PARAM_INPUT_OUTPUT, 4000); 

// call the stored procedure
$stmt->execute();

print "procedure returned $value\n";
?>
]]>
     </programlisting>
    </example>
   </para>
  </section>

  <section xml:id='pdo.error-handling'>
   <title>Fehler und Fehlerbehandlung</title>
    <para>
     PDO bietet Ihnen die Wahl unter 3 verschiedenen Strategien zur Fehlerbehandlung,
     um Ihrem Stil der Anwendungsentwicklung gerecht zu werden.
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <constant>PDO::ERRMODE_SILENT</constant>
      </para>
      <para>
        Das ist die Standardmethode. PDO setzt einfach den Fehler-Code, damit Sie ihn mit
        den Methoden <function>PDO::errorCode</function> und 
        <function>PDO::errorInfo</function> sowohl im Statement- als auch im 
        Datenbank-Objekt überprüfen können. Wenn der Fehler aus einem Aufruf eines 
        Statement-Objekts hervorging, würden Sie die Methoden
        <function>PDOStatement::errorCode</function> oder
        <function>PDOStatement::errorInfo</function> des Objekts aufrufen. Wenn der
        Fehler aus einem Aufruf des Datenbank-Objekts hervorging, würden Sie diese
        Methoden des Datenbank-Objekts aufrufen.
       </para>
     </listitem>
     <listitem>
      <para>
       <constant>PDO::ERRMODE_WARNING</constant>
      </para>
      <para>
        Zusätzlich zum Setzen des Fehler-Codes wird PDO eine traditionelle
        E_WARNING-Nachricht ausgeben. Diese Einstellung ist nützlich während des
        Debuggens/Testens, wenn Sie sehen wollen, welche Probleme aufgetreten sind, ohne
        den Ablauf der Anwendung zu unterbrechen.
       </para>
      </listitem>
      <listitem>
       <para>
        <constant>PDO::ERRMODE_EXCEPTION</constant>
       </para>
       <para>
        Zusätzlich zum Setzen des Fehler-Codes wirft PDO eine
        <classname>PDOException</classname> und setzt deren Eigenschaften so, dass sie
        den Fehler-Code und Fehlerinformationen widergeben. Diese Einstellung ist auch
        nützlich während des Debuggens, da sie das Script am Ort des Fehlers
        gewissermaßen "sprengt" und sehr schnell mögliche Problemstellen in Ihrem Code
        aufzeigt. (Zur Erinnerung: Transaktionen bekommen automatisch einen Rollback,
        wenn eine Ausnahme das Script beendet.)
       </para>
       <para>
        Diese Einstellung ist auch nützlich, da Sie ihre Fehlerbehandlung klarer als
        mit traditionellen PHP-Warnungen strukturireren können und mit weniger Code und
        Verschachtelung als im stillen Modus mit expliziter Überprüfung des
        Rückgabewertes jedes einzelnen Datenbankaufrufes.
       </para>
       <para>
        Unter <link linkend='language.exceptions'>Ausnahmen</link> finden Sie weitere
        Informationen über Ausnahmen in PHP.
       </para>
      </listitem>
    </itemizedlist>
    <para>
     PDO benutzt Fehler-Codes nach SQL-92 SQLSTATE. Individuelle PDO-Treiber sind selbst
     verantwortlich, ihre nativen Fehler-Codes in die entsprechenden SQLSTATE-Pendants
     umzuwandeln. Die Methode <function>PDO::errorCode</function> gibt einen einzelnen 
     SQLSTATE-Code zurück. Wenn Sie genauere Informationen über einen Fehler benötigen,
     bietet PDO auch die Methode <function>PDO::errorInfo</function>, die ein Array 
     zurückgibt, das den SQLSTATE-Code, den treiberspezifischen Fehler-Code und die
     treiberspezifische Fehlermeldung enthält.
    </para>
   </section>

   <section xml:id='pdo.lobs'>
    <title>Large Objects (LOBs)</title>
    <para>
      Es könnte an irgendeinem Punkt in Ihrer Anwendung passieren, dass Sie eine "große"
      Menge an Daten in Ihrer Datenbank ablegen müssen. Groß bedeutet typischerweise
      "etwa 4kb oder mehr", obwohl manche Datenbanken spielend bis zu 32kb bearbeiten
      können, bevor das als "groß" zählt. Large Objects können aus Text oder Binärdaten
      bestehen. PDO erlaubt Ihnen, mit diesem großen Datentyp zu arbeiten, indem Sie
      <constant>PDO::PARAM_LOB</constant> als Typ in Ihren Methodenaufrufen von
      <function>PDOStatement::bindParam</function> oder
      <function>PDOStatement::bindColumn</function> benutzen.
      <constant>PDO::PARAM_LOB</constant> veranlasst PDO, die Daten als Stream zu behandeln, so
      dass Sie diese mit Hilfe der <link linkend='ref.stream'>PHP Streams-API</link>
      bearbeiten können.
    </para>
    <para>
     
    </para>
    <para>
     <example><title>Ein Bild aus einer Datenbank anzeigen</title>
     <para>
      Dieses Beispiel weist das LOB der Variable namens $lob zu und sendet es mittels
      <function>fpassthru</function> an den Browser. Weil das LOB als Stream 
      dargestellt wird, können Funktionen wie <function>fgets</function>, 
      <function>fread</function> und <function>stream_get_contents</function> damit
      benutzt werden.
     </para>
     <programlisting role='php'>
<![CDATA[
<?php
$db = new PDO('odbc:SAMPLE', 'db2inst1', 'ibmdb2');
$stmt = $db->prepare("select contenttype, imagedata from images where id=?");
$stmt->execute(array($_GET['id']));
$stmt->bindColumn(1, $type, PDO::PARAM_STR, 256);
$stmt->bindColumn(2, $lob, PDO::PARAM_LOB);
$stmt->fetch(PDO::FETCH_BOUND);

header("Content-Type: $type");
fpassthru($lob);
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example><title>Ein Bild in eine Datenbank einfügen</title>
     <para>
      Dieses Beispiel öffnet eine Datei und übergibt das File-Handle an PDO, damit sie
      als LOB eingefügt wird. PDO wird sein Möglichstes tun, den Inhalt der Datei auf
      möglichst effiziente Weise in die Datenbank zu bekommen.
     </para>
     <programlisting role='php'>
<![CDATA[
<?php
$db = new PDO('odbc:SAMPLE', 'db2inst1', 'ibmdb2');
$stmt = $db->prepare("insert into images (id, contenttype, imagedata) values (?, ?, ?)");
$id = get_new_id(); // some function to allocate a new ID

// assume that we are running as part of a file upload form
// You can find more information in the PHP documentation

$fp = fopen($_FILES['file']['tmp_name'], 'rb');

$stmt->bindParam(1, $id);
$stmt->bindParam(2, $_FILES['file']['type']);
$stmt->bindParam(3, $fp, PDO::PARAM_LOB);

$stmt->beginTransaction();
$stmt->execute();
$stmt->commit();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example><title>Ein Bild in eine Datenbank einfügen: Oracle</title>
     <para>
      Oracle erfordert eine leicht unterschiedliche Syntax, um ein LOB aus einer Datei
      einzufügen. Es ist auch unumgänglich, dass Sie diesen Insert innerhalb einer
      Transaktion durchführen, andernfalls wird Ihr frisch eingefügtes LOB mit einer
      Länge von 0 als Teil des impliziten commits, der beim Ausführen der Abfrage
      passiert, gespeichert.
     </para>
     <programlisting role='php'>
<![CDATA[
<?php
$db = new PDO('oci:', 'scott', 'tiger');
$stmt = $db->prepare("insert into images (id, contenttype, imagedata) " .
  "VALUES (?, ?, EMPTY_BLOB()) RETURNING imagedata INTO ?");
$id = get_new_id(); // some function to allocate a new ID

// assume that we are running as part of a file upload form
// You can find more information in the PHP documentation

$fp = fopen($_FILES['file']['tmp_name'], 'rb');

$stmt->bindParam(1, $id);
$stmt->bindParam(2, $_FILES['file']['type']);
$stmt->bindParam(3, $fp, PDO::PARAM_LOB);

$stmt->beginTransaction();
$stmt->execute();
$stmt->commit();
?>
]]>
     </programlisting>
     </example>
    </para>

   </section>

   <section xml:id='pdo.classes'>
    &reftitle.classes;
    <section xml:id='pdo.class.PDO'>
     <title><classname>PDO</classname></title>
     <para>
      Stellt eine Verbindung zwischen PHP und einem Datenbankserver dar.
     </para>
     <section xml:id='pdo.class.PDO.constructor'>
      &reftitle.constructor;
      <itemizedlist>
       <listitem>
        <para>
         <link linkend='function.PDO-construct'>PDO</link> - erstellt ein neues 
         PDO-Objekt
        </para>
       </listitem>
      </itemizedlist>
     </section>
     <section xml:id='pdo.class.PDO.methods'>
      &reftitle.methods;
      <itemizedlist>
       <listitem>
        <para>
         <link linkend='function.PDO-beginTransaction'>beginTransaction</link> 
         - startet eine Transaktion
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDO-commit'>commit</link> 
         - schliesst eine Transaktion ab
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDO-errorCode'>errorCode</link> 
         - fragt einen Fehler-Code, falls es einen gibt, von der Datenbank ab
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDO-errorInfo'>errorInfo</link> 
         - fragt ein Array mit Fehlerinformationen, wenn es welche gibt, von der
         Datenbank ab
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDO-exec'>exec</link> 
         - führt ein SQL-Statement aus und gibt die Anzahl der betroffenen Zeilen zurück
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDO-getAttribute'>getAttribute</link> 
         - fragt ein Attribut der Datenbankverbindung ab
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDO-lastInsertId'>lastInsertId</link> 
         - fragt den Wert der letzten Zeile ab, die in eine Tabelle eingefügt wurde
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDO-prepare'>prepare</link> 
         - bereitet ein SQL-Statement zur Ausführung vor
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDO-query'>query</link> 
         - führt ein SQL-Statement aus und gibt eine Ergebnismenge zurück
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDO-quote'>quote</link> 
         - gibt eine maskierte Version einer zeichenkette zur Benutzung in SQL-Statements
         zurück
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDO-rollBack'>rollBack</link> 
         - Rollback einer Transaktion durchführen
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDO-setAttribute'>setAttribute</link> 
         - setzt ein Attribut der Datenbankverbindung
        </para>
       </listitem>
      </itemizedlist>
     </section>
    </section>
    <section xml:id='pdo.class.PDOStatement'>
     <title><classname>PDOStatement</classname></title>
     <para>
      Stellt ein Prepared Statement dar und nach der Ausführung desselben eine
      zugeordnete Ergebnismenge
     </para>
     <section xml:id='pdo.class.Statement.methods'>
      &reftitle.methods;
      <itemizedlist>
       <listitem>
        <para>
         <link linkend='function.PDOStatement-bindColumn'>bindColumn</link> 
         - bindet eine PHP-Variable an eine Ausgabe-Spalte in der Ergebnismenge
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDOStatement-bindParam'>bindParam</link> 
         - bindet eine PHP-Variable an einen Parameter im Prepared Statement
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDOStatement-bindValue'>bindValue</link> 
         - bindet einen Wert an einen Parameter im Prepared Statement
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDOStatement-closeCursor'>closeCursor</link> 
         - schließt den Cursor und erlaubt die erneute Ausführung des Statements
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDOStatement-columnCount'>columnCount</link> 
         - gibt die Anzahl der Spalten in der Ergebnismenge zurück
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDOStatement-errorCode'>errorCode</link> 
         - fragt einen Fehler-Code, falls es einen gibt, vom Statement ab
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDOStatement-errorInfo'>errorInfo</link> 
         - fragt ein Array von Fehlerinformationen, falls es welche gibt, vom Statement
         ab
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDOStatement-execute'>execute</link> 
         - führt ein Prepared Statement aus
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDOStatement-fetch'>fetch</link> 
         - holt eine Zeile aus einer Ergebnismenge
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDOStatement-fetchAll'>fetchAll</link> 
         - holt ein Array mit allen Zeilen einer Ergebnismenge
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDOStatement-fetchColumn'>fetchColumn</link> 
         - gibt die Daten einer einzelnen Spalte der Ergebnismenge zurück
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDOStatement-getAttribute'>getAttribute</link> 
         - fragt ein Attribut von PDOStatement ab
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDOStatement-getColumnMeta'>getColumnMeta</link> 
         - fragt Metadaten für eine Spalte in der Ergebnismenge ab
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDOStatement-nextRowset'>nextRowset</link> 
         - fragt die nächste Zeilenmenge (Ergebnismenge) ab
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDOStatement-rowCount'>rowCount</link> 
         - gibt die Anzahl der Zeilen zurück, die durch die Ausführung eines
         SQL-Statements betroffen wurden
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDOStatement-setAttribute'>setAttribute</link> 
         - setzt ein Attribut von PDOStatement
        </para>
       </listitem>
       <listitem>
        <para>
         <link linkend='function.PDOStatement-setFetchMode'>setFetchMode</link> 
         - setzt die Methode zur Abfrage für ein PDOStatement
        </para>
       </listitem>
      </itemizedlist>
     </section>
    </section>

    <section xml:id='pdo.class.PDOException'>
     <title><classname>PDOException</classname></title>
     <para>
      Stellt einen Fehler dar, der von PDO ausgelöst wird. Sie sollten selbst keine
      <classname>PDOException</classname> in Ihrem eigenen Code werfen.
      Unter <link linkend='language.exceptions'>Ausnahmen</link> finden Sie weitere
      Informationen über Ausnahmen in PHP.
     </para>
     <example>
      <title>The PDOException class</title>
      <programlisting role='php'>
<![CDATA[
<?php
class PDOException extends Exception
{
    public $errorInfo = null;    // corresponds to PDO::errorInfo()
                                 // or PDOStatement::errorInfo()
    protected $message;          // textual error message
                                 // use Exception::getMessage() to access it
    protected $code;             // SQLSTATE error code
                                 // use Exception::getCode() to access it
}
?>
]]>
      </programlisting>
     </example>
    </section>
    
   </section>
  &reference.pdo.constants;
  </partintro>
 &reference.pdo.entities.functions;
 </reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
