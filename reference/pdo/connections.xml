<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.1 $ -->
<!-- EN-Revision: 1.4 Maintainer: fa Status: ready -->

<chapter xml:id="pdo.connections" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Connections and Connection management</title>
    <title>Verbindungen und Verwaltung der Verbindungen</title>
    <para>
     Verbindungen werden durch das Erstellen von Instanzen der PDO-Basisklase erzeugt.
     Es ist unerheblich, welchen Treiber Sie benutzen wollen. Sie benutzen immer den
     PDO-Klassennamen. Der Konstruktor erwartet Parameter zur Angabe der 
     Datenbankquelle (auch bekannt als DSN) und optional für Benutzername und Passwort
     (falls vorhanden).
    </para>
    <para>
     <example><title>Mit MySQL verbinden</title>
      <programlisting role='php'>
<![CDATA[
<?php
$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass);
?>
]]> 
      </programlisting>
     </example>
    </para>
    <para>
     Wenn es Fehler bei der Verbindung gibt, wird eine Ausnahme vom Typ
     <literal>PDOException</literal> geworfen. Sie können die Ausnahme abfangen, wenn
     Sie sich selbst um die Fehlerbedingung kümmern wollen, oder Sie können es einer
     globalen Routine zur Ausnahmebehandlung überlassen, die Sie mit
     <function>set_exception_handler</function> konfigurieren.
    </para>
    <para>
     <example><title>Verbindungsfehler behandeln</title>
      <programlisting role='php'>
<![CDATA[
<?php
try {
   $dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass);
   foreach ($dbh->query('SELECT * from FOO') as $row) {
      print_r($row);
   }
   $dbh = null;
} catch (PDOException $e) {
   print "Error!: " . $e->getMessage() . "<br/>";
   die();
}
?>
]]>
      </programlisting>
     </example>
    </para>
    <warning>
     <para>
      Wenn Ihre Anwendung die vom PDO-Konstruktor geworfene Ausnahme nicht auffängt,
      ist die normale Vorgehnsweise der Zend Engine, das Script zu terminieren und einen
      Backtrace anzuzeigen. Dieser Backtrace wird wahrscheinlich alle Details der
      Datenbankverbindung enthüllen, inklusive Benutzername und Passwort. Sie sind also
      verantwortlich, diese Ausnahme aufzufangen, entweder explizit (mit einem
      <literal>catch</literal>-Block) oder implizit mit 
      <function>set_exception_handler</function>.
     </para>
    </warning>
    <para>
     Bei erfolgreicher Verbindung zur Datenbank wird eine Instanz der PDO-Klasse an Ihr
     Script zurückgegeben. Die Verbindung bleibt während der Lebensdauer des PDO-Objekts
     aktiv. Um die Verbindung zu beenden, müssen Sie das Objekt löschen, indem Sie 
     sicherstellen, dass alle Referenzen darauf gelöscht werden - das erreichen Sie,
     indem Sie der Variable, die das Objekt beinhaltet, &null; zuweisen. Wenn Sie das
     nicht explizit tun, schließt PHP die verbindung automatisch, wenn Ihr Script endet.
    </para>
    <para>
     <example><title>Eine Verbindung schließen</title>
     <programlisting role='php'>
<![CDATA[
<?php
$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass);
// use the connection here


// and now we're done; close it
$dbh = null;
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Viele Webanwendungen profitieren von persistenten Verbindungen zum Datenbankserver.
    Persistente Verbindungen werden nicht am Ende des Scripts geschlossen, sondern
    werden gecachet und wieder benutzt, wenn ein anderes Script eine Verbindung mit
    denselben Daten anfordert. Der Cache an persistenten Verbindungen erlaubt Ihnen,
    den Overhead zu vermeiden, wenn jedes mal eine neue Verbindung geöffnet wird,
    sobald ein Script mit der Datenbank kommunizieren muss, was sich in einer schnelleren
    Anwendung widerspiegelt.
   </para>
   <para>
    <example><title>Persistente Verbindungen</title>
     <programlisting role='php'>
<![CDATA[
<?php
$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass, array(
  PDO::ATTR_PERSISTENT => true
));
?>
]]>
     </programlisting>
     </example>
    </para>
    <note>
     <para>
      Wenn Sie den PDO-ODBC-Treiber benutzen und Ihre ODBC-Bibliotheken ODBC Connection
      Pooling unterstützen (unixODBC und Windows etwa, es könnte auch andere geben), dann
      wird empfohlen, dass sie keine persistenten PDO-Verbindungen benutzen, sondern das
      Cachen der Verbindungen der ODBC Connection Pooling-Schicht überlassen. Der ODBC
      Connection Pool wird mit anderen Modulen im Prozess geteilt. Wenn PDO also
      angewiesen wird die Verbindung zu cachen, wird diese Verbindung nie dem ODBC
      Connection Pool zurückgegeben, was darin resultiert, dass zusätzliche Verbindungen
      aufgebaut werden, um jene anderen Module zu bedienen.
     </para>
    </note>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
 
