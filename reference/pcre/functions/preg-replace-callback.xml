<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.8 $ -->
<!-- EN-Revision: 1.14 Maintainer: samesch Status: ready -->
<refentry id="function.preg-replace-callback">
 <refnamediv>
  <refname>preg_replace_callback</refname>
  <refpurpose>Sucht und ersetzt einen regulären Ausdruck unter Verwendung eines Callbacks</refpurpose>
 </refnamediv>
 <refsect1>
  <title>Beschreibung</title>
  <methodsynopsis>
   <type>mixed</type><methodname>preg_replace_callback</methodname>
   <methodparam><type>mixed</type><parameter>Suchmuster</parameter></methodparam>
   <methodparam><type>callback</type><parameter>Callback</parameter></methodparam>
   <methodparam><type>mixed</type><parameter>Zeichenkette</parameter></methodparam>
   <methodparam choice="opt"><type>int</type><parameter>Limit</parameter></methodparam>
   <methodparam choice="opt"><type>int</type><parameter role="reference">Zähler</parameter></methodparam>
  </methodsynopsis>
  <para>
   Abgesehen von der Tatsache, dass statt des Parameters
   <parameter>Ersatz</parameter> ein <parameter>Callback</parameter> angeben
   werden soll, dem ein Array von Übereinstimmungen mit der durchsuchten
   Zeichenkette übergeben wird, ist das Verhalten dieser Funktion identisch zu
   <function>preg_replace</function>. Der Callback sollte die
   Ersetzungs-Zeichenkette liefern. Für eine Beschreibung der anderen
   Parameter siehe <function>preg_replace</function>.
  </para>
  <example>
   <title><function>preg_replace_callback</function> Beispiel</title>
   <programlisting role='php'>
<![CDATA[
<?php
// dieser Text wurde 2002 verwendet
// wir wollen ihn für 2003 aktualisieren
$text = "Aprilscherze gibts am 01.04.2002\n";
$text.= "Das letzte Weihnachten war am 24.12.2001\n";
// die Callback-Funktion
function naechstes_jahr($treffer)
{
  // wie üblich: $treffer[0] ist die Übereinstimmung mit dem
  // kompletten Suchmuster, $treffer[1] die Übereinstimmung mit
  // dem ersten eingeklammerten Teil-Suchmuster und so weiter
  return $treffer[1].($treffer[2]+1);
}
echo preg_replace_callback(
            "|(\d{2}\.\d{2}\.)(\d{4})|",
            "naechstes_jahr",
            $text);
// das Ergebnis:
// Aprilscherze gibts am 01.04.2003
// Das letzte Weihnachten war am 24.12.2002
?>
]]>
   </programlisting>
  </example>
  <para>
   Häufig werden Sie die <parameter>Callback</parameter>-Funktion für
   <function>preg_replace_callback</function> nur an einer Stelle benötigen.
   In diesem Fall können Sie <function>create_function</function> verwenden,
   um innerhalb des Aufrufs von <function>preg_replace_callback</function>
   eine anonyme Funktion als Callback zu deklarieren. Auf diese Weise haben
   Sie alle Informationen für den Aufruf an einer Stelle und stopfen den
   Namensraum für Funktionen nicht mit Namen für Callback-Funktionen voll, die
   sonst nirgends verwendet werden.
  </para>
  <example>
   <title>
    <function>preg_replace_callback</function> und
    <function>create_function</function>
   </title>
   <programlisting role='php'>
<![CDATA[
<?php
// ein Kommandozeilen-Filter im Unix-Stil zum Umwandeln von Groß- in
// Kleinschreibung am Beginn eines Abschnitts
$fp = fopen("php://stdin", "r") or die("kann stdin nicht lesen");
while (!feof($fp)) {
  $zeile = fgets($fp);
  $zeile = preg_replace_callback(
    '|<p>\s*\w|',
    create_function(
      // hier sind entweder einfache Anführungszeichen nötig
      // oder alternativ die Maskierung aller $ als \$
      '$treffer',
      'return strtolower($treffer[0]);'
    ),
    $zeile
  );
  echo $zeile;
}
fclose($fp);
?>
]]>
   </programlisting>
  </example>
  <example>
   <title>
    <function>preg_replace_callback</function> unter Verwendung einer
    rekursiven Struktur um gekapselten BB-Code zu verarbeiten
   </title>
   <programlisting role='php'>
<![CDATA[
<?php
$input = "plain [indent] deep [indent] deeper [/indent] deep [/indent] plain";

function parseTagsRecursive($input)
{
  $regex = '#\[indent]((?:[^[]|\[(?!/?indent])|(?R))+)\[/indent]#';

  if (is_array($input)) {
    $input = '<div style="margin-left: 10px">'.$input[1].'</div>';
  }

  return preg_replace_callback($regex, 'parseTagsRecursive', $input);
}

$output = parseTagsRecursive($input);

echo $output;
?>
]]>
   </programlisting>
  </example>
  <note>
   <para>
    Der Parameter <parameter>Zähler</parameter> steht ab PHP 5.1.0 zur
    Verfügung.
   </para>
  </note>
  <para>
   Siehe auch <function>preg_replace</function>,
   <function>create_function</function>
   &listendand; &seealso.callback;.
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
