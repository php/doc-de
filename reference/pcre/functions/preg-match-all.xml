<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.1 $ -->
<!-- EN-Revision: 1.12 Maintainer: samesch Status: ready -->
<!-- splitted from ./en/functions/pcre.xml, last change in rev 1.2 -->
  <refentry id="function.preg-match-all">
   <refnamediv>
    <refname>preg_match_all</refname>
    <refpurpose>
     Führt eine umfassende Suche nach Übereinstimmungen mit regulärem
     Ausdruck durch
   </refnamediv>
   <refsect1>
    <title>Beschreibung</title>
     <methodsynopsis>
      <type>int</type><methodname>preg_match_all</methodname>
      <methodparam><type>string</type><parameter>Suchmuster</parameter></methodparam>
      <methodparam><type>string</type><parameter>Zeichenkette</parameter></methodparam>
      <methodparam><type>array</type><parameter>Treffer</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>Flags</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>Versatz</parameter></methodparam>
     </methodsynopsis>
    <para>
     Durchsucht <parameter>Zeichenkette</parameter> nach allen
     Übereinstimmungen mit dem in <parameter>Suchmuster</parameter>
     angegebenen regulären Ausdruck und legt sie in der durch
     <parameter>Flags</parameter> festgelegten Reihenfolge in
     <parameter>Treffer</parameter> ab.
    </para>
    <para>
     Nachdem die erste Übereinstimmung gefunden wurde, wird die nachfolgende
     Suche jeweils am Ende der letzten Übereinstimmung fortgesetzt.
    </para>
    <para>
     <parameter>Flags</parameter> kann eine Kombination folgender Flags sein
     (beachten Sie, dass es keinen Sinn hat,
     <constant>PREG_PATTERN_ORDER</constant> zusammen mit
     <constant>PREG_SET_ORDER</constant> zu verwenden):
     <variablelist>
      <varlistentry>
       <term>PREG_PATTERN_ORDER</term>
       <listitem>
        <para>
         Ordnet die Ergebnisse so an, dass $treffer[0] ein Array von
         Übereinstimmungen mit dem kompletten Suchmuster ist, $treffer[1] ein
         Array von Zeichenketten, die mit dem ersten eingeklammerten
         Teil-Suchmuster übereinstimmen und so weiter.
        </para>
        <para>
         <informalexample>
          <programlisting role="php">
<![CDATA[
<?php
preg_match_all("|<[^>]+>(.*)</[^>]+>|U", 
    "<b>Beispiel: </b><div align=left>das ist ein Test</div>", 
    $ausgabe, PREG_PATTERN_ORDER);
echo $ausgabe[0][0] . ", " . $ausgabe[0][1] . "\n";
echo $ausgabe[1][0] . ", " . $ausgabe[1][1] . "\n";
?>
]]>
          </programlisting>
          <para>
           Dieses Beispiel erzeugt:
          </para>
          <screen role="html">
<![CDATA[
<b>Beispiel: </b>, <div align=left>das ist ein Test</div>
Beispiel: , das ist ein Test
]]>
          </screen>
          <para>
           Also enthält $ausgabe[0] ein Array von Zeichenketten, die mit dem
           kompletten Suchmuster übereinstimmen und $ausgabe[1] ein Array von
           Zeichenketten, die sich zwischen Tags befinden.
          </para>
         </informalexample>
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>PREG_SET_ORDER</term>
       <listitem>
        <para>
         Ordnet die Ergebnisse so an, dass $treffer[0] ein Array aus dem
         ersten Satz von Übereinstimmungen ist, $treffer[1] ein Array aus dem
         zweiten Satz von Übereinstimmungen und so weiter.
         <informalexample>
          <programlisting role="php">
<![CDATA[
<?php
preg_match_all("|<[^>]+>(.*)</[^>]+>|U", 
    "<b>Beispiel: </b><div align=\"left\">das ist ein Test</div>", 
    $ausgabe, PREG_SET_ORDER);
echo $ausgabe[0][0] . ", " . $out[0][1] . "\n";
echo $ausgabe[1][0] . ", " . $out[1][1] . "\n";
?>
]]>
          </programlisting>
          <para>
           Dieses Beispiel erzeugt:
          </para>
          <screen role="html">
<![CDATA[
<b>Beispiel: </b>, Beispiel: 
<div align="left">das ist ein Test</div>, das ist ein Test
]]>
          </screen>
         </informalexample>
        </para>
        <para>
         In diesem Fall ist $treffer[0] der erste Satz von Übereinstimmungen
         und $treffer[0][0] enthält den Text, der mit dem kompletten
         Suchmuster übereinstimmt, $treffer[0][1] den Text, der mit dem ersten
         Teil-Suchmuster übereinstimmt und so weiter. Auf die gleiche Weise
         ist $treffer[1] der zweite Satz von Übereinstimmungen etc.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>PREG_OFFSET_CAPTURE</term>
       <listitem>
        <para>
         Wenn dieses Flag gesetzt ist, wird mit jeder gefundenen
         Übereinstimmung der dazugehörige Versatz in der Zeichenkette
         zurückgegeben. Beachten Sie, dass dies die Rückgabewerte in einem
         Array dahingehend ändert, dass jedes Element ein Array ist, das aus
         der übereinstimmenden Zeichenkette als Element <literal>0</literal>
         und deren Stelle in der durchsuchten Zeichenkette als Element
         <literal>1</literal> besteht. Dieses Flag steht seit PHP 4.3.0 zur
         Verfügung.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Falls kein Flag für die Anordnung angegeben wurde, wird
     <constant>PREG_PATTERN_ORDER</constant> angenommen.
    </para>

    <para>
     Normalerweise beginnt die Suche am Anfang der Zeichenkette. Der optionale
     Parameter <parameter>Versatz</parameter> kann verwendet werden, um eine
     andere Stelle anzugeben, ab der gesucht werden soll. Es ist der Übergabe
     von <function>substr</function>($zeichenkette, $versatz) an Stelle der
     Zeichenkette an <function>preg_match</function> gleichwertig.
     Der Parameter <parameter>Versatz</parameter> steht seit
     <literal>PHP</literal> 4.3.3 zur Verfügung.
    </para>

    <para>
     Gibt die Anzahl der Übereinstimmungen mit dem kompletten Suchmuster
     zurück (die auch Null sein kann) oder &false;, falls ein Fehler auftrat.
    </para>
    <para>
     <example>
      <title>Alle Telefonnummern aus einem Text holen.</title>
      <programlisting role="php">
<![CDATA[
<?php
preg_match_all("/\(?  (\d{3})?  \)?  (?(1)  [\-\s] ) \d{3}-\d{4}/x",
                "Wählen Sie 555-1212 oder 1-800-555-1212", $telefon);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>Zusammen gehörende HTML-Tags finden (gierig)</title>
      <programlisting role="php">
<![CDATA[
<?php
// Das \\2 ist ein Beispiel für Rückreferenzierung. Es teilt pcre mit, dass
// der reguläre Ausdruck mit dem für das zweite Klammerpaar, also in diesem
// Fall mit dem für ([\w]+) gefundenen Ausdruck selbst übereinstimmen muss.
// Der zusätzliche Backslash wird wegen der doppelten Anführungsstriche
// benötigt.
$html = "<b>fett gedruckter Text</b><a href=howdy.html>klick mich an</a>";

preg_match_all("/(<([\w]+)[^>]*>)(.*)(<\/\\2>)/", $html, $treffer);

for ($i=0; $i< count($treffer[0]); $i++) {
  echo "gefunden: " . $treffer[0][$i] . "\n";
  echo "Teil 1: " . $treffer[1][$i] . "\n";
  echo "Teil 2: " . $treffer[3][$i] . "\n";
  echo "Teil 3: " . $treffer[4][$i] . "\n\n";
}
?>
]]>
      </programlisting>
      <para>
       Dieses Beispiel erzeugt:
      </para>
      <screen role="html">
<![CDATA[
gefunden: <b>fett gedruckter Text</b>
Teil 1: <b>
Teil 2: fett gedruckter Text
Teil 3: </b>

gefunden: <a href=howdy.html>klick mich an</a>
Teil 1: <a href=howdy.html>
Teil 2: klick mich an
Teil 3: </a>
]]>
      </screen>
     </example>
    </para>
    <simpara>
     Siehe auch <function>preg_match</function>,
     <function>preg_replace</function> und <function>preg_split</function>.
    </simpara>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
