<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.10 $ -->
<!-- EN-Revision: 1.23 Maintainer: samesch Status: ready -->
<refentry id="function.preg-match">
 <refnamediv>
  <refname>preg_match</refname>
  <refpurpose>Führt eine Suche mit einem regulären Ausdruck durch</refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>int</type><methodname>preg_match</methodname>
   <methodparam><type>string</type><parameter>Suchmuster</parameter></methodparam>
   <methodparam><type>string</type><parameter>Zeichenkette</parameter></methodparam>
   <methodparam choice="opt"><type>array</type><parameter role="reference">Treffer</parameter></methodparam>
   <methodparam choice="opt"><type>int</type><parameter>Flags</parameter></methodparam>
   <methodparam choice="opt"><type>int</type><parameter>Versatz</parameter></methodparam>
  </methodsynopsis>
  <para>
   Durchsucht <parameter>Zeichenkette</parameter> nach Übereinstimmungen mit
   dem in <parameter>Suchmuster</parameter> angegebenen regulären Ausdruck.
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>Suchmuster</parameter></term>
     <listitem>
      <para>
       Der Ausdruck nach dem gesucht werden soll als Zeichenkette
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>Zeichenkette</parameter></term>
     <listitem>
      <para>
       Die zu durchsuchende Zeichenkette
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>Treffer</parameter></term>
     <listitem>
      <para>
       Falls der Parameter <parameter>Treffer</parameter> angegeben wurde,
       wird er mit den Suchergebnissen gefüllt. <varname>$treffer[0]</varname>
       enthält dann den Text, der auf das komplette Suchmuster passt,
       <varname>$treffer[1]</varname> den Text, der auf das erste
       eingeklammerte Teilsuchmuster passt und so weiter.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>Flags</parameter></term>
     <listitem>
      <para>
       <parameter>Flags</parameter> kann das folgende Flag sein:
       <variablelist>
        <varlistentry>
         <term><constant>PREG_OFFSET_CAPTURE</constant></term>
         <listitem>
          <simpara>
           Falls dieses Flag gesetzt ist, wird mit jeder gefundenen
           Übereinstimmung der dazugehörige Versatz in der Zeichenkette
           zurückgegeben. Beachten Sie, dass dies die Rückgabewerte in einem
           Array dahingehend ändert, dass jedes Element ein Array ist, das aus
           der übereinstimmenden Zeichenkette als Element <literal>0</literal>
           und deren Stelle in <parameter>Zeichenkette</parameter> als Element
           <literal>1</literal> besteht.
          </simpara>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>Versatz</parameter></term>
     <listitem>
      <para>
       Normalerweise beginnt die Suche am Anfang der Zeichenkette. Der
       optionale Parameter <parameter>Versatz</parameter> kann verwendet
       werden, um eine andere Stelle anzugeben, ab der gesucht werden soll.
      </para>
      <note>
       <para>
        Die Verwendung von <parameter>Versatz</parameter> entspricht nicht der
        Übergabe von <literal>substr($zeichenkette, $versatz)</literal> an
        Stelle der zu Zeichenkette an <function>preg_match</function>, weil
        <parameter>Suchmuster</parameter> Angaben wie zum Beispiel
        <emphasis>^</emphasis>, <emphasis>$</emphasis> oder
        <emphasis>(?&lt;=x)</emphasis> enthalten kann. Vergleiche:
        <informalexample>
         <programlisting role="php">
<![CDATA[
<?php
$zeichenkette = "abcdef";
$suchmuster = '/^def/';
preg_match($suchmuster, $zeichenkette, $treffer, PREG_OFFSET_CAPTURE, 3);
print_r($treffer);
?>
]]>
         </programlisting>
         &example.outputs;
         <screen>
<![CDATA[
Array
(
)
]]>
         </screen>
         <para>
          während dieses Beispiel
         </para>
         <programlisting role="php">
<![CDATA[
<?php
$zeichenkette = "abcdef";
$suchmuster = '/^def/';
preg_match($suchmuster, substr($zeichenkette,3), $treffer, PREG_OFFSET_CAPTURE);
print_r($treffer);
?>
]]>
         </programlisting>
         <para>
          folgende Ausgabe erzeugt
         </para>
         <screen>
<![CDATA[
Array
(
    [0] => Array
        (
            [0] => def
            [1] => 0
        )
)
]]>
         </screen>
        </informalexample>
       </para>
      </note>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   <function>preg_match</function> gibt die Anzahl der Übereinstimmungen mit
   <parameter>Suchmuster</parameter> zurück. Das ist entweder 0 (keine
   Übereinstimmung) oder 1, weil <function>preg_match</function> die Suche
   nach der ersten Übereinstimmung beendet. Im Gegensatz dazu setzt
   <function>preg_match_all</function> die Suche bis zum Ende von
   <parameter>Zeichenkette</parameter> fort. <function>preg_match</function>
   gibt &false; zurück, falls ein Fehler auftrat.
  </para>
 </refsect1>

 <refsect1 role="changelog">
  &reftitle.changelog;
  <para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>4.3.3</entry>
       <entry>Den Parameter <parameter>Versatz</parameter> hinzugefügt</entry>
      </row>
      <row>
       <entry>4.3.0</entry>
       <entry>
        Das Flag <constant>PREG_OFFSET_CAPTURE</constant> hinzugefügt
       </entry>
      </row>
      <row>
       <entry>4.3.0</entry>
       <entry>Den Parameter <parameter>Flags</parameter> hinzugefügt</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example>
    <title>Die Zeichenkette "php" finden</title>
    <programlisting role="php">
<![CDATA[
<?php
// Das "i" nach der Suchmuster-Begrenzung kennzeichnet eine Suche ohne
// Berücksichtigung von Groß- und Kleinschreibung
if (preg_match("/php/i", "PHP ist die Web-Scripting-Sprache der Wahl.")) {
   echo "Es wurde eine Übereinstimmung gefunden.";
} else {
   echo "Es wurde keine Übereinstimmung gefunden.";
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Die Zeichenkette "web" finden</title>
    <programlisting role="php">
<![CDATA[
<?php
// Das \b im Suchmuster kennzeichnet eine Wortgrenze, weshalb nur eine
// Übereinstimmung mit der einzelnen Zeichenkette "web" gefunden wird und
// nicht ein Teilwort in "webbing" oder "cobweb"
if (preg_match("/\bweb\b/i", "Für das Web ist PHP die Scripting-Sprache der Wahl.")) {
   echo "Es wurde eine Übereinstimmung gefunden.";
} else {
   echo "Es wurde keine Übereinstimmung gefunden.";
}

if (preg_match("/\bweb\b/i", "PHP ist die Web-Scripting-Sprache der Wahl.")) {
   echo "Es wurde eine Übereinstimmung gefunden.";
} else {
   echo "Es wurde keine Übereinstimmung gefunden.";
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>Den Domänen-Namen aus einer URL holen</title>
    <programlisting role="php">
<![CDATA[
<?php
// den Hostnamen aus URL holen
preg_match('@^(?:http://)?([^/]+)@i',
    "http://www.php.net/index.html", $treffer);
$host = $treffer[1];

// die letzten beiden Segmente aus Hostnamen holen
preg_match('/[^.]+\.[^.]+$/', $host, $treffer);
echo "Der Domänen-Name lautet: {$treffer[0]}\n";
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Der Domänen-Name lautet: php.net
]]>
    </screen>
   </example>
  </para>
 </refsect1>

 <refsect1 role="notes">
  &reftitle.notes;
  <tip>
   <para>
    Verwenden Sie nicht <function>preg_match</function>, wenn Sie nur
    überprüfen wollen, ob eine Zeichenkette in einer anderen Zeichenkette
    enthalten ist. Verwenden Sie dafür stattdessen die Funktionen
    <function>strpos</function> oder <function>strstr</function>, die das
    schneller erledigen.
   </para>
  </tip>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>preg_match_all</function></member>
    <member><function>preg_replace</function></member>
    <member><function>preg_split</function></member>
   </simplelist>
  </para>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
