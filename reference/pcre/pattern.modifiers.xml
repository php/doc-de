<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: a9ada9d6f9b5504aca3815eed58aa5d499e03eab Maintainer: samesch Status: ready -->

<article xml:id="reference.pcre.pattern.modifiers" xmlns="http://docbook.org/ns/docbook">
 <title>Suchmuster-Modifikatoren</title>
 <titleabbrev>Mögliche Modifikatoren in RegEx-Suchmustern</titleabbrev>
 <para>
  Die zurzeit möglichen PCRE-Modifikatoren sind unten aufgelistet. Die
  Bezeichnungen in Klammern beziehen sich auf die internen PCRE-Bezeichnungen
  für diese Modifikatoren. Leerzeichen und Zeilenumbrüche in Modifikatoren
  werden ignoriert. Andere Zeichen führen zu einem Fehler.
 </para>
 <para>
  <blockquote>
   <variablelist>
    <varlistentry>
     <term><emphasis>i</emphasis> (<literal>PCRE_CASELESS</literal>)</term>
     <listitem>
      <simpara>
       Wenn dieser Modifikator gesetzt ist, passen Buchstaben im Suchmuster
       sowohl auf groß- als auch auf kleingeschriebene Buchstaben.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>m</emphasis> (<literal>PCRE_MULTILINE</literal>)</term>
     <listitem>
      <simpara>
       Standardmäßig behandelt PCRE eine zu durchsuchende Zeichenkette wie
       eine einzige Zeile von Zeichen (auch wenn sie tatsächlich mehrere
       Zeilenumbrüche enthält). Das Metazeichen für einen Zeilenanfang (^)
       passt nur auf den Anfang der Zeichenkette, das Metazeichen für ein
       Zeilenende ($) nur auf das Ende der Zeichenkette (falls der Modifikator
       <emphasis>D</emphasis> nicht gesetzt ist). Das ist genauso wie bei
       Perl.
      </simpara>
      <simpara>
       Wenn dieser Modifikator gesetzt ist, passen die Zeilenanfang- und
       Zeilenende-Konstrukte in der Zeichenkette sowohl direkt nach, bzw. vor
       einem Zeilenumbruch als auch auf deren Anfang und Ende. Das entspricht
       dem Perl-Modifikator /m. Falls die Zeichenkette keine Sequenz "\n"
       enthält, oder im Suchmuster kein ^ oder $ vorkommt, hat dieser
       Modifikator keine Wirkung.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>s</emphasis> (<literal>PCRE_DOTALL</literal>)</term>
     <listitem>
      <simpara>
       Wenn dieser Modifikator gesetzt ist, passt das Metazeichen Punkt im
       Suchmuster auf alle Zeichen inklusive Zeilenumbrüche. Ohne diesen
       Modifikator sind Zeilenumbrüche ausgeschlossen. Dieser Modifikator
       entspricht dem Perl-Modifikator /s. Unabhängig davon, ob dieser
       Modifikator gesetzt ist, passt eine verneinende Zeichenklasse wie z.B.
       [^a] immer auf einen Zeilenumbruch.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>x</emphasis> (<literal>PCRE_EXTENDED</literal>)</term>
     <listitem>
      <simpara>
       Wenn dieser Modifikator gesetzt ist, werden Leerräume im Suchmuster
       ignoriert, sofern sie nicht maskiert sind oder sich innerhalb einer
       Zeichenklasse befinden. Außerdem werden Zeichen, die außerhalb einer
       Zeichenklasse zwischen nicht maskierten # stehen, einschließlich dem
       nächsten Zeilenumbruch ignoriert. Das entspricht dem Perl-Modifikator
       /x und bietet die Möglichkeit, Kommentare in komplizierte Suchmuster
       einzufügen. Beachten Sie aber, dass dies nur für Datenzeichen gilt.
       Leerräume dürfen niemals innerhalb einer Folge spezieller Zeichen
       auftreten, zum Beispiel in der Folge (?(, die einen
       bedingten Teilausdruck einleitet.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry xml:id="reference.pcre.pattern.modifiers.eval">
     <term><emphasis>e</emphasis> (<literal>PREG_REPLACE_EVAL</literal>)</term>
     <listitem>
      &warn.deprecated.feature-5-5-0.removed-7-0-0;
      <simpara>
       Wenn dieser veraltete Modifikator gesetzt ist, macht
       <function>preg_replace</function> in der Ersetzungszeichenkette eine
       normale Ersetzung von Rückrefenzen, wertet sie als PHP-Code aus und
       verwendet das Ergebnis um damit die gesuchte Zeichenkette zu ersetzen.
       Einfache Anführungszeichen, doppelte Anführungszeichen, Backslashes
       (<literal>\</literal>) und NULL-Zeichen werden in den ersetzten
       Rückreferenzen mit einem Backslash maskiert.
      </simpara>
      <caution>
       <para>
        Bei jeder passenden Rückreferenz wird die Funktion
        <function>addslashes</function> aufgerufen, bevor sie ersetzt wird.
        Wenn die Rückreferenz als Zeichenkette in Anführungszeichen verwendet
        wird, werden von daher maskierte Zeichen in Buchstabensymbole
        umgewandelt. Allerdings behalten maskierte Zeichen, die normalerweise
        nicht umgewandelt würden, ihre Backslashes. Das macht die Verwendung
        dieses Modifikators sehr kompliziert.
       </para>
      </caution>
      <caution>
       <para>
        Stellen Sie sicher, dass <parameter>replacement</parameter> gültigen
        PHP-Code erzeugt, weil sich PHP sonst über einen Parse Error in der
        Zeile beschwert, die den Aufruf von <function>preg_replace</function>
        enthält.
       </para>
      </caution>
      <caution>
       <para>
        Von der Verwendung dieses Modifikators wird
        <emphasis>abgeraten</emphasis>, weil damit sehr leicht
        Sicherheitslücken entstehen können:
       </para>
       <informalexample>
        <programlisting role="php">
<![CDATA[
<?php
$html = $_POST['html'];

// großgeschriebene Überschriften
$html = preg_replace(
    '(<h([1-6])>(.*?)</h\1>)e',
    '"<h$1>" . strtoupper("$2") . "</h$1>"',
    $html
);
]]>
        </programlisting>
       </informalexample>
       <para>
        Der obige Beispiel-Code kann durch Übergabe einer Zeichenkette wie
        z.B.
        <literal>&lt;h1&gt;{${eval($_GET[php_code])}}&lt;/h1&gt;</literal>
        leicht ausgenutzt werden. Das gibt Angreifern die Möglichkeit,
        beliebigen PHP-Code auszuführen und gibt ihnen somit beinahe
        vollständigen Zugriff auf den Server.
       </para>
       <para>
        Um diese Sicherheitslücke zur Ausführung von Code von außen (Remote
        Code Execution) zu vermeiden, sollte stattdessen die Funktion
        <function>preg_replace_callback</function> verwendet werden:
       </para>
       <informalexample>
        <programlisting role="php">
<![CDATA[
<?php
$html = $_POST['html'];

// großgeschriebene Überschriften
$html = preg_replace_callback(
    '(<h([1-6])>(.*?)</h\1>)',
    function ($m) {
        return "<h$m[1]>" . strtoupper($m[2]) . "</h$m[1]>";
    },
    $html
);
]]>
        </programlisting>
       </informalexample>
      </caution>
      <note>
       <para>
        Dieser Modifikator wird nur von <function>preg_replace</function>
        verwendet; von anderen PCRE-Funktionen wird er ignoriert.
       </para>
      </note>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>A</emphasis> (<literal>PCRE_ANCHORED</literal>)</term>
     <listitem>
      <simpara>
       Wenn dieser Modifikator gesetzt ist, wird das Suchmuster "verankert",
       das bedeutet, dass es gezwungen wird, nur auf den Anfang der
       durchsuchten Zeichenkette zu passen. Diese Wirkung kann auch durch
       geeignete Konstrukte im Suchmuster selbst erreicht werden, was in Perl
       die einzige Möglichkeit ist, sie zu realisieren.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>D</emphasis> (<literal>PCRE_DOLLAR_ENDONLY</literal>)</term>
     <listitem>
      <simpara>
       Wenn dieser Modifikator gesetzt ist, passt ein Dollar-Metazeichen im
       Suchmuster nur auf das Ende der durchsuchten Zeichenkette. Ohne diesen
       Modifikator passt ein Dollarzeichen auch direkt vor dem letzten
       Zeichen, falls es ein Zeilenumbruch ist (aber nicht vor anderen
       Zeilenumbrüchen). Wenn der Modifikator <emphasis>m</emphasis> gesetzt
       ist, wird dieser Modifikator ignoriert. Für diesen Modifikator gibt es
       in Perl keine Entsprechung.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>S</emphasis></term>
     <listitem>
      <simpara>
       Wenn ein Suchmuster mehrmals verwendet werden soll, lohnt es sich, mehr
       Zeit für dessen Analyse aufzubringen um die Suche zu optimieren. Wenn
       dieser Modifikator gesetzt ist, wird diese zusätzliche Analyse
       durchgeführt. Gegenwärtig ist die Untersuchung eines Suchmusters nur
       für nicht verankerte Suchmuster brauchbar, die am Anfang kein einzelnes
       fixiertes Zeichen haben.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>U</emphasis> (<literal>PCRE_UNGREEDY</literal>)</term>
     <listitem>
      <simpara>
       Dieser Modifikator kehrt die Gier von Quantifikatoren um, sodass sie
       standardmäßig nicht gierig sind, aber gierig werden, wenn ihnen ein
       <literal>?</literal> folgt. Das ist nicht mit Perl kompatibel. Es kann
       auch <link linkend="regexp.reference.internal-options">innerhalb des
       Suchmusters</link> mit dem Modifikator (<literal>?U</literal>) oder
       durch ein Fragezeichen hinter dem Quantifikator (z.B.
       <literal>.*?</literal>) gesetzt werden.
      </simpara>
       <note>
        <para>
         Im Ungreedy-Modus ist es nicht möglich, mehr als <link
         linkend="ini.pcre.backtrack-limit">pcre.backtrack_limit</link>
         Übereinstimmungen zu treffen.
        </para>
       </note>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>X</emphasis> (<literal>PCRE_EXTRA</literal>)</term>
     <listitem>
      <simpara>
       Dieser Modifikator schaltet zusätzliche PCRE-Funktionalität ein, die
       nicht mit Perl kompatibel ist. Ein Backslash vor einem Buchstaben, der
       keine spezielle Bedeutung hat, verursacht eine Fehlermeldung und
       reserviert diese Kombinationen somit für künftige Erweiterungen.
       Standardmäßig wird ein Backslash vor einem Buchstaben, der keine
       spezielle Bedeutung hat, wie in Perl als Buchstabensymbol behandelt.
       Gegenwärtig werden von diesem Modifikator keine weiteren Eigenschaften
       kontrolliert.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>J</emphasis> (<literal>PCRE_INFO_JCHANGED</literal>)</term>
     <listitem>
      <simpara>
       Die interne Option (?J) ändert die lokale Option
       <literal>PCRE_DUPNAMES</literal>. Erlaubt doppelte Namen für
       Teilsuchmuster.
       Von PHP 7.2.0 an wird der <literal>J</literal>-Modifikator ebenfalls
       unterstützt.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><emphasis>u</emphasis> (<literal>PCRE_UTF8</literal>)</term>
     <listitem>
      <simpara>
       Dieser Modifikator schaltet zusätzliche PCRE-Funktionalität ein, die
       nicht mit Perl kompatibel ist. Suchmuster und durchsuchte Zeichenketten
       werden als UTF-8 behandelt. Eine ungültige Zeichenkette bewirkt, dass
       die preg_*-Funktionen keine Übereinstimmungen finden. Ein ungültiges
       Suchmuster erzeugt einen Fehler der Stufe E_WARNING.
       UTF-8-Zeichenfolgen mit fünf oder sechs Oktetten werden seit PHP 5.3.4,
       bzw. PCRE 7.3 2007-08-28 als ungültig betrachtet; davor wurden sie als
       gültiges UTF-8 betrachtet.
      </simpara>
     </listitem>
    </varlistentry>
   </variablelist>
  </blockquote>
 </para>
</article>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
