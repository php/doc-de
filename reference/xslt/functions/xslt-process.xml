<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.10 $ -->
<!-- EN-Revision: 1.21 Maintainer: sammywg Status: ready -->
<refentry xml:id="function.xslt-process" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>xslt_process</refname>
  <refpurpose>Führt eine XSLT-Transformation durch</refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>mixed</type><methodname>xslt_process</methodname>
   <methodparam><type>resource</type><parameter>xh</parameter></methodparam>
   <methodparam><type>string</type><parameter>xmlcontainer</parameter></methodparam>
   <methodparam><type>string</type><parameter>xslcontainer</parameter></methodparam>
   <methodparam choice="opt"><type>string</type><parameter>resultcontainer</parameter></methodparam>
   <methodparam choice="opt"><type>array</type><parameter>arguments</parameter></methodparam>
   <methodparam choice="opt"><type>array</type><parameter>parameters</parameter></methodparam>
  </methodsynopsis>
  <para>
   Die Funktion <function>xslt_process</function> ist die Krux der
   XSLT-Extension. Sie erlaubt es Ihnen, eine XSLT-Transformation unter
   Verwendung von fast jeder Art von Eingabequelle durchzuführen - den
   Containern. Dies wird durch die Verwendung von Argument-Buffern erreicht,
   einem Konzept, das vom Sablotron-XSLT-Prozessor übernommen wurde (derzeit
   der einzige XSLT-Prozessor, den diese Extension unterstützt). Die
   Input-Container enthalten standardmäßig einen Dateinamen, der für die zu
   prozessierende Datei steht.
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>xh</parameter></term>
     <listitem>
      <para>
       Der XSLT-Prozessor-Linkidentifier, der mittels
       <function>xslt_create</function> erzeugt wurde.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>xmlcontainer</parameter></term>
     <listitem>
      <para>
       Pfad zur XML-Datei oder Platzhalter für ein XML-Argument.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>xslcontainer</parameter></term>
     <listitem>
      <para>
       Pfad zur XSL-Datei oder Platzhalter für ein XML-Argument.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>resultcontainer</parameter></term>
     <listitem>
      <para>
       Der Result-Container enthält standardmäßig den Dateinamen des
       transformierten Dokuments. Wenn der Result-Container nicht angegeben
       wurde (also &null; ist), wird das Ergebnis zurückgegeben.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>arguments</parameter></term>
     <listitem>
      <para>
       Anstelle von Dateien können Sie auch &quot;Argument-Platzhalter&quot;
       als XML- oder XSLT-Argumente an <function>xslt_process</function>
       übergeben. Diese Platzhalter werden durch die im
       <parameter>arguments</parameter>-Array angegebenen Werte ersetzt.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>parameters</parameter></term>
     <listitem>
      <para>
       Ein Array von aller Toplevel-Parameter, die an das XSLT-Dokument
       übergeben werden sollen. Auf diese Parameter können Sie in Ihren
       XSL-Dateien unter Verwendung einer
       &lt;xsl:param name=&quot;parameter_name&quot;&gt;-Anweisung zugreifen.
       Die Parameter müssen UTF-8-kodiert sein, ihre Werte werden vom
       <productname>Sablotron</productname>-Prozessor als Strings interpretiert.
       Mit anderen Worten, Sie können keine Node-Sets als Parameter an ein
       XSLT-Dokument übergeben.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  <para>
   Container können außerdem mittels des <parameter>arguments</parameter>-Arrays
   bestimmt werden (siehe unten).
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   &return.success; Wenn der Result-Container nicht angegeben wurde (also z.B.
   &null; ist), wird das Ergebnis zurückgegeben.
  </para>
 </refsect1>

 <refsect1 role="changelog">
  &reftitle.changelog;
  <para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>&Version;</entry>
       <entry>&Description;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>4.0.6</entry>
       <entry>
        Die Funktion akzeptiert nicht länger Strings in
        <parameter>xmlcontainer</parameter> und
        <parameter>xslcontainer</parameter>. Die Übergabe von XML-enthaltenden
        Zeichenketten an einen der beiden Parameter erzeugt einen
        Speicherzugriffsfehler in Sablotronversionen bis inklusive 0.95.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   Die einfachste Art einer Transformation mit der
   <function>xslt_process</function>-Funktion ist die Transformation eines
   XML-Files durch ein XSLT-File und die Speicherung des Ergebnisses in eine
   dritte Datei, die das neue XML- (oder HTML-)Dokument enthält. Dies mit
   Sablotron zu tun ist mehr als einfach.
  </para>
  <example>
   <title>Verwendung von <function>xslt_process</function>, um eine XML-Datei
   und eine XSL-datei in ein neues XML-File zu transformieren</title>
   <programlisting role="php">
<![CDATA[
<?php

// Einen neuen XSLT-Prozessor erstellen
$xh = xslt_create();

// Das Dokument verarbeiten
if (xslt_process($xh, 'sample.xml', 'sample.xsl', 'result.xml')) {
    echo "ERFOLG, sample.xml wurde durch sample.xsl in result.xml transformiert";
    echo ", result.xml hat folgenden Inhalt\n<br />\n";
    echo "<pre>\n";
    readfile('result.xml');
    echo "</pre>\n";
} else {
    echo "Sorry, sample.xml konnte nicht von sample.xsl in result.xml ";
    echo "transformiert werden. Fehlermeldung: " . xslt_error($xh) . " und ";
    echo "Fehlernummer: " . xslt_errno($xh);
}

xslt_free($xh);

?>
]]>
   </programlisting>
  </example>
  <para>
   Obwohl diese Funktion in den meisten Fällen, besonders im Webumfeld,
   hervorragend läuft, sollten Sie dennoch davon absehen, Ihre Ergebnisse
   direkt auszugeben. Daher ist es geschickter, das dritte Argument der
   <function>xslt_process</function>-Funktion wegzulassen (oder dem Argument
   &null; zu übergeben) und damit den Rückgabewert der XSLT-Transformation zu
   erhalten, statt ihn in eine Datei zu schreiben.
  </para>
  <para>
   <example>
   <title>Verwendung von <function>xslt_process</function>, um eine XML-Datei
   und eine XSL-Datei zu transformieren und einer Variable die resultierenden
   XML-Daten zuzuweisen</title>
   <programlisting role="php">
<![CDATA[
<?php

// Einen neuen XSLT-Prozessor erstellen
$xh = xslt_create();

// Dokument verarbeiten, Rückgabe des Ergebnisses an die $result-Variable
$result = xslt_process($xh, 'sample.xml', 'sample.xsl');
if ($result) {
    echo "ERFOLG, sample.xml wurde durch sample.xsl in die Variable \$result ";
    echo "transformiert, die Variable \$result hat folgenden Inhalt\n<br />\n";
    echo "<pre>\n";
    echo $result;
    echo "</pre>\n";
} else {
    echo "Sorry, sample.xml konnte nicht von sample.xsl in die Variable \$result ";
    echo "transformiert werden. Fehlermeldung: " . xslt_error($xh) . " und ";
    echo "Fehlernummer: " . xslt_errno($xh);
}

xslt_free($xh);

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Die oberen zwei Fälle sind die einfachsten Fälle die es gibt, wenn eine
   XSLT-Transformation durchgeführt werden soll. Unseres Erachtens sind sie
   sogar die häufigsten Fälle; allerdings erhalten Sie auch häufig Ihr
   XML- und XSLT-Daten aus externen Quellen wie Datenbanken oder Sockets.
   In diesen Fällen befinden sich die XML- und/oder die XSL-Daten in einer
   Variablen - und in Anwendungen, die produktiv eingesetzt werden, erzeugt es
   zu viel Overhead, diese Daten vor ihrer Verarbeitung erst in eine Datei zu
   schreiben. An dieser Stelle kommt die XSLT-&quot;argument&quot;-Syntax zum
   Tragen. Anstatt Dateien als XML- und XSLT-Argumente an
   <function>xslt_process</function> zu übergeben, können Sie
   &quot;Argumentplatzhalter&quot; angeben, die durch die im Argument-Array
   übergebenen Werte ersetzt werden (der fünfte Parameter der Funktion
   <function>xslt_process</function>). Nachfolgend zeigen wir in einem Beispiel,
   wie XML und XSLT verarbeitet und das Ergebnis in eine Variable geschrieben
   wird, ohne eine Datei zu verwenden.
  </para>
  <para>
   <example>
   <title>Verwendung von <function>xslt_process</function>, um eine XML-Daten
    enthaltende Variable und eine XSL-Daten enthaltende Variable in eine
    Variable zu transformieren, die die resultierenden XML-Daten enthält</title>
   <programlisting role="php">
<![CDATA[
<?php
// $xml und $xsl enthalten die XML- und XSL-Daten

$arguments = array(
     '/_xml' => $xml,
     '/_xsl' => $xsl
);

// Einen neuen XSLT-Prozessor erzeugen
$xh = xslt_create();

// Dokument verarbeiten
$result = xslt_process($xh, 'arg:/_xml', 'arg:/_xsl', NULL, $arguments);
if ($result) {
    echo "ERFOLG, sample.xml wurde durch sample.xsl in die Variable \$result ";
    echo "transformiert, die Variable \$result hat folgenden Inhalt\n<br />\n";
    echo "<pre>\n";
    echo $result;
    echo "</pre>\n";
} else {
    echo "Sorry, sample.xml konnte nicht von sample.xsl in die Variable \$result ";
    echo "transformiert werden. Fehlermeldung: " . xslt_error($xh) . " und ";
    echo "Fehlernummer: " . xslt_errno($xh);
}
xslt_free($xh);
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <example>
    <title>PHP-Variablen an die XSL-Dateien übergeben</title>
    <programlisting role="php">
<![CDATA[
<?php

// XML-String
$xml = '<?xml version="1.0"?>
<para>
 ändere mich
</para>';

// XSL-String
$xsl = '
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="html" encoding="ISO-8859-1" indent="no"
 omit-xml-declaration="yes"  media-type="text/html"/>
 <xsl:param name="myvar"/>
 <xsl:param name="mynode"/>
 <xsl:template match="/">
Meine PHP-Variable: <xsl:value-of select="$myvar"/><br />
Mein Node-Set: <xsl:value-of select="$mynode"/>
 </xsl:template>
</xsl:stylesheet>';


$xh = xslt_create();

// der zweite Parameter wird als String interpretiert
$parameters = array (
  'myvar' => 'test',
  'mynode' => '<foo>bar</foo>'
);

$arguments = array (
  '/_xml' => $xml,
  '/_xsl' => $xsl
);

echo xslt_process($xh, 'arg:/_xml', 'arg:/_xsl', NULL, $arguments, $parameters);

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Meine PHP-Variable: test<br>
Mein Node-Set: &lt;foo&gt;bar&lt;/foo&gt;
]]>
    </screen>
   </example>
  </para>
 </refsect1>

 <refsect1 role="notes">
  &reftitle.notes;
  &note.xslt.windows;
 </refsect1>

</refentry>


<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
