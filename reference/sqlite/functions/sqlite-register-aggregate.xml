<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.3 $ -->
<!-- EN-Revision: 1.1 Maintainer: hartmann Status: working -->
<refentry xml:id="function.sqlite-register-aggregate" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>sqlite_register_aggregate</refname>
  <refpurpose>Erzeugt eine aggregierende UDF zur Nutzung in SQL-Befehlen</refpurpose></refnamediv>
 <refsect1>
  <title>Beschreibung</title>
  <methodsynopsis>
   <type>bool</type><methodname>sqlite_register_aggregate</methodname>
   <methodparam><type>resource</type><parameter>db</parameter></methodparam>
   <methodparam><type>string</type><parameter>Funktionsname</parameter></methodparam>
   <methodparam><type>mixed</type><parameter>Schrittfunktion</parameter></methodparam>
   <methodparam><type>mixed</type><parameter>Finalefunktion</parameter></methodparam>
   <methodparam choice="opt"><type>int</type><parameter>Argumentenzahl</parameter></methodparam>
  </methodsynopsis>
  <para>
   <function>sqlite_register_aggregate</function> entspricht etwa der Funktion
   <function>sqlite_create_function</function> mit der Ausnahme, dass die erzeugte
   Funktion für Zusammenfassungsoperationen über alle Zeilen einer Query genutzt 
   werden kann.
  </para>
  <para>
   Der Hauptunterschied zwischen dieser Funktion und <function>sqlite_create_function</function>
   besteht darin, dass hier zwei Funktionen benötigt werden, um das
   Aggregate zu erzeugen. 
   <parameter>Schrittfunktion</parameter> wird für jede einzelne Zeile 
   des Ergebnis aufgerufen. Die PHP Funktion sollte in dieser Funktion
   das Aggregationsergebnis aufbauen und zwischenspeichern. 
   Nachdem alle Zeilen bearbeitet wurden, wird die Funktion 
   <parameter>Finalefunktion</parameter> aufgerufen, die die 
   gesammelten Daten zusammenführt und das Ergebnis der gesamten
   Funktion zurückliefert. 
  </para>
  <para>
   <example>
    <title>Funktionsbeispiel für Aggregatsfunktionen max_laenge</title>
    <programlisting role="php">
<![CDATA[
<?php
$data = array(
   'eins',
   'zwei',
   'drei',
   'vier'
   'fünf'
   'sechs',
   'sieben',
   'acht',
   'neun'
   'zehn'
   );
$db = sqlite_open(':memory:');
sqlite_query($db, "CREATE TABLE strings(a)");
foreach ($data as $str) {
  sqlite_query($db, "INSERT INTO strings VALUES('" .
    sqlite_escape_string($str) . "')");
}

function max_laenge_schritt(&$context, $string) {
  if (strlen($string) > $context) {
    $context = strlen($string);
  }
}

function max_laenge_finalisieren(&$context) {
  return $context;
}

sqlite_create_aggregate($db, 'max_laenge', 'max_laenge_schritt', 'max_laenge_finalisieren');

var_dump(sqlite_array_query($db, 'SELECT max_laenge(a) from strings'));

?>]]>
    </programlisting>
   </example>
  </para>
  <para>
   In diesem Beispiel erzeugen wir eine Aggregationsfunktion, die die 
   Länge des längsten Strings für eine bestimmte Spalte der Tabelle 
   ermittelt.
   Für jede einzelne Zeile wird die Funktion <literal>max_laenge_schritt
    </literal> mit dem <parameter>context</parameter> aufgerufen. 
   Der Kontextparameter verhält sich wie eine normale PHP-Variable und
   kann zum Beispiel ein Objekt oder ein Array sein. In diesem Beispiel
   wird er einfach dazu benutzt, die bislang größte Länge zwischenzuspeichern.
   Wenn der <parameter>string</parameter> länger als er ist, wird die
   Kontextvariable auf diesen neuen Wert geändert. 
  </para>
  <para>
   Nachdem alle einzelnen Zeilen bearbeitet wurden, ruft SQLite die 
   Funktion <literal>max_laenge_finalisieren</literal> auf um die 
   Zusammenfassung des Ergebnisses zu ermitteln. 
   Hier könnten zum Beispiel Berechnungen erfolgen, die auf den
   in der Kontextvariablen <parameter>context</parameter> 
   gesammelten Informationen beruhen. 
   In unserem einfachem Beispiel haben wir das Resultat aber
   schon in jeder Schrittfunktion automatisch berechnet, also 
   brauchen wir hier nur den Wert der Kontextvariablen zurückzuliefern.
  </para>
  <tip>
   <para>
    Es ist NICHT empfohlen, eine Kopie jedes einzelnen Wertes in der Kontext-
    Variablen zu speichern, weil SQLite dann deutlich mehr Speicher zum 
    Bearbeiten der Funktion benötigen würde - stellen Sie sich einfach 
    vor, wieviel Speicher sie benötigen würden, wenn Sie mehr als eine 
    Million Zeilen dort halten würden, von denen jede einen 32 Bytes langen
    String enthält. 
   </para>
  </tip>
  <para>
   Siehe auch <function>sqlite_create_function</function>.
  </para>
 </refsect1>
</refentry>
<!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 vim600: syn=xml fen fdm=syntax fdl=2 si
 vim: et tw=78 syn=sgml
 vi: ts=1 sw=1
 -->
