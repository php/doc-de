<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.4 $ -->
<!-- EN-Revision: 1.3 Maintainer: betz Status: ready -->

  <refentry id="function.mysql-unbuffered-query">
   <refnamediv>
    <refname>mysql_unbuffered_query</refname>
    <refpurpose>Sendet eine SQL Anfrage an MySQL,
     ohne Ergebniszeilen abzuholen und zu puffern.</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Beschreibung</title>
     <methodsynopsis>
      <type>resource</type><methodname>mysql_unbuffered_query</methodname>
      <methodparam><type>string</type><parameter>Anfrage</parameter></methodparam>
      <methodparam choice="opt"><type>resource</type><parameter>Verbindungs-Kennung</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>Ergebnis-Modus</parameter></methodparam>
     </methodsynopsis>
    <para> 
     <function>mysql_unbuffered_query</function> sendet eine SQL
     <parameter>Anfrage</parameter> an MySQL, ohne dass die Datensätze des
     Ergebnisses automatisch geholt und gepuffert werden, wie es bei der
     Verwendung von <function>mysql_query</function> der Fall ist. Einerseits
     spart dieses Vorgehen eine erhebliche Menge an Speicher bei SQL Anfragen
     ein, die große Ergebnismengen liefern. Andererseits können Sie
     unmittelbar mit dem Anfrageergebnis arbeiten, sobald der erste Datensatz
     gefunden wurde: Sie müssen nicht darauf warten, bis die gesamte SQL
     Anfrage abgeschlossen ist. Wird auf verschiedene Datenbanken gleichzeitig
     zugegriffen, muss der optionale Parameter
     <parameter>Verbindungs-Kennung</parameter> angegeben werden.
    </para>
    <para>
     Der optionale Parameter <parameter>Ergebnis-Modus</parameter>
     kann MYSQL_USE_RESULT oder MYSQL_STORE_RESULT sein. Der Vorgabewert
     ist MYSQL_USE_RESULT, damit wird das Ergebnis nicht zwischengespeichert.
     Siehe auch <function>mysql_query</function> für das
     das entgegengesetzte Verhalten.
    </para>
    <note>
     <para>
      Die Vorteile von <function>mysql_unbuffered_query</function> haben ihren
      Preis: Auf ein Ergebnis von <function>mysql_unbuffered_query</function>
      kann die Funktion <function>mysql_num_rows</function> nicht angewendet
      werden. Ausserdem müssen Sie sicherstellen, dass Sie alle Datensätze des
      Ergebnisses einer ungepufferteten SQL Anfrage abgeholt haben. Erst dann
      können Sie eine neue SQL Anfrage an MySQL absetzen.
     </para>
    </note>
    <para>
     Siehe auch: <function>mysql_query</function>.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
