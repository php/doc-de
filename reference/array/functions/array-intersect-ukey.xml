<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.5 $ -->
<!-- EN-Revision: 1.4 Maintainer: simp Status: ready -->
  <refentry xml:id="function.array-intersect-ukey" xmlns="http://docbook.org/ns/docbook">
   <refnamediv>
    <refname>array_intersect_ukey</refname>
    <refpurpose>Ermittelt die Schnittmenge zweier Arrays mittels eines durch eine
     Callbackfunktion durchgeführten Schlüsselvergleiches</refpurpose>
   </refnamediv>
   <refsect1 role="description">
    &reftitle.description;
     <methodsynopsis>
      <type>array</type><methodname>array_intersect_ukey</methodname>
      <methodparam><type>array</type><parameter>array1</parameter></methodparam>
      <methodparam><type>array</type><parameter>array2</parameter></methodparam>
      <methodparam choice="opt"><type>array</type><parameter>...</parameter></methodparam>
      <methodparam><type>callback</type><parameter>key_compare_func</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>array_intersect_ukey</function> gibt ein Array zurück, welches
     alle Werte von <parameter>array1</parameter> enthält, die Schlüssel 
     besitzen die in allen anderen Argumente enthalten sind.
    </para>
    <para>
     Dieser Vergleich wird von einer benutzerdefinierten Callbackfunktion
     durchgeführt. Diese muss einen Integer kleiner als, genau gleich oder
     größer als Null zurückgeben, wenn das erste Argument entsprechend als
     kleiner, gleich oder größer als das Zweite betrachtet wird.
    </para>
    <para>
     <example>
      <title><function>array_intersect_ukey</function> Beispiel</title>
      <programlisting role="php">
<![CDATA[
<?php
function key_compare_func($key1, $key2)
{
    if ($key1 == $key2)
        return 0;
    else if ($key1 > $key2)
        return 1;
    else
        return -1;
}

$array1 = array('blau'  => 1, 'rot'  => 2, 'grün'  => 3, 'violett' => 4);
$array2 = array('grün' => 5, 'blau' => 6, 'gelb' => 7, 'türkis'   => 8);

var_dump(array_intersect_ukey($array1, $array2, 'key_compare_func'));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
array(2) {
  ["blau"]=>
  int(1)
  ["grün"]=>
  int(3)
})
]]>
      </screen>
     </example>
    </para>
    <para>
     In unserem Beispiel sehen Sie, dass nur die Schlüssel <literal>'blau'</literal>
     und <literal>'grün'</literal> in beiden Arrays vorhanden sind und daher
     zurückgegeben werden. Beachten Sie auch, dass die Werte zu den Schlüsseln
     <literal>'blau'</literal> und <literal>'grün'</literal> sich in beiden
     Arrays voneinander unterscheiden. Eine Übereinstimmung wird dennoch
     festgestellt, da nur die Schlüssel überprüft werden. Die zurückgegebenen
     Werte sind diejenigen aus <parameter>array1</parameter>.
    </para>
    <para>
     Siehe auch <function>array_diff</function>,
     <function>array_udiff</function>
     <function>array_diff_assoc</function>,
     <function>array_diff_uassoc</function>,
     <function>array_udiff_assoc</function>,
     <function>array_udiff_uassoc</function>,
     <function>array_diff_key</function>,
     <function>array_diff_ukey</function>,
     <function>array_intersect</function>,
     <function>array_intersect_assoc</function>,
     <function>array_intersect_uassoc</function> und
     <function>array_intersect_key</function>.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
