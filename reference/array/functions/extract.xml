<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.4 $ -->
<!-- EN-Revision: 1.4 Maintainer: tom Status: ready -->
  <refentry id="function.extract">
   <refnamediv>
    <refname>extract</refname>
    <refpurpose>
     Importiert Variablen in die aktuelle Symboltabelle eines Arrays
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Beschreibung</title>
     <methodsynopsis>
      <type>int</type><methodname>extract</methodname>
      <methodparam><type>array</type><parameter>var_array</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>extract_type</parameter></methodparam>
      <methodparam choice="opt"><type>string</type><parameter>prefix</parameter></methodparam>
     </methodsynopsis>
    <para>
     Diese Funktion wird verwendet, um Variablen eines Arrays in die
     aktuelle Symboltabelle zu importieren. Es behandelt die Schlüssel
     des assoziativen Arrays <parameter>var_array</parameter> als
     Variablennamen, und die Werte als Variablenwerte. Für jedes Paar
     Schlüssel/Wert wird - abhängig von den Parametern
     <parameter>extract_type</parameter> und
     <parameter>prefix</parameter> - eine Variable in der aktuellen
     Symboltabelle eingetragen.
    </para>
    <note>
     <para>
      Seit Version 4.0.5 gibt diese Funktion die Anzahl der
      extrahierten Variablen zurück.
     </para>
    </note>
    <note>
     <para>
      EXTR_IF_EXISTS und EXTR_PREFIX_IF_EXISTS wurde in Version 4.2.0.
      eingeführt.
     </para>
    </note>
    <para>
     <function>extract</function> prüft jeden Schlüssel, ob dieser
     einen gültigen Variablennamen ergibt, und auch auf eventuelle
     Kollisionen mit existierenden Variablen in der Symboltabelle. Die
     Art, wie ungültige/numerische Schlüssel und Kollisionen behandelt
     werden, wird mit <parameter>extract_type</parameter>
     spezifiziert. Es kann einen der folgenden Werte annehmen:
     <variablelist>
      <varlistentry>
       <term>EXTR_OVERWRITE</term>
       <listitem>
        <simpara>
         Im Falle einer Kollision wird die existierende Variable
         überschrieben.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>EXTR_SKIP</term>
       <listitem>
        <simpara>
         Im Falle einer Kollision wird die existierende Variable
         nicht überschrieben.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>EXTR_PREFIX_SAME</term>
       <listitem>
        <simpara>Im Falle einer Kollision wird dem Variablennamen
        <parameter>prefix</parameter> vorangestellt.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>EXTR_PREFIX_ALL</term>
       <listitem>
        <simpara>
         Allen Variablennamen wird <parameter>prefix</parameter>
         vorangestellt. Seit PHP 4.0.5 gilt dies auch für numerische
         Schlüssel.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>EXTR_PREFIX_INVALID</term>
       <listitem>
        <simpara>
         Nur ungültigen/numerischen Variablennamen wird
         <parameter>prefix</parameter> vorangestellt. Dieser Flag
         wurde mit PHP 4.0.5 eingeführt.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>EXTR_IF_EXISTS</term>
       <listitem>
        <simpara>
         Überschreibt die Variable nur, wenn sie bereits in der aktuellen
         Symboltabelle existiert, sonst geschieht nichts. Dies ist dann
         hilfreich, wenn Sie eine Liste mit gültigen Variablen definieren,
         und dann z.B. nur jene Variablen extrahieren, welche Sie aus
         $_REQUEST definiert haben. Dieser Flag wurde in PHP 4.2.0
         eingeführt.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>EXTR_PREFIX_IF_EXISTS</term>
       <listitem>
        <simpara>
         Erstellt nur Variablennamen mit Präfix, wenn die Version ohne
         Präfix der selben Variable in der aktuellen Symboltabelle
         existiert. Dieser Flag wurde in PHP 4.2.0 eingeführt.
        </simpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Ist <parameter>extract_type</parameter> nicht spezifiziert, so wird
     EXTR_OVERWRITE angenommen.
    </para>
    <para>
     Beachten Sie, dass <parameter>prefix</parameter> nur dann nötig
     ist, wenn <parameter>extract_type</parameter> EXTR_PREFIX_SAME,
     EXTR_PREFIX_ALL, EXTR_PREFIX_INVALID, oder EXTR_PREFIX_IF_EXISTS
     ist. Ist das Resultat trotz Präfix kein gültiger Variablenname,
     wird es nicht in die Symboltabelle importiert.
    </para>
    <para>
     <function>extract</function> gibt die Anzahl erfolgreich in die
     Symboltabelle importierter Variablen zurück.
    </para>
    <para>
     Eine mögliche Verwendung für extract ist der Import der Variablen
     in einem von <function>wddx_deserialize</function> gelieferten
     assoziativen Array in die Symboltabelle.
    </para>
    <para>
     <example>
      <title><function>extract</function></title>
      <programlisting role="php">
<![CDATA[
<?php

/* Annahme: $var_array ist ein von wddx_deserialize
   zurückgegebenes Array */

$groesse = "groß";
$var_array = array ("farbe"   => "blau",
                    "groesse" => "mittel",
                    "form"    => "Kugel");
extract ($var_array, EXTR_PREFIX_SAME, "wddx");

print "$farbe, $groesse, $form, $wddx_groesse\n";

?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Das obige Beispiel wird folgendes ausgeben:
     <programlisting>
<![CDATA[
blau, groß, Kugel, mittel
]]>
     </programlisting>
    </para>
    <para>
     <varname>$size</varname> wurde nicht überschrieben, da wir
     EXTR_PREFIX_SAME spezifiziert haben, was im Anlegen von
     <varname>$wddx_size</varname> endete. Wäre EXTR_SKIP spezifiziert
     worden, dann wäre $wddx_size nicht angelegt worden. EXTR_OVERWRITE
     hätte <varname>$size</varname> mit dem Wert "medium" überschrieben,
     und EXTR_PREFIX_ALL hätte die neuen Variablen
     <varname>$wddx_color</varname>, <varname>$wddx_size</varname>,
     und <varname>$wddx_shape</varname> angelegt.
    </para>
    <para>
     Sie müssen assoziative Arrays benutzen, numerisch indizierte
     Arrays liefern keine Resultate.
    </para>
    <para>
     Siehe auch <function>compact</function>.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
