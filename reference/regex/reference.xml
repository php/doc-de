<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.9 $ -->
<!-- EN-Revision: 1.9 Maintainer: samesch Status: ready -->
 <reference id="ref.regex">
  <title>Reguläre Ausdrücke Funktionen (POSIX erweitert)</title>
  <titleabbrev>Regexps</titleabbrev>

  <partintro>
   <section id="regex.intro">
    &reftitle.intro;
    <tip>
     <para>
      Bei Verwendung der <link linkend="ref.pcre">PCRE
      Funktionen</link> unterstützt PHP auch Reguläre Ausdrücke mit
      einer zu Perl kompatiblen Syntax. Diese Funktionen unterstützen
      non-greedy Matching, Assertions, bedingte Subpatterns und viele
      andere Merkmale, die von der POSIX-erweiterten Syntax regulärer
      Ausdrücke nicht unterstützt werden.
     </para>
    </tip>
    <warning>
     <para>
      Diese Funktionen regulärer Ausdrücke sind im Gegensatz zu den
      <link linkend="ref.pcre">PCRE Funktionen</link> nicht
      binary-safe.
     </para>
    </warning>
    <para>
     Reguläre Ausdrücke werden für komplexe Manipulationen an
     Zeichenketten mit PHP verwendet. Folgende Funktionen unterstützen
     reguläre Ausdrücke:
     <itemizedlist>
      <listitem>
       <simpara><function>ereg</function></simpara>
      </listitem>
      <listitem>
       <simpara><function>ereg_replace</function></simpara>
      </listitem>
      <listitem>
       <simpara><function>eregi</function></simpara>
      </listitem>
      <listitem>
       <simpara><function>eregi_replace</function></simpara>
      </listitem>
      <listitem>
       <simpara><function>split</function></simpara>
      </listitem>
      <listitem>
       <simpara><function>spliti</function></simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Alle diese Funktionen nehmen als erstes Argument einen regulären
     Ausdruck an. PHP verwendet durch POSIX 1003.2 definierte POSIX
     erweiterte reguläre Ausdrücke. Eine vollständige Beschreibung der
     POSIX regulären Ausdrücke finden Sie im Regex-Verzeichnis der
     PHP-Distribution in den Regex man pages.  Da sie im manpage-Fomat
     vorliegt, sollten Sie einen Befehl der Art <command> man
     /usr/local/src/regex/regex.7</command> verwenden, um sie zu
     lesen.
    </para>
   </section>

   <section id="regex.requirements">
    &reftitle.required;
    &no.requirement;
   </section>

   &reference.regex.configure;

   <section id="regex.configuration">
    &reftitle.runtime;
    &no.config;
   </section>

   <section id="regex.resources">
    &reftitle.resources;
    &no.resource;
   </section>

   <section id="regex.constants">
    &reftitle.constants;
    &no.constants;
   </section>

   <section id="regex.examples">
    &reftitle.examples;
    <para>
     <example>
      <title>Beispiele regulärer Ausdrücke</title>
      <programlisting role="php">
<![CDATA[
<?php
// Gibt true zurück, falls "abc" irgendwo in $string gefunden wird.
ereg("abc", $string);            

// Gibt true zurück, falls "abc" am Anfang von $string gefunden wird.
ereg("^abc", $string);

// Gibt true zurück, falls "abc" am Ende von $string gefunden wird.
ereg("abc$", $string);

// Gibt true zurück, falls es sich beim Client Browser um Netscape 2,
// 3 oder MSIE 3 handelt.
eregi("(ozilla.[23]|MSIE.3)", $HTTP_USER_AGENT);  

// Setzt drei Wörter, die durch Leerzeichen getrennt sind, in
// $regs[1], $regs[2] und $regs[3] ein.
ereg("([[:alnum:]]+) ([[:alnum:]]+) ([[:alnum:]]+)", $string, $regs); 

// Setzt ein <br /> Tag vor $string.
$string = ereg_replace("^", "<br />", $string); 

// Setzt ein <br /> Tag hinter $string.
$string = ereg_replace("$", "<br />", $string); 

// Entfernt alle Zeilenumbrüche aus $string.
$string = ereg_replace("\n", "", $string);
?>
]]>
      </programlisting>
     </example>
    </para>
   </section>

   <section id="regex.seealso">
    &reftitle.seealso;
    <para>
     Schauen Sie sich bezüglich regulärer Ausdrücke mit einer zu Perl
     kompatiblen Syntax die <link
     linkend="ref.pcre">PCRE Funktionen</link> an.
     <function>fnmatch</function> bietet die Möglichkeit der Suche
     nach Übereinstimmungen mit Wildcard-Suchmustern im einfacheren
     Shell-Stil.
    </para>
   </section>
  </partintro>

  &reference.regex.functions;

 </reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

