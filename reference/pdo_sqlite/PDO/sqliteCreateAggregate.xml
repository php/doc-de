<?xml version='1.0' encoding='utf-8'?>
<!-- $Revision: 318318 $ -->
<!-- EN-Revision: dc706816c30f61d28686b4bf43f5b09e6d2de8e0 Maintainer: lapistano Status: ready -->
<refentry xml:id="pdo.sqlitecreateaggregate" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>PDO::sqliteCreateAggregate</refname>
  <refpurpose>
   Registriert eine aggregierte, benutzerdefinierte Funktion, die in einer SQLite-Anfrage genutzt werden kann
  </refpurpose>
 </refnamediv>
 
 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <modifier>public</modifier> <type>bool</type><methodname>PDO::sqliteCreateAggregate</methodname>
   <methodparam><type>string</type><parameter>function_name</parameter></methodparam>
   <methodparam><type>callable</type><parameter>step_func</parameter></methodparam>
   <methodparam><type>callable</type><parameter>finalize_func</parameter></methodparam>
   <methodparam choice="opt"><type>int</type><parameter>num_args</parameter></methodparam>
  </methodsynopsis>
  &warn.experimental.func;
  <para>
   Diese Methode entspricht
   <xref linkend="pdo.sqlitecreatefunction" />, mit dem Unterschied, dass
   sie Funktionen registriert, welche benutzt werden können, ein Ergebnis über alle 
   Reihen einer Anfrage zu aggregieren.
  </para>
  <para>
   Der Hauptunterschied zwischen dieser Methode und <xref
   linkend="pdo.sqlitecreatefunction" /> ist, dass zwei Funktionen
   notwendig sind, um die Aggregierung zu verwalten.
  </para>
 </refsect1>
 
 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>function_name</parameter></term>
     <listitem>
      <para>
       Der Name der in der Anfrage genutzten Funktion.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>step_func</parameter></term>
     <listitem>
      <para>
       'Callback'-Funktion, welche für jede Reihe des Abfrageergebnisses ausgeführt wird.
       Ihr PHP sollte das Ergebnis akkumulieren und in der Aggregation 'context' speichern.
      </para>
      <para>
       Es ist notwendig, diese Funktion wie folgt zu definieren:
       <methodsynopsis>
        <type>mixed</type><methodname><replaceable>step</replaceable></methodname>
        <methodparam><type>mixed</type><parameter>context</parameter></methodparam>
        <methodparam><type>int</type><parameter>rownumber</parameter></methodparam>
        <methodparam><type>mixed</type><parameter>value1</parameter></methodparam>
        <methodparam choice="opt"><type>mixed</type><parameter>value2</parameter></methodparam>
        <methodparam choice="opt"><type>mixed</type><parameter>..</parameter></methodparam>
       </methodsynopsis>
      </para>
      <para>
       Für die erste Reihe wird <varname>context</varname> &null; sein. Folgende Reihen 
       werden den zuvor zurückgegebenen Wert haben. Sie sollten diesen nutzen, um den
       Status der Aggregation zu pflegen.
      </para>
      <para>
       <varname>rownumber</varname> wird die Number der aktuellen Reihe beinhalten.
      </para>
      <para>
       Der Rückgabewert dieser Funktion wird als <parameter>context</parameter>
       Argument im nächsten Aufruf der step oder finalize Funktion verwendet.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>finalize_func</parameter></term>
     <listitem>
      <para>
       'Callback'-Funktion, die die Informationen aller Reihen aggregiert.
       Sind alle Reihen abgearbeitet, wird diese Funktion aufgerufen. Diese
       sollte dann die Daten der Aggregation 'context' auswerten und das 
       Ergebnis zurückgeben. 'Callback'-Funktionen sollten einen Variablentyp 
       liefern, der von SQLite erwartet wird (z.B. <link 
       linkend="language.types.intro">scalar type</link>).
      </para>
      <para>
       Diese Funktion ist als
       <methodsynopsis>
        <type>mixed</type><methodname><replaceable>fini</replaceable></methodname>
        <methodparam><type>mixed</type><parameter>context</parameter></methodparam>
        <methodparam><type>int</type><parameter>rownumber</parameter></methodparam>
       </methodsynopsis>
       zu definieren.
      </para>
      <para>
       <varname>context</varname> wird den Rückgabewert des letzten Aufrufs der
       Schritt-Funktion enthalten.
      </para>
      <para>
       <varname>rownumber</varname> wird die Anzahl an Reihen enthalten, die
       bereite Aggregiert wurden.
      </para>
      <para>
       Der Rückgabewert dieser Funktion wird als Rückgabewert für die
       Aggregation genutzt.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>num_args</parameter></term>
     <listitem>
      <para>
       Hinweis für den SQLite-Parser, ob die 'Callback'-Funktion eine 
       bestimmte Anzahl an Parametern erwartet.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>
 
 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   &return.success;
  </para>
 </refsect1>
 
 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example>
    <title>Beispiel für eine 'max_length'-Aggregierungs-Funktion</title>
    <programlisting role="php">
<![CDATA[
<?php
$data = array(
   'one',
   'two',
   'three',
   'four',
   'five',
   'six',
   'seven',
   'eight',
   'nine',
   'ten',
   );
$db = new PDO('sqlite::memory:');
$db->exec("CREATE TABLE strings(a)");
$insert = $db->prepare('INSERT INTO strings VALUES (?)');
foreach ($data as $str) {
    $insert->execute(array($str));
}
$insert = null;

function max_len_step(&$context, $rownumber, $string) 
{
    if (strlen($string) > $context) {
        $context = strlen($string);
    }
    return $context;
}

function max_len_finalize(&$context, $rownumber) 
{
    return $context === null ? 0 : $context;
}

$db->sqliteCreateAggregate('max_len', 'max_len_step', 'max_len_finalize');

var_dump($db->query('SELECT max_len(a) from strings')->fetchAll());

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   In diesem Beispiel erzeugen wir eine Aggregat-Funktion, die die Länge 
   der längsten Zeichenkette innerhalb einer der Tabellenspalten ermittelt.
   Die <literal>max_len_step</literal>-Funktion wird für jede durchlaufene Reihe
   mit dem Parameter <parameter>context</parameter> aufgerufen. Der Parameter 
   'context' ist eine normal PHP Variable, welche Listen oder Objektinhalte 
   beinhalten kann. In diesem Beispiel benötigen wir sie als Speicher für die 
   größte bisher gefundene Länge der geprüften Zeichenketten. Wenn also die 
   die Zeichenkette in <parameter>string</parameter> länger ist, als die aktuell
   Längste, wird der Inhalt von 'context' mit der neuen Länge überschrieben.
  </para>
  <para>
   Nachdem alle Reihen abgearbeitet wurden, ruft SQLite die 
   <literal>max_len_finalize</literal>-Funktion auf, um das Endergebnis 
   zu ermitteln. Hier können wir nun jede Art von Berechnungen,
   basierend auf den in <parameter>context</parameter> gesammelten Daten, 
   durchführen. In unserem Beispiel haben wir die Berechgungen bereits bei
   der Datenerhebung getätigt, dass wir nun nur noch das Ergebnis - 
   den Inhalt von 'context' - zurückgeben brauchen.
  </para>
  <tip>
   <para>
    Es ist nicht ratsam, eine Kopie der Inhalte in 'context' zu speichern, 
    um diese dann am Ende auszuwerten. Das würde dazu führen, dass SQLite eine
    große Menge an Speicher benötigt, um die Abfrage abzuarbeiten. Überlegen Sie
    nur mal, wieviel Speicher eine Abfrage braucht, die 1 Millionen Reihen mit
    je 32 Byte Inhalt aus der Datenbank liest.
   </para>
  </tip>
  <tip>
   <para>
    Sie können <xref linkend="pdo.sqlitecreatefunction" /> und
    <xref linkend="pdo.sqlitecreateaggregate" /> nutzen, um SQLites
    native SQL-Funktionen zu überschreiben.
   </para>
  </tip>
  <note>
   <para>
    Diese Methode ist im SQLite2-Treiber nicht verfügbar.
    Benutzen Sie stattdessen die alte SQLite-API.
   </para>
  </note>
 </refsect1>
 
 
 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><xref linkend="pdo.sqlitecreatefunction" /></member>
    <member><function>sqlite_create_function</function></member>
    <member><function>sqlite_create_aggregate</function></member>
   </simplelist>
  </para>
 </refsect1>
 
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
