<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.2 $ -->
<!-- EN-Revision: 1.7 Maintainer: conni Status: ready -->
  <refentry id="function.socket-create">
   <refnamediv>
    <refname>socket_create</refname>
    <refpurpose>Erzeugt einen Socket (Endpunkt für die Kommunikation)</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Beschreibung</title>
     <methodsynopsis>
      <type>resource</type><methodname>socket_create</methodname>
      <methodparam><type>int</type><parameter>domain</parameter></methodparam>
      <methodparam><type>int</type><parameter>type</parameter></methodparam>
      <methodparam><type>int</type><parameter>protocol</parameter></methodparam>
     </methodsynopsis>
    <para>
	 Erzeugt einen Kommunikationsendpunkt (einen Socket) und gibt einen
     Socket-Deskriptor zurück. Ein typisches Netzwerk besteht aus zwei
     Sockets, von denen der eine die Rolle des Clients und der andere die
     Rolle des Servers übernimmt.
    </para>
    <para>
     Der <parameter>domain</parameter> Parameter legt die Protokollfamilie
     fest, die  für die Kommunikation vom Socket benutzt wird. 
    </para>

    <table>
    <title>Folgende Adressen/Protokollfamilien sind verfügbar:</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Domain</entry>
       <entry>Beschreibung</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>AF_INET</entry>
       <entry>
        IPv4 basierete Internet-Protokolle. TCP und UDP sind allgemein
        gebräuchliche Protokolle dieser Familie.
       </entry>
      </row>
      <row>
       <entry>AF_INET6</entry>
       <entry>
        IPv6 basierete Internet-Protokolle. TCP und UDP sind allgemein
        gebräuchliche Protokolle dieser Familie. Diese Unterstützung gibt
        es seit PHP 5.0.0.
       </entry>
      </row>
      <row>
       <entry>AF_UNIX</entry>
       <entry>
        Protokollfamilie für die lokale Kommunikation. Hohe Effizienz und
        ein geringer Overhead machen sie zur ersten Wahl für IPC
        (Inter-Process-Communication).
       </entry>
      </row>
     </tbody>
    </tgroup>
    </table>
    <para>
     Der Parameter <parameter>type</parameter> bestimmt den
     Kommunikationstyp, den der Socket verwenden soll.
    </para>
    <table>
    <title>Die möglichen Socket-Typen sind:</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Type</entry>
       <entry>Beschreibung</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>SOCK_STREAM</entry>
       <entry>
         Stellt zuverlässige, sequentielle verbindungsorientierte Streams
         im Vollduplexmodus zur Verfügung. Ein externer Mechanismus zur
         Datenübertragung kann unterstützt werden. Das TCP-Protokoll
         beruht auf diesem Socket.Typ.
       </entry>
      </row>
      <row>
       <entry>SOCK_DGRAM</entry>
       <entry>
         Unterstützt Datagramme (verbindunglos, Nachrichten vorgegebener
         Maximallänge, deren Übertragung nicht zuverlässig ist). Das
         UDP-Protikoll beruht auf diesem Socket-Typ.
       </entry>       
      </row>
        <row>
       <entry>SOCK_SEQPACKET</entry>
       <entry>
         Stellt eine zuverlässige, sequentielle. bidirektionale
         verbindungsorientierte Übertragungsweg für Datagramme 
         vorgegebener Maximallänge zur Verfügung. Ein Empfänger muss 
         bei jeder Leseanforderung das gesamte Datenpaket lesen. 
       </entry>       
      </row>
      <row>
       <entry>SOCK_RAW</entry>
       <entry>
         Stellt einen Zugang mit einem nicht bestimmten Netzwerkprotokoll
         zur Verfügung. Dieser spezielle Socket-Typ kann dazu benutzt
         werden, um manuell ein Protokoll eines beliebigen Typs zu
         erstellen. Solche Sockets werden üblicherweise benutzt, um ICMP
         Requests zu senden (wie etwa ping oder traceroute usw.).
       </entry>
      </row>
      <row>
       <entry>SOCK_RDM</entry>
       <entry>
         Stellt eine zuverlässige Schicht für Datagramme zur Verfügung, in
         der die Reihenfolge der Datagramme nicht garantiert wird. Dies
         ist in Ihrem Betriebssytem höchstwahrscheinlich nicht
         implementiert.
       </entry>
      </row>
     </tbody>
    </tgroup>
    </table>    
    <para>
     Der Parameter <parameter>protocol</parameter> setzt das spezifische
     Protokoll innerhalb der angegebenen <parameter>domain</parameter>,
     das vom zurückgegebenen Socket für die Kommunikation benutzt wird.
     Der passende Wert kann ermittelt werden, indem der Name an die
     Funktion <function>getprotobyname</function>übergeben wird. Wenn TCP
     oder UDP gewünscht werden, können auch die entsprechenden Konstanten
     <constant>SOL_TCP</constant> oder <constant>SOL_UDP</constant>
     benutzt werden.
    </para>
    <table>
    <title>Gebräuchliche Protokolle</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Name</entry>
       <entry>Beschreibung</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>icmp</entry>
       <entry>
        Das Internet Control Message Protocol wird hauptsächlich von
        Gateways und Hosts benutzt, um Datagramm-Fehler zu melden. Das
        Kommando "ping" (das in den meisten modernen Betriebssystemen
        enthalten ist) ist ein Beispiel für eine Anwendung von ICMP.
       </entry>
      </row>
      <row>
       <entry>udp</entry>
       <entry>
        Das User Datagram Protocol ist ein verbindungsloses,
        unzuverlässiges Protokoll, mit dem Datensätze fester Länge
        versendet werden können. Aufgrund dieser geringen Anforderungen
        braucht UDP nur einen minimalen Protokoll-Overhead.
       </entry>       
      </row>
        <row>
       <entry>tcp</entry>
       <entry>
        Das Transmission Control Protocol ist ein zuverlässiges,
        verbindungsorientiertes, Stream-orientiertes Protokoll für den
        Vollduplex-Betrieb. Bei TCP ist garantiert, dass alle Datenpakete
        in derselben Reihenfolge empfangen werden, in der sie gesendet
        wurden. Falls während der Übertragung ein Datenpaket verlorengeht,
        wird es von TCP erneut versendet, und zwar solange, bis der
        Empfängerhost den Eingang dieses Paktes zurückmeldet. Aus Gründen
        der Zuverlässigkeit und Leistung ist TCP so implementiert, dass es
        eigenständig die oktalen Grenzen der darunterliegenden Datagramm-
        Kommunikationschicht anpassen kann. Aus diesem Grund müssen TCP
        Anwendungen in der Lage sein, auch Teilübertragungen empfangen zu
        können.
       </entry>
      </row>
     </tbody>
    </tgroup>
    </table>
    <para>
     Bei Erfolg gibt <function>socket_create</function> einen
     Socket-Deskriptor zurück, bei einem Fehler wird &false;
     zurückgegeben. Der aktuelle Fehlercode kann mit
	 <function>socket_last_error</function>
     ermittelt werden. Dieser Fehlercode kann an die Funktion
     <function>socket_strerror</function> übergeben werden, um eine
	 textuelle Beschreibing des Fehlers zu erhalten.
    </para>
    <note>
     <para>
      Falls ein fehlerhafter <parameter>domain</parameter>- oder 
      <parameter>type</parameter>-Parameter angegeben wird, benutzt
	  <function>socket_create</function> standardmässig 
      <constant>AF_INET</constant> sowie 
      <constant>SOCK_STREAM</constant> und gibt eine 
      <constant>E_WARNING</constant>-Meldung aus.
     </para>
    </note>
    <para>
     Siehe auch 
     <function>socket_accept</function>,
     <function>socket_bind</function>,
     <function>socket_connect</function>,
     <function>socket_listen</function>,
     <function>socket_last_error</function> und
     <function>socket_strerror</function>.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
