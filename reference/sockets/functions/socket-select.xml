<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.3 $ -->
<!-- EN-Revision: 1.13 Maintainer: conni Status: ready -->

  <refentry xml:id="function.socket-select" xmlns="http://docbook.org/ns/docbook">
   <refnamediv>
    <refname>socket_select</refname>
    <refpurpose>Führt einen select() Systemaufruf auf den gegebenen
    Socket-Arrays aus, wobei mit tv_sec und tv_usec ein Zeitlimit
    bestimmt wird. </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Beschreibung</title>
     <methodsynopsis>
      <type>int</type><methodname>socket_select</methodname>
      <methodparam><type>array</type><parameter role="reference">read</parameter></methodparam>
      <methodparam><type>array</type><parameter role="reference">write</parameter></methodparam>
      <methodparam><type>array</type><parameter role="reference">except</parameter></methodparam>
      <methodparam><type>int</type><parameter>tv_sec</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>tv_usec</parameter></methodparam>
     </methodsynopsis>
    <para>
     Die Funktion <function>socket_select</function> nimmt als Parameter
     Socket-Arrays entgegen und wartet, ob diese ihren Status ändern.
     Diejenigen, die Hintergrundwissen über BSD Sockets haben, werden
     feststellen, dass diese Socket-Arrays in Wirklichkeit die so
     genannten Datei-Deskriptor-Mengen sind. Drei, voneinander
     unabhängige Arrays mit Socket-Deskriptoren werden überwacht. 
    </para>
    <para>
     Die Sockets, die im <parameter>read</parameter> Array aufgelistet
     sind, werden daraufhin überwacht, ob Zeichen zum Auslesen an den
     Sockets verfügbar sind (um genauer zu sein: es wird überwacht, ob
     das Auslesen den Socket blockiert - besonders aber, ob ein Socket
     bereit ist, wenn er zu Ende gelesen hat. In diesem Fall gibt ein
     <function>socket_read</function> einen leeren String zurück.)  
    </para>
    <para>
     Die Sockets, die im <parameter>write</parameter> Array aufgelistet
     sind, werden daraufhin überwacht, ob ein Schreibvorgang den Socket
     blockiert.
    </para>
    <para>
     Die Sockets, die im <parameter>except</parameter> Array aufgelistet
     sind, werden auf Ausnahmen überwacht. 
    </para>
    <warning>
     <para>
      Beim Beenden werden alle Arrays aktualisiert, und zeigen an, welche
      Sockets ihren Status geändert haben. 
     </para>
    </warning>
    <para>
     Sie brauchen nicht jedes Array einzeln an     
     <function>socket_select</function> übergeben. Sie können leere
     Arrays oder &null; stattdessen angeben. Vergessen Sie nicht, dass
     diese Arrays <emphasis>by reference</emphasis> übergeben werden
     müssen und dass sie verändert werden, nachdem die Funktion
     <function>socket_select</function> beendet ist.
    </para>
    <para>
     <example>
      <title><function>socket_select</function> Beispiel</title>
      <programlisting role="php">
<![CDATA[
<?php
/* Das Array zum Lesen vorbereiten */
$read = array($socket1, $socket2);

$num_changed_sockets = socket_select($read, $write = NULL, $except = NULL, 0);

if ($num_changed_sockets === false) {
    /* Fehlerbehandlung */
} else if ($num_changed_sockets > 0) {
    /* Mindestes an einem Socket ist etwas interessantes passiert */
}
?>
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      Wegen einer Einschränkung in der aktuellen Zend Engine ist es nicht
      möglich, eine Konstante, wie etwa &null;, direkt als Parameter an
      Funktionen zu übergeben, die Referenzen auf Parameter als Argumente
      erwarten. Sie können stattdessen eine temporäre Variable oder einen
      Ausdruck, in dem der am weitesten links stehende Teilausdruck eine
      temporäre Variable ist, benutzen. 
      <example>
       <title>&null; mit <function>socket_select</function> benutzen</title>
       <programlisting role="php">
<![CDATA[
<?php
socket_select($r, $w, $e = NULL, 0);
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
    <para>
     <parameter>tv_sec</parameter> und <parameter>tv_usec</parameter>
     bilden zusammen den <emphasis>timeout</emphasis> Parameter. Der
     <emphasis>timeout</emphasis> ist nach oben durch die verstrichene
     Zeit, bis <function>socket_select</function> zurückkehrt, begrenzt.
     <parameter>tv_sec</parameter> kann 0 sein, wodurch
     <function>socket_select</function> sofort zurückkehrt. Dies ist
     nützlich beim Polling. Falls der Parameter
     <parameter>tv_sec</parameter> &null; ist (kein Timeout), kann
     <function>socket_select</function> unendlich lange blockieren. 
    </para>
    <para>
     Bei Erfolg gibt <function>socket_select</function> die Anzahl der
     Socket-Deskriptoren zurück, die in den aktualisierten Arrays
     enthalten sind. Falls der Timeout wirksam wird, bevor irgend etwas
     Interessantes passiert, ist das Funktionsergebnis 0. Falls ein
     Fehler auftritt wird &false; zurückgegeben. Der Fehlercode kann dann
     mit <function>socket_last_error</function> abgefragt werden.
    </para>
    <note>
     <para>
     Wenn Sie einen Fehler aufspüren wollen, müssen Sie unbedingt den
     Operator <literal>===</literal> benutzen. Weil
     <function>socket_select</function> auch 0 zurückgeben kann, wird der
     Vergleich mit <literal>==</literal> sonst zu &true; ausgewertet. 
     <example>
      <title>Understanding <function>socket_select</function>'s result</title>
      <programlisting role="php">
<![CDATA[
<?php
if (false === socket_select($r, $w, $e = NULL, 0)) {
    echo "socket_select() failed, reason: " .
        socket_strerror(socket_last_error()) . "\n";
}
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
    <note>
     <para>
      Seien Sie sich bewusst, dass manche Socket-Implementierungen sehr
      sorgfältig benutzt werden müssen. Ein paar grundsätzliche Regeln: 
      <itemizedlist>
       <listitem>
        <simpara>
         Sie sollten immer versuchen, <function>socket_select</function>
         ohne Timeout zu benutzen. Ihr Programm sollte nichts tun, wenn
         keine Daten verfügbar sind. Code, der von Zeitbegrenzungen
         abhängig ist, ist normalerweise nicht portierbar und schwierig
         zu debuggen. 
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Es sollte kein Socket-Deskriptor in die Arrays eingefügt werden,
         wenn Sie nicht vorhaben, die Ergebnisse nach der Ausführung
         eines <function>socket_select</function> Funktionsaufrufs zu
         prüfen und entsprechend darauf zu reagieren.         
         Nachdem <function>socket_select</function> beendet ist, müssen
         alle Sockets in allen Socket-Arrays geprüft werden. Jeder
         Socket, der zum Schreiben zur Verfügung steht, muss beschrieben
         werden und aus jedem Socket, der zum Lesen verfügbar ist, muss
         gelesen werden. 
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Bei Schreib/Leseoperationen auf den Sockets in den Arrays müssen
         Sie damit rechnen, dass nicht notwendigerweise alle Daten
         geschrieben/gelesen werden, die Sie angeben. Seien Sie darauf
         vorbereitet, dass Sie möglicherweise nur ein einziges Byte
         schreiben/lesen können. 
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Fast allen Socket-Implementierungen ist gemeinsam, dass sie nur
         eine einzige Ausnahme in dem <parameter>except</parameter>
         Array auffangen können. Dies ist, wenn ausserordentlich Daten
         höherer Priorität empfangen werden.
        </simpara>
       </listitem>
      </itemizedlist>
     </para>
    </note>
    <para>
     See also
     <function>socket_read</function>,
     <function>socket_write</function>,
     <function>socket_last_error</function> und 
     <function>socket_strerror</function>.
    </para>
   </refsect1>
  </refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
