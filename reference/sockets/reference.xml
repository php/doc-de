<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.6 $ -->
<!-- EN-Revision 1.21: Maintainer: conni Status: ready -->
<!-- Purpose: remote.other -->
<!-- Membership: bundled -->

 <reference id="ref.sockets">
  <title>Socket Funktionen</title>
  <titleabbrev>Sockets</titleabbrev>

  <partintro>

   <section id="sockets.intro">
    &reftitle.intro;
    <para>
	 Die Socket-Erweiterung stellt eine hardwarenahe Schnittstelle
	 zu den Datenaustauschfunktionen über eine Socket-Verbindung zur
	 Verfügung, die auf den bekannten BSD Sockets aufbaut, und bietet
	 die Möglichkeit, entweder als Socket-Server oder als Client zu
	 agieren.
    </para>
    <para>
	 Für eine allgemeinere clientseitige Socket Schnittstelle siehe <function>stream_socket_client</function>, <function>stream_socket_server</function>,
     <function>fsockopen</function> und      <function>pfsockopen</function>.     
    </para>
    <para>
	 Wenn man diese Funktionen benutzt, darf man nicht vergessen,
     dass, obwohl viele der Funktionen gleichlautende Namen wie ihre
     Entsprechungen in C haben, sie dennoch oft unterschiedliche
     Deklarationen haben. Bitte lesen Sie die Beschreibungen, um
     Verwirrung zu vermeiden.
    </para>
    <para>
	 Das heisst, wem Socketprogrammierung fremd ist, der findet eine
     grosse Menge nützlicher Materialien in den entsprechenden Unix
     manpages und es gibt jede Menge von Tutorials und Informationen
	 über Socketprogrammierung in C im Internet. Vieles davon kann mit
	 leichten Änderungen für die Socketprogrammierung mit PHP benutzt
	 werden. Die <ulink url="&url.socket.faq;">UNIX Socket FAQ</ulink> ist 
	 dafür ein guter Anfang.
    </para>
   </section>
   
   <section id="sockets.requirements">
    &reftitle.required;
    &no.requirement;
   </section>
   
   &reference.sockets.configure;  

   <section id="sockets.configuration">
    &reftitle.runtime;
    &no.config;
   </section>

   <section id="sockets.resources">
    &reftitle.resources;
    &no.resource;
   </section>

   &reference.sockets.constants;

   <section id="sockets.errors">
    <title>Socket Fehler</title>
    <para>
	 Die Socket-Erweiterung wurde geschrieben, um eine nützliche
	 Schnittstelle zu den mächtigen BSD-Funktionen zur Verfügung zu
	 stellen. Es wurde darauf geachtet, dass die Funktionen sowohl
	 unter Win32 als auch unter Unix-Implementierungen arbeiten. Fast
	 alle Socket-Funktionen können unter bestimmten Umständen
	 fehlschlagen und deshalb eine <constant>E_WARNING</constant>-
	 Meldung ausgeben, die den aufgetretenen Fehler beschreibt. Dies
	 ist manchmal nicht wünschenswert für den Entwickler. Zum Beispiel
	 kann die Funktion <function>socket_read</function> plötzlich eine
	 <constant>E_WARNING</constant>-Meldung ausgeben, weil die
	 Verbindung unerwartet beendet wurde. Normalerweise werden solche
	 Meldungen mit dem <literal>@</literal>-Operator unterdrückt und
	 der Fehlercode innerhalb der Anwendung mit der Funktion
	 <function>socket_last_error</function> aufgefangen. Sie können
	 auch die Funktion <function>socket_strerror</function> mit diesem
	 Fehlercode aufrufen, um eine Fehlerbeschreibung zu erhalten.
	 zu erhalten. Nähere Informationen finden Sie bei diesen beiden
	 Funktionen. 
    </para>
    <note>
     <para>
      Die <constant>E_WARNING</constant>-Meldungen, die von der
	  Socket-Extension generiert werden, sind auf Englisch, aber die
	  Meldungen, die Sie extra abfragen können, erscheinen in der
	  entsprechenden Sprache, die Sie eingestellt haben 
	  (<constant>LC_MESSAGES</constant>):
      <programlisting role="php">
<![CDATA[
Warning - socket_bind() unable to bind address [98]: Die Adresse wird bereits verwendet
]]>
      </programlisting>
     </para>
    </note>
   </section>
   
   <section id="sockets.examples">
    &reftitle.examples;
    <para>
     <example>
      <title>Socket Beispiel: Einfacher TCP/IP Server</title>
       <para>
	    Dieses Beispiel zeigt einen einfachen Echo-Server. Passen Sie
        die Variablen <varname>address</varname> und
        <varname>port</varname> an Ihre Systemumgebung an und führen
        Sie das Skript aus. Dann können Sie sich mit einem Befehl wie:
        <command>telnet 192.168.1.53 10000</command> (bei dem adress
        und port an Ihre Umgebung angepasst ist) mit dem Server
        verbinden. Alles, was Sie eingeben, wird an den Server geschickt
        und von diesem wieder an Sie zurückgegeben. Um die Verbindung
        zu trennen, geben sie 'quit' ein.
       </para>
      <programlisting role="php">
<![CDATA[
#!/usr/local/bin/php -q
<?php
error_reporting (E_ALL);

/* Das Skript wartet auf hereinkommende Verbindungsanforderungen. */
set_time_limit (0);

/* Die implizite Ausgabe wird eingeschaltet, so dass man sieht, was gesendet wurde. */
ob_implicit_flush ();

$address = '192.168.1.53';
$port = 10000;

if (($sock = socket_create (AF_INET, SOCK_STREAM, 0)) < 0) {
    echo "socket_create() fehlgeschlagen: Grund: " . socket_strerror ($sock) . "\n";
}

if (($ret = socket_bind ($sock, $address, $port)) < 0) {
    echo "socket_bind() fehlgeschlagen: Grund: " . socket_strerror ($ret) . "\n";
}

if (($ret = socket_listen ($sock, 5)) < 0) {
    echo "socket_listen() fehlgeschlagen: Grund: " . socket_strerror ($ret) . "\n";
}

do {
    if (($msgsock = socket_accept($sock)) < 0) {
        echo "socket_accept() fehlgeschlagen: Grund: " . socket_strerror ($msgsock) . "\n";
        break;
    }
    /* Anweisungen senden. */
    $msg = "\nWillkommen auf dem PHP Testserver.  \n" .
        "Um zu beenden, geben Sie 'quit' ein. Um den Server herunterzufahren, geben Sie 'shutdown' ein.\n";
    socket_write($msgsock, $msg, strlen($msg));

    do {
        if (FALSE === ($buf = socket_read ($msgsock, 2048))) {
            echo "socket_read() fehlgeschlagen: Grund: " . socket_strerror ($ret) . "\n";
            break 2;
        }
        if (!$buf = trim ($buf)) {
            continue;
        }
        if ($buf == 'quit') {
            break;
        }
        if ($buf == 'shutdown') {
            socket_close ($msgsock);
            break 2;
        }
        $talkback = "PHP: Sie haben '$buf' eingegeben.\n";
        socket_write ($msgsock, $talkback, strlen ($talkback));
        echo "$buf\n";
    } while (true);
    socket_close ($msgsock);
} while (true);

socket_close ($sock);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>Socket Beispiel: Einfacher TCP/IP Client</title>
      <para>
       Dieses Beispiel zeigt einen einfachen HTTP-Client, der einen
	   einzelnen Request absetzen kann. Er verbindet sich mit einer
	   Seite, setzt einen HEAD-Request ab, gibt die Antwort zurück und
	   wird beendet.
      </para>
      <programlisting>
<![CDATA[
<?php
error_reporting (E_ALL);

echo "<h2>TCP/IP Verbindung</h2>\n";

/* Den Port des WWW-Dienstes holen. */
$service_port = getservbyname ('www', 'tcp');

/* Die IP-Adresse des Zielhosts holen. */
$address = gethostbyname ('www.example.com');

/* einen TCP/IP Socket erzeugen. */
$socket = socket_create (AF_INET, SOCK_STREAM, SOL_TCP);
if ($socket < 0) {
    echo "socket_create() fehlgeschlagen: Grund: " . socket_strerror ($socket) . "\n";
} else {
    echo "OK.\n";
}

echo "Versuche, eine Verbindung zu '$address' auf Port '$service_port' aufzubauen ...";
$result = socket_connect ($socket, $address, $service_port);
if ($result < 0) {
    echo "socket_connect() fehlgeschlagen.\nGrund: ($result) " . socket_strerror($result) . "\n";
} else {
    echo "OK.\n";
}

$in = "HEAD / HTTP/1.1\r\n";
$in .= "Host: www.example.com\r\n";
$in .= "Connection: Close\r\n\r\n";
$out = '';

echo "Einen HTTP HEAD Request senden ...";
socket_write ($socket, $in, strlen ($in));
echo "OK.\n";

echo "Die Antwort lesen:\n\n";
while ($out = socket_read ($socket, 2048)) {
    echo $out;
}

echo "Den Socket schliessen ...";
socket_close ($socket);
echo "OK.\n\n";
?>
]]>
      </programlisting>
     </example>
    </para>
   </section>
  </partintro>

&reference.sockets.functions;

 </reference>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
