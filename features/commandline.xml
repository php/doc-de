<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: eee245cdbd89dc2fd908285f588e3b9e055924e5 Maintainer: nikic Status: ready -->
<!-- Reviewed: yes -->
<!-- Rev-Revision: a2fc23851f710d7f0de3dceb23dc68ee34d17b32 Reviewer: samesch -->
<!-- Credits: hholzgra, fa -->
<chapter xml:id="features.commandline" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Nutzung von PHP auf der Kommandozeile</title>
 <titleabbrev>Nutzung der Kommandzeile</titleabbrev>

 <!--Introduction: {{{-->
 <section xml:id="features.commandline.introduction" annotations="chunk:false">
  <title>Introduction</title>
  <para>
   Das Hauptaugenmerk der &cli.sapi; liegt auf der Entwicklung von
   Kommandozeilenanwendungen. Es gibt einige Unterschiede zwischen der
   &cli.sapi; und anderen <acronym>SAPI</acronym>s, welche in diesem Kapitel
   beschrieben werden. Es ist erwähnenswert, dass &cli; und
   <acronym>CGI</acronym> verschiedene <acronym>SAPI</acronym>s sind, auch
   wenn sie viele Verhaltensweisen teilen.
  </para>
  <para>
   Die &cli.sapi; ist standardmäßig durch die Option
   <option role="configure">--enable-cli</option> aktiviert, kann jedoch durch
   Angabe der Option <option role="configure">--disable-cli</option> im
   <command>./configure</command>-Skript deaktiviert werden.
  </para>
  <para>
   Der Name, der Pfad und das Vorhandensein der
   &cli;/<acronym>CGI</acronym>-Binaries hängt davon ab, wie PHP auf dem
   System installiert wurde. Standarmäßig werden nach dem Aufruf von
   <command>make</command> sowohl <acronym>CGI</acronym> als auch &cli;
   kompiliert und als <filename>sapi/cgi/php-cgi</filename> beziehungsweise
   <filename>sapi/cli/php</filename> in Ihrem PHP-Quellcodeverzeichnis
   gespeichert. Sie werden bemerken, dass beide <filename>php</filename>
   heißen. Was während <command>make install</command> passiert, hängt davon
   ab, wie PHP konfiguriert wurde. Wenn bei der Konfiguration eine
   Modul-<acronym>SAPI</acronym> wie &zb; apxs gewählt wurde oder die Option
   <option role="configure">--disable-cgi</option> genutzt wurde, wird die
   &cli; während <command>make install</command> nach
   <filename>{PREFIX}/bin/php</filename> kopiert. Andernfalls wird das
   <acronym>CGI</acronym>-Binary dorthin kopiert. Also wird, wenn
   beispielsweise <option role="configure">--with-apxs</option> in Ihrem
   configure-Kommando angegeben ist, die &cli; während <command>make
   install</command> nach <filename>{PREFIX}/bin/php</filename> kopiert. Wenn
   Sie die Installation des <acronym>CGI</acronym>-Binaries überschreiben
   wollen, verwenden Sie <command>make install-cli</command> nach
   <command>make install</command>. Alternativ können Sie
   <option role="configure">--disable-cgi</option> in Ihrem configure-Kommando
   angeben.
  </para>
  <note>
   <para>
    Weil sowohl <option role="configure">--enable-cli</option> als auch
    <option role="configure">--enable-cgi</option> standardmäßig eingeschaltet
    sind, muss <option role="configure">--enable-cli</option> in Ihrem
    configure-Kommando nicht zwingend bedeuten, dass die &cli; während
    <command>make install</command> nach <filename>{PREFIX}/bin/php</filename>
    kopiert wird.
   </para>
  </note>
  <para>
   Auf Windows wird das &cli;-Binary im Hauptordner als
   <filename>php.exe</filename> ausgeliefert. Die
   <acronym>CGI</acronym>-Version wird als <filename>php-cgi.exe</filename>
   bereitgestellt. Zusätzlich wird <filename>php-win.exe</filename>
   ausgeliefert, wenn PHP mit
   <option role="configure">--enable-cli-win32</option> konfiguriert wurde.
   Dieses Binary verhält sich genauso wie die &cli;-Version, bis auf die
   Tatsache, dass sie nichts ausgibt und somit keine Konsole zur Verfügung
   stellt.
  </para>
  <note>
   <title>Welche SAPI habe ich?</title>
   <para>
    Auf der Kommandozeile wird Ihnen die Eingabe von <command>php -v</command>
    verraten, ob Sie <filename>php</filename> als <acronym>CGI</acronym> oder
    &cli; einsetzen. Sehen Sie sich auch die Funktion
    <function>php_sapi_name</function> und die Konstante
    <constant>PHP_SAPI</constant> an.
   </para>
  </note>
  <note>
   <para>
    Eine UNIX-<literal>man</literal>page ist durch Eingabe von
    <command>man php</command> auf der Kommandozeile verfügbar.
   </para>
  </note>
 </section>
 <!--}}}-->

 <!--Differences: {{{-->
 <section xml:id="features.commandline.differences">
  <title>Unterschiede zu anderen <acronym>SAPI</acronym>s</title>
  <para>
   Wesentliche Unterschiede der &cli;-<acronym>SAPI</acronym> zu anderen
   <acronym>SAPI</acronym>s:
   <itemizedlist>
    <listitem>
     <para>
      Anders als bei der <acronym>CGI</acronym>-<acronym>SAPI</acronym> werden
      keine Header ausgegeben.
     </para>
     <para>
      Obwohl die <acronym>CGI</acronym>-<acronym>SAPI</acronym> eine Option
      bietet, HTTP-Header zu unterdrücken, gibt es keine gleichwertige Option,
      sie in der &cli.sapi; anzuzeigen.
     </para>
     <para>
      &cli; wird standardmäßig im stillen Modus gestartet, dennoch gibt es die
      Optionen <option>-q</option> und <option>--no-header</option> aus
      Kompatibilitätsgründen noch, sodass auch ältere
      <acronym>CGI</acronym>-Skripte noch verwendet werden können.
     </para>
     <para>
      Es wechselt das Arbeitsverzeichnis nicht in das des Skriptes. (Die
      Optionen <option>-C</option> und <option>--no-chdir</option> wurden aus
      Kompatibilitätsgründen beibehalten.)
     </para>
     <para>
      Fehlermeldungen im Klartext (keine <acronym>HTML</acronym>-Formatierung).
     </para>
    </listitem>
    <listitem>
     <para>
      Es gibt bestimmte &php.ini;-Direktiven, die von der &cli.sapi; außer
      Kraft gesetzt werden, weil sie in einer Kommandozeilenumgebung keinen
      Sinn ergeben.
     </para>
     <para>
      <table>
       <title>Überschriebene &php.ini;-Direktiven</title>
       <tgroup cols="3">
        <thead>
         <row>
          <entry>Direktive</entry>
          <entry>&cli; <acronym>SAPI</acronym>-Standardwert</entry>
          <entry>Kommentar</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><link linkend="ini.html-errors">html_errors</link></entry>
          <entry>&false;</entry>
          <entry>
           Die Standardeinstellung ist &false;, weil es sehr schwierig sein
           kann, Fehlermeldunge auf der Kommandozeile zu lesen, wenn sie
           mit bedeutungslosen <acronym>HTML</acronym>-Tags vollgestopft ist.
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.implicit-flush">implicit_flush</link></entry>
          <entry>&true;</entry>
          <entry>
           Auf der Kommandozeile ist es normalerweise erwünscht, dass alle
           Ausgaben, die von <function>print</function>,
           <function>echo</function> und Konsorten kommen, sofort angezeigt
           werden und nicht in einem Puffer zwischengespeichert werden. Es ist
           jedoch immer noch möglich,
           <link linkend="ref.outcontrol">output buffering</link> zu
           verwenden, um die Standardausgabe aufzuschieben oder zu
           manipulieren.
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.max-execution-time">max_execution_time</link></entry>
          <entry>0 (unendlich)</entry>
          <entry>
           Da die Anwendungsbereiche von PHP auf der Kommandozeile wesentlich
           vielfältiger sind als in webbasierten Anwendungen und oft lange
           Laufzeiten besitzen, wird die maximale Ausführungszeit auf
           unendlich gesetzt.
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.register-argc-argv">register_argc_argv</link></entry>
          <entry>&true;</entry>
          <entry>
           <para>
            Weil diese Einstellung auf &true; gesetzt ist, werden Skripte, die
            über die &cli;-<acronym>SAPI</acronym> ausgeführt werden, immer
            Zugriff auf <emphasis>argc</emphasis> (die Anzahl der Argumente,
            die der Anwendung übergeben wurden) und <emphasis>argv</emphasis>
            (das Array mit den übergebenen Argumenten) haben.
           </para>
           <para>
            Die PHP-Variablen <varname>$argc</varname> und
            <varname>$argv</varname> werden automatisch mit den entsprechenden
            Werten gefüllt, wenn die &cli;-<acronym>SAPI</acronym> verwendet
            wird. Diese Werte können auch im Array <varname>$_SERVER</varname>
            gefunden werden, beispielsweise:
            <varname>$_SERVER['argv']</varname>.
           </para>
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.output-buffering">output_buffering</link></entry>
          <entry>&false;</entry>
          <entry>
           <para>
            Auch wenn diese &php.ini;-Option fest auf &false; gesetzt ist,
            sind die Funktionen der
            <link linkend="book.outcontrol">Ausgabepufferung</link> verfügbar.
           </para>
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.max-input-time">max_input_time</link></entry>
          <entry>&false;</entry>
          <entry>
           <para>
            Die PHP-&cli; unterstützt GET, POST und Dateiuploads nicht.
           </para>
          </entry>
         </row>
        </tbody>
       </tgroup>
      </table>
     </para>
     <note>
      <para>
       Diese Direktiven können nicht mit einem anderen Wert aus der
       Konfigurationsdatei &php.ini; oder einer eigenen (falls angegeben)
       initialisiert werden. Diese Einschränkung ergibt sich dadurch, dass
       diese Standardwerte angewandt werden, nachdem alle
       Konfigurationsdateien gelesen wurden. Dennoch können die Werte zur
       Laufzeit verändert werden (was aber nicht für alle dieser Direktiven
       einen Sinn ergibt, beispielsweise
       <link linkend="ini.register-argc-argv">register_argc_argv</link>).
      </para>
     </note>
     <note>
      <para>
       Es wird empfohlen
       <link linkend="ini.ignore-user-abort">ignore_user_abort</link> für
       Kommandozeilenanwendungen zu setzen. Siehe
       <function>ignore_user_abort</function> für weitere Informationen.
      </para>
     </note>
    </listitem>
    <listitem>
     <para>
      Um die Arbeit auf der Kommandozeilenumgebung zu erleichtern, wurden
      einige Konstanten für
      <link linkend="features.commandline.io-streams">Ein- und Ausgabestreams</link>
      definiert.
     </para>
    </listitem>
    <listitem>
     <para>
      Die &cli.sapi; wechselt das aktuelle Arbeitsverzeichnis <emphasis
      role="strong">nicht</emphasis> ins Verzeichnis des ausgeführten Skripts.
     </para>
     <example>
      <title>
       Beispiel, welches den Unterschied zur
       <acronym>CGI</acronym>-<acronym>SAPI</acronym> verdeutlicht:
      </title>
      <programlisting role="php">
<![CDATA[
<?php
// Unsere einfache Anwendung namens test.php
echo getcwd(), "\n";
?>
]]>
      </programlisting>
      <para>
       Bei der <acronym>CGI</acronym>-Version ist die Ausgabe folgende:
      </para>
      <screen>
<![CDATA[
$ pwd
/tmp

$ php -q anderes_verzeichnis/test.php
/tmp/anderes_verzeichnis
]]>
      </screen>
      <para>
       Dies zeigt deutlich, dass PHP vom aktuellen Verzeichnis in das des
       ausgeführten Skriptes wechselt.
      </para>
      <para>
       Nutzung der &cli.sapi; führt zu folgender Ausgabe:
      </para>
      <screen>
<![CDATA[
$ pwd
/tmp

$ php -f anderes_verzeichnis/test.php
/tmp
]]>
      </screen>
      <para>
       Dies ermöglicht eine größere Flexibilität beim Erstellen von
       Kommandozeilenanwendungen in PHP.
      </para>
     </example>
     <note>
      <para>
       Die <acronym>CGI</acronym>-<acronym>SAPI</acronym> unterstützt das
       Verhalten der &cli.sapi; durch Angabe der Option <option>-C</option>
       beim Starten von der Kommandozeile.
      </para>
     </note>
    </listitem>
   </itemizedlist>
  </para>
 </section>
 <!--}}}-->

 <!--Options: {{{-->
 <section xml:id="features.commandline.options">
  <title>Kommandozeilenoptionen</title>
  <titleabbrev>Optionen</titleabbrev>
  <para>
   Die Liste der Kommandozeilenoptionen, die das PHP-Binary bereitstellt, kann
   jederzeit abgerufen werden, indem PHP mit der Option <option>-h</option>
   gestartet wird:
   <screen>
<![CDATA[
Usage: php [options] [-f] <file> [--] [args...]
   php [options] -r <code> [--] [args...]
   php [options] [-B <begin_code>] -R <code> [-E <end_code>] [--] [args...]
   php [options] [-B <begin_code>] -F <file> [-E <end_code>] [--] [args...]
   php [options] -- [args...]
   php [options] -a

  -a               Run interactively
  -c <path>|<file> Look for php.ini file in this directory
  -n               No php.ini file will be used
  -d foo[=bar]     Define INI entry foo with value 'bar'
  -e               Generate extended information for debugger/profiler
  -f <file>        Parse and execute <file>.
  -h               This help
  -i               PHP information
  -l               Syntax check only (lint)
  -m               Show compiled in modules
  -r <code>        Run PHP <code> without using script tags <?..?>
  -B <begin_code>  Run PHP <begin_code> before processing input lines
  -R <code>        Run PHP <code> for every input line
  -F <file>        Parse and execute <file> for every input line
  -E <end_code>    Run PHP <end_code> after processing all input lines
  -H               Hide any passed arguments from external tools.
  -S <addr>:<port> Run with built-in web server.
  -t <docroot>     Specify document root <docroot> for built-in web server.
  -s               Output HTML syntax highlighted source.
  -v               Version number
  -w               Output source with stripped comments and whitespace.
  -z <file>        Load Zend extension <file>.

  args...          Arguments passed to script. Use -- args when first argument
                   starts with - or script is read from stdin

  --ini            Show configuration file names

  --rf <name>      Show information about function <name>.
  --rc <name>      Show information about class <name>.
  --re <name>      Show information about extension <name>.
  --rz <name>      Show information about Zend extension <name>.
  --ri <name>      Show configuration for extension <name>.
]]>
   </screen>
  </para>

  <para>
   <table>
    <title>Kommandozeilenoptionen</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Option</entry>
       <entry>Langform</entry>
       <entry>Beschreibung</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>-a</entry>
       <entry>--interactive</entry>
       <entry>
        <para>
         Startet PHP im interaktiven Modus. Für weitere Informationen siehe
         die Dokumentation für den
         <link linkend="features.commandline.interactive">Interaktiven Modus</link>.
        </para>
       </entry>
      </row>
      <row>
       <entry>-b</entry>
       <entry>--bindpath</entry>
       <entry>
        <para>
         Der Bind-Pfad für den externen FASTCGI-Servermodus (nur
         <acronym>CGI</acronym>).
        </para>
       </entry>
      </row>
      <row>
       <entry>-C</entry>
       <entry>--no-chdir</entry>
       <entry>
        <para>
         Nicht in das Verzeichnis des Skripts wechseln (nur
         <acronym>CGI</acronym>).
        </para>
       </entry>
      </row>
      <row>
       <entry>-q</entry>
       <entry>--no-header</entry>
       <entry>
        <para>
         Der Quiet-Modus. Unterdrücke die Ausgabe von
         <acronym>HTTP</acronym>-Headern (nur <acronym>CGI</acronym>).
        </para>
       </entry>
      </row>
      <row>
       <entry>-T</entry>
       <entry>--timing</entry>
       <entry>
        <para>
         Misst die Ausführungszeit des Skripts. Dies wird
         <varname>count</varname> mal durchgeführt (nur
         <acronym>CGI</acronym>).
        </para>
       </entry>
      </row>
      <row>
       <entry>-c</entry>
       <entry>--php-ini</entry>
       <entry>
        <para>
         Mit dieser Option kann man entweder ein Verzichnis angeben, in
         welchem nach der &php.ini; gesucht werden soll, oder man kann eine
         eigene <literal>INI</literal>-Datei angeben (diese muss nicht
         &php.ini; heissen). Zum Beispiel:
        </para>
        <para>
         <informalexample>
          <screen>
<![CDATA[
$ php -c /custom/directory/ my_script.php

$ php -c /custom/directory/custom-file.ini my_script.php
]]>
          </screen>
         </informalexample>
        </para>
        <para>
         Wenn diese Option nicht angegeben wird, wird die &php.ini;-Datei an
         den <link linkend="configuration.file">vorgegebenen Orten</link>
         gesucht.
        </para>
       </entry>
      </row>
      <row>
       <entry>-n</entry>
       <entry>--no-php-ini</entry>
       <entry>
        <para>
         &php.ini; komplett ignorieren.
        </para>
       </entry>
      </row>
      <row>
       <entry>-d</entry>
       <entry>--define</entry>
       <entry>
        <para>
         Diese Option erlaubt es Ihnen, einen eigenen Wert für eine beliebige
         in &php.ini; erlaubte Direktive zu setzen. Die Syntax ist:
         <screen>
<![CDATA[
-d configuration_directive[=value]
]]>
         </screen>
        </para>
        <para>
         <example>
         <title>Beispiel für die Verwendung von <literal>-d</literal> zum Setzen einer INI-Direktive</title>
          <screen>
<![CDATA[
# Auslassen des Wertes setzt die Direktive auf "1"
$ php -d max_execution_time
      -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(1) "1"

# Übergeben eines leeren Wertes setzt die Direktive auf ""
php -d max_execution_time=
    -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(0) ""

# Die Direktive wird auf das gesetzt, was nach '=' kommt
$  php -d max_execution_time=20
       -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(2) "20"
$  php
       -d max_execution_time=doesntmakesense
       -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(15) "doesntmakesense"
]]>
          </screen>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>-e</entry>
       <entry>--profile-info</entry>
       <entry>
        <para>
         Erweiterte Informationen für Debugger/Profiler erstellen.
        </para>
       </entry>
      </row>
      <row>
       <entry>-f</entry>
       <entry>--file</entry>
       <entry>
        <para>
         Parst die angegebene Datei und führt sie aus. Das <option>-f</option>
         ist optional und kann weggelassen werden. Es genügt, nur den
         Dateinamen anzugeben.
        </para>
       </entry>
      </row>
      <row>
       <entry>-h und -?</entry>
       <entry>--help und --usage</entry>
       <entry>
        Gibt eine Liste von Kommandozeilenoptionen mit kurzen Beschreibungen
        ihrer Funktion aus.
       </entry>
      </row>
      <row>
       <entry>-i</entry>
       <entry>--info</entry>
       <entry>
        Diese Kommandozeilenoption ruft <function>phpinfo</function> auf und
        gibt das Ergebnis aus. Wenn PHP nicht korrekt funktioniert, ist es
        empfehlenswert, <command>php -i</command> zu verwenden und
        nachzusehen, ob etwa Fehlermeldungen vor oder statt der
        Informationstabellen ausgegeben werden. Beachten Sie, dass die Ausgabe
        bei Verwendung des <acronym>CGI</acronym>-Modus in
        <acronym>HTML</acronym> erfolgt und deswegen ziemlich umfangreich ist.
       </entry>
      </row>
      <row>
       <entry>-l</entry>
       <entry>--syntax-check</entry>
       <entry>
        <para>
         Überprüft die Syntax, führt aber den angegebenen PHP-Code nicht aus.
         Wenn kein Dateiname angegeben ist, wird die Eingabe von der
         Standardeingabe verarbeitet, andernfalls wird jede angegebene Datei
         überprüft. Bei Erfolg wird der Text
         <literal>No syntax errors detected in &lt;filename&gt;</literal> auf
         der Standardausgabe ausgegeben.
         Bei einem Fehler wird zusätzlich zum internen Parser-Fehler der Text
         <literal>Errors parsing &lt;filename&gt;</literal> auf der
         Standardausgabe ausgegeben.
         Wenn in den angegebenen Dateien (oder der Standardeingabe)
         irgendwelche Fehler gefunden werden, wird der Shell-Rückgabecode auf
         <literal>-1</literal> gesetzt, andernfalls wird er auf
         <literal>0</literal> gesetzt.
        </para>
        <para>
         Diese Option findet keine fatalen Fehler (&zb; undefinierte
         Funktionen), die die Ausführung des Codes erfordern.
        </para>
        <note>
         <para>
          Vor PHP 8.3.0 war es nur möglich, den Namen einer Datei anzugeben,
          die überprüft werden sollte.
         </para>
        </note>
        <note>
         <para>
          Diese Option funktioniert nicht zusammen mit der Option
          <option>-r</option>.
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-m</entry>
       <entry>--modules</entry>
       <entry>
        <para>
         <example>
          <title>Ausgabe der geladenen PHP- und Zend-Module</title>
          <screen>
<![CDATA[
$ php -m
[PHP Modules]
xml
tokenizer
standard
session
posix
pcre
overload
mysql
mbstring
ctype

[Zend Modules]
]]>
          </screen>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>-r</entry>
       <entry>--run</entry>
       <entry>
        <para>
         Diese Option erlaubt die Ausführung von PHP Code direkt von der
         Kommandozeile. Die PHP-Tags <literal>&lt;?php</literal> und
         <literal>?&gt;</literal> werden <emphasis role="strong">nicht
         benötigt</emphasis> und verursachen einen Parsefehler, wenn sie
         dennoch vorhanden sind.
        </para>
        <note>
         <para>
          Bei der Verwendung dieser Option in PHP ist besondere Vorsicht
          geboten, dass es nicht zu Kollisionen mit dem Ersetzen von
          Kommandozeilenvariablen durch die Shell kommt.
         </para>
         <example>
          <title>Syntaxfehler beim Verwenden von doppelten Anführungszeichen</title>
          <screen>
<![CDATA[
$ php -r "$foo = get_defined_constants();"
PHP Parse error:  syntax error, unexpected '=' in Command line code on line 1

Parse error: syntax error, unexpected '=' in Command line code on line 1
]]>
          </screen>
         </example>
         <para>
          Das Problem hier ist, dass auch sh/bash Variablen ersetzt, wenn
          doppelte Anführungszeichen (<literal>"</literal>) verwendet werden.
          Weil die Variable <varname>$foo</varname> wahrscheinlich nicht
          definiert ist, wird die Variable zu nichts aufgelöst. Der
          entstehende Code, welcher PHP übergeben wird, sieht so aus:
         </para>
         <informalexample>
          <screen>
<![CDATA[
$ php -r " = get_defined_constants();"
]]>
          </screen>
         </informalexample>
         <para>
          Der richtige Weg wäre, einfache Anführungszeichen
          (<literal>'</literal>) zu verwenden. Variablen in einfachen
          Anführungszeichen werden von sh/bash nicht ersetzt.
         </para>
         <example>
          <title>Verwendung einfacher Anführungszeichen, um ein Ersetzen der Variablen durch die Shell zu verhindern</title>
          <screen>
<![CDATA[
$ php -r '$foo = get_defined_constants(); var_dump($foo);'
array(370) {
  ["E_ERROR"]=>
  int(1)
  ["E_WARNING"]=>
  int(2)
  ["E_PARSE"]=>
  int(4)
  ["E_NOTICE"]=>
  int(8)
  ["E_CORE_ERROR"]=>
  [...]
]]>
          </screen>
         </example>
         <para>
          Wenn eine andere Kommandozeilenumgebung als sh/bash verwendet wird,
          könnten weitere Probleme auftreten. Gegebenenfalls kann unter
          <link xlink:href="&url.php.bugs;">&url.php.bugs;</link> ein
          Bugreport erstellt werden. Man kann dennoch leicht in
          Schwierigkeiten geraten, wenn man versucht PHP- oder Shell-Variablen
          zu verwenden, oder Backslashes zum Maskieren verwendet. Sie wurden
          gewarnt!
         </para>
        </note>
        <note>
         <para>
          <literal>-r</literal> ist in der &cli.sapi; verfügbar, nicht jedoch
          in der <emphasis>CGI</emphasis>-<acronym>SAPI</acronym>.
         </para>
        </note>
        <note>
         <para>
          Diese Option ist für sehr einfachen Code gedacht, weshalb einige
          Direktiven wie etwa
          <link linkend="ini.auto-prepend-file">auto_prepend_file</link> und
          <link linkend="ini.auto-append-file">auto_append_file</link> in
          diesem Modus ignoriert werden.
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-B</entry>
       <entry>--process-begin</entry>
       <entry>
        <para>
         PHP-Code, der ausgeführt werden soll, bevor stdin ausgewertet wird.
        </para>
       </entry>
      </row>
      <row>
       <entry>-R</entry>
       <entry>--process-code</entry>
       <entry>
        <para>
         PHP-Code, der für jede Eingabezeile ausgeführt werden soll.
        </para>
        <para>
         Es gibt zwei spezielle Variablen in diesem Modus:
         <varname>$argn</varname> und <varname>$argi</varname>.
         <varname>$argn</varname> enthält die Zeile, die PHP gerade
         verarbeitet und <varname>$argi</varname> enthält die Zeilennummer.
        </para>
       </entry>
      </row>
      <row>
       <entry>-F</entry>
       <entry>--process-file</entry>
       <entry>
        <para>
         PHP-Datei, die für jede Eingabezeile ausgeführt werden soll.
        </para>
       </entry>
      </row>
      <row>
       <entry>-E</entry>
       <entry>--process-end</entry>
       <entry>
        <para>
         PHP-Code, der nach der Verarbeitung der Eingabe ausgeführt werden
         soll.
        </para>
        <para>
         <example>
          <title>
           Nutzung der Optionen <option>-B</option>, <option>-R</option> und
           <option>-E</option>, um die Anzahl der Zeilen in einem Projekt zu
           zählen.
          </title>
          <screen>
<![CDATA[
$ find my_proj | php -B '$l=0;' -R '$l += count(@file($argn));' -E 'echo "Zeilen insgesamt: $l\n";'
Zeilen insgesamt: 37328
]]>
          </screen>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>-S</entry>
       <entry>--server</entry>
       <entry>
        <para>
         Startet den
         <link linkend="features.commandline.webserver">eingebauten Webserver</link>.
        </para>
       </entry>
      </row>
      <row>
       <entry>-t</entry>
       <entry>--docroot</entry>
       <entry>
        Gibt den Document-Root (Wurzelverzeichnis der Dokumente) für den
        <link linkend="features.commandline.webserver">eingebauten Webserver</link>
        an.
       </entry>
      </row>
      <row>
       <entry>-s</entry>
       <entry>--syntax-highlight und --syntax-highlighting</entry>
       <entry>
        <para>
         Den Quelltext mit farblich hervorgehobener Syntax anzeigen.
        </para>
        <para>
         Diese Option verwendet den internen Mechanismus zum Parsen von
         Dateien, um eine HTML-Version mit Syntax-Highlighting auf die
         Standardausgabe zu schreiben. Beachten Sie, dass sie nur einen Block
         mit den HTML-Tags <literal>&lt;code&gt; [...] &lt;/code&gt;</literal>
         erzeugt, jedoch keine HTML-Header.
        </para>
        <note>
         <para>
          Diese Option funktioniert nicht zusammen mit <option>-r</option>.
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-v</entry>
       <entry>--version</entry>
       <entry>
        <para>
         <example>
          <title>
           Nutzung von <option>-v</option>, um den
           <acronym>SAPI</acronym>-Namen, sowie die PHP- und Zend-Version zu
           ermitteln
          </title>
          <screen>
<![CDATA[
$ php -v
PHP 5.3.1 (cli) (built: Dec 11 2009 19:55:07)
Copyright (c) 1997-2009 The PHP Group
Zend Engine v2.3.0, Copyright (c) 1998-2009 Zend Technologies
]]>
          </screen>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>-w</entry>
       <entry>--strip</entry>
       <entry>
        <para>
         Den Quelltext ohne Kommentare und Leerzeichen anzeigen.
        </para>
        <note>
         <para>
          Diese Option funktioniert nicht zusammen mit <option>-r</option>.
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-z</entry>
       <entry>--zend-extension</entry>
       <entry>
        <para>
         Eine Zend-Erweiterung laden. Wenn nur ein Dateiname angegeben wird,
         versucht PHP, die Erweiterung aus dem momentanen
         Standard-Bibliotheken-Pfad auf Ihrem System zu laden (auf
         Linux-Systemen normalerweise in <filename>/etc/ld.so.conf</filename>
         angegeben). Wenn ein Dateiname mit absoluter Pfadinformation
         übergeben wird, wird der Bibliotheken-Pfad des Systems nicht
         verwendet. Ein relativer Dateiname mit Pfadinformationen wird PHP
         veranlassen, zu versuchen, die Erweiterung in einem Pfad relativ zum
         aktuellen Verzeichnis zu laden.
        </para>
       </entry>
      </row>
      <row>
       <entry></entry>
       <entry>--ini</entry>
       <entry>
        <para>
         Zeigt die Namen der Konfigurationsdateien und die durchsuchten
         Verzeichnisse.
         <example>
          <title><literal>--ini</literal>-Beispiel</title>
          <programlisting role="shell">
<![CDATA[
$ php --ini
Configuration File (php.ini) Path: /usr/dev/php/5.2/lib
Loaded Configuration File:         /usr/dev/php/5.2/lib/php.ini
Scan for additional .ini files in: (none)
Additional .ini files parsed:      (none)
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>--rf</entry>
       <entry>--rfunction</entry>
       <entry>
        <para>
         Zeigt Informationen über die angegebene Funktion oder Klassenmethode
         (&zb; Anzahl und Namen der Parameter).
        </para>
        <para>
         Diese Option ist nur verfügbar, wenn PHP mit
         <link linkend="book.reflection">Reflection</link>-Unterstützung
         kompiliert wurde.
        </para>
        <para>
         <example>
          <title>Einfache <literal>--rf</literal>-Nutzung</title>
          <programlisting role="shell">
<![CDATA[
$ php --rf var_dump
Function [ <internal> public function var_dump ] {

  - Parameters [2] {
    Parameter #0 [ <required> $var ]
    Parameter #1 [ <optional> $... ]
  }
}
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>--rc</entry>
       <entry>--rclass</entry>
       <entry>
        <para>
         Zeigt Inforationen über die angegebene Klasse (Liste der Konstanten,
         Eigenschaften und Methoden).
        </para>
        <para>
         Diese Option ist nur verfügbar, wenn PHP mit
         <link linkend="book.reflection">Reflection</link>-Unterstützung
         kompiliert wurde.
        </para>
        <para>
         <example>
          <title><literal>--rc</literal>-Beispiel</title>
          <programlisting role="shell">
<![CDATA[
$ php --rc Directory
Class [ <internal:standard> class Directory ] {

  - Constants [0] {
  }

  - Static properties [0] {
  }

  - Static methods [0] {
  }

  - Properties [0] {
  }

  - Methods [3] {
    Method [ <internal> public method close ] {
    }

    Method [ <internal> public method rewind ] {
    }

    Method [ <internal> public method read ] {
    }
  }
}
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>--re</entry>
       <entry>--rextension</entry>
       <entry>
        <para>
         Zeigt Informationen über die angegebene Erweiterung (Liste der
         &php.ini;-Optionen, definierte Funktionen, Konstanten und Klassen).
        </para>
        <para>
         Diese Option ist nur verfügbar, wenn PHP mit
         <link linkend="book.reflection">Reflection</link>-Unterstützung
         kompiliert wurde.
        </para>
        <para>
         <example>
          <title><literal>--re</literal>-Beispiel</title>
          <programlisting role="shell">
<![CDATA[
$ php --re json
Extension [ <persistent> extension #19 json version 1.2.1 ] {

  - Functions {
    Function [ <internal> function json_encode ] {
    }
    Function [ <internal> function json_decode ] {
    }
  }
}
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>--rz</entry>
       <entry>--rzendextension</entry>
       <entry>
        <para>
         Zeigt Konfiguration der angegebenen Zend-Erweiterung an (entspricht
         der von <function>phpinfo</function> zurückgegebenen Information).
        </para>
       </entry>
      </row>
      <row>
       <entry>--ri</entry>
       <entry>--rextinfo</entry>
       <entry>
        <para>
         Zeigt die Konfiguration der angegebenen Erweiterung an (entspricht
         der von <function>phpinfo</function> zurückgegebenen Information).
         Die Konfiguration des Sprachkerns kann über den speziellen
         Erweiterungsnamen "main" ermittelt werden.
        </para>
        <para>
         <example>
          <title><literal>--ri</literal>-Beispiel</title>
          <programlisting role="shell">
<![CDATA[
$ php --ri date

date

date/time support => enabled
"Olson" Timezone Database Version => 2009.20
Timezone Database => internal
Default timezone => Europe/Oslo

Directive => Local Value => Master Value
date.timezone => Europe/Oslo => Europe/Oslo
date.default_latitude => 59.930972 => 59.930972
date.default_longitude => 10.776699 => 10.776699
date.sunset_zenith => 90.583333 => 90.583333
date.sunrise_zenith => 90.583333 => 90.583333
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
  <note>
   <para>
    Die Optionen <literal>-rBRFEH</literal>, <literal>--ini</literal> und
    <literal>--r[fcezi]</literal> sind nur für &cli; verfügbar.
   </para>
  </note>
 </section>
 <!--}}}-->

 <!--Usage: {{{-->
 <section xml:id="features.commandline.usage">
  <title>Ausführen von PHP-Dateien</title>
  <titleabbrev>Verwendung</titleabbrev>
  <para>
   Es gibt drei verschiedene Wege, PHP-Code in der &cli.sapi; auszuführen:
   <orderedlist>
    <listitem>
     <para>
      PHP mitteilen, eine bestimmte Datei auszuführen.
     </para>
     <informalexample>
      <screen>
<![CDATA[
$ php my_script.php

$ php -f my_script.php
]]>
      </screen>
     </informalexample>
     <para>
      Beide Methoden (ob die Option <option>-f</option> verwendet wird oder
      nicht) führen die Datei <filename>my_script.php</filename> aus. Zu
      beachten ist, dass es keine Einschränkungen dafür gibt, welche Dateien
      ausgeführt werden können; beispielsweise muss das PHP-Skript nicht auf
      <literal>.php</literal> enden.
     </para>
    </listitem>
    <listitem>
     <para>
      Den auszuführenden PHP-Code direkt auf der Kommandozeile angeben.
     </para>
     <informalexample>
      <screen>
<![CDATA[
$ php -r 'print_r(get_defined_constants());'
]]>
      </screen>
     </informalexample>
     <para>
      Es muss besonders Acht gegeben werden auf die Ersetzung von
      Kommandozeilenvariablen und Benutzung von Anführungszeichen.
     </para>
     <note>
      <para>
       Achten Sie darauf, dass sie keine PHP-Tags übergeben. Die Option
       <option>-r</option> benötigt diese nicht und löst einen Parser-Fehler
       aus, falls sie dennoch verwendet werden.
      </para>
     </note>
    </listitem>
    <listitem>
     <para>
      Eingabe des PHP-Codes über die Standardeingabe
      (<literal>stdin</literal>).
     </para>
     <para>
      Dies eröffnet die Möglichkeit, PHP-Code dynamisch zu generieren und
      anschließend an das PHP-Binary zu übergeben, wie in diesem
      (ausgedachten) Beispiel dargestellt:
     </para>
     <informalexample>
      <screen>
<![CDATA[
$ some_application | some_filter | php | sort -u > final_output.txt
]]>
      </screen>
     </informalexample>
    </listitem>
   </orderedlist>
   Die drei Möglichkeiten zur Codeausführung können nicht kombiniert werden.
  </para>
  <para>
   Wie jede Kommandozeilenanwendung nimmt das PHP-Binary etliche Argumente
   entgegen, aber auch das PHP-Skript kann Argumente entgegennehmen. Die
   Anzahl der Argumente, die an ein Skript übergeben werden können, ist nicht
   von PHP beschränkt (und obwohl die Kommandozeilenumgebung ein Limit für die
   Anzahl der Zeichen hat, die übergeben werden können, wird dieses im
   Allgemeinen nicht erreicht werden). Die Argumente, die dem Skript übergeben
   werden, sind in dem globalen Array <varname>$argv</varname> gespeichert.
   Der erste Index (Null) enthält immer den Skriptnamen. Wenn der Code mittels
   der Option <option>-r</option> ausgeführt wurde, ist der Wert von
   <varname>$argv[0]</varname> <literal>"Standard input code"</literal>; vor
   PHP 7.2.0 war es ein Bindestrich (<literal>-</literal>). Selbiges gilt für
   Code, welcher über <constant>STDIN</constant> ausgeführt wird.
  </para>
  <para>
   Die zweite registrierte globale Variable ist <varname>$argc</varname>,
   welche die Anzahl der Elemente im Array <varname>$argv</varname> enthält,
   (<emphasis role="strong">nicht</emphasis> die Anzahl Argumente, die dem
   Skript übergeben wurden).
  </para>
  <para>
   Solange die Argumente, welche dem Skript übergeben werden, nicht mit dem
   Zeichen <literal>-</literal> beginnen, gibt es nichts besonderes zu
   beachten. Ein Argument zu übergeben, welches mit <literal>-</literal>
   beginnt, wird jedoch Probleme bereiten, da PHP denkt, dass es das Argument
   selbst verarbeiten muss, noch bevor das Skript ausgeführt wird. Nutzen Sie
   das Argument-Trennzeichen <literal>--</literal>, um dies zu vermeiden.
   Nachdem dieses Trennzeichen von PHP geparst wurde, wird jedes folgende
   Argument unangetastet an das Skript weitergereicht.
  </para>
  <informalexample>
   <screen>
<![CDATA[
# Dies führt nicht den angegebenen Code aus, sondern zeigt die Optionen von PHP an
$ php -r 'var_dump($argv);' -h
Usage: php [options] [-f] <file> [args...]
[...]

# Dies übergibt das Argument '-h' an Ihr Skript und zeigt die Optionen von PHP nicht an
$ php -r 'var_dump($argv);' -- -h
array(2) {
  [0]=>
  string(1) "-"
  [1]=>
  string(2) "-h"
}
]]>
   </screen>
  </informalexample>
  <para>
   Es gibt auf Unix-Systemen jedoch einen weiteren Weg, um PHP für
   Kommandozeilenskripte zu verwenden. Sie können ein Skript erstellen, in dem
   die erste Zeile mit <literal>#!/usr/bin/php</literal> beginnt (oder wie
   auch immer der Pfad zu Ihrer PHP-&cli;-Binärdatei ist). Nachfolgend können
   Sie normalen PHP-Code innerhalb der PHP-Start- und -End-Tags verwenden.
   Sobald Sie die Datei ausführbar gemacht haben (beispielsweise mittels
   <command>chmod +x test</command>), kann Ihr Skript wie ein normales
   Kommandozeilen- oder Perl-Skript gestartet werden.
  </para>
  <example>
   <title>PHP als Shellskript ausführen</title>
   <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php
var_dump($argv);
?>
]]>
   </programlisting>
   <para>
    Angenommen, die Datei heißt <filename>test</filename> und befindet sich im
    aktuellen Verzeichnis, dann können wir nun folgendes tun:
   </para>
   <screen>
<![CDATA[
$ chmod +x test
$ ./test -h -- foo
array(4) {
  [0]=>
  string(6) "./test"
  [1]=>
  string(2) "-h"
  [2]=>
  string(2) "--"
  [3]=>
  string(3) "foo"
}
]]>
   </screen>
  </example>
  <para>
   Wie zu sehen ist, muss in diesem Fall keine besondere Rücksicht auf die
   Übergabe von Parametern genommen werden, die mit <literal>-</literal>
   beginnen.
  </para>
  <para>
   Die ausführbare PHP-Datei kann verwendet werden, um PHP-Skripte vollkommen
   unabhängig von einem Webserver auszuführen. Auf Unix-Systemen sollte die
   spezielle erste Zeile <literal>#!</literal> ("Shebang") zu PHP-Skripten
   hinzugefügt werden, damit das System automatisch herausfinden kann, welches
   Programm zur Ausführung der Datei genutzt werden soll. Auf Windows-Systemen
   ist es möglich, <filename>php.exe</filename> mit der Doppelklick-Option der
   Erweiterung <literal>.php</literal> zu verknüpfen. Es kann auch eine
   Batchdatei erstellt werden, um das Skript von PHP ausführen zu lassen. Die
   erste Zeile, die dem Skript hinzugefügt wird, damit es unter UNIX läuft,
   stört unter Windows nicht, so dass auf diese Weise problemlos
   plattformübergreifende Programme geschrieben werden können. Im Folgenden
   wird anhand eines einfachen Beispiels gezeigt, wie ein
   PHP-Kommandozeilenprogramm geschrieben wird.
  </para>
  <para>
   <example>
    <title>Ein Skript, das von der Kommandozeile aus ausgeführt werden soll (script.php)</title>
    <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php

if ($argc != 2 || in_array($argv[1], array('--help', '-help', '-h', '-?'))) {
?>

Das ist ein Kommandozeilenprogramm in PHP mit einer Option.

  Verwendung:
  <?php echo $argv[0]; ?> <option>

  <option> kann ein Wort sein, das Sie gerne
  ausgeben möchten. Mit den Optionen --help,
  -help, -h oder -? bekommen Sie diese Hilfe.

<?php
} else {
    echo $argv[1];
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   In dem oben beschriebenen Skript haben wir die erste Zeile dazu verwendet,
   anzugeben, dass die Datei von PHP ausgeführt werden soll. Wir arbeiten hier
   mit einer &cli;-Version, deswegen werden keine
   <acronym>HTTP</acronym>-Header ausgegeben.
  </para>
  <para>
   In dem obigen Programm wird zuerst überprüft, ob das notwendige Argument
   angeben ist (zusätzlich zum Skriptnamen, welcher auch gezählt wird). Wenn
   nicht, oder wenn das Argument <option>--help</option>,
   <option>-help</option>, <option>-h</option> oder <option>-?</option> war,
   wird eine Hilfe-Nachricht ausgegeben, welche <varname>$argv[0]</varname>
   nutzt, um den auf der Kommandozeile eingegebenen Skript-Namen auszugeben.
   Andernfalls wird das Argument genauso ausgegeben, wie es übergeben wurde.
  </para>
  <para>
   Um das obige Skript unter UNIX auszuführen, muss es zuerst ausführbar
   gemacht werden, und danach einfach als <command>script.php
   GebeDasHierAus</command> oder <command>script.php -h</command> aufgerufen
   werden. Unter Windows kann zu diesem Zweck eine Batchdatei erstellt werden:
  </para>

  <para>
   <example>
    <title>Batchdatei zur Ausführung eines Kommandozeilen-Skripts in PHP (script.bat)</title>
    <programlisting role="winbat">
<![CDATA[
@echo OFF
"C:\php\php.exe" script.php %*
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Angenommen, das obige Programm wurde <filename>script.php</filename> genannt
   und die &cli; <filename>php.exe</filename> hat den Pfad
   <filename>C:\php\php.exe</filename>, so wird diese Batchdatei es mit allen
   übergebenen Argumenten aufrufen: <command>script.bat
   GebeDasHierAus</command> oder <command>script.bat -h</command>.
  </para>
  <para>
   Siehe auch die <link linkend="ref.readline">Readline</link>-Erweiterung für
   weitere Funktionen, um PHP-Kommandozeilenanwendungen zu verbessern.
  </para>
  <para>
   Unter Windows kann PHP so konfiguiert werden, dass es auch ausgeführt wird,
   wenn weder <filename>C:\php\php.exe</filename> angegeben wird, noch die
   Dateierweiterung <literal>.php</literal> genutzt wird. Siehe dazu die
   Dokumentation zur
   <link linkend="install.windows.commandline">PHP-Kommandozeile unter Microsoft Windows</link>.
  </para>
  <note>
   <para>
    Unter Windows wird empfohlen, PHP unter einem echten User-Account
    auszuführen. Wird es unter einem Netzwerk-Account ausgeführt, werden
    bestimmte Operationen fehlschlagen, weil "keine Zuordnung zwischen
    Kontennamen und Sicherheits-IDs erfolgte".
   </para>
  </note>
 </section>
 <!--}}}-->

 <!--I/O Streams: {{{-->
 <section xml:id="features.commandline.io-streams">
  <title>Ein- und Ausgabestreams</title>
  <titleabbrev>I/O Streams</titleabbrev>
  <para>
   Die &cli.sapi; definiert einige Konstanten für Ein- und Ausgabestreams, um
   das Erstellen von Kommandozeilenanwendungen zu erleichtern.
  </para>
  <para>
   <table>
    <title>CLI-spezifische Konstanten</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Konstante</entry>
       <entry>Beschreibung</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><constant>STDIN</constant></entry>
       <entry>
        <para>
         Ein schon geöffneter Stream auf <literal>stdin</literal>. Dies
         erspart das Öffnen mit
         <programlisting role="php">
<![CDATA[
<?php
$stdin = fopen('php://stdin', 'r');
?>
]]>
         </programlisting>
         Wenn sie einzelne Zeilen von <literal>stdin</literal> lesen wollen,
         können Sie folgendes Code-Fragment verwenden:
         <programlisting role="php">
<![CDATA[
<?php
$line = trim(fgets(STDIN)); // liest eine Zeile von STDIN
fscanf(STDIN, "%d\n", $number); // liest eine Zahl von STDIN
?>
]]>
         </programlisting>
        </para>
       </entry>
      </row>
      <row>
       <entry><constant>STDOUT</constant></entry>
       <entry>
        <para>
         Ein schon geöffneter Stream auf <literal>stdout</literal>. Das
         erspart das Öffnen mit
         <programlisting role="php">
<![CDATA[
<?php
$stdout = fopen('php://stdout', 'w');
?>
]]>
         </programlisting>
        </para>
       </entry>
      </row>
      <row>
       <entry><constant>STDERR</constant></entry>
       <entry>
        <para>
         Ein schon geöffneter Stream auf <literal>stderr</literal>. Das
         erspart das Öffnen mit
         <programlisting role="php">
<![CDATA[
<?php
$stderr = fopen('php://stderr', 'w');
?>
]]>
         </programlisting>
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
  <para>
   Angesichts des oben Genannten, brauchen Sie beispielsweise nicht selbst
   einen Stream für <literal>stderr</literal> öffnen, sondern können einfach
   die Konstante anstelle der Ressource verwenden:
   <programlisting role="shell">
<![CDATA[
php -r 'fwrite(STDERR, "stderr\n");'
]]>
   </programlisting>
   Sie brauchen diese Streams nicht explizit zu schließen, weil sie
   automatisch von PHP geschlossen werden, wenn Ihr Skript endet.
  </para>
  <note>
   <para>
    Diese Konstanten sind nicht verfügbar, wenn ein PHP Skript von
    <literal>stdin</literal> eingelesen wird.
   </para>
  </note>
 </section>
 <!--}}}-->

 <!--Interactive shell: {{{-->
 <section xml:id="features.commandline.interactive">
  <title>Interaktive Shell</title>
  <para>
   Wenn PHP mit der Option <option role="configure">--with-readline</option>
   kompiliert wurde, bietet die &cli.sapi; mit der Option <option>-a</option>
   eine interaktive Shell an. Von PHP 7.1.0 an steht die interaktive Shell
   auch unter Windows zu Verfügung, wenn die
   <link linkend="book.readline">readline-Erweiterung</link> aktiviert ist.
  </para>
  <para>
   Mittels der interaktiven Shell können Sie PHP-Code eingeben und direkt
   ausführen lassen.
  </para>
  <example>
   <title>Ausführung von Code in der interaktiven Shell</title>
   <programlisting role="shell">
<![CDATA[
$ php -a
Interactive shell

php > echo 5+8;
13
php > function addTwo($n)
php > {
php { return $n + 2;
php { }
php > var_dump(addtwo(2));
int(4)
php >
]]>
   </programlisting>
  </example>
  <para>
   Die interaktive Shell bietet auch Tabulator-Autovervollständigung für
   Funktionen, Konstanten, Klassen, Variablen, statische Methoden und
   Klassenkonstanten.
  </para>
  <example>
   <title>Tabulator-Autovervollständigung</title>
   <simpara>
    Wenn es mehrere mögliche Vervollständigungen gibt, wird durch zweimaliges
    Drücken der Tabulator-Taste eine Liste dieser Vervollständigungen
    angezeigt:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > strp[TAB][TAB]
strpbrk   strpos    strptime
php > strp
]]>
   </programlisting>
   <simpara>
    Wenn es nur eine mögliche Vervollständigung gibt, führt ein einmaliges
    Drücken der Tabulator-Taste zur Vervollständigung der Zeile:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > strpt[TAB]ime(
]]>
   </programlisting>
   <simpara>
    Autovervollständigung funktioniert auch für Namen, welche bereits während
    dieser interaktiven Session definiert wurden:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > $fooThisIsAReallyLongVariableName = 42;
php > $foo[TAB]ThisIsAReallyLongVariableName
]]>
   </programlisting>
  </example>
  <para>
   Die interaktive Shell speichert den Verlauf von zuletzt eingegeben Zeilen,
   auf die mittels der Pfeiltasten zugegriffen werden kann. Der Verlauf wird
   in der Datei <filename>~/.php_history</filename> gespeichert.
  </para>
  <para>
   Die &cli.sapi; bietet die &php.ini;-Optionen
   <parameter>cli.pager</parameter> und <parameter>cli.prompt</parameter>. Die
   Option <parameter>cli.pager</parameter> erlaubt einem externen Programm
   (wie etwa <filename>less</filename>) als Pager für die Ausgabe zu agieren,
   anstatt dass diese direkt ausgegeben wird. Die Option
   <parameter>cli.prompt</parameter> erlaubt das Ändern der
   <literal>php &gt;</literal>-Eingabeaufforderung.
  </para>
  <para>
   Es ist auch möglich, die &php.ini;-Optionen in der interaktiven Shell zu
   setzen, indem man eine Kurzschreibweise verwendet.
  </para>
  <example>
   <title>Setzen von &php.ini;-Optionen in der interaktiven Shell</title>
   <simpara>
    Die Option <parameter>cli.prompt</parameter>:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > #cli.prompt=hello world :>
hello world :>
]]>
   </programlisting>
   <simpara>
    Mittels Backticks kann PHP-Code in der Eingabeaufforderung ausgeführt
    werden:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > #cli.prompt=`echo date('H:i:s');` php >
15:49:35 php > echo 'hi';
hi
15:49:43 php > sleep(2);
15:49:45 php >
]]>
   </programlisting>
   <simpara>
    Setzen des Pagers auf <filename>less</filename>:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > #cli.pager=less
php > phpinfo();
(output displayed in less)
php >
]]>
   </programlisting>
  </example>
  <para>
   Die Option <parameter>cli.prompt</parameter> unterstützt einige
   Escape-Sequenzen.
   <table>
    <title><parameter>cli.prompt</parameter>-Escape-Sequenzen</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Sequenzen</entry>
       <entry>Beschreibung</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>\e</literal></entry>
       <entry>
        Wird verwendet, um Farben zur Eingabeaufforderung hinzuzufügen. Ein
        Beispiel: <literal>\e[032m\v \e[031m\b \e[34m\> \e[0m</literal>
       </entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>Die PHP-Version.</entry>
      </row>
      <row>
       <entry><literal>\b</literal></entry>
       <entry>
        Gibt an, in welchem Block sich PHP befindet. Zum Beispiel gibt
        <literal>/*</literal> an, dass man sich gerade in einem mehrzeiligen
        Kommentar befindet. Der äußerste Block ist <literal>php</literal>.
       </entry>
      </row>
      <row>
       <entry><literal>\&gt;</literal></entry>
       <entry>
        Gibt das Eingabeaufforderungszeichen an. Standardmäßig ist dies
        <literal>&gt;</literal>, ändert sich jedoch, wenn sich die Shell
        innerhalb eines nicht beendeten Blocks oder Strings befindet. Mögliche
        Zeichen sind: <literal>' " { ( &gt;</literal>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
  <note>
   <para>
    Dateien, die mit
    <link linkend="ini.auto-prepend-file">auto_prepend_file</link> und
    <link linkend="ini.auto-append-file">auto_append_file</link> eingebunden
    wurden, werden in diesem Modus mit einigen Einschränkungen geparst - &zb;
    müssen Funktionen vor dem Aufruf definiert werden.
   </para>
  </note>

  <section xml:id="features.commandline.interactive.mode">
   <title>Interaktiver Modus</title>
   <para>
    Wenn die readline-Erweiterung nicht verfügbar ist, wurde vor PHP 8.1.0
    durch den Aufruf von &cli.sapi; mit der Option <option>-a</option> in den
    interaktiven Modus gewechselt. In diesem Modus muss ein komplettes
    PHP-Skript über STDIN übergeben werden, das nach dem Beenden mit
    <keycombo action='simul'>
     <keycap>CTRL</keycap>
     <keycap>D</keycap>
    </keycombo>
    (POSIX) oder
    <keycombo action='simul'>
     <keycap>CTRL</keycap>
     <keycap>Z</keycap>
    </keycombo>
    gefolgt von <literal>ENTER</literal> (Windows) ausgewertet wird.
    Dies ist im Grunde dasselbe wie der Aufruf von &cli.sapi; ohne die Option
    <option>-a</option>.
   </para>
   <para>
    Seit PHP 8.1.0 schlägt der Aufruf von &cli.sapi; mit der Option
    <option>-a</option> fehl, wenn die readline-Erweiterung nicht verfügbar
    ist.
   </para>
  </section>
 </section>
 <!--}}}-->

 <!--Built-in CLI Web Server: {{{-->
 <section xml:id="features.commandline.webserver">
  <title>Eingebauter Webserver</title>
  <warning>
   <para>
    Dieser Webserver wurde entwickelt, um bei der Anwendungsentwicklung zu
    helfen. Er kann ebenso für Testzwecke und für Anwendungsdemonstrationen
    nützlich sein, die in kontrollierten Umgebungen ausgeführt werden. Er ist
    nicht als voll funktioneller Webserver gedacht. Er sollte nicht in einem
    öffentlichen Netzwerk verwendet werden.
   </para>
  </warning>
  <para>
   Die &cli.sapi; bietet einen eingebauten Webserver.
  </para>
  <para>
   Der Webserver läuft nur mit einem single-threaded Prozess, sodass
   PHP-Anwendungen nicht weiter ausgeführt werden, wenn eine Anfrage blockiert
   wird.
  </para>
  <para>
   URI-Anfragen werden vom aktuellen Arbeitsverzeichnis ausgehend
   ausgeliefert, sofern nicht die -t Option genutzt wurde um ein explizites
   Document-Root anzugeben. Wenn eine URI-Anfrage keine Datei angibt, wird
   entweder index.php oder index.html aus dem aufgerufenen Verzeichnis
   zurückgegeben. Wenn beide Dateien nicht existieren, wird die Suche von
   index.php und index.html im übergeordneten Verzeichnis fortgesetzt usw.,
   bis eine gefunden wurde, oder das Document-Root erreicht wurde. Wurde eine
   index.php oder index.html gefunden, wird sie zurückgegeben und
   $_SERVER['PATH_INFO'] wird auf den abschließenden Teil des URI gesetzt.
   Andernfalls wird ein 404-Antwortcode zurückgeben.
  </para>
  <para>
   Wenn auf der Kommandozeile beim Starten des Webservers eine PHP-Datei
   angegeben wird, wird diese als "Router"-Skript verwendet. Dieses Skript
   wird dann zu Beginn jeder HTTP-Anfrage gestartet. Wenn dieses Skript
   &false; zurückgibt, dann wird die angefragte Ressource direkt
   zurückgegeben. Andernfalls wird die Ausgabe des Skripts zurückgegeben.
  </para>
  <para>
   Standard-MIME-Typen werden für Dateien mit den folgenden Erweiterungen
   zurückgegeben:
   <simplelist type="inline">
    <member><literal>.3gp</literal></member>
    <member><literal>.apk</literal></member>
    <member><literal>.avi</literal></member>
    <member><literal>.bmp</literal></member>
    <member><literal>.css</literal></member>
    <member><literal>.csv</literal></member>
    <member><literal>.doc</literal></member>
    <member><literal>.docx</literal></member>
    <member><literal>.flac</literal></member>
    <member><literal>.gif</literal></member>
    <member><literal>.gz</literal></member>
    <member><literal>.gzip</literal></member>
    <member><literal>.htm</literal></member>
    <member><literal>.html</literal></member>
    <member><literal>.ics</literal></member>
    <member><literal>.jpe</literal></member>
    <member><literal>.jpeg</literal></member>
    <member><literal>.jpg</literal></member>
    <member><literal>.js</literal></member>
    <member><literal>.kml</literal></member>
    <member><literal>.kmz</literal></member>
    <member><literal>.m4a</literal></member>
    <member><literal>.mov</literal></member>
    <member><literal>.mp3</literal></member>
    <member><literal>.mp4</literal></member>
    <member><literal>.mpeg</literal></member>
    <member><literal>.mpg</literal></member>
    <member><literal>.odp</literal></member>
    <member><literal>.ods</literal></member>
    <member><literal>.odt</literal></member>
    <member><literal>.oga</literal></member>
    <member><literal>.ogg</literal></member>
    <member><literal>.ogv</literal></member>
    <member><literal>.pdf</literal></member>
    <member><literal>.png</literal></member>
    <member><literal>.pps</literal></member>
    <member><literal>.pptx</literal></member>
    <member><literal>.qt</literal></member>
    <member><literal>.svg</literal></member>
    <member><literal>.swf</literal></member>
    <member><literal>.tar</literal></member>
    <member><literal>.text</literal></member>
    <member><literal>.tif</literal></member>
    <member><literal>.txt</literal></member>
    <member><literal>.wav</literal></member>
    <member><literal>.webm</literal></member>
    <member><literal>.wmv</literal></member>
    <member><literal>.xls</literal></member>
    <member><literal>.xlsx</literal></member>
    <member><literal>.xml</literal></member>
    <member><literal>.xsl</literal></member>
    <member><literal>.xsd</literal></member>
    <member><literal>.zip</literal></member>
   </simplelist>
   .
  </para>

  <simpara>
   Seit PHP 7.4.0 kann der eingebaute Webserver so konfiguriert werden, dass
   mehrere Worker geforkt werden können, um Code zu testen, der mehrere
   gleichzeitige Anfragen erfordert. Dazu muss die Umgebungsvariable
   <envar>PHP_CLI_SERVER_WORKERS</envar> auf die Zahl der gewünschten Worker
   gesetzt werden, bevor der Server gestartet wird.
  </simpara>
  <note>
   <simpara>Dieses Feature wird unter Windows nicht unterstützt.</simpara>
  </note>
  <warning>
   <para>
    Dieses <emphasis>experimentelle</emphasis> Feature ist
    <emphasis>nicht</emphasis> für den Produktionseinsatz vorgesehen.
    Der eingebaute Webserver ist grundsätzlich <emphasis>nicht</emphasis>
    für den Produktionseinsatz vorgesehen.
   </para>
  </warning>

  <example>
   <title>Starten des Webservers</title>
   <programlisting role="shell">
<![CDATA[
$ cd ~/public_html
$ php -S localhost:8000
]]>
   </programlisting>
   <para>
    Die Kommandozeile wird ausgeben:
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:43:28 2011
Listening on localhost:8000
Document root is /home/me/public_html
Press Ctrl-C to quit
]]>
   </screen>
   <para>
    Nach URI-Anfragen für http://localhost:8000/ und
    http://localhost:8000/myscript.html wird die Kommandozeile in etwa so
    aussehen:
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:43:28 2011
Listening on localhost:8000
Document root is /home/me/public_html
Press Ctrl-C to quit.
[Thu Jul 21 10:48:48 2011] ::1:39144 GET /favicon.ico - Request read
[Thu Jul 21 10:48:50 2011] ::1:39146 GET / - Request read
[Thu Jul 21 10:48:50 2011] ::1:39147 GET /favicon.ico - Request read
[Thu Jul 21 10:48:52 2011] ::1:39148 GET /myscript.html - Request read
[Thu Jul 21 10:48:52 2011] ::1:39149 GET /favicon.ico - Request read
]]>
   </screen>
   <para>
    Es ist zu beachten, dass bis zu PHP 7.4.0 symbolisch verknüpfte statische
    Ressourcen unter Windows nicht erreichbar waren, es sei denn, das
    Router-Skript würde diese verarbeiten.
   </para>
  </example>
  <example>
   <title>Starten mit einer expliziten Document-Root</title>
   <programlisting role="shell">
<![CDATA[
$ cd ~/public_html
$ php -S localhost:8000 -t foo/
]]>
   </programlisting>
   <para>
    Die Kommandozeile wird ausgeben:
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:50:26 2011
Listening on localhost:8000
Document root is /home/me/public_html/foo
Press Ctrl-C to quit
]]>
   </screen>
  </example>

  <example>
   <title>Nutzung eines Router-Skripts</title>
   <para>
    In diesem Beispiel werden bei Anfragen nach Bildern diese direkt
    angezeigt; bei Anfragen nach HTML-Dateien wird stattdessen "Willkommen in
    PHP!" angezeigt.
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// router.php
if (preg_match('/\.(?:png|jpg|jpeg|gif)$/', $_SERVER["REQUEST_URI"])) {
    return false; // Liefere die angefragte Ressource direkt aus
} else {
    echo "<p>Willkommen in PHP!</p>";
}
?>]]>
   </programlisting>
   <programlisting role="shell">
<![CDATA[
$ php -S localhost:8000 router.php
]]>
   </programlisting>
  </example>

  <example>
   <title>Prüfung auf die Verwendung des CLI-Webservers</title>
   <para>
    Um ein Framework-Router-Skript sowohl während der Entwicklung mit dem
    CLI-Webserver als auch später mit einem Produktions-Webserver zu
    verwenden:
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// router.php
if (php_sapi_name() == 'cli-server') {
    /* statische Assets weiterleiten und false zurückgeben */
}
/* weiter mit den normalen index.php-Operationen */
?>]]>
   </programlisting>
   <programlisting role="shell">
<![CDATA[
$ php -S localhost:8000 router.php
]]>
   </programlisting>
  </example>

  <example>
   <title>Behandlung nicht unterstützter Dateitypen</title>
   <para>
    Wenn Sie statische Ressourcen ausliefern müssen, deren MIME-Typ vom
    CLI-Webserver nicht unterstützt wird, verwenden Sie:
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// router.php
$path = pathinfo($_SERVER["SCRIPT_FILENAME"]);
if ($path["extension"] == "el") {
    header("Content-Type: text/x-script.elisp");
    readfile($_SERVER["SCRIPT_FILENAME"]);
}
else {
    return FALSE;
}
?>]]>
   </programlisting>
   <programlisting role="shell">
<![CDATA[
$ php -S localhost:8000 router.php
]]>
   </programlisting>
  </example>
  <example>
   <title>Zugriff auf den CLI-Webserver von anderen Computern aus</title>
   <para>
    Sie können den Webserver wie folgt auf Port 8000 für jeden zugänglich
    machen:
   </para>
   <programlisting role="shell">
<![CDATA[
$ php -S 0.0.0.0:8000
]]>
   </programlisting>
   <warning>
    <para>
     Der eingebaute Webserver sollte nicht in einem öffentlichen Netzwerk
     verwendet werden.
    </para>
   </warning>
  </example>
 </section>
 <!--}}}-->

 <section xml:id="features.commandline.ini">
  <title>INI-Einstellungen</title>
  <para>
   <table>
    <title>CLI-SAPI-Konfigurations-Direktiven</title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>&Name;</entry>
       <entry>&Default;</entry>
       <entry>&Changeable;</entry>
       <entry>&Changelog;</entry>
      </row>
     </thead>
      <tbody xml:id="features.commandline.ini.list">
      <row>
       <entry><link linkend="ini.cli-server.color">cli_server.color</link></entry>
       <entry>"0"</entry>
       <entry><constant>INI_ALL</constant></entry>
       <entry></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>

  &ini.descriptions.title;

  <para>
   <variablelist>
    <varlistentry xml:id="ini.cli-server.color">
     <term>
      <parameter>cli_server.color</parameter>
      <type>bool</type>
     </term>
     <listitem>
      <para>
       Gibt an, ob der eingebaute Webserver ANSI-Color-Codes für Ausgaben auf
       die Kommandozeile nutzen soll.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </section>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=marker fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
