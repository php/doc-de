<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 86e6094e86b84a51d00ab217ac50ce8dde33d82a Maintainer: nikic Status: ready -->
<!-- Credits: hholzgra, fa -->

<chapter xml:id="features.commandline" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Nutzung von PHP auf der Kommandozeile</title>
 <titleabbrev>Nutzung auf der Kommandzeile</titleabbrev>
 
 <!--Introduction: {{{-->
 <section xml:id="features.commandline.introduction">
  <title>Introduction</title>
  
  <para>
   Das Hauptaugenmerk der
   &cli.sapi; ist die Entwicklung von Kommandozeilenapplikationen.
   Es gibt einige Unterschiede zwischen der &cli.sapi; und anderen <acronym>SAPI</acronym>s,
   welche in diesem Kapitel beschrieben werden. Es ist erwähnenswert, dass &cli; und
   <acronym>CGI</acronym> verschiedene <acronym>SAPI</acronym>s sind, auch wenn sie
   viele Verhaltensweisen teilen.
  </para>
  
  <para>
   Die &cli.sapi; ist standardmäßig durch die <option role="configure">--enable-cli</option>
   Option aktiviert, kann jedoch durch Angabe der <option role="configure">--disable-cli</option>
   Option im <command>./configure</command> Skript deaktiviert werden.
  </para>
  
  <para>
   Der Name, der Pfad und das Vorhandensein der &cli;/<acronym>CGI</acronym> Binaries hängt
   davon ab wie PHP auf dem System installiert wurde. Standarmäßig werden nach dem Aufruf von
   <command>make</command> sowohl <acronym>CGI</acronym> als auch &cli; kompiliert und als
   <filename>sapi/cgi/php-cgi</filename> beziehungsweise <filename>sapi/cli/php</filename>
   in Ihrem PHP-Quellcodeverzeichnis gespeichert. Sie werden bemerken, dass beide
   <filename>php</filename> heissen. Was während <command>make install</command> passiert,
   hängt davon ab wie PHP konfiguriert wurde. Wenn eine Modul-<acronym>SAPI</acronym>
   während der Konfiguration gewählt wurde, wie etwa apxs, oder die
   <option role="configure">--disable-cgi</option> Option genutzt wurde, wird die &cli; während
   <command>make install</command> nach <filename>{PREFIX}/bin/php</filename> kopiert. Andernfalls
   wird das <acronym>CGI</acronym> Binary dorthin kopiert. Also wird, wenn beispielsweise
   <option role="configure">--with--apxs</option> in Ihrem configure-Kommando angegeben ist,
   wird die &cli; während <command>make install</command> nach <filename>{PREFIX}/bin/php</filename>
   kopiert. Wenn Sie die Installation des <acronym>CGI</acronym> Binaries überschreiben wollen,
   benutzen Sie <command>make install-cli</command> nach <command>make install</command>.
   Alternativ können Sie <option role="configure">--disable-cgi</option> in Ihrem configure-Kommando
   angeben.
  </para>
  
  <note>
   <para>
    Weil sowohl <option role="configure">--enable-cli</option> als auch <option role="configure">
    --enable-cgi</option> standardmäßig eingeschaltet sind,
    muss <option role="configure">--enable-cli</option> in Ihrem configure-Kommando
    nicht zwingend bedeuten, dass die &cli; während
    <command>make install</command> nach
    <filename>{PREFIX}/bin/php</filename> kopiert wird.
   </para>
  </note>
  
  <para>
   Seit PHP 5 wird auf Windows das &cli; Binary im Hauptordner als
   <filename>php.exe</filename> ausgeliefert. Die <acronym>CGI</acronym> Version
   wird als <filename>php-cgi.exe</filename> bereitgestellt. Zusätzlich
   wird <filename>php-win.exe</filename> ausgeliefert, wenn PHP mit
   <option role="configure">--enable-cli-win32</option> konfiguriert wurde. Dieses
   Binary verhält sich genauso wie die &cli; Version, bis auf die Tatsache,
   dass sie nichts ausgibt und somit keine Konsole zur Verfügung stellt.
  </para>
  
  <note>
   <title>Welche SAPI habe ich?</title>
   <para>
    Auf der Kommandozeile wird Ihnen die Eingabe von <command>php -v</command>
    verraten, ob Sie <filename>php</filename> als <acronym>CGI</acronym> oder &cli;
    einsetzen. Sehen Sie sich auch die Funktion <function>php_sapi_name</function>
    und die Konstante <constant>PHP_SAPI</constant> an.
   </para>
  </note>
  
  <note>
   <para>
    Eine UNIX <literal>man</literal> Seite ist durch eingabe von
    <command>man php</command> in der Kommandozeile verfügbar.
   </para>
  </note>
 </section>
 <!--}}}-->
 
 <!--Differences: {{{-->
 <section xml:id="features.commandline.differences">
  <title>Unterschiede zu anderen <acronym>SAPI</acronym>s</title>
  
  <para>
   Beachtenswerte Unterschiede der &cli; <acronym>SAPI</acronym> zu anderen
   <acronym>SAPI</acronym>s:
   <itemizedlist>
    <listitem>
     <para>
      Anders als bei der <acronym>CGI</acronym> <acronym>SAPI</acronym> werden
      keine Header ausgegeben.
     </para>
     <para>
      Obwohl die <acronym>CGI</acronym> <acronym>SAPI</acronym> eine Option bietet,
      HTTP-Header zu unterdrücken, gibt es keine gleichwertige Option, sie in der
      &cli.sapi; anzuzeigen.
     </para>
     <para>
      &cli; wird standardmäßig im stillen Modus gestartet, dennoch gibt
      es die Optionen <option>-q</option> und <option>--no-header</option>
      aus Kompatibilitätsgründen noch, so dass Sie auch ältere
      <acronym>CGI</acronym>-Skripte noch benutzen können.
     </para>
     <para>
      Es verändert das Arbeitsverzeichnis nicht zu dem des Skriptes.
      (Die Optionen <option>-C</option> und <option>--no-chdir</option>
      wurden aus Kompatibilitätsgründen beibehalten.)
     </para>
     <para>
      Fehlermeldungen in Plaintext (keine <acronym>HTML</acronym>-Formatierung).
     </para>
    </listitem>
    <listitem>
     <para>
      Es gibt bestimmte &php.ini;-Direktiven, die von der &cli.sapi; außer Kraft
      gesetzt werden, weil sie in einer Kommandozeilenumgebung keinen Sinn ergeben.
     </para>
     <para>
      <table>
       <title>Überschriebene &php.ini;-Direktiven</title>
       <tgroup cols="3">
        <thead>
         <row>
          <entry>Direktive</entry>
          <entry>&cli; <acronym>SAPI</acronym>-Standardwert</entry>
          <entry>Kommentar</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><link linkend="ini.html-errors">html_errors</link></entry>
          <entry>&false;</entry>
          <entry>
           Es kann sehr schwierig sein, eine Fehlermeldung auf der Kommandozeile
           zu lesen, wenn sie mit all diesen bedeutungslosen <acronym>HTML</acronym>-Tags
           vollgestopft ist, deswegen wird diese Direktive auf &false; gesetzt.
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.implicit-flush">implicit_flush</link></entry>
          <entry>&true;</entry>
          <entry>
           Es ist normalerweise erwünscht, dass alle Ausgaben, die von <function>print</function>,
           <function>echo</function> und Konsorten kommen, sofort auf die Ausgabe geschrieben werden
           und nicht in einem Puffer gecacht werden. Sie können jedoch immer noch
           <link linkend="ref.outcontrol">output buffering</link> benutzen, wenn Sie die Standardausgabe
           aufschieben oder manipulieren wollen.
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.max-execution-time">max_execution_time</link></entry>
          <entry>0 (unendlich)</entry>
          <entry>
           Da die Anwendungsbereiche von Kommandozeilenanwendungen deutlich unterschiedlicher
           sind als die von Web-Applikationen und da diese oft lange Laufzeiten besitzen, wird
           die maximale Ausführungszeit auf unendlich gesetzt.
           Wegen der unendlichen Möglichkeiten, PHP in
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.register-argc-argv">register_argc_argv</link></entry>
          <entry>&true;</entry>
          <entry>
           <para>
            Weil diese Einstellung auf &true; gesetzt ist, werden Scripte die über die
            &cli; <acronym>SAPI</acronym> ausgeführt werden, immer Zugriff auf <emphasis>argc</emphasis>
            (Anzahl der Argumente, die der Anwendung übergeben wurden) und <emphasis>argv</emphasis>
            (Array der eigentlichen Argumente) haben.
           </para>
           <para>
            Die PHP-Variablen <varname>$argc</varname> und <varname>$argv</varname> werden
            automatisch mit den entsprechenden Werten gefüllt, wenn die &cli;
            <acronym>SAPI</acronym> benutzt wird. Diese Werte können auch in dem
            <varname>$_SERVER</varname> Array gefunden werden, beispielsweise:
            <varname>$_SERVER['argv']</varname>.
           </para>
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.output-buffering">output_buffering</link></entry>
          <entry>&false;</entry>
          <entry>
           <para>
            Auch wenn die &php.ini; Option fest auf &false; gesetzt ist, sind dennoch die
            <link linkend="book.outcontrol">Output buffering</link> Funktionen verfügbar.
           </para>
          </entry>
         </row>
         <row>
          <entry><link linkend="ini.max-input-time">max_input_time</link></entry>
          <entry>&false;</entry>
          <entry>
           <para>
            Die PHP &cli; unterstützt GET, POST und File Uploads nicht.
           </para>
          </entry>
         </row>
        </tbody>
       </tgroup>
      </table>
     </para>
     <note>
      <para>
       Diese Direktiven können nicht mit einem anderen Wert aus der
       Konfigurationsdatei &php.ini; oder einer eigenen (falls angegeben)
       initialisiert werden. Diese Einschränkung ergibt sich dadurch, dass diese
       Standardwerte angewandt werden, nachdem alle Konfigurationsdateien
       gelesen wurden. Dennoch können die Werte zur Laufzeit verändert werden
       (was aber nicht für alle dieser Direktiven einen Sinn ergibt, beispielsweise
       <link linkend="ini.register-argc-argv">register_argc_argv</link>).
      </para>
     </note>
     <note>
      <para>
       Es wird empfohlen <link linkend="ini.ignore-user-abort">ignore_user_abort</link>
       für Kommandozeilenanwendungen zu setzen. Siehe <function>ignore_user_abort</function>
       für weitere Informationen.
      </para>
     </note>
    </listitem>
    
    <listitem>
     <para>
      Um die Arbeit in der Kommandozeilenumgebung zu erleichtern, wurden einige
      Konstanten für <link linkend="features.commandline.io-streams">Ein- und
      Ausgabestreams</link> definiert.
     </para>
    </listitem>
    
    <listitem>
     <para>
      Die &cli.sapi; ändert das aktuelle Arbeitsverzeichnis <emphasis role="strong">nicht</emphasis>
      zu dem Verzeichnis des ausgeführten Skripts.
     </para>
     <example>
      <title>
       Beispiel, welches den Unterschied zu der <acronym>CGI</acronym>
       <acronym>SAPI</acronym> verdeutlicht:
      </title>
      <programlisting role="php">
<![CDATA[
<?php
// Unsere einfache Anwendung namens test.php
echo getcwd(), "\n";
?>
]]>
      </programlisting>
      <para>
       Bei der <acronym>CGI</acronym>-Version ist die Ausgabe folgende:
      </para>
      <screen>
<![CDATA[
$ pwd
/tmp

$ php -q another_directory/test.php
/tmp/another_directory
]]>
      </screen>
      <para>
       Dies zeigt deutlich, dass PHP das aktuelle Verzeichnis auf
       das des ausgeführten Skriptes ändert.
      </para>
      <para>
       Nutzung der &cli.sapi; führt zu folgender Ausgabe:
      </para>
      <screen>
<![CDATA[
$ pwd
/tmp

$ php -f another_directory/test.php
/tmp
]]>
      </screen>
      <para>
       Dies ermöglicht eine größere Flexibilität beim Erstellen von
       Kommandozeilenanwendungen in PHP.
      </para>
     </example>
     <note>
      <para>
       Die <acronym>CGI</acronym> <acronym>SAPI</acronym> unterstützt das
       Verhalten der &cli.sapi; durch Angabe der Option <option>-C</option>
       beim Starten von der Kommandozeile.
      </para>
     </note>
    </listitem>
   </itemizedlist>
  </para>
 </section>
 <!--}}}-->
 
 <!--Options: {{{-->
 <section xml:id="features.commandline.options">
  <title>Kommandozeilenoptionen</title>
  <titleabbrev>Optionen</titleabbrev>
  
  <para>
   Die Liste der Kommandozeilenoptionen, die das PHP-Binary
   bereitstellt, kann jederzeit abgerufen werden, indem PHP
   mit der <option>-h</option> Option gestartet wird:
   <screen>
<![CDATA[
Usage: php [options] [-f] <file> [--] [args...]
   php [options] -r <code> [--] [args...]
   php [options] [-B <begin_code>] -R <code> [-E <end_code>] [--] [args...]
   php [options] [-B <begin_code>] -F <file> [-E <end_code>] [--] [args...]
   php [options] -- [args...]
   php [options] -a

  -a               Run interactively
  -c <path>|<file> Look for php.ini file in this directory
  -n               No php.ini file will be used
  -d foo[=bar]     Define INI entry foo with value 'bar'
  -e               Generate extended information for debugger/profiler
  -f <file>        Parse and execute <file>.
  -h               This help
  -i               PHP information
  -l               Syntax check only (lint)
  -m               Show compiled in modules
  -r <code>        Run PHP <code> without using script tags <?..?>
  -B <begin_code>  Run PHP <begin_code> before processing input lines
  -R <code>        Run PHP <code> for every input line
  -F <file>        Parse and execute <file> for every input line
  -E <end_code>    Run PHP <end_code> after processing all input lines
  -H               Hide any passed arguments from external tools.
  -S <addr>:<port> Run with built-in web server.
  -t <docroot>     Specify document root <docroot> for built-in web server.
  -s               Output HTML syntax highlighted source.
  -v               Version number
  -w               Output source with stripped comments and whitespace.
  -z <file>        Load Zend extension <file>.

  args...          Arguments passed to script. Use -- args when first argument
                   starts with - or script is read from stdin

  --ini            Show configuration file names

  --rf <name>      Show information about function <name>.
  --rc <name>      Show information about class <name>.
  --re <name>      Show information about extension <name>.
  --rz <name>      Show information about Zend extension <name>.
  --ri <name>      Show configuration for extension <name>.
]]>
   </screen>
  </para>
  
  <para>
   <table>
    <title>Kommandozeilenoptionen</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Option</entry>
       <entry>Langform</entry>
       <entry>Beschreibung</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>-a</entry>
       <entry>--interactive</entry>
       <entry>
        <para>
         Startet PHP im interaktiven Modus. Weitere Informationen siehe die
         Dokumentation für den <link linkend="features.commandline.interactive">Interaktiven
         Modus</link>.
        </para>
       </entry>
      </row>
      <row>
       <entry>-b</entry>
       <entry>--bindpath</entry>
       <entry>
        <para>
         Bind Path für den externen FASTCGI Server Modus (nur <acronym>CGI</acronym>).
        </para>
       </entry>
      </row>
      <row>
       <entry>-C</entry>
       <entry>--no-chdir</entry>
       <entry>
        <para>
         Nicht in das Verzeichnis des Skripts wechseln (nur <acronym>CGI</acronym>).
        </para>
       </entry>
      </row>
      <row>
       <entry>-q</entry>
       <entry>--no-header</entry>
       <entry>
        <para>
         Quiet-mode. Unterdrücke die Ausgabe von <acronym>HTTP</acronym> Headern
         (nur <acronym>CGI</acronym>).
        </para>
       </entry>
      </row>
      <row>
       <entry>-T</entry>
       <entry>--timing</entry>
       <entry>
        <para>
         Messe die Ausführungszeit des Skriptes. Dies wird <varname>count</varname>
         Mal durchgeführt (nur <acronym>CGI</acronym>).
        </para>
       </entry>
      </row>
      <row>
       <entry>-c</entry>
       <entry>--php-ini</entry>
       <entry>
        <para>
         Mit dieser Option kann man entweder ein Verzichnis angeben, in welchem
         nach der &php.ini; gesucht werden soll, oder man kann eine eigene
         <literal>INI</literal>-Datei angeben (diese muss nicht &php.ini; heissen).
         Zum Beispiel:
        </para>
        <para>
         <informalexample>
          <screen>
<![CDATA[
$ php -c /custom/directory/ my_script.php

$ php -c /custom/directory/custom-file.ini my_script.php
]]>
          </screen>
         </informalexample>
        </para>
        <para>
         Wenn Sie diese Option nicht angeben, wird die &php.ini; Datei an den
         <link linkend="configuration.file">vorgegebenen Orten</link> gesucht.
        </para>
       </entry>
      </row>
      <row>
       <entry>-n</entry>
       <entry>--no-php-ini</entry>
       <entry>
        <para>
         &php.ini; komplett ignorieren.
        </para>
       </entry>
      </row>
      <row>
       <entry>-d</entry>
       <entry>--define</entry>
       <entry>
        <para>
         Diese Option erlaubt es Ihnen, einen eigenen Wert für eine beliebige
         in &php.ini; erlaubte Direktive zu setzen. Die Syntax ist:
         <screen>
<![CDATA[
-d configuration_directive[=value]
]]>
         </screen>
        </para>
        <para>
         <example>
          <screen>
<![CDATA[
# Auslassen des Wertes setzt die Direktive auf "1"
$ php -d max_execution_time
      -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(1) "1"

# Übergeben eines leeren Wertes setzt die Direktive auf ""
php -d max_execution_time=
    -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(0) ""

# Die Direktive wird auf das gesetzt, was nach '=' kommt
$  php -d max_execution_time=20
       -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(2) "20"
$  php -d max_execution_time=doesntmakesense
       -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(15) "doesntmakesense"
]]>
          </screen>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>-e</entry>
       <entry>--profile-info</entry>
       <entry>
        <para>
         Erweiterte Informationen für Debugger/Profiler erstellen.
        </para>
       </entry>
      </row>
      <row>
       <entry>-f</entry>
       <entry>--file</entry>
       <entry>
        <para>
         Parst und führt die angegebene Datei aus. Das <option>-f</option> ist
         optional und kann weggelassen werden. Es genügt nur den Dateinamen anzugeben.
        </para>
        <note>
         <para>
          Um Argumente an das Skript zu übergeben, muss das erste Argument
          <literal>--</literal> sein, ansonsten interpretiert PHP diese
          als PHP Optionen.
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-h und -?</entry>
       <entry>--help und --usage</entry>
       <entry>
        Gibt eine Liste von Kommandozeilenoptionen, sowie kurzen Beschreibungen aus.
       </entry>
      </row>
      <row>
       <entry>-i</entry>
       <entry>--info</entry>
       <entry>
        Diese Kommandozeilenoption ruft <function>phpinfo</function> auf und gibt
        das Ergebnis aus. Wenn PHP nicht korrekt funktioniert, ist es empfehlenswert,
        <command>php -i</command> zu benutzen und nachzusehen, ob etwa Fehlermeldungen
        vor oder statt der Informationstabellen ausgegeben werden. Beachten Sie, dass
        die Ausgabe bei Verwendung des <acronym>CGI</acronym>-Modus in <acronym>HTML</acronym>
        erfolgt und deswegen ziemlich umfangreich ist.
       </entry>
      </row>
      <row>
       <entry>-l</entry>
       <entry>--syntax-check</entry>
       <entry>
        <para>
         Diese Option stellt eine angenehme Methode bereit, nur eine Syntaxüberprüfung
         des angegebenen PHP-Codes durchzuführen. Bei Erfolg wird der Text <literal>No syntax
         errors detected in &lt;filename&gt;</literal> auf die Standardausgabe geschrieben
         und der Rückgabewert ist <literal>0</literal>. Bei Misserfolg wird der Text
         <literal>Errors parsing &lt;filename&gt;</literal> zusätzlich zur internen
         Parser-Fehlermeldung auf der Standardausgabe ausgegeben und der Rückgabewert auf
         <literal>-1</literal> gesetzt.
        </para>
        <para>
         Diese Option wird keine Fatalen Fehler (wie undefinierte Funktionen) finden.
         Benutzen Sie die Option <option>-f</option>, wenn sie auch diese überprüfen wollen.
        </para>
        <note>
         <para>
          Diese Option funktioniert nicht zusammen mit <option>-r</option>.
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-m</entry>
       <entry>--modules</entry>
       <entry>
        <para>
         <example>
          <title>Ausgabe des geladenen PHP und Zend Module</title>
          <screen>
<![CDATA[
$ php -m
[PHP Modules]
xml
tokenizer
standard
session
posix
pcre
overload
mysql
mbstring
ctype

[Zend Modules]
]]>
           
          </screen>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>-r</entry>
       <entry>--run</entry>
       <entry>
        <para>
         Diese Option erlaubt die Ausführung von PHP Code direkt von der
         Kommandozeile. Die PHP Tags <literal>&lt;?php</literal> und <literal>?&gt;</literal>
         werden <emphasis role="strong">nicht benötigt</emphasis> und verursachen
         einen Parsefehler, wenn sie dennoch vorhanden sind.
        </para>
        <note>
         <para>
          Man muss bei Benutzung dieser Form von PHP aufpassen, dass es zu
          keinen Kollisionen mit Kommandozeilenvariablen kommt.
         </para>
         <example>
          <title>Syntax Fehler beim Verwenden von doppelten Anführungszeichen</title>
          <screen>
<![CDATA[
$ php -r "$foo = get_defined_constants();"
PHP Parse error:  syntax error, unexpected '=' in Command line code on line 1

Parse error: syntax error, unexpected '=' in Command line code on line 1
]]>
          </screen>
         </example>
         <para>
          Das Problem hier ist, dass sh/bash Variablen auch ersetzt, wenn doppelte
          Anführungszeichen verwendet werden (<literal>"</literal>). Weil die Variable
          <varname>$foo</varname> wahrscheinlich nicht definiert ist, wird die Variable
          zu nichts aufgelöst. Der entstehende Code, welcher PHP übergeben wird, sieht so aus:
         </para>
         <informalexample>
          <screen>
<![CDATA[
$ php -r " = get_defined_constants();"
]]>
          </screen>
         </informalexample>
         
         <para>
          Der richtige Weg wäre, einfache Anführungszeichen zu benutzen (<literal>'</literal>).
          Variablen in einfachen Anführungszeichen werden von sh/bash nicht ersetzt.
         </para>
         <example>
          <title>Nutzung von einfachen Anführungszeichen ein Ersetzen der Variablen zu verhindern</title>
          <screen>
<![CDATA[
$ php -r '$foo = get_defined_constants(); var_dump($foo);'
array(370) {
  ["E_ERROR"]=>
  int(1)
  ["E_WARNING"]=>
  int(2)
  ["E_PARSE"]=>
  int(4)
  ["E_NOTICE"]=>
  int(8)
  ["E_CORE_ERROR"]=>
  [...]
]]>
          </screen>
         </example>
         <para>
          Wenn Sie eine andere Kommandozeilenumgebung als sh/bash benutzen,
          könnten Sie auf weitere Probleme stoßen. Sie können gerne einen
          Bugreport unter <link xlink:href="&url.php.bugs;">&url.php.bugs;</link>
          erstellen. Man kann dennoch leicht in Schwierigkeiten geraten, wenn man
          versucht PHP oder Shell Variablen zu verwenden oder Backslashes zum
          Escapen benutzt. Sie wurden gewarnt!
         </para>
        </note>
        <note>
         <para>
          <literal>-r</literal> ist in der &cli.sapi; verfügbar, nicht jedoch
          in der <emphasis>CGI</emphasis> <acronym>SAPI</acronym>.
         </para>
        </note>
        <note>
         <para>
          Diese Option ist für sehr einfachen Code gedacht, weshalb einige Direktiven wie etwa
          <link linkend="ini.auto-prepend-file">auto_prepend_file</link> und <link
          linkend="ini.auto-append-file">auto_append_file</link> in diesem Modus ignoriert werden.
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-B</entry>
       <entry>--process-begin</entry>
       <entry>
        <para>
         PHP-Code der ausgeführt werden soll, bevor stdin ausgewertet wird. Verfügbar seit PHP 5.
        </para>
       </entry>
      </row>
      <row>
       <entry>-R</entry>
       <entry>--process-code</entry>
       <entry>
        <para>
         PHP-Code der für jede Eingabezeile ausgeführt werden soll. Verfügbar seit PHP 5.
        </para>
        <para>
         Es gibt zwei spezielle Variablen in diesem Modus:
         <varname>$argn</varname> und <varname>$argi</varname>.
         <varname>$argn</varname> enthält die Zeile, die PHP gerade verarbeitet und
         <varname>$argi</varname> enthält die Zeilennummer.
        </para>
       </entry>
      </row>
      <row>
       <entry>-F</entry>
       <entry>--process-file</entry>
       <entry>
        <para>
         PHP-Datei die für jede Eingabezeile ausgeführt werden soll. Verfügbar seit PHP 5.
        </para>
       </entry>
      </row>
      <row>
       <entry>-E</entry>
       <entry>--process-end</entry>
       <entry>
        <para>
         PHP-Code der nach der Verarbeitung der Eingabe ausgeführt werden soll.
         Verfügbar seit PHP 5.
        </para>
        <para>
         <example>
          <title>Nutzung der <option>-B</option>, <option>-R</option> und
           <option>-E</option> Optionen, um die Anzahl der Zeilen in einem
           Projekt zu zählen.</title>
          <screen>
<![CDATA[
$ find my_proj | php -B '$l=0;' -R '$l += count(@file($argn));' -E 'echo "Total Lines: $l\n";'
Total Lines: 37328
]]>
          </screen>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>-S</entry>
       <entry>--server</entry>
       <entry>
        <para>
         Startet den <link linkend="features.commandline.webserver">eingebauten Webserver</link>.
         Verfügbar seit PHP 5.4.0.
        </para>
       </entry>
      </row>
      <row>
       <entry>-t</entry>
       <entry>--docroot</entry>
       <entry>
        Gibt den Document Root für den <link linkend="features.commandline.webserver">eingebauten
        Webserver</link> an. Verfügbar seit PHP 5.4.0.
       </entry>
      </row>
      <row>
       <entry>-s</entry>
       <entry>--syntax-highlight und --syntax-highlighting</entry>
       <entry>
        <para>
         Den Quelltext mit farbiger Syntaxhervorhebung anzeigen.
        </para>
        <para>
         Diese Option benutzt den internen Mechanismus zum Parsen von Dateien, um
         eine HTML-Version mit Syntax-Highlighting auf die Standardausgabe
         zu schreiben. Beachten Sie, dass sie nur einen Block von
         <literal>&lt;code&gt; [...] &lt;/code&gt;</literal> HTML-Tags
         erzeugt, jedoch keine HTML-Header.
        </para>
        <note>
         <para>
          Diese Option funktioniert nicht zusammen mit <option>-r</option>.
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-v</entry>
       <entry>--version</entry>
       <entry>
        <para>
         <example>
          <title>Nutzung von <option>-v</option>, um den <acronym>SAPI</acronym>
           Namen, sowie die PHP und Zend Version zu bestimmen</title>
          <screen>
<![CDATA[
$ php -v
PHP 5.3.1 (cli) (built: Dec 11 2009 19:55:07)
Copyright (c) 1997-2009 The PHP Group
Zend Engine v2.3.0, Copyright (c) 1998-2009 Zend Technologies
]]>
          </screen>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>-w</entry>
       <entry>--strip</entry>
       <entry>
        <para>
         Den Quelltext mit entfernten Kommentaren und Leerzeichen anzeigen.
        </para>
        <note>
         <para>
          Diese Option funktioniert nicht zusammen mit <option>-r</option>.
         </para>
        </note>
       </entry>
      </row>
      <row>
       <entry>-z</entry>
       <entry>--zend-extension</entry>
       <entry>
        <para>
         Eine Zend-Erweiterung laden. Wenn nur ein Dateiname angegeben wird,
         versucht PHP, die Erweiterung aus dem momentanen Standard-Bibliotheken-Pfad
         auf Ihrem System zu laden (auf Linux-Systemen normalerweise in
         <filename>/etc/ld.so.conf</filename> angegeben). Wenn ein Dateiname mit
         absoluter Pfadinformation übergeben wird, wird der Bibliotheken-Pfad
         des Systems nicht benutzt. Ein relativer Dateiname mit Pfadinformationen wird
         PHP veranlassen, zu versuchen, die Erweiterung in einem Pfad relativ zum
         aktuellen Verzeichnis zu laden.
        </para>
       </entry>
      </row>
      <row>
       <entry></entry>
       <entry>--ini</entry>
       <entry>
        <para>
         Zeigt die Namen der Konfigurationsdateien und die durchsuchten
         Verzeichnisse. Verfügbar seit PHP 5.2.3.
         <example>
          <title><literal>--ini</literal> example</title>
          <programlisting role="shell">
<![CDATA[
$ php --ini
Configuration File (php.ini) Path: /usr/dev/php/5.2/lib
Loaded Configuration File:         /usr/dev/php/5.2/lib/php.ini
Scan for additional .ini files in: (none)
Additional .ini files parsed:      (none)
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>--rf</entry>
       <entry>--rfunction</entry>
       <entry>
        <para>
         Zeigt Informationen über die gegebene Funktion oder Klassenmethode (z.B.
         Anzahl und Namen der Parameter). Verfügbar seit PHP 5.1.2.
        </para>
        <para>
         Diese Option ist nur verfügbar, wenn PHP mit
         <link linkend="book.reflection">Reflection</link>-Unterstützung
         kompiliert wurde.
        </para>
        <para>
         <example>
          <title>Einfache <literal>--rf</literal> Nutzung</title>
          <programlisting role="shell">
<![CDATA[
$ php --rf var_dump
Function [ <internal> public function var_dump ] {

  - Parameters [2] {
    Parameter #0 [ <required> $var ]
    Parameter #1 [ <optional> $... ]
  }
}
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>--rc</entry>
       <entry>--rclass</entry>
       <entry>
        <para>
         Zeigt Inforationen über die gegebene Klasse (Liste der Konstanten,
         Eigenschaften und Methoden). Verfügbar seit PHP 5.1.2.
        </para>
        <para>
         Diese Option ist nur verfügbar, wenn PHP mit
         <link linkend="book.reflection">Reflection</link>-Unterstützung
         kompiliert wurde.
        </para>
        <para>
         <example>
          <title><literal>--rc</literal> Beispiel</title>
          <programlisting role="shell">
<![CDATA[
$ php --rc Directory
Class [ <internal:standard> class Directory ] {

  - Constants [0] {
  }

  - Static properties [0] {
  }

  - Static methods [0] {
  }

  - Properties [0] {
  }

  - Methods [3] {
    Method [ <internal> public method close ] {
    }

    Method [ <internal> public method rewind ] {
    }

    Method [ <internal> public method read ] {
    }
  }
}
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>--re</entry>
       <entry>--rextension</entry>
       <entry>
        <para>
         Zeigt Informationen über die gegebene Erweiterung (Liste der &php.ini;
         Optionen, definierte Funktionen, Konstanten und Klassen. Verfügbar seit PHP 5.1.2.
        </para>
        <para>
         Diese Option ist nur verfügbar, wenn PHP mit
         <link linkend="book.reflection">Reflection</link> -nterstützung
         kompiliert wurde.
        </para>
        <para>
         <example>
          <title><literal>--re</literal> Beispiel</title>
          <programlisting role="shell">
<![CDATA[
$ php --re json
Extension [ <persistent> extension #19 json version 1.2.1 ] {

  - Functions {
    Function [ <internal> function json_encode ] {
    }
    Function [ <internal> function json_decode ] {
    }
  }
}
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
      <row>
       <entry>--rz</entry>
       <entry>--rzendextension</entry>
       <entry>
        <para>
         Zeigt Konfiguration der gegebenen Zend-Erweiterung an (entspricht der von
         <function>phpinfo</function> zurückgegebenen Information).
         Verfügbar seit PHP 5.4.0.
        </para>
       </entry>
      </row>
      <row>
       <entry>--ri</entry>
       <entry>--rextinfo</entry>
       <entry>
        <para>
         Zeigt die Konfiguration der gegebenen Extension (entspricht der von
         <function>phpinfo</function> zurückgegebenen Information).
         Verfügbar seit PHP 5.2.2. Die Konfiguration des Sprachkerns kann über
         den speziellen Erweiterungsnamen "main" ermittelt werden.
        </para>
        <para>
         <example>
          <title><literal>--ri</literal> Beispiel</title>
          <programlisting role="shell">
<![CDATA[
$ php --ri date

date

date/time support => enabled
"Olson" Timezone Database Version => 2009.20
Timezone Database => internal
Default timezone => Europe/Oslo

Directive => Local Value => Master Value
date.timezone => Europe/Oslo => Europe/Oslo
date.default_latitude => 59.930972 => 59.930972
date.default_longitude => 10.776699 => 10.776699
date.sunset_zenith => 90.583333 => 90.583333
date.sunrise_zenith => 90.583333 => 90.583333
]]>
          </programlisting>
         </example>
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
  
  <note>
   <para>
    Die Optionen <literal>-rBRFEH</literal>, <literal>--ini</literal> und
    <literal>--r[fcezi]</literal> sind nur für &cli; verfügbar.
   </para>
  </note>
 </section>
 <!--}}}-->
 
 <!--Usage: {{{-->
 <section xml:id="features.commandline.usage">
  <title>Ausführen von PHP-Dateien</title>
  <titleabbrev>Nutzung</titleabbrev>
  
  <para>
   Es gibt drei verschiedene Wege PHP Code in der &cli.sapi; auszuführen:
   <orderedlist>
    <listitem>
     <para>
      PHP mitteilen, eine bestimmte Datei auszuführen.
     </para>
     <informalexample>
      <screen>
<![CDATA[
php my_script.php

php -f my_script.php
]]>
      </screen>
     </informalexample>
     <para>
      Beide Wege (ob sie die Option <option>-f</option> benutzen oder nicht)
      führen die Datei <filename>my_script.php</filename> aus. Es gibt keine
      Einschränkungen darauf welche Dateien ausgeführt werden können; beispielsweise
      muss ihr PHP-Skript nicht auf <literal>.php</literal> enden.
     </para>
     <note>
      <para>
       Wenn Sie Argumente an das Skript übergeben wollen, müssen Sie als erstes
       Argument <literal>--</literal> übergeben, wenn Sie die <option>-f</option> Option benutzen.
      </para>
     </note>
    </listitem>
    <listitem>
     <para>
      Den auszuführenden PHP-Code direkt auf der Kommandozeile angeben.
     </para>
     <informalexample>
      <screen>
<![CDATA[
$ php -r 'print_r(get_defined_constants());'
]]>
      </screen>
     </informalexample>
     <para>
      Es muss besonders Acht auf die Ersetzung von Kommandozeilenvariablen und
      Benutzung von Anführungszeichen gegeben werden.
     </para>
     <note>
      <para>
       Achten Sie darauf, dass sie keine PHP tags übergeben. Die Option <option>-r</option>
       benötigt diese nicht und wirft einen Parser-Fehler falls sie dennoch benutzt werden.
      </para>
     </note>
    </listitem>
    <listitem>
     <para>
      Eingabe des PHP-Codes über die Standardeingabe
      (<literal>stdin</literal>).
     </para>
     <para>
      Dies eröffnet die Möglichkeit PHP dynamisch zu generieren und anschließend
      an die Binary zu übergeben, wie in diesem (ausgedachten) Beispiel dargestellt:
     </para>
     <informalexample>
      <screen>
<![CDATA[
$ some_application | some_filter | php | sort -u > final_output.txt
]]>
      </screen>
     </informalexample>
    </listitem>
   </orderedlist>
   Die drei Möglichkeiten zur Codeausführung können nicht kombiniert werden.
  </para>
  
  <para>
   Wie jede Kommandozeilenanwendung nimmt das PHP-Binary etliche Argumente entgegen,
   aber auch das PHP-Skript kann Argumente entgegennehmen. Die Anzahl der Argumente,
   die an ein Skript übergeben werden können, ist nicht von PHP beschränkt
   (aber die Kommandozeilenumgebung hat ein bestimmtes Größenlimit für die Anzahl
   der Argumente, die übergeben werden können; normalerweise werden Sie dieses Limit
   nicht erreichen). Die Argumente, die dem Skript übergeben werden, sind in dem
   globalen Array <varname>$argv</varname> gespeichert. Der erste Index (Null)
   enthält immer den Skriptnamen. Wenn der Code mittels der <option>-r</option>
   Option ausgeführt wurde, ist der Wert von <varname>$argv[0]</varname> ein
   Bindestrich (<literal>-</literal>). Selbiges gilt für Code, welcher über
   <literal>STDIN</literal> ausgeführt wird.
  </para>
  
  <para>
   Die zweite registrierte globale Variable ist <varname>$argc</varname>,
   welche die Anzahl der Elemente im <varname>$argv</varname> Array enthält
   (<emphasis role="strong">nicht</emphasis> die Anzahl Argumente, die dem
   Skript übergeben wurden).
  </para>
  
  <para>
   Solange die Argumente, welche dem Skript übergeben werden, nicht mit dem
   Zeichen <literal>-</literal> beginnen, gibt es nichts besonderes zu beachten.
   Ein Argument, welches mit <literal>-</literal> beginnt zu übergeben, wird
   jedoch Probleme bereiten, da PHP denkt, dass es das Argument selbst verarbeiten
   muss. Nutzen Sie das Argument-Trennzeichen <literal>--</literal>, um dies zu
   vermeiden. Nachdem dieses Trennzeichen von PHP geparst wurde, wird jedes folgende
   Argument unangetastet an das Skript weitergereicht.
  </para>
  
  <informalexample>
   <screen>
<![CDATA[
# Dies führt nicht den angegebenen Code aus, sondern zeigt die Optionen von PHP an
$ php -r 'var_dump($argv);' -h
Usage: php [options] [-f] <file> [args...]
[...]

# Dies übergibt das Argument '-h' an Ihr Skript und zeigt die Optionen von PHP nicht an
$ php -r 'var_dump($argv);' -- -h
array(2) {
  [0]=>
  string(1) "-"
  [1]=>
  string(2) "-h"
}
]]>
   </screen>
  </informalexample>
  
  <para>
   Es gibt auf Unix-Systemen jedoch einen weiteren Weg, um PHP für
   Kommandozeilenskripte zu benutzen. Sie können ein Skript erstellen,
   in dem die erste Zeile mit <literal>#!/usr/bin/php</literal> beginnt.
   Nachfolgend können Sie normalen PHP-Code innerhalb der PHP-Start- und
   -End-Tags benutzen. Sobald Sie die Datei ausführbar gemacht haben
   (beispielsweise mittels <command>chmod +x test</command>), kann Ihr Skript
   wie ein normales Kommandozeilen- oder Perl-Skript gestartet werden.
  </para>
  
  <example>
   <title>PHP als Shellskript ausführen</title>
   <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php
var_dump($argv);
?>
]]>
   </programlisting>
   <para>
    Angenommen, die Datei heißt <filename>test</filename> und befindet
    sich im aktuellen Verzeichnis, dann können wir nun folgendes tun:
   </para>
   <screen>
<![CDATA[
$ chmod +x test
$ ./test -h -- foo
array(4) {
  [0]=>
  string(6) "./test"
  [1]=>
  string(2) "-h"
  [2]=>
  string(2) "--"
  [3]=>
  string(3) "foo"
}
]]>
   </screen>
  </example>
  
  <para>
   Wie Sie sehen können, müssen Sie sich in diesem Fall um nichts weiter
   kümmern, wenn Sie Ihrem Skript Paramater, die mit <literal>-</literal>
   beginnen, übergeben.
  </para>
  
  <para>
   Die ausführbare PHP-Datei kann benutzt werden, um PHP-Skripte vollkommen
   unabhängig von einem Webserver auszuführen. Auf Unix-Systemen, sollte die
   spezielle <literal>#!</literal> ("shebang") erste Zeile zu PHP-Skripten
   hinzugefügt werden, damit das System automatisch herausfinden kann, welches
   Programm zur Ausführung der Datei genutzt werden soll. Auf einem Windows-System
   können Sie <filename>php.exe</filename> mit der Doppelklick-Option von
   <literal>.php</literal>-Dateien verknüpfen. Sie können auch eine Batchdatei
   erstellen, um das Skript von PHP ausführen zu lassen. Die erste Zeile, die dem
   Skript hinzugefügt wird, damit es unter UNIX läuft, stört unter Windows nicht,
   so dass Sie auf diese Weise problemlos plattformübergreifende Programme schreiben
   können. Sie finden anschließend ein einfaches Beispiel, wie man ein Kommandozeilenprogramm
   in PHP schreibt.
  </para>
  
  <para>
   <example>
    <title>Ein Skript, das von der Kommandozeile aus ausgeführt werden soll (script.php)</title>
    <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php

if ($argc != 2 || in_array($argv[1], array('--help', '-help', '-h', '-?'))) {
?>

Das ist ein Kommandozeilenprogramm in PHP mit einer Option.

  Benutzung:
  <?php echo $argv[0]; ?> <option>

  <option> kann ein Wort sein, das Sie gerne
  ausgeben möchten. Mit den Optionen --help,
  -help, -h oder -? bekommen Sie diese Hilfe.

<?php
} else {
    echo $argv[1];
}
?>
]]>
    </programlisting>
   </example>
  </para>
  
  <para>
   In dem oben beschriebenen Skript haben wir die erste Zeile dazu benutzt
   anzugeben, dass die Datei von PHP ausgeführt werden soll. Wir arbeiten hier
   mit einer &cli;-Version, deswegen werden keine <acronym>HTTP</acronym>-Header ausgegeben.
  </para>
  
  <para>
   In dem obigen Programm wird zuerst überprüft, dass das notwendige Argument
   angeben ist (zuzugülich dem Skriptnamen, welcher auch gezählt wird). Wenn nicht,
   oder wenn das Argument <option>--help</option>, <option>-help</option>,
   <option>-h</option> oder <option>-?</option> was, wird eine Hilfe-Nachricht
   ausgegeben, welche <varname>$argv[0]</varname> nutzt, um den genutzten Skript-Namen
   auszugeben. Andernfalls wird das Argument ausgegeben, genauso wie es übergeben wurde.
  </para>
  
  <para>
   Wenn Sie das obige Skript unter UNIX laufen lassen wollen, müssen Sie
   es zuerst ausführbar machen, und es danach einfach als <command>script.php
   GebeDasHierAus</command> oder <command>script.php -h</command> aufrufen.
   Unter Windows können Sie zu diesem Zweck eine Batchdatei erstellen:
  </para>
  
  <para>
   <example>
    <title>Batchdatei zur Ausführung eines Kommandozeilen-Skripts in PHP (script.bat)</title>
    <programlisting role="shell">
<![CDATA[
@echo OFF
"C:\php\php.exe" script.php %*
]]>
    </programlisting>
   </example>
  </para>
  
  <para>
   Angenommen, Sie haben das Programm <filename>script.php</filename> genannt
   und die &cli; <filename>php.exe</filename> hat den Pfad <filename>C:\php\php.exe</filename>
   so wird diese Batchdatei es mit allen übergebenen Argumenten aufrufen:
   <command>script.bat GebeDasHierAus</command> oder <command>script.bat -h</command>.
  </para>
  
  <para>
   Siehe auch die <link linkend="ref.readline">Readline</link>-Erweiterung für
   weitere Funktionen, um Kommandozeilenanwendungen zu verbessern.
  </para>
  
  <para>
   Auf Windows kann PHP so konfiguiert werden, dass auch ausgeführt wird, wenn
   weder <filename>C:\php\php.exe</filename> angegeben wird, noch die
   <literal>.php</literal> Dateierweiterung genutzt wird. Siehe dazu die
   Dokumentation zur <link linkend="install.windows.legacy.commandline">PHP Kommandozeile
   auf Microsoft Windows</link>.
  </para>
  <note>
   <para>
    Unter Windows wird empfohlen PHP unter einem echten User-Account auszuführen.
    Wird es unter einem Netzwerk-Account ausgeführt, werden bestimmte Operationen
    fehlschlagen, weil "keine Zuordnung zwischen Kontennamen und Sicherheits-IDs
    erfolgte".
   </para>
  </note>
 </section>
 
 <!--I/O Streams: {{{-->
 <section xml:id="features.commandline.io-streams">
  <title>Ein- und Ausgabestreams</title>
  <titleabbrev>I/O Streams</titleabbrev>
  
  <para>
   Die &cli.sapi; definiert einige Konstanten für Ein- und Ausgabestreams,
   um das Erstellen von Kommandozeilenanwendungen zu erleichtern.
  </para>
  
  <para>
   <table>
    <title>CLI-spezifische Konstanten</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Konstante</entry>
       <entry>Beschreibung</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><constant>STDIN</constant></entry>
       <entry>
        <para>
         Ein schon geöffneter Stream auf <literal>stdin</literal>.
         Dies erspart das Öffnen mit
         <programlisting role="php">
<![CDATA[
<?php
$stdin = fopen('php://stdin', 'r');
?>
]]>
         </programlisting>
         Wenn sie einzelne Zeilen von <literal>stdin</literal> lesen wollen, können Sie
         folgendes Code-Fragment benutzen:
         <programlisting role="php">
<![CDATA[
<?php
$line = trim(fgets(STDIN)); // liest eine Zeile von STDIN
fscanf(STDIN, "%d\n", $number); // liest eine Zahl von STDIN
?>
]]>
         </programlisting>
        </para>
       </entry>
      </row>
      <row>
       <entry><constant>STDOUT</constant></entry>
       <entry>
        <para>
         Ein schon geöffneter Stream auf <literal>stdout</literal>.
         Das erspart das Öffnen mit
         <programlisting role="php">
<![CDATA[
<?php
$stdout = fopen('php://stdout', 'w');
?>
]]>
         </programlisting>
        </para>
       </entry>
      </row>
      <row>
       <entry><constant>STDERR</constant></entry>
       <entry>
        <para>
         Ein schon geöffneter Stream auf <literal>stderr</literal>.
         Das erspart das Öffnen mit
         <programlisting role="php">
<![CDATA[
<?php
$stderr = fopen('php://stderr', 'w');
?>
]]>
         </programlisting>
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
  
  <para>
   Angesichts des oben genannten, brauchen Sie beispielsweise nicht
   selbst einen Stream für <literal>stderr</literal> öffnen, sondern
   können einfach die Konstante anstelle der Ressource benutzen:
   <programlisting role="shell">
<![CDATA[
php -r 'fwrite(STDERR, "stderr\n");'
]]>
   </programlisting>
   Sie brauchen diese Streams nicht explizit schließen, weil sie
   automatisch von PHP geschlossen werden, wenn Ihr Skript endet.
  </para>
  
  <note>
   <para>
    Diese Konstanten sind nicht verfügbar, wenn ein PHP Skript von
    <literal>stdin</literal> eingelesen wird.
   </para>
  </note>
 </section>
 
 <!--Interactive shell: {{{-->
 <section xml:id="features.commandline.interactive">
  <title>Interaktiver Modus</title>
  
  <para>
   Seit PHP 5.1.0 bietet die &cli.sapi; mit der <option>-a</option> Option
   eine interaktive Shell an, wenn PHP mit der <option
   role="configure">--with-readline</option> Option kompiliert wurde.
   Von PHP 7.1.0 an steht die interaktive Shell auch unter Windows zu Verfügung,
   wenn die <link linkend="book.readline">readline Extension</link> aktiviert ist.
  </para>
  
  <para>
   Mittels der interaktiven Shell können sie PHP code eingeben und direkt
   ausführen lassen.
  </para>
  
  <example>
   <title>Ausführung von Code auf der interaktiven Shell</title>
   <programlisting role="shell">
<![CDATA[
$ php -a
Interactive shell

php > echo 5+8;
13
php > function addTwo($n)
php > {
php { return $n + 2;
php { }
php > var_dump(addtwo(2));
int(4)
php >
]]>
   </programlisting>
  </example>
  
  <para>
   Die interaktive Shell bietet ebenfalls Tab-Autovervollständigung für
   Funktionen, Konstanten, Klassen, Variablen, statische Methoden und
   Klassenkonstanten.
  </para>
  
  <example>
   <title>Tab-Autovervollständigung</title>
   <simpara>
    Zweimaliges Drücken der Tab-Taste im Falle mehrerer Möglichkeiten
    führt zu einer Auflistung dieser Möglichkeiten:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > strp[TAB][TAB]
strpbrk   strpos    strptime  
php > strp
]]>
   </programlisting>
   <simpara>
    Wenn es nur eine mögliche Vervollständigung gibt, führt ein einmaliges
    Drücken der Tab-Taste zur Vervollständigung der Zeile:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > strpt[TAB]ime(
]]>
   </programlisting>
   <simpara>
    Autovervollständigung funktioniert auch für Namen, welche bereits während
    dieser interaktiven Session definiert wurden:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > $fooThisIsAReallyLongVariableName = 42;
php > $foo[TAB]ThisIsAReallyLongVariableName
]]>
   </programlisting>
  </example>
  
  <para>
   Die interaktive Shell speichert den Verlauf von zuletzt eingegeben Zeilen. Auf diesen
   kann mittels der Pfeiltasten zugegriffen werden. Er wird in der
   <filename>~/.php_history</filename> Datei gespeichert.
  </para>
  
  <para>
   Seit PHP 5.4.0 bietet die &cli.sapi; die &php.ini; Optionen <parameter>cli.pager</parameter>
   und <parameter>cli.prompt</parameter>. Die <parameter>cli.pager</parameter>
   Option erlaubt einem externen Programm (wie etwa <filename>less</filename>) als
   Pager für die Ausgabe zu agieren, anstatt dass diese direkt ausgegeben wird.
   Die <parameter>cli.prompt</parameter> Option erlaubt das Ändern der
   <literal>php &gt;</literal> Eingabeaufforderung.
  </para>
  
  <para>
   Seit PHP 5.4.0 ist es auch möglich &php.ini; Optionen einfacher zu ändern.
  </para>
  
  <example>
   <title>Setzen von &php.ini; Optionen in der interaktiven Shell</title>
   <simpara>
    Die <parameter>cli.prompt</parameter> Option:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > #cli.prompt=hello world :> 
hello world :> 
]]>
   </programlisting>
   <simpara>
    Mittels Backticks kann PHP Code in dem Präfix ausgeführt werden:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > #cli.prompt=`echo date('H:i:s');` php > 
15:49:35 php > echo 'hi';
hi
15:49:43 php > sleep(2);
15:49:45 php > 
]]>
   </programlisting>
   <simpara>
    Setzen des Pagers auf <filename>less</filename>:
   </simpara>
   <programlisting role="shell">
<![CDATA[
php > #cli.pager=less
php > phpinfo();
(output displayed in less)
php > 
]]>
   </programlisting>
  </example>
  
  <para>
   Die <parameter>cli.prompt</parameter> Option unterstützt einige
   Escape-Sequenzen.
   <table>
    <title><parameter>cli.prompt</parameter> Escape-Sequenzen</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Sequenzen</entry>
       <entry>Beschreibung</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>\e</literal></entry>
       <entry>
        Wird benutzt um Farben zur Eingabeaufforderung hinzuzufügen. Ein
        Beispiel: <literal>\e[032m\v \e[031m\b \e[34m\> \e[0m</literal>
       </entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>Die PHP Version.</entry>
      </row>
      <row>
       <entry><literal>\b</literal></entry>
       <entry>
        Gibt an, in welchem Block PHP sich befindet. Zum Beispiel gibt
        <literal>/*</literal> an, dass man sich gerade in einem mehrzeiligen
        Kommentar befindet. Der äußerste Block ist <literal>php</literal>.
       </entry>
      </row>
      <row>
       <entry><literal>\&gt;</literal></entry>
       <entry>
        Gibt das Eingabeaufforderungszeichen an. Standardmäßig ist dies
        <literal>&gt;</literal>, ändert sich jedoch, wenn sich die Shell
        innerhalb eines nicht beendeten Blocks oder Strings befindet.
        Mögliche Buchstaben sind: <literal>' " { ( &gt;</literal>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
  
  <note>
   <para>
    Dateien, die mit <link linkend="ini.auto-prepend-file">auto_prepend_file</link> und
    <link linkend="ini.auto-append-file">auto_append_file</link> eingebunden wurden,
    werden in diesem Modus mit einigen Einschränkungen geparset - Funktionen
    müssen etwa vor dem Aufruf definiert werden.
   </para>
  </note>
  
  <note>
   <para>
    <link linkend="language.oop5.autoload">Automatisches Laden (autoload)</link>
    ist im interaktiven PHP &cli; Modus nicht verfügbar.
   </para>
  </note>
 </section>
 <!--}}}-->
 
 <!--Built-in CLI Web Server: {{{-->
 <section xml:id="features.commandline.webserver">
  <title>Eingebauter Webserver</title>
  
  <warning>
   <para>
    Dieser Webserver wurde entwickelt, um bei der Anwendungsentwicklung zu
    helfen. Er kann ebenso für Testzwecke und für Anwendungsdemonstrationen
    nützlich sein, die in kontrollierten Umgebungen ausgeführt werden. Er ist
    nicht als voll funktioneller Webserver gedacht. Er sollte nicht in einem
    öffentlichen Netzwerk verwendet werden.
   </para>
  </warning>

  <para>
   Seit PHP 5.4.0 bietet die &cli.sapi; einen eingebauten Webserver.
  </para>
  
  <para>
   Der Webserver läuft in einem einfach Prozess (single-threaded), so dass
   PHP-Anwendungen nicht weiter ausgeführt werden, wenn eine Anfrage blockiert
   wird.
  </para>

  <para>
   URI Anfragen werden von dem aktuellen Arbeitsverzeichnis ausgehend
   ausgeliefert, sofern nicht die -t Option genutzt wurde um einen expliziten
   Document Root anzugeben.
   Wenn eine URI Anfrage keine Datei angibt, wird entweder index.php oder
   index.html aus dem aufgerufenen Verzeichnis zurückgegeben. Wenn beide
   Dateien nicht existieren, wird die Suche von index.php und index.html
   im übergeordneten Verzeichnis usw. fortgesetzt, bis eine gefunden wurde,
   oder das Document Root erreicht wurde. Wurde eine index.php oder index.html
   gefunden, wird sie zurückgegeben, und $_SERVER['PATH_INFO'] wird auf den
   abschließenden Teil des URI gesetzt. Andernfalls wird ein 404 Response Code
   zurückgeben.
  </para>
  
  <para>
   Wenn auf der Kommandozeile beim Starten des Webservers eine PHP-Datei
   angegeben wird, wird diese als "Router" Skript verwendet.
   Dieses Skript wird dann zu Beginn jedes HTTP Requests gestartet. Wenn dieses
   Skript &false; zurückgibt, dann wird die angefragte Ressource direkt
   zurückgegeben. Andernfalls wird die Ausgabe des Skripts zurückgegeben.
  </para>

  <para>
   Standard MIME-Typen werden für Dateien mit den folgenden Erweiterungen
   zurückgegeben: .3gp, .apk, .avi, .bmp, .css, .csv, .doc, .docx, .flac, .gif,
   .gz, .gzip, .htm, .html, .ics, .jpe, .jpeg, .jpg, .js, .kml, .kmz, .m4a,
   .mov, .mp3, .mp4, .mpeg, .mpg, .odp, .ods, .odt, .oga, .ogg, .ogv, .pdf,
   .pdf, .png, .pps, .pptx, .qt, .svg, .swf, .tar, .text, .tif, .txt, .wav,
   .webm, .wmv, .xls, .xlsx, .xml, .xsl, .xsd und .zip.
  </para>

  <table>
   <title>Changelog: Unterstützte MIME-Typen (Dateierweiterungen)</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>&Version;</entry>
      <entry>&Description;</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>5.5.12</entry>
      <entry>
       .xml, .xsl und .xsd
      </entry>
     </row>
     <row>
      <entry>5.5.7</entry>
      <entry>
       .3gp, .apk, .avi, .bmp, .csv, .doc, .docx, .flac, .gz, .gzip,
       .ics, .kml, .kmz, .m4a, .mp3, .mp4, .mpg, .mpeg, .mov, .odp, .ods,
       .odt, .oga, .pdf, .pptx, .pps, .qt, .swf, .tar, .text, .tif, .wav,
       .wmv, .xls, .xlsx und .zip
      </entry>
     </row>
     <row>
      <entry>5.5.5</entry>
      <entry>
       .pdf
      </entry>
     </row>
     <row>
      <entry>5.4.11</entry>
      <entry>
       .ogg, .ogv und .webm
      </entry>
     </row>
     <row>
      <entry>5.4.4</entry>
      <entry>
        .htm und .svg
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table>
   <title>Changelog</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>&Version;</entry>
      <entry>&Description;</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>7.4.0</entry>
      <entry>
       Der eingebaute Webserver kann so konfiguriert werden, dass mehrere Worker
       geforkt werden können, um Code zu testen, der mehrere gleichzeitige Anfragen
       erfordert. Dazu muss die Umgebungsvariable <envar>PHP_CLI_SERVER_WORKERS</envar>
       auf die Zahl der gewünschten Worker gesetzt werden bevor der Server gestartet
       wird.
       Dies wird unter Windows nicht unterstützt.
       <warning>
        <para>
         Dieses <emphasis>experimentelle</emphasis> Feature ist <emphasis>nicht</emphasis>
         für den Produktionseinsatz vorgesehen. Grundsätzlich ist der eingebaute Webserver
         <emphasis>nicht</emphasis> für den Produktionseinsatz vorgesehen.
        </para>
       </warning>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <example>
   <title>Starten des Webservers</title> 
   <programlisting role="shell">
<![CDATA[
$ cd ~/public_html
$ php -S localhost:8000
]]>
   </programlisting>
   <para>
    Die Kommandozeile wird ausgeben:
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:43:28 2011
Listening on localhost:8000
Document root is /home/me/public_html
Press Ctrl-C to quit
]]>
   </screen>
   <para>
    Nach URI Anfragen für http://localhost:8000/ und
    http://localhost:8000/myscript.html wird die Kommandozeile
    in etwa so aussehen:
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:43:28 2011
Listening on localhost:8000
Document root is /home/me/public_html
Press Ctrl-C to quit.
[Thu Jul 21 10:48:48 2011] ::1:39144 GET /favicon.ico - Request read
[Thu Jul 21 10:48:50 2011] ::1:39146 GET / - Request read
[Thu Jul 21 10:48:50 2011] ::1:39147 GET /favicon.ico - Request read
[Thu Jul 21 10:48:52 2011] ::1:39148 GET /myscript.html - Request read
[Thu Jul 21 10:48:52 2011] ::1:39149 GET /favicon.ico - Request read
]]>
   </screen>
   <para>
    Es ist zu beachten, dass bis zu PHP 7.4.0 symbolisch verknüpfte statische
    Ressourcen unter Windows nicht erreichbar waren, es sei denn, das Router-Script
    würde diese verarbeiten.
   </para>
  </example>
  
  <example>
   <title>Starten mit einem expliziten Document Root</title> 
   <programlisting role="shell">
<![CDATA[
$ cd ~/public_html
$ php -S localhost:8000 -t foo/
]]>
   </programlisting>
   <para>
    Die Kommandozeile wird ausgeben:
   </para>
   <screen>
<![CDATA[
PHP 5.4.0 Development Server started at Thu Jul 21 10:50:26 2011
Listening on localhost:8000
Document root is /home/me/public_html/foo
Press Ctrl-C to quit
]]>
   </screen>
  </example>
  
  <example>
   <title>Nutzung eines Router-Skripts</title> 
   <para>
    In diesem Beispiel werden Anfragen für Bilder diese direkt ausliefern; Anfragen für
    HTML-Dateien, werden stattdessen "Willkommen zu PHP!" ausgeben. 
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// router.php
if (preg_match('/\.(?:png|jpg|jpeg|gif)$/', $_SERVER["REQUEST_URI"])) {
    return false; // Liefere die angefragte Ressource direkt aus
} else {
    echo "<p>Willkommen zu PHP!</p>";
}
?>]]>
   </programlisting>
   <programlisting role="shell">
<![CDATA[
$ php -S localhost:8000 router.php
]]>
   </programlisting>
  </example>

  <example>
   <title>Prüfung auf die Verwendung des CLI Webservers</title>
<para>
 Um ein Framework-Router-Skript sowohl während der Entwicklung mit dem CLI Webserver
 als auch später mit einem Produktionswebserver zu verwenden:
</para>
   <programlisting role="php">
<![CDATA[
<?php
// router.php
if (php_sapi_name() == 'cli-server') {
    /* route statische Assets und gibt false zurück */
}
/* weiter mit den normalen index.php Operationen */
?>]]>
   </programlisting>
   <programlisting role="shell">
<![CDATA[
$ php -S localhost:8000 router.php
]]>
   </programlisting>
  </example>

  <example>
   <title>Behandlung nicht unterstützter Dateitypen</title>
<para>
 Wenn Sie statische Ressourcen, deren MIME Typ vom CLI Webserver nicht behandelt
 wird, ausliefern müssen, verwenden Sie:
</para>
   <programlisting role="php">
<![CDATA[
<?php
// router.php
$path = pathinfo($_SERVER["SCRIPT_FILENAME"]);
if ($path["extension"] == "el") {
    header("Content-Type: text/x-script.elisp");
    readfile($_SERVER["SCRIPT_FILENAME"]);
}
else {
    return FALSE;
}
?>]]>
   </programlisting>
   <programlisting role="shell">
<![CDATA[
$ php -S localhost:8000 router.php
]]>
   </programlisting>
  </example>

  <example>
   <title>Zugriff auf den CLI Webserver von Remote-Computern</title>
   <para>
    Sie können den Webserver wie folgt auf Port 8000 für jeden zugänglich machen:
   </para>
   <programlisting role="shell">
<![CDATA[
$ php -S 0.0.0.0:8000
]]>
   </programlisting>
   <warning>
    <para>
     Der eingebaute Webserver sollte nicht in einem öffentlichen Netzwerk verwendet
     werden.
    </para>
   </warning>
  </example>

 </section>
 <!--}}}-->
 
 <section xml:id="features.commandline.ini">
  <title>INI Einstellungen</title>
  <para>
   <table>
    <title>CLI SAPI Konfigurations-Direktiven</title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>&Name;</entry>
       <entry>&Default;</entry>
       <entry>&Changeable;</entry>
       <entry>&Changelog;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><link linkend="ini.cli-server.color">cli_server.color</link></entry>
       <entry>"0"</entry>
       <entry>PHP_INI_ALL</entry>
       <entry>Verfügbar seit PHP 5.4.0.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>
  
  &ini.descriptions.title;
  
  <para>
   <variablelist>
    <varlistentry xml:id="ini.cli-server.color">
     <term>
      <parameter>cli_server.color</parameter>
      <type>bool</type>
     </term>
     <listitem>
      <para>
       Gibt an, ob der eingebaute Web Server ANSI Color Codes für
       Ausgaben auf die Kommandozeile nutzen soll.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </section>
 
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
