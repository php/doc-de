<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.10 $ -->
<!-- EN-Revision: 1.53 Maintainer: hholzgra Status: ready -->
<!-- Credits: fa -->
<chapter xml:id="features.commandline" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>PHP auf der Kommandozeile</title>
 <para>
  Seit Version 4.3.0 unterstützt PHP einen neuen
  Typ <literal>SAPI</literal> (Server Application Programming
  Interface) namens <literal>CLI</literal> (<emphasis>Command Line
  Interface</emphasis>). Wie der Name schon verrät, liegt das
  Hauptaugemerk dieses <literal>SAPI</literal>-Typs auf der Entwicklung
  von Anwendungen für die Kommandozeile (und auch den Desktop) mit
  PHP. Es gibt etliche Unterschiede zwischen dem
  <literal>CLI SAPI</literal> und anderen <literal>SAPI</literal>s,
  die in diesem Kapitel beschrieben werden. Es ist erwähnenswert,
  dass <literal>CLI</literal> und <literal>CGI</literal> verschiedene
  SAPIs sind, obwohl sie viele Verhaltensweisen teilen.
 </para>
 <para>
  Das <literal>CLI SAPI</literal> wurde zum ersten Mal mit
  PHP 4.2.0 eingeführt, war aber noch experimentell
  und musste explizit mit <option role="configure">--enable-cli</option> beim
  <command>./configure</command>-Aufruf eingeschaltet werden. Seit
  PHP 4.3.0 ist das <literal>CLI SAPI</literal> nicht
  länger experimentell und die Option <option role="configure">--enable-cli</option>
  standardmäßig auf aktiviert. Sie können
  <option role="configure">--disable-cli</option> benutzen, um es auszuschalten.
 </para>
 <para>
  Von <literal>PHP 4.3.0</literal> an werden Namen, Pfade und
  Vorhandensein der CLI/CGI-Binaries voneinander abweichen, abhängig
  davon, wie PHP auf Ihrem System installiert ist.
  Standarmäßig werden nach dem Aufruf von <command>make</command>
  sowohl CGI als auch CLI kompiliert und als <filename>sapi/cgi/php</filename>
  beziehungsweise <filename>sapi/cli/php</filename> in Ihrem
  PHP-Quellcodeverzeichnis hinterlegt. Sie werden bemerken, dass beide
  php heissen. Was während
  <command>make install</command> passiert, hängt von Ihrem
  configure-Kommando ab. Wenn ein Modul-SAPI während configure gewählt
  wird, wie etwa apxs oder wenn die
  <option role="configure">--disable-cgi</option>-Option benutzt wird, wird das CLI
  während <literal>make install</literal> nach
  <filename>{PREFIX}/bin/php</filename> kopiert, ansonsten wird das CGI
  dort hinterlegt. Also wird, wenn beispielsweise
  <option role="configure">--with--apxs</option> in Ihrem configure-Kommando auftaucht,
  das CLI während  <command>make install</command> nach
  <filename>{PREFIX}/bin/php</filename> kopiert. Wenn Sie die Installation
  des CGI-Binaries außer Kraft setzen wollen, benutzen Sie
  <command>make install-cli</command> nach
  <command>make install</command>. Alternativ können Sie
  <option role="configure">--disable-cgi</option> in Ihrem configure-Kommando angeben.
 </para>
 <para>
  <note>
   <para>
    Weil sowohl <option role="configure">--enable-cli</option> als auch <option role="configure">
    --enable-cgi</option> standardmäßig eingeschaltet sind,
    muss <option role="configure">--enable-cli</option> in Ihrem configure-Kommando
    nicht zwingend bedeuten, dass das CLI während
    <command>make install</command> nach
    <filename>{PREFIX}/bin/php</filename> kopiert wird.
   </para>
  </note>
 </para>
 <para>
  Die Windows-Pakete zwischen PHP 4.2.0 und PHP 4.2.3 enthielten das
  CLI als <filename>php-cli.exe</filename>, beheimatet im selben
  Verzeichnis wie das CGI <filename>php.exe</filename>. Beginnend mit
  PHP 4.3.0 enthält das Windows-Paket das CLI als <filename>php.exe</filename>
  in einem eigenen Verzeichnis namens <filename class="directory">cli</filename>, also
  <filename>cli/php.exe</filename>. Beginnend mit PHP 5 wird das CLI im
  Hauptordner als <filename>php.exe</filename> ausgeliefert. Die CGI-Version
  heisst <filename>php-cgi.exe</filename>.
 </para>
 <para>
  Seit PHP 5 gibt es eine neue Datei, <filename>php-win.exe</filename>. Diese ist
  identisch mit der CLI-Version, die einzige Ausnahme besteht darin, dass
  php-win nichts ausgibt und somit keine Konsole bietet. (Es erscheint keine
  "MS-DOS-Eingabeaufforderung".)  Dieses Verhalten ist ähnlich php-gtk. Sie
  sollten die folgende Option für ./configure benutzen:
  <option role="configure">--enable-cli-win32</option>.
 </para>
 <para>
  <note>
   <title>Welche SAPI habe ich?</title>
   <para>
    Auf der Kommandozeile wird Ihnen die Eingabe von <command>php -v</command>
    verraten, ob Sie <command>php</command> als CGI oder CLI einsetzen.
    Sehen Sie sich auch die Funktion <function>php_sapi_name</function>
    und die Konstante <constant>PHP_SAPI</constant> an.
   </para>
  </note>
 </para>
 <para>
  <note>
   <para>
    Eine UNIX <literal>man</literal>ual page wurde in PHP 4.3.2 hinzugefügt.
    Sie können sie ansehen, indem sie <command>man php</command> auf der
    Kommandozeile eintippen.
   </para>
  </note>
 </para>
 <para>
  Beachtenswerte Unterschiede des <literal>CLI SAPI</literal> verglichen mit
  anderen <literal>SAPI</literal>s:
  <itemizedlist>
   <listitem>
    <para>
     Anders als beim <literal>CGI SAPI</literal> werden keine
     Header auf der Standardausgabe ausgegeben.
    </para>
    <para>
     Obwohl das <literal>CGI SAPI</literal> einen Weg bietet, HTTP-Header zu
     unterdrücken, gibt es keine gleichwertige Option, sie im <literal>CLI
     SAPI</literal> anzuzeigen.
    </para>
    <para>
     CLI wird standardmäßig im stillen Modus gestartet, dennoch gibt
     es die Optionen <option>-q</option> und <option>--no-header</option>
     aus Kompatibilitätsgründen noch, so dass Sie auch ältere CGI-Skripte noch
     benutzen können.
    </para>
    <para>
     Es verändert das Arbeitsverzeichnis nicht zu dem des Skriptes.
     (Die Optionen <option>-C</option> und <option>--no-chdir</option>
     wurden aus Kompatibilitätsgründen beibehalten.)
    </para>
    <para>
     Fehlermeldungen in Plaintext (keine HTML-Formatierung).
    </para>
   </listitem>
   <listitem>
    <para>
     Es gibt bestimmte &php.ini;-Direktiven, die vom
     <literal>CLI SAPI</literal> außer Kraft gesetzt werden, weil sie in
     einer Kommandozeilenumgebung keinen Sinn ergeben.
    </para>
    <para>
     <table>
      <title>Überschriebene &php.ini;-Direktiven</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Direktive</entry>
         <entry><literal>CLI SAPI</literal>-Standardwert</entry>
         <entry>Kommentar</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><link linkend="ini.html-errors">html_errors</link></entry>
         <entry>&false;</entry>
         <entry>
          Es kann sehr schwierig sein, eine Fehlermeldung auf der
          Kommandozeile zu lesen, wenn sie mit all diesen bedeutungslosen
          <literal>HTML</literal>-Tags vollgestopft ist, deswegen wird
          diese Direktive auf &false; gesetzt.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.implicit-flush">implicit_flush</link></entry>
         <entry>&true;</entry>
         <entry>
          Es ist erwünscht, dass alle Ausgaben, die von
          <function>print</function>, <function>echo</function> und Konsorten
          kommen, sofort auf die Ausgabe geschrieben werden und nicht in
          irgendeinem Puffer gecacht werden. Sie können immer noch
          <link linkend="ref.outcontrol">output buffering</link> benutzen,
          wenn Sie die Standardausgabe aufschieben oder manipulieren wollen.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.max-execution-time">max_execution_time</link></entry>
         <entry>0 (unlimited)</entry>
         <entry>
          Wegen der unendlichen Möglichkeiten, PHP in
          Kommandozeilenumgebungen zu benutzen wurde die maximale
          Ausführungszeit auf unbegrenzte Zeit eingestellt. Wohingegen
          Anwendungen, die für das Web geschrieben wurden, oft in sehr kurzer
          Zeit ausgeführt werden, neigen Anwendungen für die Kommandozeile
          dazu, eine viel längere Ausführungszeit zu beanspruchen.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.register-argc-argv">register_argc_argv</link></entry>
         <entry>&true;</entry>
         <entry>
         <para>
          Weil diese Einstellung auf &true; gesetzt ist, werden Sie immer
          Zugriff auf <emphasis>argc</emphasis> (Anzahl der Argumente, die
          der Anwendung übergeben wurden) und <emphasis>argv</emphasis>
          (Array der eigentlichen Argumente) im <literal>CLI SAPI</literal>
          haben.
         </para>
         <para>
          Seit PHP 4.3.0 werden die PHP-Variablen
          <varname>$argc</varname> und <varname>$argv</varname> registriert
          und mit den entsprechenden Werten gefüllt, wenn das
          <literal>CLI SAPI</literal> benutzt wird. Vor dieser Version
          verhielt sich die Erzeugung dieser Variablen so wie in den
          <literal>CGI</literal>- und <literal>MODULE</literal>-Versionen,
          die die PHP-Direktive
          <link linkend="ini.register-globals">register_globals</link> auf
          <emphasis>on</emphasis> verlangen. Ungeachtet der Version oder der
          Einstellung von
          <link linkend="ini.register-globals">register_globals</link>
          können Sie immer
          <link linkend="reserved.variables.server">$_SERVER</link> oder
          <varname>$HTTP_SERVER_VARS</varname> benutzen. Beispiel:
          <varname>$_SERVER['argv']</varname>
         </para>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <note>
     <para>
      Diese Direktiven können nicht mit einem anderen Wert aus der
      Konfigurationsdatei &php.ini; oder einer eigenen (falls angegeben)
      initialisiert werden. Das ist eine Einschränkung, weil diese
      Standardwerte angewandt werden, nachdem alle Konfigurationsdateien
      durchlaufen wurden. Dennoch können die Werte zur Laufzeit
      verändert werden (was aber für alle diese Direktiven keinen
      Sinn ergibt, beispielsweise
      <link linkend="ini.register-argc-argv">register_argc_argv</link>).
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     Um die Arbeit in der Kommandozeilenumgebung zu vereinfachen, wurden
     folgende Konstanten definiert:
     <table>
      <title>CLI-spezifische Konstanten</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Konstante</entry>
         <entry>Beschreibung</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><constant>STDIN</constant></entry>
         <entry>
         Ein schon geöffneter Stream auf <literal>stdin</literal>.
         Das erspart das Öffnen mit
         <programlisting role="php">
<![CDATA[
<?php

$stdin = fopen('php://stdin', 'r');

?>
]]>
         </programlisting>
         Wenn sie einzelne Zeilen von <literal>stdin</literal> lesen wollen, können Sie
         folgendes Code-Fragment benutzen:
         <programlisting role="php">
<![CDATA[
<?php
$line = trim(fgets(STDIN)); // liest eine Zeile von STDIN
fscanf(STDIN, "%d\n", $number); // liest eine Zahl von STDIN
?>
]]>
         </programlisting>
         </entry>
        </row>
        <row>
         <entry><constant>STDOUT</constant></entry>
         <entry>
         Ein schon geöffneter Stream auf <literal>stdout</literal>.
         Das erspart das Öffnen mit
         <programlisting role="php">
<![CDATA[
<?php

$stdout = fopen('php://stdout', 'w');

?>
]]>
         </programlisting>
         </entry>
        </row>
        <row>
         <entry><constant>STDERR</constant></entry>
         <entry>
         Ein schon geöffneter Stream auf <literal>stderr</literal>.
         Das erspart das Öffnen mit
         <programlisting role="php">
<![CDATA[
<?php

$stderr = fopen('php://stderr', 'w');

?>
]]>
         </programlisting>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     Angesichts des oben genannten brauchen Sie beispielsweise nicht
     selbst einen Stream für <literal>stderr</literal> öffnen, sondern
     einfach die Konstante statt der Ressource benutzen:
     <programlisting role="shell">
<![CDATA[
php -r 'fwrite(STDERR, "stderr\n");'
]]>
     </programlisting>
     Sie brauchen diese Ressourcen nicht explizit schließen, weil sie
     automatisch von PHP geschlossen werden, wenn
     ihr Skript endet.
    </para>
    <note>
     <para>
      Diese Konstanten sind nicht verfügbar wenn ein PHP Skript von
      <literal>stdin</literal> eingelesen wird.
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     Das <literal>CLI SAPI</literal> ändert das aktuelle Verzeichnis
     <emphasis role="strong">nicht</emphasis> auf das Verzeichnis des
     ausgeführten Skriptes!
    </para>
    <informalexample>
     <para>
      Ein Beispiel, das den Unterschied zum <literal>CGI SAPI</literal> zeigt:
     </para>
     <programlisting role="php">
<![CDATA[
<?php
// Unsere einfache Anwendung namens test.php
echo getcwd(), "\n";
?>
]]>
     </programlisting>
    <para>
     Bei der <literal>CGI</literal>-Version ist die Ausgabe folgende:
    </para>
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -q another_directory/test.php
/tmp/another_directory
]]>
     </screen>
    <para>
     Dies zeigt deutlich, dass PHP das aktuelle
     Verzeichnis auf das des ausgeführten Skriptes ändert.
    </para>
    <para>
     Benutzen der <literal>CLI SAPI</literal>-Version ergibt:
    </para>
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -f another_directory/test.php
/tmp
]]>
     </screen>
    <para>
     Dies erlaubt eine größere Anpassungsfähigkeit beim
     Schreiben von Kommandozeilenanwendungen in PHP.
    </para>
   </informalexample>
    <note>
     <para>
      Das <literal>CGI SAPI</literal> unterstützt das Verhalten des
      <literal>CLI SAPI</literal> anhand der Option <option>-C</option>,
      wenn es auf der Kommandozeile gestartet wird.
     </para>
    </note>
   </listitem>
  </itemizedlist>
 </para>
 <para>
  Die Liste der Kommandozeilenoptionen, die das PHP-Binary
  bereitstellt, können jederzeit abgerufen werden, wenn man
  PHP mit der Option <option>-h</option> startet:
 </para>
  <informalexample>
  <screen>
<![CDATA[
Usage: php [options] [-f] <file> [--] [args...]
       php [options] -r <code> [--] [args...]
       php [options] [-B <begin_code>] -R <code> [-E <end_code>] [--] [args...]
       php [options] [-B <begin_code>] -F <file> [-E <end_code>] [--] [args...]
       php [options] -- [args...]
       php [options] -a

  -a               Run interactively
  -c <path>|<file> Look for php.ini file in this directory
  -n               No php.ini file will be used
  -d foo[=bar]     Define INI entry foo with value 'bar'
  -e               Generate extended information for debugger/profiler
  -f <file>        Parse and execute <file>.
  -h               This help
  -i               PHP information
  -l               Syntax check only (lint)
  -m               Show compiled in modules
  -r <code>        Run PHP <code> without using script tags <?..?>
  -B <begin_code>  Run PHP <begin_code> before processing input lines
  -R <code>        Run PHP <code> for every input line
  -F <file>        Parse and execute <file> for every input line
  -E <end_code>    Run PHP <end_code> after processing all input lines
  -H               Hide any passed arguments from external tools.
  -s               Display colour syntax highlighted source.
  -v               Version number
  -w               Display source with stripped comments and whitespace.
  -z <file>        Load Zend extension <file>.

  args...          Arguments passed to script. Use -- args when first argument
                   starts with - or script is read from stdin

  --ini            Show configuration file names

  --rf <name>      Show information about function <name>.
  --rc <name>      Show information about class <name>.
  --re <name>      Show information about extension <name>.
  --ri <name>      Show configuration for extension <name>.
]]>
  </screen>
 </informalexample>
 <para>
  Beim <literal>CLI SAPI</literal> gibt es drei verschiedene
  Möglichkeiten, den zur Ausführung bestimmten
  PHP-Code zu übergeben:
  <orderedlist>
   <listitem>
    <para>
     PHP mitteilen, eine bestimmte Datei auszuführen.
    </para>
    <informalexample>
     <screen>
<![CDATA[
php my_script.php

php -f my_script.php
]]>
     </screen>
    </informalexample>
   <para>
     Beide Arten (ob sie die Option <option>-f</option> benutzen oder
     nicht) führen die Datei <filename>my_script.php</filename> aus.
     Sie können eine beliebige Datei ausführen - Ihr PHP-Skript
     muss nicht die Dateiendung <literal>.php</literal> haben, sie
     kann einen beliebigen Namen und eine beliebige Endung haben.
    </para>
	<note>
     <para>
      Wenn Sie Argumente an Ihr Skript übergeben wollen müssen Sie
      <literal>--</literal> als erstes Argument übergeben wenn Sie
      die <option>-f</option> Option benutzen.
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     Den PHP-Code, der ausgeführt werden soll,
     direkt auf der Kommandozeile übergeben.
    </para>
    <para>
     <screen>
<![CDATA[
php -r 'print_r(get_defined_constants());'
]]>
     </screen>
     Bezüglich Ersetzung von Kommandozeilenvariablen und Benutzung von
     Quotes muss besondere Vorsicht getroffen werden.
    </para>
    <note>
     <para>
      Betrachten Sie das Beispiel sorgfältig, es sind keine Start- oder
      Endtags gesetzt! Die Option <option>-r</option> benötigt sie nicht.
      Werden sie dennoch verwendet, kommt es zu einem Parser-Fehler.
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     Stellen Sie den PHP-Code, der ausgeführt werden soll,
     über den Standard-Input (<literal>stdin</literal>) bereit.
    </para>
    <para>
     Dies eröffnet die leistungsfähige Möglichkeit,
     PHP-Code dynamisch zu generieren und ihn dem
     PHP-Binary zu übergeben, wie in diesem
     möglichem Beispiel:
     <screen>
<![CDATA[
$ some_application | some_filter | php | sort -u >final_output.txt
]]>
     </screen>
    </para>
   </listitem>
  </orderedlist>
  Sie können diese drei Möglichkeiten zur Ausführung nicht kombinieren.
 </para>
 <para>
  Wie jede Kommandozeilenanwendung nimmt das PHP-Binary
  etliche Argumente entgegen, aber auch ein PHP-Skript
  kann Argumente entgegennehmen. Die Anzahl der Argumente, die an ein
  Skript übergeben werden können, ist nicht von PHP
  beschränkt (aber die Kommandozeilenumgebung hat ein bestimmtes Größenlimit
  für die Anzahl der Argumente, die übergeben werden können; normalerweise
  werden Sie dieses Limit nicht erreichen). Die Argumente, die dem Skript
  übergeben werden, sind in dem globalen Array <varname>$argv</varname>
  gespeichert. Der Null-Index enthält immer den Skriptnamen (das bedeutet
  <literal>-</literal>, wenn der PHP-Code entweder
  von der Standardeingabe oder von der Kommandozeilenoption
  <option>-r</option> kommt). Die zweite registrierte globale
  Variable ist <varname>$argc</varname>, die die Anzahl der Elemente
  im Array <varname>$argv</varname> enthält
  (<emphasis role="strong">nicht</emphasis> die Anzahl
  Argumente, die dem Skript übergeben wurden).
 </para>
 <para>
  Solange die Argumente, die Sie dem Skript übergeben möchten, nicht
  mit dem Zeichen <literal>-</literal> beginnen, gibt es nichts besonderes
  zu beachten. Ein Argument, das mit <literal>-</literal> beginnt zu
  übergeben, wird Probleme bereiten, weil PHP
  selbst denkt, dass sie verarbeitet werden muss. Benutzen Sie das
  Argument-Trennzeichen <literal>--</literal> um das zu vermeiden.
  Nachdem dieses Trennzeichen von PHP geparst
  wurde, wird jedes folgende Argument
  unangetastet an das Skript weitergereicht.
 </para>
 <informalexample>
  <screen>
<![CDATA[
# Dies führt nicht den angegebenen Code aus, sondern die Optionen von PHP anzeigen
$ php -r 'var_dump($argv);' -h
Usage: php [options] [-f] <file> [args...]
[...]

# Dies übergibt das Argument '-h' an Ihr Skript und zeigt die Optionen von PHP nicht an
$ php -r 'var_dump($argv);' -- -h
array(2) {
  [0]=>
  string(1) "-"
  [1]=>
  string(2) "-h"
}
]]>
  </screen>
 </informalexample>
 <para>
  Dennoch gibt es einen anderen Weg, um <literal>PHP</literal> für
  Kommandozeilenskripte zu benutzen. Sie können ein Skript erstellen,
  in dem die erste Zeile mit <literal>#!/usr/bin/php</literal> beginnt.
  Nachfolgend können Sie normalen PHP-Code innerhalb
  der PHP-Start- und -End-Tags setzen. Sobald Sie
  die Datei ausführbar gemacht haben (beispielsweise
  <command>chmod +x test</command>), kann Ihr Skript wie ein normales
  Kommandozeilen- oder Perl-Skript gestartet werden.
 </para>
 <example>
  <title>PHP als Shellskript ausführen</title>
  <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php
var_dump($argv);
?>
]]>
  </programlisting>
  <para>
  Angenommen, die Datei heißt <filename>test</filename> und befindet
  sich im aktuellen Verzeichnis, dann können wir nun folgendes tun:
  </para>
  <screen>
<![CDATA[
$ chmod 755 test
$ ./test -h -- foo
array(4) {
  [0]=>
  string(6) "./test"
  [1]=>
  string(2) "-h"
  [2]=>
  string(2) "--"
  [3]=>
  string(3) "foo"
}
]]>
  </screen>
 </example>
 <para>
  Wie Sie sehen können, müssen Sie sich in diesem Fall um nichts weiter
  kümmern, wenn Sie Ihrem Skript Paramater, die mit <literal>-</literal>
  beginnen, übergeben.
 </para>
 <para>
  Die Langformen der Optionen sind seit PHP 4.3.3 verfügbar.
  <table>
   <title>Kommandozeilenoption</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Option</entry>
      <entry>Langform</entry>
      <entry>Beschreibung</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>-a</entry>
      <entry>--interactive</entry>
      <entry>
       <para>
        Startet PHP im interaktiven Modus. Wenn Sie PHP mit der <link
         linkend="ref.readline">Readline</link>-Erweiterung (die unter
        Windows nicht verfügbar ist) kompilieren, bekommen Sie eine feine Shell, komplett mit
        einer Auto-Vervollständigung (das bedeutet, Sie können anfangen, einen
        Variablennamen zu tippen, die TAB-Taste drücken und PHP vervollständigt den Namen)
        und einem Verlauf der letzten Zeilen, auf den mit den Pfeiltasten zugegriffen
        werden kann. Der Verlauf wird in der Datei
        <filename>~/.php_history</filename> gespeichert.
       </para>
       <note>
        <para>
         Dateien, die mit <link
         linkend="ini.auto-prepend-file">auto_prepend_file</link> und <link
         linkend="ini.auto-append-file">auto_append_file</link> eingebunden wurden,
         werden in diesem Modus mit einigen Einschränkungen auch geparset - Funktionen
         müssen etwa vor dem Aufruf definiert werden.
        </para>
       </note>
       <note>
        <para>
         <link linkend="language.oop5.autoload">Automatisches Laden (autoload)</link>
         ist im interaktiven PHP CLI Modus nicht verfügbar.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-c</entry>
      <entry>--php-ini</entry>
      <entry>
       <para>
        Mit dieser Option kann man entweder ein Verzichnis angeben,
        wo nach &php.ini; gesucht werden soll, oder man kann eine
        eigene <literal>INI</literal>-Datei direkt angeben (diese
        muss nicht &php.ini; heissen). Zum Beispiel:
       </para>
       <informalexample>
        <screen>
<![CDATA[
$ php -c /custom/directory/ my_script.php

$ php -c /custom/directory/custom-file.ini my_script.php
]]>
        </screen>
       </informalexample>
       <para>
        Wenn Sie diese Option nicht angeben, wird die Datei an den
        <link linkend="configuration.file">vorgegebenen Orten</link> gesucht.
       </para>
      </entry>
     </row>
     <row>
      <entry>-n</entry>
      <entry>--no-php-ini</entry>
       <entry>
       <para>
        php.ini komplett ignorieren. Diese Option gibt es seit PHP 4.3.0.
       </para>
      </entry>
     </row>
     <row>
      <entry>-d</entry>
      <entry>--define</entry>
      <entry>
       <para>
        Diese Option erlaubt es Ihnen, einen eigenen Wert für eine beliebige
        in &php.ini; erlaubte Direktive zu setzen. Die Syntax ist:
        <screen>
<![CDATA[
-d configuration_directive[=value]
]]>
        </screen>
       </para>
       <informalexample>
       <para>
        Beispiele (die Zeilen sind aus layouttechnischen Gründen umgebrochen):
       </para>
        <screen>
<![CDATA[
# Auslassen des Wertes setzt die Direktive auf "1"
$ php -d max_execution_time
      -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(1) "1"

# Übergeben eines leeren Wertes setzt die Direktive auf ""
php -d max_execution_time=
    -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(0) ""

# Die Direktive wird auf das gesetzt, was nach '=' kommt
$  php -d max_execution_time=20
       -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(2) "20"
$  php -d max_execution_time=doesntmakesense
       -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(15) "doesntmakesense"
]]>
        </screen>
       </informalexample>
      </entry>
     </row>
     <row>
      <entry>-e</entry>
      <entry>--profile-info</entry>
      <entry>
       <para>
        Erweiterte Informationen für Debugger/Profiler erstellen.
        <!--
        mfischer, 20020510: Anyone who can provide more information what it
        really does (even if it's only for developers) ?
        -->
       </para>
      </entry>
     </row>
     <row>
      <entry>-f</entry>
      <entry>--file</entry>
      <entry>
       <para>
        Parst und führt die angegebene Datei aus. Diese Option ist nicht
        verbindlich und kann weggelassen werden. Alleinige Angabe des
        Dateinamens ist ausreichend.
       </para>
       <note>
        <para>
         Um Argumente an das Srkipt zu übergeben muss das erste Argument
         <literal>--</literal> sein, ansonsten interpretiert PHP diese
         als PHP Optionen.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-h und -?</entry>
      <entry>--help und --usage</entry>
      <entry>
       Mit dieser Option bekommen Sie Informationen über die tatsächlichen
       Kommandozeilenoptionen und kurze Beschreibungen dazu.
      </entry>
     </row>
     <row>
      <entry>-i</entry>
      <entry>--info</entry>
      <entry>
       Diese Kommandozeilenoption ruft <function>phpinfo</function>
       auf und gibt das Ergebnis aus. Wenn PHP
       nicht korrekt funktioniert, ist es ratsam, <command>php -i</command>
       zu benutzen und nachzusehen, ob etwa Fehlermeldungen vor oder
       statt der Informationstabellen ausgegeben werden. Beachten Sie,
       dass die Ausgabe bei Verwendung des CGI-Modus in <literal>HTML</literal> erfolgt
       und deswegen ziemlich umfangreich ist.
      </entry>
     </row>
     <row>
      <entry>-l</entry>
      <entry>--syntax-check</entry>
      <entry>
       <para>
        Diese Option stellt eine angenehme Methode bereit, nur eine
        Syntaxüberprüfung auf den angegebenen PHP-Code
        durchzuführen. Bei Erfolg wird der Text <literal>No syntax errors
        detected in &lt;filename&gt;</literal> auf die Standardausgabe
        geschrieben und der Rückgabewert ist <literal>0</literal>. Bei
        Misserfolg wird der Text <literal>Errors parsing
        &lt;filename&gt;</literal> zusätzlich zur internen
        Parser-Fehlermeldung auf der Standardausgabe
        ausgegeben und der Rückgabewert auf <literal>255</literal> gesetzt.
       </para>
       <para>
        Diese Option wird keine Fatalen Fehler (wie undefinierte Funktionen)
        finden. Benutzen Sie die Option <option>-f</option>, wenn sie
        auch diese überprüfen wollen.
       </para>
       <note>
        <para>
         Diese Option funktioniert nicht zusammen mit <option>-r</option>.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-m</entry>
      <entry>--modules</entry>
      <entry>
       <informalexample>
       <para>
        Wird diese Option benutzt, gibt PHP die eingebauten (und geladenen) PHP- und
        Zend-Module aus:
       </para>
        <screen>
<![CDATA[
$ php -m
[PHP Modules]
xml
tokenizer
standard
session
posix
pcre
overload
mysql
mbstring
ctype

[Zend Modules]
]]>
        </screen>
       </informalexample>
      </entry>
     </row>
     <row>
      <entry>-r</entry>
      <entry>--run</entry>
      <entry>
       <para>
        Diese Option erlaubt die Ausführung von PHP
        direkt aus der Kommandozeile. Die PHP-Start-
        und -End-Tags (<literal>&lt;?php</literal> und
        <literal>?&gt;</literal>) werden
        <emphasis role="strong">nicht benötigt</emphasis> und verursachen
        Parserfehler, wenn sie dennoch vorhanden sind.
       </para>
       <note>
        <para>
         Man muss bei Benutzung dieser Form von PHP
         aufpassen, dass es zu keinen Kollisionen mit
         Kommandozeilenvariablen kommt.
        </para>
        <informalexample>
        <para>
         Dieses Beispiel zeigt einen Parserfehler:
        </para>
         <screen>
<![CDATA[
$ php -r "$foo = get_defined_constants();"
Command line code(1) : Parse error - parse error, unexpected '='
]]>
         </screen>
        </informalexample>
        <para>
         Das Problem hier ist, dass die sh/bash Variablen auch ersetzt,
         wenn doppelte Anführungszeichen benutzt werden (<literal>"</literal>).
         Weil die Variable <varname>$foo</varname> wahrscheinlich nicht
         definiert ist, passiert nichts. Der tatsächliche Code, der an
         PHP übergeben wird, sieht so aus:
        </para>
        <informalexample>
         <screen>
<![CDATA[
$ php -r " = get_defined_constants();"
]]>
         </screen>
         <para>
         Der korrekte Weg wäre, einfache Anführungszeichen zu benutzen
         (<literal>'</literal>). Variablen in einfachen Anführungszeichen
         werden von sh/bash nicht ersetzt.
         </para>
         <screen>
<![CDATA[
$ php -r '$foo = get_defined_constants(); var_dump($foo);'
array(370) {
  ["E_ERROR"]=>
  int(1)
  ["E_WARNING"]=>
  int(2)
  ["E_PARSE"]=>
  int(4)
  ["E_NOTICE"]=>
  int(8)
  ["E_CORE_ERROR"]=>
  [...]
]]>
         </screen>
        </informalexample>
        <para>
         Wenn Sie eine andere Kommandozeilenumgebung als sh/bash benutzen,
         könnten Sie auf weitere Probleme stoßen. Sie können gerne einen
         Bugreport unter <link xlink:href="&url.php.bugs;">&url.php.bugs;</link> eintragen.

         Man kann dennoch leicht in Schwierigkeiten kommen, wenn man versucht,
         Kommandozeilenvariablen zu verwenden oder mit Backslashes zu escapen.
         Sie wurden gewarnt. <!-- :-) -->
        </para>
       </note>
       <note>
        <para>
         <literal>-r</literal> ist nur im <emphasis>CLI</emphasis>-SAPI
         verfügbar und nicht im <emphasis>CGI</emphasis>-SAPI
        </para>
       </note>
       <note>
        <para>
         Diese Option ist für sehr rudimentäre Sachen gedacht. Deswegen werden manche
         Direktiven (etwa <link
         linkend="ini.auto-prepend-file">auto_prepend_file</link> und <link
         linkend="ini.auto-append-file">auto_append_file</link>) in diesem Modus ignoriert.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-B</entry>
      <entry>--process-begin</entry>
      <entry>
       <para>
        PHP-Code der ausgeführt werden soll, bevor <literal>stdin</literal> ausgewertet wird. Verfügbar seit PHP 5.
       </para>
      </entry>
     </row>
     <row>
      <entry>-R</entry>
      <entry>--process-code</entry>
      <entry>
       <para>
        PHP-Code der für jede Eingabezeile ausgeführt werden soll. Verfügbar seit PHP 5.
       </para>
       <para>
        Es gibt zwei spezielle Variablen in diesem Modus:
        <varname>$argn</varname> und <varname>$argi</varname>.
        <varname>$argn</varname> enthält die Zeile, die PHP gerade verarbeitet und
        <varname>$argi</varname> enthält die Zeilennummer.
       </para>
      </entry>
     </row>
     <row>
      <entry>-F</entry>
      <entry>--process-file</entry>
      <entry>
       <para>
        PHP-Datei die für jede Eingabezeile ausgeführt werden soll. Verfügbar seit PHP 5.
       </para>
      </entry>
     </row>
     <row>
      <entry>-E</entry>
      <entry>--process-end</entry>
      <entry>
       <para>
        PHP-Code der nach der Verarbeitung der Eingabe ausgeführt werden soll.
        Verfügbar seit PHP 5.
       </para>
       <para>
        Ein Beispiel, wie man die Optionen <option>-B</option>, <option>-R</option> und
        <option>-E</option> benutzt, um die Anzahl der Zeilen in einem Projekt zu zählen.
       </para>
        <informalexample>
        <screen>
<![CDATA[
$ find my_proj | php -B '$l=0;' -R '$l += count(@file($argn));' -E 'echo "Total Lines: $l\n";'
Total Lines: 37328
]]>
        </screen>
       </informalexample>
      </entry>
     </row>
     <row>
      <entry>-s</entry>
      <entry>--syntax-highlight and --syntax-highlighting</entry>
      <entry>
       <para>
        Den Quelltext mit farbiger Syntaxhervorhebung anzeigen.
       </para>
       <para>
        Diese Option benutzt den internen Mechanismus zum Analysieren
        der Datei, generiert eine <literal>HTML</literal>-Version mit
        Syntax-Highlighting davon, und schreibt sie auf die
        Standardausgabe. Beachten Sie, dass sie nur einen Block von
        <literal>&lt;code&gt; [...] &lt;/code&gt;</literal>-HTML-Tags
        erzeugt, keine HTML-Header.
       </para>
       <note>
        <para>
         Diese Option funktioniert nicht zusammen mit <option>-r</option>.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-v</entry>
      <entry>--version</entry>
      <entry>
       <informalexample>
       <para>
        Schreibt die Version von PHP, PHP SAPI und
        Zend auf die Standardausgabe. Zum Beispiel:
       </para>
        <screen>
<![CDATA[
$ php -v
PHP 4.3.0 (cli), Copyright (c) 1997-2002 The PHP Group
Zend Engine v1.3.0, Copyright (c) 1998-2002 Zend Technologies
]]>
        </screen>
       </informalexample>
      </entry>
     </row>
     <row>
      <entry>-w</entry>
      <entry>--strip</entry>
      <entry>
       <para>
        Den Quelltext mit entfernten Kommentaren und Leerzeichen anzeigen.
       </para>
       <note>
        <para>
         Diese Option funktioniert nicht zusammen mit <option>-r</option>.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-z</entry>
      <entry>--zend-extension</entry>
      <entry>
       <para>
        Eine <literal>Zend</literal>-Erweiterung laden. Wenn nur ein Dateiname
        angegeben wird, versucht PHP, die Erweiterung aus
        dem momentanen Standard-Bibliotheken-Pfad auf Ihrem System zu laden
        (auf Linux-Systemen normalerweise in
        <filename>/etc/ld.so.conf</filename> angegeben). Wenn ein Dateiname mit
        absoluter Pfadinformation übergeben wird, wird der Bibliotheken-Pfad
        des Systems nicht benutzt. Ein relativer Dateiname mit
        Pfadinformationen wird PHP nur veranlassen,
        zu versuchen, die Erweiterung in einem Pfad relativ zum
        aktuellen Verzeichnis zu laden.
       </para>
      </entry>
     </row>
     <row>
      <entry></entry>
      <entry>--ini</entry>
      <entry>
       <para>
        Zeigt die Namen der Konfigurationsdateien und die durchsuchten
        Verzeichnisse. Verfügbar seit PHP 5.2.3.
        <example>
         <title><literal>--ini</literal> example</title>
         <programlisting role="shell">
<![CDATA[
$ php --ini
Configuration File (php.ini) Path: /usr/dev/php/5.2/lib
Loaded Configuration File:         /usr/dev/php/5.2/lib/php.ini
Scan for additional .ini files in: (none)
additional .ini files parsed:      (none)
]]>
         </programlisting>
         </example>
        </para>
       </entry>
      </row>
      <row>
      <entry>--rf</entry>
      <entry>--rfunction</entry>
      <entry>
       <para>
        Zeigt Informationen über die gegebene Funktion oder
        Klassenmethode (z.B. Anzahl und Name der Parameter).
        Verfügbar seit PHP 5.1.2.
      </para>
      <para>
       Diese Option ist nur verfügbar wenn PHP mit
       <link linkend="language.oop5.reflection">Reflection</link> Unterstützung
       kompiliert wurde.
      </para>
      <para>
       <example>
        <title>Einfache <literal>--rf</literal> Nutzung</title>
        <programlisting role="shell">
<![CDATA[
$ php --rf var_dump
Function [ <internal> public function var_dump ] {

  - Parameters [2] {
    Parameter #0 [ <required> $var ]
    Parameter #1 [ <optional> $... ]
  }
}
]]>
         </programlisting>
        </example>
       </para>
      </entry>
     </row>
     <row>
      <entry>--rc</entry>
      <entry>--rclass</entry>
      <entry>
       <para>
        Zeigt Inforationen über die gegebene Klasse (Liste der Konstanten,
        Eigenschaften und Methoden). Verfügbar seit PHP 5.1.2.
       </para>
      <para>
       Diese Option ist nur verfügbar wenn PHP mit
       <link linkend="language.oop5.reflection">Reflection</link> Unterstützung
       kompiliert wurde.
      </para>
        <para>
        <example>
         <title><literal>--rc</literal> example</title>
         <programlisting role="shell">
<![CDATA[
$ php --rc Directory
Class [ <internal:standard> class Directory ] {

  - Constants [0] {
  }

  - Static properties [0] {
  }

  - Static methods [0] {
  }

  - Properties [0] {
  }

  - Methods [3] {
    Method [ <internal> public method close ] {
    }

    Method [ <internal> public method rewind ] {
    }

    Method [ <internal> public method read ] {
    }
  }
}
]]>
         </programlisting>
        </example>
       </para>
      </entry>
     </row>
     <row>
      <entry>--re</entry>
      <entry>--rextension</entry>
      <entry>
       <para>
        Zeigt Informationen über die gegebene Extension (Liste der &php.ini;
        Optionen, definierte Funktionen, Konstanten und Klassen.
        Verfügbar seit PHP 5.1.2.
       </para>
      <para>
       Diese Option ist nur verfügbar wenn PHP mit
       <link linkend="language.oop5.reflection">Reflection</link> Unterstützung
       kompiliert wurde.
      </para>
        <para>
        <example>
         <title><literal>--re</literal> example</title>
         <programlisting role="shell">
<![CDATA[
$ php --re json
Extension [ <persistent> extension #19 json version 1.2.1 ] {

  - Functions {
    Function [ <internal> function json_encode ] {
    }
    Function [ <internal> function json_decode ] {
    }
  }
}
]]>
         </programlisting>
        </example>
       </para>
      </entry>
     </row>
     <row>
      <entry>--ri</entry>
      <entry>--rextinfo</entry>
      <entry>
       <para>
        Zeigt die Konfiguration der gegebenen Extension (entspricht der von
        <function>phpinfo</function> zurückgegebenen Information).
        Verfügbar seit PHP 5.2.2. Die Konfiguration des Sprachkerns können
        über den speziellen Extension Namen "main" ermittelt werden.
       </para>
       <para>
        <example>
         <title><literal>--ri</literal> example</title>
         <programlisting role="shell">
<![CDATA[
$ php --ri date

date

date/time support => enabled
"Olson" Timezone Database Version => 2007.5
Timezone Database => internal
Default timezone => Europe/Oslo

Directive => Local Value => Master Value
date.timezone => Europe/Oslo => Europe/Oslo
date.default_latitude => 59.22482 => 59.22482
date.default_longitude => 11.018084 => 11.018084
date.sunset_zenith => 90.583333 => 90.583333
date.sunrise_zenith => 90.583333 => 90.583333
]]>
         </programlisting>
        </example>
       </para>
      </entry>
     </row>
     <!--
     new, not in PHP 4.3.4, but are in php_cli.c 1.102 or cgi_main.c 1.243
     -b <address:port>|<port> bindpath Bind Path for external FASTCGI Server mode, only CGI, no Windows
     -B <begin_code>     process-begin Run PHP <begin_code> before processing input lines
     -R <code>           process-code  Run PHP <code> for every input line
     -F <file>           process-file  Parse and execute <file> for every input line
     -E <end_code>       process-end   Run PHP <end_code> after processing all input lines
     -H                  hide-args     Hide any passed arguments from external tools.
     -g                  global        Define global variables on command line
     -->
    </tbody>
   </tgroup>
  </table>
 </para>
 <para>
  Die ausführbare PHP-Version kann benutzt werden, um PHP-Skripte vollkommen
  unabhängig von einem Webserver auszuführen. Wenn Sie auf einem UNIX-System
  arbeiten, sollten Sie Ihrem Skript eine spezielle erste Zeile hinzufügen und
  es ausführbar machen, so dass das System erkennt, welches Programm das Skript
  ausführen soll. Auf einem Windows-System können Sie <filename>php.exe</filename>
  mit der Doppelklick-Option von <literal>.php</literal>-Dateien verknüpfen.
  Sie können auch eine Batchdatei erzeugen, um das Skript von PHP ausführen zu
  lassen. Die erste Zeile, die dem Skript hinzugefügt wird, damit es unter UNIX
  läuft, stört unter Windows nicht, so dass Sie auf diese Weise problemlos
  plattformübergreifende Programme schreiben können. Sie finden anschließend
  ein einfaches Beispiel, wie man ein Kommandozeilenprogramm in PHP schreibt.
 </para>
 <para>
  <example>
   <title>Ein Skript, das von der Kommandozeile aus ausgeführt werden soll (script.php)</title>
   <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php

if ($argc != 2 || in_array($argv[1], array('--help', '-help', '-h', '-?'))) {
?>

Das ist ein Kommandozeilenprogramm in PHP mit einer Option.

  benutzung:
  <?php echo $argv[0]; ?> <option>

  <option> kann ein Wort sein, das Sie gerne
  ausgeben möchten. Mit den Optionen --help,
  -help, -h oder -? bekommen Sie diese Hilfe.

<?php
} else {
    echo $argv[1];
}
?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  In dem oben beschriebenen Skript haben wir die erste Zeile dazu benutzt
  anzugeben, dass die Datei von PHP ausgeführt werden soll. Wir arbeiten hier
  mit einer CLI-version, deswegen werden keine HTTP-Header ausgegeben. Es gibt
  zwei Variablen, die Sie in Kommandozeilen-Applikationen mit PHP benutzen
  können: <varname>$argc</varname> und <varname>$argv</varname>. Die erste ist
  die Anzahl der Argumente plus Eins (dem Namen des laufenden Skripts). Die
  zweite ist ein Array, das die Argumente enthält, beginnend mit dem Skriptnamen
  als Nummer Null (<varname>$argv[0]</varname>).
 </para>
 <para>
  In dem oben genannten Programm haben wir überprüft, ob es weniger oder mehr
  als zwei Argumente gibt. Falls das Argument <option>--help</option>,
  <option>-help</option>, <option>-h</option> oder <option>-?</option>
  war, haben wir die Hilfe-Nachricht mit dem dynamisch übergebenen
  Skriptnamen ausgegeben. Wenn wir ein anderes Argument erhalten haben, haben
  wir es ausgegeben.
 </para>
 <para>
  Wenn Sie das oben genannte Skript unter UNIX laufen lassen wollen, müssen Sie
  es zuerst ausführbar machen, und es danach einfach als
  <command>script.php echothis</command> oder
  <command>script.php -h</command> aufrufen. Unter Windows können Sie zu diesem
  Zweck eine Batchdatei erstellen:
 </para>
 <para>
  <example>
   <title>Batchdatei zur Ausführung eines Kommandozeilen-Skripts in PHP (script.bat)</title>
   <programlisting role="shell">
<![CDATA[
@C:\php\php.exe script.php %1 %2 %3 %4
]]>
   </programlisting>
  </example>
 </para>
 <para>
  Angenommen, Sie haben das Programm <filename>script.php</filename> genannt
  und die CLI-<filename>php.exe</filename> hat den Pfad
  <filename>c:\php\php.exe</filename>, wird diese Batchdatei es mit den von
  Ihnen übergebnen Optionen ausführen:
  <command>script.bat echothis</command> oder
  <command>script.bat -h</command>.
 </para>
 <para>
  Sehen Sie sich auch die zusätzlichen Funktionen in der Dokumentation der
  <link linkend="ref.readline">Readline</link>-Extension an, um Ihre in PHP
  geschriebenen Kommandozeilenanwendungen zu verbessern.
 </para>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
