<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.14 $ -->
<!-- EN-Revision: 1.54 Maintainer: tom Status: ready -->
 <chapter id="features.file-upload">
  <title>Steuerung von Dateiuploads</title>

  <sect1 id="features.file-upload.post-method">
   <title>Dateiuploads mit POST</title>

   <simpara>
    PHP kann Dateiuploads mit jedem RFC-1867 konformen Browser
    (dazu gehören der Netscape Navigator 3 oder höher, Microsoft
    Internet Explorer 3 mit einem Patch von Microsoft oder höher
    ohne Patch) durchführen. Es können sowohl Text- als auch
    Binärdaten hochgeladen werden. Mit PHP´s Authentifizierungs-
    und Dateifunktionen besteht volle Kontrolle darüber, wer
    Dateien hochladen darf und was mit den Dateien geschehen soll,
    wenn der Upload beendet ist.
   </simpara>
   <note>
    <title>Diesbezügliche Konfigurationshinweise</title>
    <para>
     Siehe auch die Anweisungen
     <link linkend="ini.file-uploads">file_uploads</link>, 
     <link linkend="ini.upload-max-filesize">upload_max_filesize</link>,
     <link linkend="ini.upload-tmp-dir">upload_tmp_dir</link> und
     <link linkend="ini.post-max-size">post_max_size</link> in der &php.ini;
    </para>
   </note>
   <para>
    PHP unterstützt auch Dateiuploads nach der PUT-Methode, die
    beispielsweise vom Netscape Composer und den W3C Amaya
    Clients benutzt wird. Siehe dazu <link
    linkend="features.file-upload.put-method">PUT-Unterstützung</link>
    für nähere Informationen.
   </para>
   <para>
    Eine Maske für den Dateiupload kann erstellt werden, indem man
    ein Formular entwirft, das ungefähr so aussieht:
    <example>
     <title>Formular für den Dateiupload</title>
     <programlisting role="html">
<![CDATA[
<form enctype="multipart/form-data" action="_URL_" method="post">
<input type="hidden" name="MAX_FILE_SIZE" value="1000">
Send this file: <input name="userfile" type="file">
<input type="submit" value="Send File">
</form>
]]>
     </programlisting>
    </example>
    Die _URL_ sollte auf eine PHP-Datei verweisen. Das versteckte Feld
    MAX_FILE_SIZE muss dem Dateieingabefeld vorangestellt werden und den
    Wert der maximal akzeptierten Dateigröße in Bytes enthalten.
	<warning>
	 <para>
	  Die maximale Dateigröße MAX_FILE_SIZE ist für den Browser nur
	  ein Hinweis und es ist leicht, diese Grenze zu umgehen. Also
	  verlassen Sie sich nicht darauf, dass der Browser Ihrem Wunsch
	  auch nachkommt! Wie auch immer, die PHP-Einstellungen für die
	  maximale Dateigröße können nicht getäuscht werden.
	 </para>
	</warning>
   </para>

   <para>
    Die für hochgeladene Dateien definierten Variablen sind je nach
    PHP Version und Konfiguration verschieden. Die Autoglobale
    <link linkend="reserved.variables.files">$_FILES</link> existiert
    seit PHP 4.1.0 und das Array <varname>$HTTP_POST_FILES</varname>
    seit PHP 4.0.0. Diese Arrays enthalten alle Informationen über
    Ihre hochgeladenen Dateien. Die Verwendung von
    <varname>$_FILES</varname> wird bevorzugt. Ist die PHP Anweisung
    <link linkend="ini.register-globals">register_globals</link> auf
    <emphasis>on</emphasis>, stehen auch entsprechende Variablennamen
    zur Verfügung. Seit PHP <ulink url="&url.php.release4.2.0;">4.2.0</ulink>
    steht <link linkend="ini.register-globals">register_globals</link>
    standardmäßig  auf <emphasis>off</emphasis>.
   </para>
   <para>
    Im Folgenden sind die Inhalte von
    <link linkend="reserved.variables.files">$_FILES</link> aus unserem
    Beispielskript aufgelistet. Beachten Sie, dass dies auf der Annahme
    basiert, dass der Name des Dateiuploads wie in dem obigen
    Beispielskript <emphasis>userfile</emphasis> ist.
    <variablelist>
     <varlistentry>
      <term><varname>$_FILES['userfile']['name']</varname></term>
      <listitem>
       <para>
        Der ursprüngliche Dateiname auf der Client Maschine.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['type']</varname></term>
      <listitem>
       <para>
        Der Mime-Type der Datei, falls der Browser diese Information
        zur Verfügung gestellt hat. Ein Beispiel wäre
        <literal>"image/gif"</literal>.
        </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['size']</varname></term>
      <listitem>
       <para>
        Die Größe der hochgeladenen Datei in Bytes.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['tmp_name']</varname></term>
      <listitem>
       <para>
        Der temporäre Dateiname, unter dem die hochgeladene Datei auf
        dem Server gespeichert wurde.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$_FILES['userfile']['error']</varname></term>
      <listitem>
       <para>
        Der <link linkend="features.file-upload.errors">Fehlercode</link>
        im Zusammenhang mit dem hochladen der Datei.
        <emphasis>['error']</emphasis> wurde in PHP 4.2.0 eingeführt.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <note>
    <para>
     In den Versionen vor PHP 4.1.0 war dies
     <varname>$HTTP_POST_FILES</varname>, und ist keine 
     <link linkend="language.variables.superglobals">'Autoglobale'</link>
     Variable wie <varname>$_FILES</varname>. PHP 3 unterstützt
     <varname>$HTTP_POST_FILES</varname> nicht.
    </para>
   </note>
   <para>
    Ist <link linkend="ini.register-globals">register_globals</link>
    in der &php.ini; aktiviert, stehen zusätzliche Variablen zur Verfügung.
    Zum Beispiel entspricht <varname>$userfile_name</varname>
    <varname>$_FILES['userfile']['name']</varname>,
    <varname>$userfile_type</varname> entspricht
    <varname>$_FILES['userfile']['type']</varname>, etc. Beachten Sie,
    dass register_globals standardmäßig  deaktiviert ist, jedoch wird
    empfohlen, sich nicht darauf zu verlassen.
   </para>
   <para>
    Standardmäßig werden Dateien in dem vorgegebenen temporären
    Verzeichnis des Servers gespeichert, außer es wurde mittels
    <link linkend="ini.upload-tmp-dir">upload_tmp_dir</link> in
    der &php.ini; ein anderer Ort konfiguriert.
    Das Standardverzeichnis des Servers kann durch das Setzen der
    Umgebungsvariablen <envar>TMPDIR</envar> in der Umgebung, in der
    PHP ausgeführt wird, geändert werden. Das Setzen mittels der
    Funktion <function>putenv</function> innerhalb eines Skriptes
    ist nicht möglich. Mittels dieser Umgebungsvariable kann auch
    sichergestellt werden, dass auch andere Operationen an
    hochgeladenen Dateien arbeiten können.
    <example>
     <title>Dateiuploads prüfen</title>
     <para>
      Die folgenden Beispiele sind für PHP Versionen größer als PHP
      4.0.2. Funktionsbeschreibungen finden Sie für 
      <function>is_uploaded_file</function> und
      <function>move_uploaded_file</function>.
     </para>
     <programlisting role="php">
<![CDATA[
<?php 
// In PHP kleiner als 4.1.0 sollten Sie $HTTP_POST_FILES anstatt $_FILES verwenden.
if (is_uploaded_file($_FILES['userfile']['tmp_name'])) {
    copy($_FILES['userfile']['tmp_name'], "/place/to/put/uploaded/file");
} else {
    echo "Possible file upload attack. Filename: " . $_FILES['userfile']['name'];
}
/* ...oder... */
move_uploaded_file($_FILES['userfile']['tmp_name'], "/place/to/put/uploaded/file");
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Das die hochgeladene Datei empfangende Skript sollte die notwendige
    Logik zur Entscheidung enthalten, was mit der hochgeladenen Datei
    geschehen soll. Sie können zum Beispiel
    <varname>$_FILES['userfile']['size']</varname> benutzen,
    um zu kleine bzw. zu große Dateien wegzuwerfen. Sie können
    <varname>$_FILES['userfile']['type']</varname> nutzen, um Dateien
    eines unerwünschten Typs wegzuwerfen. Seit PHP 4.2.0 können Sie Ihre
    Logik auch mittels <varname>$_FILES['userfile']['error']</varname>
    anhand der <link linkend="features.file-upload.errors">Fehlercodes</link>
    planen. Egal welche Logik Sie verwenden, Sie sollten die Datei in dem
    temporären Verzeichnis entweder löschen, oder an einen anderen Ort
    verschieben.
   </simpara>
   <simpara>
    Wurde die Datei in dem temporären Verzeichnis nicht verschoben oder
    umbenannt, wird sie am Ende des Requests gelöscht.
   </simpara>
  </sect1>
 
  <sect1 id="features.file-upload.errors">
   <title>Fehlermeldungen erklärt</title>
   <simpara>
    Seit PHP 4.2.0 gibt PHP zusammen mit dem Datei-Array entsprechende
    Fehlermeldungen. Die Fehlermeldung befindet sich im Segment
    <emphasis>['error']</emphasis> des Datei-Arrays, welches während des
    Hochladens der Datei erstellt wird. In anderen Worten kann der Fehler
    in <varname>$_FILES['userfile']['error']</varname> gefunden werden.
   </simpara>
   <para>
    <variablelist>
     <varlistentry>
      <term><varname>UPLOAD_ERR_OK</varname></term>
      <listitem>
       <para>
        Wert: 0; Es liegt kein Fehler vor, die Datei wurde erfolgreich hochgeladen.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>UPLOAD_ERR_INI_SIZE</varname></term>
      <listitem>
       <para>
        Wert: 1; Die hochgeladene Datei überschreitet die in der Anweisung
        <link linkend="ini.upload-max-filesize">upload_max_filesize</link> 
        in &php.ini; festgelegte Größe.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>UPLOAD_ERR_FORM_SIZE</varname></term>
      <listitem>
       <para>
        Wert: 2; Die hochgeladene Datei überschreitet die in dem HTML Formular
        mittels der Anweisung <emphasis>MAX_FILE_SIZE</emphasis> angegebene
        maximale Dateigröße.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>UPLOAD_ERR_PARTIAL</varname></term>
      <listitem>
       <para>
        Wert: 3; Die Datei wurde nur teilweise hochgeladen.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>UPLOAD_ERR_NO_FILE</varname></term>
      <listitem>
       <para>
        Wert: 4; Es wurde keine Datei hochgeladen.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <note>
    <para>
     Dies wurden Konstanten in PHP 4.3.0.
    </para>
   </note>
  </sect1>

  <sect1 id="features.file-upload.common-pitfalls">
   <title>Häufige Probleme</title>
   <simpara>
    Der mit <literal>MAX_FILE_SIZE</literal> eingestellte Wert
    kann nicht größer sein als der des ini-Parameters <link
    linkend="ini.upload-max-filesize">upload_max_filesize</link>.
    Der Standardwert ist 2 Megabyte.
   </simpara>
   <simpara>
    Ist <literal>memory limit</literal> aktiviert, könnte eine Erhöhung
    von <link linkend="ini.memory-limit">memory_limit</link> nötig sein.
    Stellen Sie sicher, dass der Wert von <link
    linkend="ini.memory-limit">memory_limit</link> groß genug ist.
   </simpara>
<!-- FIXME: max_execution_time INI -->
   <simpara>
    Wenn <link linkend="ini.max-execution-time">max_execution_time</link>
    zu kurz konfiguriert ist, könnte das Skript den Wert überschritten
    haben. Stellen Sie sicher, dass der Wert von
    <literal>max_execution_time</literal> groß genug ist.
   </simpara>
   <simpara>
    Ist <link linkend="ini.post-max-size">post_max_size</link> zu klein
    konfiguriert, können große Dateien nicht hochgeladen werden. Stellen
    Sie sicher, dass der Wert von <literal>post_max_size</literal> groß
    genug ist.
   </simpara>
   <simpara>
    Nicht zu prüfen an welcher Datei Sie arbeiten kann bedeuten, dass
    Benutzer auf sensible Informationen in anderen Verzeichnissen Zugriff
    erhalten.
   </simpara>
   <simpara>
    Beachten Sie, dass CERN httpd in dem vom Client erhaltenen
    Content-Type Mime Header alles nach dem ersten Whitespace
    wegzuschneiden scheint. Solange dies der Fall ist, unterstützt
    CERN httpd keine Dateiuploads.
   </simpara>
   <simpara>
    Aufgrund der vielen möglichen Arten der Darstellung von Verzeichnissen
    können wir nicht garantieren, dass Dateien mit exotischen Namen (wie z.B.
    mit enthaltenen Leerzeichen) auch wirklich richtig verarbeitet werden.
   </simpara>
  </sect1>

  <sect1 id="features.file-upload.multiple">
   <title>Upload mehrerer Dateien</title>
   <simpara>
    Mehrere Dateien können hochgeladen werden, indem Sie verschiedene
    Namen <literal>name</literal> für <literal>input</literal> verwenden.
   </simpara>
   <simpara>
    Es ist ebenfalls möglich, mehrere Dateien simultan hochzuladen, und
    die Informationen automatisch in Arrays zu erhalten. Um dies zu tun,
    verwenden Sie in dem HTML Formular die gleiche Array-Sende-Syntax
    wie bei Auswahllisten mit Mehrfachauswahl und Checkboxen:
   </simpara>
   <note>
    <para>
     Die Unterstützung für den Upload von mehreren Dateien wurde in
     PHP 3.0.10 hinzugefügt.
    </para>
   </note>
   <para>
    <example>
     <title>Upload mehrerer Dateien</title>
     <programlisting role="html">
<![CDATA[
<form action="file-upload.php" method="post" enctype="multipart/form-data">
  Send these files:<br>
  <input name="userfile[]" type="file"><br>
  <input name="userfile[]" type="file"><br>
  <input type="submit" value="Send files">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Wenn das obige Formular übermittelt ist, werden die Arrays
    <varname>$_FILES['userfile']</varname>,
    <varname>$_FILES['userfile']['name']</varname> und
    <varname>$_FILES['userfile']['size']</varname>
    initialisiert (wie auch in $HTTP_POST_FILES vor PHP Version 4.1.0.).
    Ist <literal>register_globals</literal> aktiviert, werden auch
    globale Variablen für die hochgeladenen Dateien initialisiert.
    Jedes von ihnen ist ein numerisch indiziertes Array mit den
    entsprechenden Werten für die hochgeladenen Dateien.
   </simpara>
   <simpara>
    Nehmen wir zum Beispiel an, dass die Dateinamen
    <filename>/home/test/review.html</filename> und
    <filename>/home/test/xwp.out</filename> übermittelt wurden.
    In diesem Fall würde
    <varname>$_FILES['userfile']['name'][0]</varname>
    <filename>review.html</filename> enthalten, und
    <varname>$_FILES['userfile']['name'][1]</varname>
    hätte den Wert <filename>xwp.out</filename>. Genauso würde
    <varname>$_FILES['userfile']['size'][0]</varname> die
    Dateigröße von <filename>review.html</filename> enthalten, usw.
   </simpara>
   <simpara>
    <varname>$_FILES['userfile']['name'][0]</varname>,
    <varname>$_FILES['userfile']['tmp_name'][0]</varname>,
    <varname>$_FILES['userfile']['size'][0]</varname> und
    <varname>$_FILES['userfile']['type'][0]</varname> sind
    ebenfalls gesetzt.
   </simpara>
  </sect1>

  <sect1 id="features.file-upload.put-method">
   <title>PUT-Unterstützung</title>
   <simpara>
    Die Unterstützung der PUT-Methode hat sich zwischen PHP 3 und
    PHP 4 geändert. In PHP 4 sollten Sie den standard Input-Datenstrom
    benutzen, um die Inhalte eines HTTP PUT zu lesen.
   </simpara>
   <para>
    <example>
     <title>Speicher von HTTP PUT Dateien mit PHP 4</title>
     <programlisting role="php">
<![CDATA[
<?php
/* PUT Daten kommen in den stdin Stream */
$putdata = fopen("php://stdin","r");

/* Eine Datei zum Schreiben öffnen */
$fp = fopen("myputfile.ext","w");

/* Jeweils 1kB Daten lesen und
   in die Datei schreiben */
while ($data = fread($putdata,1024))
  fwrite($fp,$data);

/* Die Streams schließen */
fclose($fp);
fclose($putdata);
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Sämtliche untenstehende Dokumentation betrifft nur PHP 3.
    </para>
   </note>
   <para>
    PHP unterstützt die HTTP PUT-Methode, wie sie von Clients wie Netscape
    Composer oder W3C Amaya benutzt wird. PUT-Anfragen sind weitaus
    unkomplizierter als ein Dateiupload und sehen etwa so aus:
    <informalexample>
     <programlisting>
PUT /path/filename.html HTTP/1.1
     </programlisting>
    </informalexample>
   </para>
   <para>
    Das würde normalerweise bedeuten, dass der entfernte Client den
    folgenden Inhalt als /path/filename.html im Webverzeichnisbaum
    speichert. Natürlich ist es keine gute Idee, dass PHP oder
    Apache jeden Benutzer beliebige Dateien überschreiben lassen.
    Um eine solche Anfrage bearbeiten zu können, muss der Webserver
    erst angewiesen werden, ein bestimmtes PHP-Skript für die
    Abarbeitung aufzurufen. Im Apache wird dies durch die
    <emphasis>Script</emphasis> - Direktive festgelegt. Sie kann fast
    überall in der Apache-Konfigurationsdatei platziert werden,
    gebräuchlich ist die Platzierung innerhalb einer &lt;Directory&gt;- oder
    &lt;Virtualhost&gt;- Sektion. Eine Zeile wie die folgende erledigt dies:
    <informalexample>
     <programlisting>
Script PUT /put.php
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Diese Zeile legt fest, dass Apache alle PUT-Anfragen für URIs, die
    dem Kontext entsprechen, in dem diese Zeile steht, an das put.php
    Skript weiterleitet. Dies setzt natürlich voraus, dass PHP aktiv
    und für die .php-Dateierweiterung registriert ist.
   </simpara>
   <simpara>
    Innerhalb der put.php-Datei könnte folgendes stehen:
   </simpara>
   <para>
    <informalexample><programlisting role="php">
<![CDATA[
<?php copy($PHP_UPLOADED_FILE_NAME,$DOCUMENT_ROOT.$REQUEST_URI); ?>
]]>
    </programlisting></informalexample>
   </para>
   <simpara>
    Dies kopiert die Datei an den vom Client angegebenen Ort.
    Möglicherweise sollen vor dem Kopieren der Datei noch
    Überprüfungen und/oder Benutzerauthentifizierung stattfinden.
    Wenn PHP eine PUT-Anfrage erhält, wird die Datei genau wie bei der
    <link linkend="features.file-upload.post-method">POST-Methode</link>
    in einem temporären Verzeichnis gespeichert. Nach dem Abarbeiten
    der Anfrage wird die temporäre Datei gelöscht. Also muss das
    PHP-Skript, das die PUT-Anfrage bearbeitet, die Datei irgendwohin
    kopieren. Der Name der temporären Datei findet sich in der
    Variablen $PHP_PUT_FILENAME; der Name der zu speichernden
    Datei steht in $REQUEST_URI (kann bei Nicht-Apache Webservern
    variieren). Dieser Zieldateiname wird vom Client festgelegt. Man
    kann den Client auch umgehen; beispielsweise könnten alle
    hochgeladenen Dateien in ein spezielles Upload-Directory kopiert
    werden.
   </simpara>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
