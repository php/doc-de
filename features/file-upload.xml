<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.35 Maintainer: tom Status: ready -->
 <chapter id="features.file-upload">
  <title>Steuerung von Dateiuploads</title>

  <sect1 id="features.file-upload.post-method">
   <title>Dateiuploads mit POST</title>

   <simpara>
    PHP kann Dateiuploads mit jedem RFC-1867 konformen Browser
    (dazu gehören der Netscape Navigator 3 oder höher, Microsoft
    Internet Explorer 3 mit einem Patch von Microsoft oder höher
    ohne Patch) durchführen. Es können sowohl Text- als auch
    Binärdaten hochgeladen werden. Mit PHP´s Authentifizierungs-
    und Dateifunktionen besteht volle Kontrolle darüber, wer
    Dateien hochladen darf und was mit den Dateien geschehen soll,
    wenn der Upload beendet ist.
   </simpara>
   <para>
    PHP unterstützt auch Dateiuploads nach der PUT-Methode, die
    beispielsweise vom Netscape Composer und den W3C Amaya
    Clients benutzt wird. Siehe dazu <link
    linkend="features.file-upload.put-method">PUT-Unterstützung</link>
    für nähere Informationen.
   </para>
   <para>
    Eine Maske für den Dateiupload kann erstellt werden, indem man
    ein Formular entwirft, das ungefähr so aussieht:
    <example>
     <title>Formular für den Dateiupload</title>
     <programlisting role="html">
<![CDATA[
<form enctype="multipart/form-data" action="_URL_" method="post">
<input type="hidden" name="MAX_FILE_SIZE" value="1000">
Send this file: <input name="userfile" type="file">
<input type="submit" value="Send File">
</form>
]]>
     </programlisting>
    </example>
    Die _URL_ sollte auf eine PHP-Datei verweisen. Das versteckte Feld
    MAX_FILE_SIZE muss dem Dateieingabefeld vorangestellt werden und den
    Wert der maximal akzeptierten Dateigröße in Bytes enthalten.
	<warning>
	 <para>
	  Die maximale Dateigröße MAX_FILE_SIZE ist für den Browser nur
	  ein Hinweis und es ist leicht, diese Grenze zu umgehen. Also
	  verlassen Sie sich nicht darauf, dass der Browser Ihrem Wunsch
	  auch nachkommt! Wie auch immer, die PHP-Einstellungen für die
	  maximale Dateigröße können nicht getäuscht werden.
	 </para>
	</warning>
   </para>

   <para>
    Die für hochgeladene Dateien definierten Variablen sind je nach
    PHP Version und Konfiguration verschieden. Die folgenden Variablen
    werden nach einem erfolgreichen Upload innerhalb des empfangenden
    Skriptes definiert. Ist <link linkend="ini.track-vars">track_vars</link>
    aktiviert, ist das $HTTP_POST_FILES bzw. $_FILES Array initialisiert.
    Wenn <link linkend="ini.register-globals">register_globals</link>
    aktiviert ist, können die entsprechenden Variablen auch als globale
    Variablen initialisiert werden, auch wenn dies nicht mehr nicht mehr
    empfohlen wird.
   </para>
   <note>
    <para>
    <link linkend="ini.track-vars">track_vars</link> ist seit PHP
    4.0.3 immer aktiviert, und seit PHP 4.1.0 kann $_FILES statt
    <varname>$HTTP_POST_FILES</varname> verwendet werden.
    <varname>$_FILES</varname> ist immer global, weshalb Sie
    <literal>global</literal> für $_FILES innerhalb von Funktionen
    vermeiden sollten.
    </para>
   </note>
   <para>
    <varname>$HTTP_POST_FILES</varname>/<varname>$_FILES</varname>
    beinhalten die Dateiinformationen des Uploads.
   </para>

   <para>
    Im Folgenden sind die Inhalte von <varname>$HTTP_POST_FILES</varname>
    unter der Annahme, dass der Name des Dateiuploads wie in dem obigen
    Beispielskript 'userfile' ist, aufgelistet:
    <variablelist>
     <varlistentry>
      <term><varname>$HTTP_POST_FILES['userfile']['name']</varname></term>
      <listitem>
       <para>
        Der ursprüngliche Dateiname auf der Client Maschine.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$HTTP_POST_FILES['userfile']['type']</varname></term>
      <listitem>
       <para>
        Der Mime-Type der Datei, falls der Browser diese Information
        zur Verfügung gestellt hat. Ein Beispiel wäre
        <literal>"image/gif"</literal>.
        </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$HTTP_POST_FILES['userfile']['size']</varname></term>
      <listitem>
       <para>
        Die Größe der hochgeladenen Datei in Bytes.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>$HTTP_POST_FILES['userfile']['tmp_name']</varname></term>
      <listitem>
       <para>
        Der temporäre Dateiname, unter dem die hochgeladene Datei auf
        dem Server gespeichert wurde.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <note>
    <para>
     Seit PHP 4.1.0 wird auch die Kurzform <varname>$_FILES</varname>
     unterstützt. PHP 3 unterstützt <varname>$HTTP_POST_FILES</varname>
     nicht.
    </para>
   </note>

   <para>
    Wenn <link linkend="ini.register-globals">register_globals</link>
    in der <filename>php.ini</filename> aktiviert ist, stehen unter der
    Annahme, dass der Name des Dateiuploads wie in dem obigen Beispielskript
    'userfile' ist, zur Verfügung:

    <itemizedlist>
     <listitem>
      <simpara>
       <varname>$userfile</varname> - Der temporäre Name, unter dem die
       hochgeladene Datei auf dem Server gespeichert wurde.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <varname>$userfile_name</varname> - Der ursprüngliche Dateiname
       auf dem System des Absenders.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <varname>$userfile_size</varname> - Größe der hochgeladenen
       Datei in Bytes.
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <varname>$userfile_type</varname> - Der Mime-Type der Datei, falls
       der Browser diese Information zur Verfügung gestellt hat. Ein
       Beispiel wäre "image/gif".
      </simpara>
     </listitem>
    </itemizedlist>
    Beachten Sie, dass der Teil "<varname>$userfile</varname>" der
    obigen Variablen den Namen des Dateifeldes &lt;input name="userfile"
    type="file"&gt; im Uploadformular trägt. In dem obigen Beispiel
    haben wir es "userfile" genannt.
   </para>
   <note>
    <para>
     <literal>register_globals = On</literal> wird aus Sicherheits- und
     Performancegründen nicht empfohlen.
    </para>
   </note>
   <para>
    Standardmäßig werden Dateien in dem vorgegebenen temporären
    Verzeichnis des Servers gespeichert, außer es wurde mittels
    <link linkend="ini.upload-tmp-dir">upload_tmp_dir</link> in
    der <filename>php.ini</filename> ein anderer Ort konfiguriert.
    Das Standardverzeichnis des Servers kann durch das Setzen der
    Umgebungsvariablen <envar>TMPDIR</envar> in der Umgebung, in der
    PHP ausgeführt wird, geändert werden. Das Setzen mittels der
    Funktion <function>putenv</function> innerhalb eines Skriptes
    ist nicht möglich. Mittels dieser Umgebungsvariable kann auch
    sichergestellt werden, dass auch andere Operationen an
    hochgeladenen Dateien arbeiten können.
    <example>
     <title>Dateiuploads prüfen</title>
     <para>
      Die folgenden Beispiele sind für PHP Versionen größer als PHP
      4.0.2. Funktionsbeschreibungen finden Sie für 
      <function>is_uploaded_file</function> und
      <function>move_uploaded_file</function>.
     </para>
     <programlisting role="php">
<![CDATA[
<?php 
// In PHP 4.1.0 oder höher sollte $_FILES anstatt $HTTP_POST_FILES verwendet werden.
if (is_uploaded_file($HTTP_POST_FILES['userfile']['tmp_name'])) {
    copy($HTTP_POST_FILES['userfile']['tmp_name'], "/place/to/put/uploaded/file");
} else {
    echo "Possible file upload attack. Filename: " . $HTTP_POST_FILES['userfile']['name'];
}
/* ...oder... */
move_uploaded_file($HTTP_POST_FILES['userfile']['tmp_name'], "/place/to/put/uploaded/file");
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Das die hochgeladene Datei empfangene Skript jegliche, für den
    Zweck der hochgeladenen Datei nötige Logik enthalten. Sie können
    zum Beispiel <varname>$HTTP_POST_FILES['userfile']['size']</varname>
    benutzen, um zu kleine bzw. zu große Dateien wegzuwerfen. Sie können
    <varname>$HTTP_POST_FILES['userfile']['type']</varname> nutzen, um
    Dateien eines unerwünschten Typs wegzuwerfen. Egal welche Logik Sie
    verwenden, Sie sollten die Datei in dem temporären Verzeichnis
    entweder löschen, oder an einen anderen Ort verschieben.
   </simpara>
   <simpara>
    Wurde die Datei in dem temporären Verzeichnis nicht verschoben oder
    umbenannt, wird sie am Ende des Requests gelöscht.
   </simpara>
  </sect1>
 
  <sect1 id="features.file-upload.common-pitfalls">
   <title>Häufige Probleme</title>
   <simpara>
    Der mit <literal>MAX_FILE_SIZE</literal> eingestellte Wert
    kann nicht größer sein als der des ini-Parameters <link
    linkend="ini.upload-max-filesize">upload_max_filesize</link>.
    Der Standardwert ist 2 Megabyte.
   </simpara>
   <simpara>
    Ist <literal>memory limit</literal> aktiviert, könnte eine Erhöhung
    von <link linkend="ini.memory-limit">memory_limit</link> nötig sein.
    Stellen Sie sicher, dass der Wert von <link
    linkend="ini.memory-limit">memory_limit</link> groß genug ist.
   </simpara>
<!-- FIXME: max_execution_time INI -->
   <simpara>
    Wenn <link linkend="ini.max-execution-time">max_execution_time</link>
    zu kurz konfiguriert ist, könnte das Skript den Wert überschritten
    haben. Stellen Sie sicher, dass der Wert von
    <literal>max_execution_time</literal> groß genug ist.
   </simpara>
   <simpara>
    Ist <literal>post_max_size</literal> zu klein konfiguriert, können
    große Dateien nicht hochgeladen werden. Stellen Sie sicher, dass der
    Wert von <literal>post_max_size</literal> groß genug ist.
   </simpara>
   <simpara>
    Nicht zu prüfen an welcher Datei Sie arbeiten kann bedeuten, dass
    Benutzer auf sensible Informationen in anderen Verzeichnissen Zugriff
    erhalten.
   </simpara>
   <simpara>
    Beachten Sie, dass CERN httpd in dem vom Client erhaltenen
    Content-Type Mime Header alles nach dem ersten Whitespace
    wegzuschneiden scheint. Solange dies der Fall ist, unterstützt
    CERN httpd keine Dateiuploads.
   </simpara>
  </sect1>

  <sect1 id="features.file-upload.multiple">
   <title>Upload mehrerer Dateien</title>
   <simpara>
    Mehrere Dateien können hochgeladen werden, indem Sie verschiedene
    Namen <literal>name</literal> für <literal>input</literal> verwenden.
   </simpara>
   <simpara>
    Es ist ebenfalls möglich, mehrere Dateien simultan hochzuladen, und
    die Informationen automatisch in Arrays zu erhalten. Um dies zu tun,
    verwenden Sie in dem HTML Formular die gleiche Array-Sende-Syntax
    wie bei Auswahllisten mit Mehrfachauswahl und Checkboxen:
   </simpara>
   <note>
    <para>
     Die Unterstützung für den Upload von mehreren Dateien wurde in
     PHP 3.0.10 hinzugefügt.
    </para>
   </note>
   <para>
    <example>
     <title>Upload mehrerer Dateien</title>
     <programlisting role="html">
<![CDATA[
<form action="file-upload.php" method="post" enctype="multipart/form-data">
  Send these files:<br>
  <input name="userfile[]" type="file"><br>
  <input name="userfile[]" type="file"><br>
  <input type="submit" value="Send files">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Wenn das obige Formular übermittelt ist, werden die Arrays
    <varname>$HTTP_POST_FILES['userfile']</varname>,
    <varname>$HTTP_POST_FILES['userfile']['name']</varname> und
    <varname>$HTTP_POST_FILES['userfile']['size']</varname>
    initialisiert. (Wie auch in $_FILES seit PHP 4.1.0. In PHP 3
    $HTTP_POST_VARS. Ist <literal>register_globals</literal>
    aktiviert, werden auch globale Variablen für die hochgeladenen
    Dateien initialisiert). Jedes von ihnen ist ein numerisch
    indiziertes Array mit den entsprechenden Werten der
    hochgeladenen Dateien.
   </simpara>
   <simpara>
    Nehmen wir zum Beispiel an, das die Dateinamen
    <filename>/home/test/review.html</filename> und
    <filename>/home/test/xwp.out</filename> übermittelt wurden.
    In diesem Fall würde
    <varname>$HTTP_POST_FILES['userfile']['name'][0]</varname>
    <filename>review.html</filename> enthalten, und
    <varname>$HTTP_POST_FILES['userfile']['name'][1]</varname>
    hätte den Wert <filename>xwp.out</filename>. Genauso würde
    <varname>$HTTP_POST_FILES['userfile']['size'][0]</varname>
    die Dateigröße von <filename>review.html</filename> enthalten,
    usw.
   </simpara>
   <simpara>
    <varname>$HTTP_POST_FILES['userfile']['name'][0]</varname>,
    <varname>$HTTP_POST_FILES['userfile']['tmp_name'][0]</varname>,
    <varname>$HTTP_POST_FILES['userfile']['size'][0]</varname> und
    <varname>$HTTP_POST_FILES['userfile']['type'][0]</varname> sind
    ebenfalls gesetzt.
   </simpara>
  </sect1>

  <sect1 id="features.file-upload.put-method">
   <title>PUT-Unterstützung</title>

   <para>
    PHP unterstützt die HTTP PUT-Methode, wie sie von Clients wie Netscape
    Composer oder W3C Amaya benutzt wird. PUT-Anfragen sind weitaus
    unkomplizierter als ein Dateiupload und sehen etwa so aus:
    <informalexample>
     <programlisting>
PUT /path/filename.html HTTP/1.1
     </programlisting>
    </informalexample>
   </para>
   <para>
    Das würde normalerweise bedeuten, dass der entfernte Client den
    folgenden Inhalt als /path/filename.html im Webverzeichnisbaum
    speichert. Natürlich ist es keine gute Idee, dass PHP oder
    Apache jeden Benutzer beliebige Dateien überschreiben lassen.
    Um eine solche Anfrage bearbeiten zu können, muss der Webserver
    erst angewiesen werden, ein bestimmtes PHP-Skript für die
    Abarbeitung aufzurufen. Im Apache wird dies durch die
    <emphasis>Script</emphasis> - Direktive festgelegt. Sie kann fast
    überall in der Apache-Konfigurationsdatei platziert werden,
    gebräuchlich ist die Platzierung innerhalb einer &lt;Directory&gt;- oder
    &lt;Virtualhost&gt;- Sektion. Eine Zeile wie die folgende erledigt dies:
    <informalexample>
     <programlisting>
Script PUT /put.php
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Diese Zeile legt fest, dass Apache alle PUT-Anfragen für URIs, die
    dem Kontext entsprechen, in dem diese Zeile steht, an das put.php
    Skript weiterleitet. Dies setzt natürlich voraus, dass PHP aktiv
    und für die .php-Dateierweiterung registriert ist.
   </simpara>
   <simpara>
    Innerhalb der put.php-Datei könnte folgendes stehen:
   </simpara>
   <para>
    <informalexample><programlisting role="php">
<![CDATA[
<?php copy($PHP_UPLOADED_FILE_NAME,$DOCUMENT_ROOT.$REQUEST_URI); ?>
]]>
    </programlisting></informalexample>
   </para>
   <simpara>
    Dies kopiert die Datei an den vom Client angegebenen Ort.
    Möglicherweise sollen vor dem Kopieren der Datei noch
    Überprüfungen und/oder Benutzerauthentifizierung stattfinden.
    Wenn PHP eine PUT-Anfrage erhält, wird die Datei genau wie bei der
    <link linkend="features.file-upload.post-method">POST-Methode</link>
    in einem temporären Verzeichnis gespeichert. Nach dem Abarbeiten
    der Anfrage wird die temporäre Datei gelöscht. Also muss das
    PHP-Skript, das die PUT-Anfrage bearbeitet, die Datei irgendwohin
    kopieren. Der Name der temporären Datei findet sich in der
    Variablen $PHP_PUT_FILENAME; der Name der zu speichernden
    Datei steht in $REQUEST_URI (kann bei Nicht-Apache Webservern
    variieren). Dieser Zieldateiname wird vom Client festgelegt. Man
    kann den Client auch umgehen; beispielsweise könnten alle
    hochgeladenen Dateien in ein spezielles Upload-Directory kopiert
    werden.
   </simpara>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
