  <chapter id="features.http-auth">
  <title>HTTP-Authentifizierung mit PHP</title>

  <simpara>
   Die HTTP-Authentifizierung durch PHP ist nur verfügbar, wenn PHP als
   Apache-Modul läuft und funktioniert daher nicht mit der CGI-Version.
   In einem PHP-Skript für ein Apache-Modul kann man die Funktion
   <function>header</function> benutzen, um die Nachricht "Authentifizierung 
   notwendig" an den Client-Browser zu senden, damit dieser
   ein Fenster zur Eingabe von Benutzername/Passwort öffnet.
   Hat der Benutzer diese eingegeben, wird die URL des PHP-Scripts
   mit den Variablen $PHP_AUTH_USER, $PHP_AUTH_PW 
   und $PHP_AUTH_TYPE, die den jeweiligen Benutzernamen, das 
   Passwort und den Typ der Identifizierung enthalten, erneut aufgerufen.
   Momentan wird nur das Authentifizierungsmodell "basic" unterstützt. 
   Näheres hierzu bei der <function>Header</function> Funktion.</simpara>
   
  <para>
   Ein Auszug aus einem Skript, das die Clientauthentifizierung
   auf einer Seite erzwingt, würde so aussehen:
 
   <example>
    <title>HTTP-Authentifizierung</title>
    <programlisting role="php">
&lt;?php
  if(!isset($PHP_AUTH_USER)) {
    Header(&quot;WWW-Authenticate: Basic realm=\&quot;My Realm\&quot;&quot;);
    Header(&quot;HTTP/1.0 401 Unauthorized&quot;);
    echo &quot;Text to send if user hits Cancel button\n&quot;;
    exit;
  } else {
    echo &quot;Hello $PHP_AUTH_USER.&lt;P&gt;&quot;;
    echo &quot;You entered $PHP_AUTH_PW as your password.&lt;P&gt;&quot;;
  }
?>
    </programlisting>
   </example></para>

  <para>
   Anstatt $PHP_AUTH_USER und $PHP_AUTH_PW einfach nur 
   auszugeben, werden Sie den Bunutzernamen und das Passwort 
   auf Gültigkeit überprüfen wollen. Dies kann durch die Abfrage 
   einer Datenbank oder das Einlesen einer Textdatei geschehen.</para>

  <para>
   Vorsicht bei einigen Internet Explorer-Versionen - sie scheinen
   sehr wählerisch zu sein, was die Reihenfolge der Header angeht.
   Abhilfe schafft hier das Senden des <emphasis>WWW-Authenticate</emphasis>
   Headers vor dem <errorcode>HTTP/1.0 401</errorcode>.</para>

  <simpara>
   Um zu unterbinden, daß ein Skript das Passwort einer durch 
   einen traditionellen externen Mechanismus geschützten Seite
   ausliest, werden die PHP_AUTH Variablen nicht gesetzt, wenn 
   eine externe Authentifizierung für diese bestimmte Seite aktiviert
   ist. In diesem Fall kann die $REMOTE_USER Variable benutzt
   werden, um den Benutzer durch die externe Zugriffskontrolle
   zu identifizieren.</simpara>

  <simpara>
   Zu beachten ist, daß obenstehendes keinesfalls jemanden,
   der die Kontrolle über eine nichtgeschützte URL hat, davon
   abhalten kann, Passwörter von geschützten URLs auf dem
   gleichen Rechner auszulesen.</simpara>
  <simpara>
   Sowohl Netscape als auch der Internet Explorer löschen den
   lokalen Authentifizierungscache des Browserfensters, wenn der
   Server eine 401-Meldung zurückgibt. Dies kann benutzt werden, um
   einen Benutzer "auszuloggen" und eine erneute Eingabe des
   Benutzernamens/Passworts zu erzwingen. Einige nutzen dies,
   um Logins nach Ablauf einer bestimmten Zeitspanne auslaufen 
   zu lassen oder einen Logout-Button zur Verfügung zu stellen.</simpara>
  <simpara></simpara>
   <example>
     <title>HTTP-Authentifizierung, mit erneuter Anforderung von Name/Passwort</title>
     <programlisting role="php">
&lt;?php
  function  authenticate()  {
    Header( &quot;WWW-authenticate:  basic  realm='Test  Authentication  System'&quot;);
    Header( &quot;HTTP/1.0  401  Unauthorized&quot;);
    echo  &quot;You  must  enter  a  valid  login  ID  and  password  to  access  this  resource\n&quot;;
    exit;
  }

  if(!isset($PHP_AUTH_USER)  ||  ($SeenBefore ==  1  &&  !strcmp($OldAuth,  $PHP_AUTH_USER))  )  {
    authenticate();
  }  
  else  {
    echo  &quot;Welcome:  $PHP_AUTH_USER&lt;BR&gt;&quot;;
    echo  &quot;Old:  $OldAuth&quot;;
    echo  &quot;&lt;FORM  ACTION=\&quot;$PHP_SELF\&quot;  METHOD=POST&gt;\n&quot;;
    echo  &quot;&lt;INPUT  TYPE=HIDDEN  NAME=\&quot;SeenBefore\&quot;  VALUE=\&quot;1\&quot;&gt;\n&quot;;
    echo  &quot;&lt;INPUT  TYPE=HIDDEN  NAME=\&quot;OldAuth\&quot;  VALUE=\&quot;$PHP_AUTH_USER\&quot;&gt;\n&quot;;
    echo  &quot;&lt;INPUT  TYPE=Submit  VALUE=\&quot;Re  Authenticate\&quot;&gt;\n&quot;;
    echo  &quot;&lt;/FORM&gt;\n&quot;;

}
?>
   </programlisting>
  </example>
  <simpara>
   Dieses Verhalten wird vom Authentifizierungsstandard HTTP Basic 
   nicht gefordert, daher sollte man sich nie darauf verlassen. Tests
   mit Lynx haben gezeigt, daß Lynx die Authentifizierungsinformationen
   bei Erhalt einer 401-Meldung nicht löscht. Ein Klick auf den Zurück-
   Button und danach auf Vorwärts wird die angeforderte Adresse
   öffnen (und zwar so lange, bis die Identifizierung der Benutzer
   geändert wird).</simpara>
  <simpara>
   Weiterhin muss beachtet werden, daß dies unter dem Microsoft
   IIS mit der CGI-Version von PHP aufgrund einer
   Einschränkung des IIS nicht funktioniert.</simpara>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
