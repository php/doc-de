<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.10 $ -->
  <chapter id="features.http-auth">
  <title>HTTP-Authentifizierung mit PHP</title>

  <simpara>
   Die HTTP-Authentifizierung durch PHP ist nur verfügbar, wenn PHP als
   Apache-Modul läuft und funktioniert daher nicht mit der CGI-Version.
   In einem PHP-Skript für ein Apache-Modul kann man die Funktion
   <function>header</function> benutzen, um die Nachricht "Authentifizierung 
   notwendig" an den Client-Browser zu senden, damit dieser
   ein Fenster zur Eingabe von Benutzername/Passwort öffnet.
   Hat der Benutzer diese eingegeben, wird die URL des PHP-Scripts
   mit den Variablen $PHP_AUTH_USER, $PHP_AUTH_PW 
   und $PHP_AUTH_TYPE, die den jeweiligen Benutzernamen, das 
   Passwort und den Typ der Identifizierung enthalten, erneut aufgerufen.
   Momentan wird nur das Authentifizierungsmodell "basic" unterstützt. 
   Näheres hierzu bei der <function>header</function> Funktion.</simpara>
   
  <para>
   Ein Auszug aus einem Skript, das die Clientauthentifizierung
   auf einer Seite erzwingt, würde so aussehen:
 
   <example>
    <title>HTTP-Authentifizierung</title>
    <programlisting role="php">
&lt;?php
  if(!isset($PHP_AUTH_USER)) {
    Header(&quot;WWW-Authenticate: Basic realm=\&quot;My Realm\&quot;&quot;);
    Header(&quot;HTTP/1.0 401 Unauthorized&quot;);
    echo &quot;Text to send if user hits Cancel button\n&quot;;
    exit;
  } else {
    echo &quot;Hello $PHP_AUTH_USER.&lt;P&gt;&quot;;
    echo &quot;You entered $PHP_AUTH_PW as your password.&lt;P&gt;&quot;;
  }
?&gt;
    </programlisting>
   </example></para>

  <note>
   <title>Hinweis</title>
   <para>
    Achten Sie bei den Header-Zeilen für maximale Kompatibilität auf die
    richtige Schreibweise! Das Schlüsselwort "Basic" sollte genau so geschrieben
    werden, der Realm-String muss in doppelte (nicht einfache) Anführungszeichen
    eingeschlossen sein, und in der "HTTP/1.0 401"-Zeile
    darf nur genau ein Leerzeichen vor dem 401-Code stehen.
   </para>
  </note>

  <para>
   Anstatt $PHP_AUTH_USER und $PHP_AUTH_PW einfach nur 
   auszugeben, werden Sie den Benutzernamen und das Passwort 
   auf Gültigkeit überprüfen wollen. Dies kann durch die Abfrage 
   einer Datenbank oder das Einlesen einer Textdatei geschehen.</para>

  <para>
   Vorsicht bei einigen Internet Explorer-Versionen - sie scheinen
   sehr wählerisch zu sein, was die Reihenfolge der Header angeht.
   Abhilfe schafft hier das Senden des <emphasis>WWW-Authenticate</emphasis>
   Headers vor dem <errorcode>HTTP/1.0 401</errorcode>.</para>

  <simpara>
   Um zu unterbinden, dass ein Skript das Passwort einer durch 
   einen traditionellen externen Mechanismus geschützten Seite
   ausliest, werden die PHP_AUTH Variablen nicht gesetzt, wenn 
   eine externe Authentifizierung für diese bestimmte Seite aktiviert
   ist. In diesem Fall kann die $REMOTE_USER Variable benutzt
   werden, um den Benutzer durch die externe Zugriffskontrolle
   zu identifizieren.</simpara>

  <note>
   <title>Konfigurationshinweis</title>
   <para>
    PHP prüft das Vorhandensein einer <literal>AuthType</literal>
    Apache-Direktive, um zu entscheiden, ob eine externe
    Authentifizierung aktiv ist. Vermeiden Sie deshalb diese
    Konfigurationsdirektive im Kontext der PHP-Authentifizierung
    (anderenfalls wird jeder Authentifizierungsversuch misslingen).
   </para>
  </note>

  <simpara>
   Zu beachten ist, dass obenstehendes keinesfalls jemanden,
   der die Kontrolle über eine nichtgeschützte URL hat, davon
   abhalten kann, Passwörter von geschützten URLs auf dem
   gleichen Rechner auszulesen.</simpara>
  <simpara>
   Sowohl Netscape als auch der Internet Explorer löschen den
   lokalen Authentifizierungscache des Browserfensters, wenn der
   Server eine 401-Meldung zurückgibt. Dies kann benutzt werden, um
   einen Benutzer "auszuloggen" und eine erneute Eingabe des
   Benutzernamens/Passworts zu erzwingen. Manchmal wird dieses Verhalten
   für das automatische Ausloggen nach Ablauf einer bestimmten Zeitspanne
   oder für einen Logout-Button genutzt.</simpara>
  <simpara></simpara>
   <example>
     <title>HTTP-Authentifizierung, mit erneuter Anforderung von Name/Passwort</title>
     <programlisting role="php">
&lt;?php
  function authenticate() {
   Header( &quot;WWW-Authenticate: Basic realm=\&quot;Test Authentication System\&quot;&quot;);
   Header( &quot;HTTP/1.0 401 Unauthorized&quot;);
   echo &quot;You must enter a valid login ID and password to access this resource\n&quot;;
   exit;
  }

  if(!isset($PHP_AUTH_USER) || ($SeenBefore == 1 &amp;&amp; !strcmp($OldAuth, $PHP_AUTH_USER)) ) {
   authenticate();
  } 
  else {
   echo &quot;Welcome: $PHP_AUTH_USER&lt;BR&gt;&quot;;
   echo &quot;Old: $OldAuth&quot;;
   echo &quot;&lt;FORM ACTION=\&quot;$PHP_SELF\&quot; METHOD=POST&gt;\n&quot;;
   echo &quot;&lt;INPUT TYPE=HIDDEN NAME=\&quot;SeenBefore\&quot; VALUE=\&quot;1\&quot;&gt;\n&quot;;
   echo &quot;&lt;INPUT TYPE=HIDDEN NAME=\&quot;OldAuth\&quot; VALUE=\&quot;$PHP_AUTH_USER\&quot;&gt;\n&quot;;
   echo &quot;&lt;INPUT TYPE=Submit VALUE=\&quot;Re Authenticate\&quot;&gt;\n&quot;;
   echo &quot;&lt;/FORM&gt;\n&quot;;
  }
?&gt;
   </programlisting>
  </example>
  <simpara>
   Dieses Verhalten wird vom Authentifizierungsstandard HTTP Basic 
   nicht gefordert, daher sollte man sich nie darauf verlassen. Tests
   mit Lynx haben gezeigt, dass Lynx die Authentifizierungsinformationen
   bei Erhalt einer 401-Meldung nicht löscht. Ein Klick auf den Zurück-
   Button und danach auf Vorwärts wird die angeforderte Adresse
   öffnen (und zwar so lange, bis die Identifizierung der Benutzer
   geändert wird).</simpara>
  <simpara>
   Weiterhin muss beachtet werden, dass dies unter dem Microsoft
   IIS mit der CGI-Version von PHP aufgrund einer
   Einschränkung des IIS nicht funktioniert.</simpara>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
