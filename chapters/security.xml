<chapter id="security">
  <title>Sicherheit</title>

  <simpara>
   PHP ist eine mächtige Sprache, und der Interpreter, der in einen
   Webserver als Modul oder als separate <acronym>CGI</acronym>-Version
   eingebunden werden kann, kann auf Dateien zugreifen, Befehle
   ausführen und Netzwerkverbindungen zu einem Server herstellen.
   Diese Eigenschaften können einen Webserver unsicher machen, wenn man
   es bei den Voreinstellungen belässt.
   PHP wurde besonders dafür entwickelt, um eine sicherere Sprache als
   Perl oder C für die Erstellung von CGI-Programmen bereitzustellen.
   Mit der richtigen Wahl der Einstellungen beim Kompilieren und
   zur Laufzeit bietet PHP genau die Kombination aus Freiheit und
   Sicherheit, die gerade benötigt wird.
  </simpara>
  <simpara>
   Da es sehr viele verschiedene Möglichkeiten gibt, PHP zu nutzen,
   gibt es viele Konfigurationseinstellungen, die das Verhalten von
   PHP beeinflussen. Eine große Auswahl an Einstellungen garantiert,
   daß man PHP für vielerlei Zwecke einsetzen kann, allerdings
   bedeutet es auch, dass es Kombinationen gibt, die zur Folge haben,
   daß die Installation nicht genug Sicherheit bietet.
   Dieses Kapitel beschreibt die verschiedenen Kombinationen der 
   Konfigurationseinstellungen und unter welchen Gegebenheiten sie sicher
   genutzt werden können.
  </simpara>

  <sect1 id="security.cgi">
   <title>CGI-Version</title>

   <sect2>
    <title>Mögliche Angriffe</title>

    <simpara>
     PHP als <acronym>CGI</acronym> zu nutzen, ist eine Möglichkeit
     für Installationen, bei denen aus irgendwelchen Gründen kein Modul in
     die Serversoftware eingebunden werden soll (wie beim Apache) oder für
     Systeme, bei denen verschiedene CGI-Wrapper genutzt werden sollen,
     um sichere chroot- und setuid-Umgebungen für Scripts zu schaffen.
     Bei dieser Konfiguration wird das ausführbare PHP-Binary üblicherweise
     im cgi-bin Verzeichnis des Webservers installiert.
     
     CERT advisory <ulink url="&url.cert;">CA-96.11</ulink>
     spricht sich gegen die Plazierung von Interpretern im cgi-bin
     Verzeichnis aus. Obwohl das PHP-Binary als standalone
     Interpreter verwendet werden kann, wurde PHP entwickelt, um Angriffe,
     die durch diese Konfiguration möglich werden, abzuwehren:</simpara>

     <itemizedlist>
      <listitem><simpara>Sytemdatenzugriff:
        <filename role="url">http://my.host/cgi-bin/php?/etc/passwd</filename></simpara>

       <simpara>
        Die Abfrageinformation in einer URL, die auf ein Fragezeichen (?)
        folgt, wird durch das CGI-Interface als Kommandozeilenargument
        an den Interpreter weitergereicht. Üblicherweise wird von
        Interpretern die Datei geöffnet und ausgeführt, die als erstes
        Argument in der Kommandozeile steht.</simpara>
       <simpara>
        Beim Aufruf als CGI-Binary verweigert PHP die Interpretierung
        der Kommandozeilenargumente.
       </simpara></listitem>
      <listitem><simpara>Zugriff auf beliebige Web-Dokumente auf dem Server:
	<filename role="url">http://my.host/cgi-bin/php/secret/doc.html</filename></simpara>

       <simpara>
        Die Pfadinformation, Teil der URL nach dem PHP-Binarynamen,
        <filename role="uri">/secret/doc.html</filename> wurde
        ursprünglich benutzt, um den Namen der Datei zu übergeben,
        die durch das <acronym>CGI</acronym>-Programm geöffnet und
        interpretiert werden soll.
        Normalerweise werden einige Einträge in der Konfigurationsdatei
        des Webservers benutzt (Apache: Action), um Aufrufe von Dokumenten
        wie <filename role="url">http://my.host/secret/script.php3</filename>
        an den PHP-Interpreter umzuleiten. Bei dieser Konfiguration
        überprüft der Webserver zuerst die Zugriffsrechte im Verzeichnis
        <filename role="uri">/secret</filename> und erstellt anschließend
        den umgeleiteten Aufruf
        <filename role="url">http://my.host/cgi-bin/php/secret/script.php</filename>.
	Unglücklicherweise wird, wenn der Aufruf bereits in dieser Form
        geschieht, vom Webserver keine Zugriffsüberprüfung der Datei
	<filename role="uri">/secret/script.php</filename>, sondern
        lediglich der Datei <filename role="uri">/cgi-bin/php</filename>
        vorgenommen. So ist
        jeder Benutzer, der auf <filename role="uri">/cgi-bin/php</filename> 
        zugreifen darf, in der Lage, sich zu jedem geschützten Dokument
        auf dem Webserver Zugriff zu verschaffen.</simpara>

       <simpara>
        Bei PHP können beim compilieren die Konfigurationsoption
	<link linkend="enable-force-cgi-redirect">--enable-force-cgi-redirect</link> und zur Laufzeit die Direktiven
        <link linkend="ini.doc-root">doc_root</link> und <link linkend="ini.user-dir">user_dir</link>
        benutzt werden, um diesen Angriff zu verhindern, falls
        der Verzeichnisbaum des Servers Verzeichnisse mit 
        Zugriffsbeschränkungen beinhaltet. 
        Ausführliche Informationen über die verschiedenen Kombinationen
        siehe weiter unten.

       </simpara></listitem>
     </itemizedlist></sect2>

    <sect2 id="security.cgi.default">
     <title>Fall 1: Nur öffentliche Dateien vorhanden</title>
     <simpara>
      Wenn der Server keine Inhalte hat, die durch Passwort oder
      IP-basierte Zugriffskontrolle geschützt sind, gibt es für diese
      Konfiguration keinen Grund.
      Wenn der Webserver keine Redirects erlaubt oder keine Möglichkeit
      hat, auf einer sicher umgeleiteten Anfrage mit dem PHP-Binary
      Verbindung aufzunehmen, kann die Option <link linkend="enable-force-cgi-redirect">--disable-force-cgi-redirect</link>
      im configure-Script angegeben werden. Nichtsdestotrotz müssen
      Sie sicherstellenn, daß Ihre PHP-Scripte nicht auf die eine oder
      anderen Art des Aufrufs angewiesen sind, weder direkt durch
      <filename role="php">http://my.host/cgi-bin/php/dir/script.php</filename>
      noch durch einen Redirect <filename role="php">http://my.host/dir/script.php</filename>.</simpara>

     <simpara>
      Beim Apache kann der Redirect durch den Gebrauch von      
      AddHandler und Action konfiguriert werden (siehe unten).</simpara></sect2>
      
    <sect2 id="security.cgi.force-redirect">
     <title>Fall 2: --enable-force-cgi-redirect benutzen</title>
     <simpara>
      Diese Option, die beim Kompilieren verwendet wird, verhindert
      grundsätzlich den Aufruf von PHP mit einer URL wie beispielsweise
      <filename role="php">http://my.host/cgi-bin/php/secretdir/script.php3</filename>.
      Stattdessen parst PHP in diesem Modus nur dann, wenn der Aufruf
      durch einen korrekten Redirect des Webservers erfolgte.</simpara>
     <simpara>
      Normalerweise wird der Redirect in der Apache-Konfiguration mit den
      folgenden Einträgen festgelegt:</simpara>
     <programlisting role="apache-conf">
Action php-script /cgi-bin/php
AddHandler php-script .php
</programlisting>

     <simpara>
      Diese Option wurde nur mit dem Apache Webserver getestet und
      ist abhängig davon, wie Apache die nicht standardmäßige 
      CGI-Umgebungsvariable <envar>REDIRECT_STATUS</envar> bei
      Redirect-Anfragen setzt.
      Sollte Ihr Webserver keine Möglichkeit unterstützen, zu übermitteln,
      ob es sich um einen direkte Aufruf oder einen Redirect handelt,
      können Sie diese Option nicht verwenden und müssen einen der
      anderen hier beschriebenen Wege gehen, die CGI-Version zu
      nutzen.</simpara></sect2>
      
    <sect2 id="security.cgi.doc-root">
     <title>Fall 3: doc_root oder user_dir festlegen</title>
     <simpara>
      Aktiven Inhalt, wie beispielsweise Skripts und ausführbare
      Dateien, in den Dokumentverzeichnissen des Webservers abzulegen,
      wird manchmal als unsichere Methode angesehen.
      Wenn, beispielsweise aufgrund von Konfigurationsfehlern, die 
      Skripte nicht ausgeführt, sodern als reguläres HTML-Dokument
      angezeigt werden kann dies den Verlust von geistigem Eigentum
      und Sicherheit (Passwörter!) zur Folge haben.
      Von daher ziehen es viele Sysadmins vor, eine zweite 
      Verzeichnisstruktur für Skripte, auf die nur durch das PHP-CGI
      zugegriffen werden soll, einzurichten. Diese werden dann stets 
      interpretiert und nicht angezeigt.</simpara>
      
     <simpara>
      Auch wenn die Methode, sicherzustellen, dass die Anfragen nicht
      umgeleitet werden (wie im vorangegangenen Kapitel beschrieben), nicht
      verfügbar ist, ist es notwendig, ein doc_root für Scripts 
      zusätzlich zum Dokumentenverzeichnis einzurichten.</simpara>
      
     <simpara>
      Sie können das PHP-Skriptverzeichnis durch die Direktive
      <link linkend="ini.doc-root">doc_root</link> in der <link linkend="configuration.file">Konfigurationsdatei</link> ändern, oder Sie setzen
      die Umgebungsvariable <envar>PHP_DOCUMENT_ROOT</envar>.
      Wenn sie gesetzt ist, wird die CGI-Version von PHP den Namen der
      zu öffnenden Datei stets aus <parameter>doc_root</parameter> und der
      Pfadinformation der Anfrage zusammensetzen, so daß man sicher
      sein kann, daß ausserhalb dieses Verzeichnisses keine Skripte
      ausgeführt werden (außer <parameter>user_dir</parameter>,
      siehe unten).</simpara>
      
     <simpara>
      Eine weitere hier nützliche Option ist <link linkend="ini.user-dir">user_dir</link>. 
      Wenn das <parameter>user_dir</parameter> nicht gesetzt ist, hat nur <parameter>doc_root</parameter>  
      Einfluß auf die zu öffnende Datei.
      Der Aufruf einer URL wie <filename role="url">http://my.host/~user/doc.php3</filename> hat nicht zum Ergebnis, daß
      eine Datei im Home-Verzeichnis des Benutzers geöffnet wird,
      sondern eine Datei namens <filename role="uri">~user/doc.php</filename> unterhalb des
      doc_root (Ja, ein Verzeichnisname, der mit einer Tilde anfängt
      [<literal>~</literal>]).</simpara>
      
     <simpara>
      Ist das user_dir beispielsweise auf <filename role="dir">public_php</filename> gesetzt,
      wird eine Anfrage wie <filename role="url">http://my.host/~user/doc.php</filename>
      eine Datei namens <filename>doc.php</filename> im Verzeichnis
      <filename role="dir">public_php</filename> im Heimatverzeichnis
      des Benutzers öffnen.  Wenn das Heimatverzeichnis des Benutzers
      <filename role="dir">/home/user</filename> ist, so ist die
      ausgeführte Datei
      <filename>/home/user/public_php/doc.php</filename>.</simpara>
      
     <simpara>
      Die <parameter>user_dir</parameter>-Expansion erfolgt ohne Berücksichtigung
      auf die <parameter>doc_root</parameter> Einstellung. So können
      Zugriffe auf die Dokumenten- und Benutzerverzeichnisse separat
      gesteuert werden.</simpara></sect2>
      
    <sect2 id="security.cgi.shell">
     <title>Fall 4: PHP-Parser außerhalb des Webverzeichnisbaums</title>
     <para>
      Eine sehr sichere Sache ist es, das PHP-Parser-Binary irgendwo
      außerhalb des Webverzeichnisbaums zu plazieren, beispielsweise
      in <filename role="dir">/usr/local/bin</filename>.  Der einzige
      Nachteil dieses Verfahrens ist, dass eine Zeile ähnlich der folgenden:
      
      <informalexample>
       <programlisting>
#!/usr/local/bin/php
       </programlisting>
      </informalexample>
	
      als erste Zeile in jeder Datei, die PHP-Tags enthält, stehen muss.
      Ausserdem muss die Datei ausführbar sein. Ansonsten ist sie genauso
      zu behandeln wie ein beliebiges CGI-Script in Perl oder sh oder
      anderen gebräuchlichen Scriptsprachen, die den
      <literal>#!</literal> shell-escape-Mechanismus nutzen, um sich
      selbst aufzurufen.</para>
     <para>
      Damit PHP bei dieser Konfiguration die <envar>PATH_INFO</envar>- und
      <envar>PATH_TRANSLATED</envar>-Informationen korrekt auswertet,
      sollte der PHP-Parser mit der Option <link linkend="enable-discard-path">--enable-discard-path</link>
      kompiliert werden.</para></sect2></sect1>

   <sect1 id="security.apache">
    <title>Apache-Modul</title>
    <simpara>
     Wenn PHP als Apache-Modul eingesetzt wird, übernimmt es die
     Benutzerrechte des Apache (üblicherweise user "nobody").</simpara></sect1>
    
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
