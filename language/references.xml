<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.17 $ -->
 <chapter id="language.references">
  <title>Referenzen in PHP</title>

  <sect1 id="language.references.whatare">
   <title>Was Referenzen sind</title>
   <simpara>  
    Referenzen sind in PHP ein Mechanismus um verschiedene Namen
    für den gleichen Inhalt von Variablen zu ermöglichen. 
    Sie sind nicht mit Zeigern in C zu vergleichen, sondern 
    Aliasdefinitionen für die Symboltabelle. 
    PHP unterscheidet zwischen Variablenname und Variableninhalt, 
    wobei der gleiche Variableninhalt unterschiedliche Namen besitzen kann. 
    Der bestmögliche Vergleich ist der mit Dateinamen und Dateien 
    im Dateisystem von Unix - Variablennamen sind Verzeichniseinträge, 
    während der Variableninhalt die eigentliche Datei darstellt. 
    Referenzen können nun als Hardlinks im Dateisystem verstanden werden.
   </simpara>
  </sect1>

  <sect1 id="language.references.whatdo">
   <title>Was Referenzen leisten</title>
   <para>
    PHP Referenzen erlauben es, zwei Variablennamen sich auf den
    gleichen Variableninhalt beziehen zu lassen. Das heisst im
    folgenden Beispiel, dass sich <varname>$a</varname> und
    <varname>$b</varname> auf dieselbe Variable beziehen:

    <informalexample>
     <programlisting role="php">
<![CDATA[
$a =& $b 
]]>
     </programlisting>
    </informalexample>

    <note>
     <para>
      <varname>$a</varname> und <varname>$b</varname> sind hier
      gleichwertig, und <varname>$a</varname> ist nicht nur ein
      Zeiger auf <varname>$b</varname> oder umgekehrt, sondern
      <varname>$a</varname> und <varname>$b</varname> zeigen auf
      den selben Inhalt.
     </para>
    </note>
   </para>
   <para>
   Seit PHP 4.0.4 kann <literal>&amp;</literal> auch in Verbindung mit
   <literal>new</literal> verwendet werden.
   <informalexample>
     <programlisting role="php">
<![CDATA[
$bar =& new fooclass();
$foo =& find_var ($bar);
]]>
     </programlisting>
    </informalexample>
    </para>
    <note>
     <para>
     Wenn der <literal>&amp;</literal> Operator nicht verwendet wird, erzeugt
     PHP eine Kopie des Objekts. Wenn nun <literal>$this</literal> innerhalb 
     der Klasse verwendet wird, bezieht es sich auf die aktuelle Instanz der 
     Klasse. Die Zuordnung ohne <literal>&amp;</literal> erzeugt eine Kopie der 
     Instanz (d.h. des Objekts) und <literal>$this</literal> wird sich auf 
     die Kopie beziehen. In der Regel will man aus Performance- und 
     Speicherverbrausgründen nur eine einzige Instanz einer Klasse
     erzeugen. Dafür stellt PHP den <literal>&amp;</literal> bereit. 
     </para>
   </note>
   
   <para>
    Eine weitere Einsatzmöglichkeit von Referenzen ist die Übergabe 
    von Parametern an eine Funktion mit pass-by-reference. Hierbei 
    beziehen sich der lokale Variablenname als auch der Variablenname 
    der aufrufenden Instanz auf denselben Variableninhalt:
    <informalexample>
     <programlisting role="php">
<![CDATA[
function foo (&$var) {
    $var++;
}

$a=5;
foo ($a);
]]>
     </programlisting>
    </informalexample>
    Nach der Ausführung hat <varname>$a</varname> den Wert 6, da sich 
    in der Funktion <varname>foo</varname> der Variablenname 
    <varname>$var</varname> auf denselben Variableninhalt bezieht wie 
    <varname>$a</varname> in der aufrufenden Instanz (hier das Hauptprogramm).
   </para>
   <simpara>
    Daneben besteht die Möglichkeit aus Funktionen heraus Werte mit 
    <link linkend="language.references.return">return by-reference</link> 
    zurückzugeben.
   </simpara>
  </sect1>

  <sect1 id="language.references.arent">
   <title>Was Referenzen nicht sind</title>
   <para>
    Wie bereits gesagt: Referenzen sind keine Zeiger. Das bedeutet, 
    der folgende Code tut nicht, was zum Beispiel ein C Programmierer 
    erwarten würde:
    <informalexample>
     <programlisting role="php">
<![CDATA[
function foo (&$var) {
    $var =& $GLOBALS["baz"];
}
foo($bar); 
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Folgendes wird passieren: <varname>$var</varname> in foo wird zunächst 
    an  <varname>$bar</varname> aus der aufrufenden Instanz, dann 
    aber an <varname>$GLOBALS["baz"]</varname>, gebunden.
    Es gibt keine Möglichkeit, <varname>$bar</varname> aus der aufrufenden 
    Instanz mittels Referenz-Mechanismen an etwas anderes zu binden, da 
    <varname>$bar</varname> in der Funktion foo nicht zur Verfügung steht 
    (<varname>$bar</varname> wird durch <varname>$var</varname> repräsentiert; 
    <varname>$var</varname> verfügt nur über Variableninhalt, besitzt 
    aber keinen name-to-value Eintrag in der Symboltabelle der aufrufenden 
    Instanz).
   </simpara>
  </sect1>

  <sect1 id="language.references.return">
   <title>Referenzen zurückgeben</title>
   <para>
    Das Zurückgeben von Ergebnissen per Referenz aus Funktionen 
    heraus kann manchmal recht nüzlich sein. Hierbei ist folgende
    Syntax zu beachten:
    <informalexample>
     <programlisting role="php">
<![CDATA[
function &find_var ($param) {
    ...code...
    return $found_var;
}

$foo =& find_var ($bar);
$foo->x = 2; 
]]>
     </programlisting>
    </informalexample>
    In diesem Beispiel wird also die Eigenschaft des von 
    <varname>find_var</varname> gelieferten Objektes gesetzt, nicht die der Kopie, 
    wie es der Fall wäre, wenn die Funktion <varname>find_var</varname> 
    ihr Ergebnis nicht per Referenz liefern würde.
   </para>
   <note>
    <simpara>
     Im Gegensatz zur Parameterübergabe per Referenz ist bei der 
     Rückgabe mittels Referenz an beiden Stellen die Angabe des 
     <literal>&amp;</literal> notwendig.
    </simpara>
   </note>
  </sect1>

  <sect1 id="language.references.unset">
   <title>Referenzen aufheben</title>
   <para>
    Wird eine Referenz aufgehoben, so wird nur die Bindung zwischen einem 
    Variablennamen und dem Variableninhalt entfernt. Der Inhalt der Variablen 
    wird hierbei nicht gelöscht. Betrachten wir folgendes Beispiel:
    <informalexample>
     <programlisting role="php">
<![CDATA[
$a = 1;
$b =& $a;
unset ($a); 
]]>
     </programlisting>
    </informalexample>
    Die Variable <varname>$b</varname> wird nicht gelöscht, sondern es 
    wird nur die Bindung des Variablennamen <varname>$a</varname> an den 
    Variableninhalt aufgehoben. Dieser Variableninhalt ist immer noch 
    über <varname>$b</varname> verfügbar.
   </para>
   <simpara>
    Wiederum sieht man die Analogie zwischen Unix und den Referenzen: Das 
    Aufheben einer Referenz entspricht einem Aufruf von 
    <command>unlink</command> unter Unix.
   </simpara>
  </sect1>

  <sect1 id="language.references.spot">
   <title>Referenzen entdecken</title>
   <simpara>
    Viele Sprachelemente von PHP sind intern mit der Benutzung von Referenzen 
    implementiert, daher gilt alles bisher gesagte auch für diese 
    Konstrukte:
   </simpara>

   <sect2 id="references.global">
    <title><literal>global</literal> References</title>
    <para>
     Die Verwendung von <command>global $var</command> erzeugt im aktuellen 
     Gültigkeitsbereich eine Referenz auf die globale Variable <varname>$var</varname>, 
     sie ist also äquivalent zu folgendem:
     <informalexample>
      <programlisting role="php">
<![CDATA[
$var =& $GLOBALS["var"];
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Dies hat zur Folge, dass das Anwenden von unset() auf <varname>$var</varname> 
     keinen Einfluss auf die globale Variable hat.
    </simpara>
   </sect2>

   <sect2 id="references.this">
    <title><literal>$this</literal></title>
    <simpara>
     In einer Objektmethode ist <varname>$this</varname> immer eine Referenz 
     auf die aufrufende Objektinstanz.
    </simpara>
   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
