<?xml version="1.0" encoding="iso-8859-1"?>
 <chapter id="language.references">
  <title>Referenzen in PHP</title>

  <sect1 id="language.references.whatare">
   <title>Was Referenzen sind</title>
   <simpara>  
    Referenzen sind in PHP ein Mechanismus um verschiedene Namen
    f&uuml;r den gleichen Inhalt von Variablen zu erm&ouml;glichen. 
    Sie sind nicht mit Zeigern in C zu vergleichen, sondern 
    Aliasdefinitionen f&uuml;r die Symboltabelle. 
    PHP unterscheidet zwischen Variablenname und Variableninhalt, 
    wobei der gleiche Variableninhalt unterschiedliche Namen besitzen kann. 
    Der bestm&ouml;gliche Vergleich ist der mit Dateinamen und Dateien 
    im Dateisystem von Unix - Variablennamen sind Verzeichniseintr&auml;ge, 
    w&auml;hrend der Variableninhalt die eigentliche Datei darstellt. 
    Referenzen k&ouml;nnen nun als Hardlinks im Dateisystem verstanden werden.
   </simpara>
  </sect1>

  <sect1 id="language.references.whatdo">
   <title>Was Referenzen leisten</title>
   <para>
    PHP Referenzen erlauben es, zwei Variablennamen sich auf den
    gleichen Variableninhalt beziehen zu lassen. Das heisst im
    folgenden Beispiel, dass sich <varname>$a</varname> und
    <varname>$b</varname> auf dieselbe Variable beziehen:

    <informalexample>
     <programlisting role="php">
<![CDATA[
$a =&amp; $b 
]]>
     </programlisting>
    </informalexample>

    <note>
     <para>
      <varname>$a</varname> und <varname>$b</varname> sind hier
      gleichwertig, und <varname>$a</varname> ist nicht nur ein
      Zeiger auf <varname>$b</varname> oder umgekehrt, sondern
      <varname>$a</varname> und <varname>$b</varname> zeigen auf
      den selben Inhalt.
     </para>
    </note>
   </para>
   <para>
   Seit PHP 4.0.4 kann <literal>&amp;</literal> auch in Verbindung mit
   <literal>new</literal> verwendet werden.
   <informalexample>
     <programlisting role="php">
<![CDATA[
$bar =& new fooclass();
$foo =& find_var ($bar);
]]>
     </programlisting>
    </informalexample>
    </para>
    <note>
     <para>
     Wenn der <literal>&amp;</literal> Operator nicht verwendet wird, erzeugt
     PHP eine Kopie des Objekts. Wenn nun <literal>$this</literal> innerhalb 
     der Klasse verwendet wird, bezieht es sich auf die aktuelle Instanz der 
     Klasse. Die Zuordnung ohne <literal>&amp;</literal> erzeugt eine Kopie der 
     Instanz (d.h. des Objekts) und <literal>$this</literal> wird sich auf 
     die Kopie beziehen. In der Regel will man aus Performance- und 
     Speicherverbrausgr&uuml;nden nur eine einzige Instanz einer Klasse
     erzeugen. Daf&uuml;r stellt PHP den <literal>&amp;</literal> bereit. 
     </para>
   </note>
   
   <para>
    Eine weitere Einsatzm&ouml;glichkeit von Referenzen ist die &Uuml;bergabe 
    von Parametern an eine Funktion mit pass-by-reference. Hierbei 
    beziehen sich der lokale Variablenname als auch der Variablenname 
    der aufrufenden Instanz auf denselben Variableninhalt:
    <informalexample>
     <programlisting role="php">
<![CDATA[
function foo (&amp;$var) {
    $var++;
}

$a=5;
foo ($a);
]]>
     </programlisting>
    </informalexample>
    Nach der Ausf&uuml;hrung hat <varname>$a</varname> den Wert 6, da sich 
    in der Funktion <varname>foo</varname> der Variablenname 
    <varname>$var</varname> auf denselben Variableninhalt bezieht wie 
    <varname>$a</varname> in der aufrufenden Instanz (hier das Hauptprogramm).
   </para>
   <simpara>
    Daneben besteht die M&ouml;glichkeit aus Funktionen heraus Werte mit 
    <link linkend="language.references.return">return by-reference</link> 
    zur&uuml;ckzugeben.
   </simpara>
  </sect1>

  <sect1 id="language.references.arent">
   <title>Was Referenzen nicht sind</title>
   <para>
    Wie bereits gesagt: Referenzen sind keine Zeiger. Das bedeutet, 
    der folgende Code tut nicht, was zum Beispiel ein C Programmierer 
    erwarten w&uuml;rde:
    <informalexample>
     <programlisting role="php">
<![CDATA[
function foo (&amp;$var) {
    $var =&amp; $GLOBALS["baz"];
}
foo($bar); 
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Folgendes wird passieren: <varname>$var</varname> in foo wird zun&auml;chst 
    an  <varname>$bar</varname> aus der aufrufenden Instanz, dann 
    aber an <varname>$GLOBALS["baz"]</varname>, gebunden.
    Es gibt keine M&ouml;glichkeit, <varname>$bar</varname> aus der aufrufenden 
    Instanz mittels Referenz-Mechanismen an etwas anderes zu binden, da 
    <varname>$bar</varname> in der Funktion foo nicht zur Verf&uuml;gung steht 
    (<varname>$bar</varname> wird durch <varname>$var</varname> repr&auml;sentiert; 
    <varname>$var</varname> verf&uuml;gt nur &uuml;ber Variableninhalt, besitzt 
    aber keinen name-to-value Eintrag in der Symboltabelle der aufrufenden 
    Instanz).
   </simpara>
  </sect1>

  <sect1 id="language.references.return">
   <title>Referenzen zur&uuml;ckgeben</title>
   <para>
    Das Zur&uuml;ckgeben von Ergebnissen per Referenz aus Funktionen 
    heraus kann manchmal recht n&uuml;zlich sein. Hierbei ist folgende
    Syntax zu beachten:
    <informalexample>
     <programlisting role="php">
<![CDATA[
function &amp;find_var ($param) {
    ...code...
    return $found_var;
}

$foo =&amp; find_var ($bar);
$foo->x = 2; 
]]>
     </programlisting>
    </informalexample>
    In diesem Beispiel wird also die Eigenschaft des von 
    <varname>find_var</varname> gelieferten Objektes gesetzt, nicht die der Kopie, 
    wie es der Fall w&auml;re, wenn die Funktion <varname>find_var</varname> 
    ihr Ergebnis nicht per Referenz liefern w&uuml;rde.
   </para>
   <note>
    <simpara>
     Im Gegensatz zur Parameter&uuml;bergabe per Referenz ist bei der 
     R&uuml;ckgabe mittels Referenz an beiden Stellen die Angabe des 
     <literal>&amp;</literal> notwendig.
    </simpara>
   </note>
  </sect1>

  <sect1 id="language.references.unset">
   <title>Referenzen aufheben</title>
   <para>
    Wird eine Referenz aufgehoben, so wird nur die Bindung zwischen einem 
    Variablennamen und dem Variableninhalt entfernt. Der Inhalt der Variablen 
    wird hierbei nicht gel&ouml;scht. Betrachten wir folgendes Beispiel:
    <informalexample>
     <programlisting role="php">
<![CDATA[
$a = 1;
$b =&amp; $a;
unset ($a); 
]]>
     </programlisting>
    </informalexample>
    Die Variable <varname>$b</varname> wird nicht gel&ouml;scht, sondern es 
    wird nur die Bindung des Variablennamen <varname>$a</varname> an den 
    Variableninhalt aufgehoben. Dieser Variableninhalt ist immer noch 
    &uuml;ber <varname>$b</varname> verf&uuml;gbar.
   </para>
   <simpara>
    Wiederum sieht man die Analogie zwischen Unix und den Referenzen: Das 
    Aufheben einer Referenz entspricht einem Aufruf von 
    <command>unlink</command> unter Unix.
   </simpara>
  </sect1>

  <sect1 id="language.references.spot">
   <title>Referenzen entdecken</title>
   <simpara>
    Viele Sprachelemente von PHP sind intern mit der Benutzung von Referenzen 
    implementiert, daher gilt alles bisher gesagte auch f&uuml;r diese 
    Konstrukte:
   </simpara>

   <sect2 id="references.global">
    <title><literal>global</literal> References</title>
    <para>
     Die Verwendung von <command>global $var</command> erzeugt im aktuellen 
     Scope eine Referenz auf die globale Variable <varname>$var</varname>, 
     sie ist also &auml;quivalent zu folgendem:
     <informalexample>
      <programlisting role="php">
<![CDATA[
$var =&amp; $GLOBALS["var"];
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Dies hat zur Folge, dass das Anwenden von unset() auf <varname>$var</varname> 
     keinen Einfluss auf die globale Variable hat.
    </simpara>
   </sect2>

   <sect2 id="references.this">
    <title><literal>$this</literal></title>
    <simpara>
     In einer Objektmethode ist <varname>$this</varname> immer eine Referenz 
     auf die aufrufende Objektinstanz.
    </simpara>
   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
