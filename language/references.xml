 <chapter id="language.references">
  <title>Referenzen in PHP</title>

  <sect1 id="language.references.whatare">
   <title>Was Referenzen sind</title>
   <simpara>  
    Referenzen sind in PHP ein Mechanismus um verschiedene Namen
    für den gleichen Inhalt von Variablen zu ermöglichen. Sie sind nicht
    mit Zeigern in C zu vergleichen, sondern Aliasdefinitionen für
    die Symboltabelle. PHP unterscheidet zwischen Variablenname
    und Variableninhalt, wobei der gleiche Variableninhalt
    unterschiedliche Namen besitzen kann. Der bestmögliche Vergleich
    ist der mit Dateinamen und Dateien im Dateisystem von Unix - 
    Variablennamen sind Verzeichniseinträge, während der 
    Variableninhalt die eigentliche Datei darstellt. Referenzen
    können nun als Hardlinks im Dateisystem verstanden werden.
   </simpara>
  </sect1>

  <sect1 id="language.references.whatdo">
   <title>Was Referenzen leisten</title>
   <para>
    PHP Referenzen erlauben es, zwei Variablennamen sich auf den
    gleichen Variableninhalt beziehen zu lassen. Das heisst im
    folgenden Beispiel, dass sich <varname>$a</varname> und
    <varname>$b</varname> auf dieselbe Variable beziehen:

    <informalexample>
     <programlisting role="php">
$a =&amp; $b 
     </programlisting>
    </informalexample>

    <note>
     <para>
      <varname>$a</varname> und <varname>$b</varname> sind hier
      gleichwertig, und <varname>$a</varname> ist nicht nur ein
      Zeiger auf <varname>$b</varname> oder umgekehrt, sondern
      <varname>$a</varname> und <varname>$b</varname> zeigen auf
      den selben Inhalt.
     </para>
    </note>
   </para>
   <para>
    Eine weitere Einsatzmöglichkeit von Referenzen ist die Übergabe 
    von Parametern an eine Funktion mit pass-by-reference. Hierbei 
    beziehen sich der lokale Variablenname als auch der Variablenname 
    der aufrufenden Instanz auf denselben Variableninhalt:
    <informalexample>
     <programlisting role="php">
function foo (&amp;$var) {
    $var++;
}

$a=5;
foo ($a);
     </programlisting>
    </informalexample>
    Nach der Ausführung hat <varname>$a</varname> den Wert 6, da sich 
    in der Funktion <varname>foo</varname> der Variablenname <varname>$var</varname> 
    auf denselben Variableninhalt bezieht wie <varname>$a</varname> 
    in der aufrufenden Instanz (hier das Hauptprogramm).
   </para>
   <simpara>
    Daneben besteht die Möglichkeit aus Funktionen heraus Werte mit 
    <link linkend="language.references.return">return by-reference</link> 
    zurückzugeben.
   </simpara>
  </sect1>

  <sect1 id="language.references.arent">
   <title>Was Referenzen nicht sind</title>
   <para>
    Wie bereits gesagt: Referenzen sind keine Zeiger. Das bedeutet, 
    der folgende Code tut nicht, was zum Beispiel ein C Programmierer 
    erwarten würde:
    <informalexample>
     <programlisting role="php">
function foo (&amp;$var) {
    $var =&amp; $GLOBALS["baz"];
}
foo($bar); 
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    What will happen that <varname>$var</varname> in foo will be bound
    with <varname>$bar</varname> in caller, but then it will be
    re-bound with <varname>$GLOBALS["baz"]</varname>. There's no way
    to bind <varname>$bar</varname> in the caller to something else
    using reference mechanism, since <varname>$bar</varname> is not
    available in the function foo (it is represented by
    <varname>$var</varname>, but <varname>$var</varname> has only
    variable contents and not name-to-value binding in the calling
    symbol table).
   </simpara>
  </sect1>

  <sect1 id="language.references.return">
   <title>Referenzen zurückgeben</title>
   <para>
    Returning by-refernce it is useful when you want to use function
    to find variable which should be bound to. When returning
    references, use this syntax:
    <informalexample>
     <programlisting role="php">
function &amp;find_var ($param) {
    ...code...
    return $found_var;
}

$foo =&amp; find_var ($bar);
$foo->x = 2; 
     </programlisting>
    </informalexample>
    In this example, property of the object returned by the
    <varname>find_var</varname> function would be set, not of the
    copy, as it would be without using reference syntax.
   </para>
   <note>
    <simpara>
     Unlike parameter passing, here you have to use
     <literal>&amp;</literal> in both places - to indicate that you
     return by-reference, not a copy as usual, and to indicate than
     reference binding and not usual assignment should be done for
     <varname>$foo</varname>.
    </simpara>
   </note>
  </sect1>

  <sect1 id="language.references.unset">
   <title>Referenzen aufheben</title>
   <para>
    When you unset the reference, you just break the binding between
    variable name and variable content. This does not mean that
    variable content will be destroyed. For example:
    <informalexample>
     <programlisting role="php">
$a = 1;
$b =&amp; $a;
unset ($a); 
     </programlisting>
    </informalexample>
    won't unset <varname>$b</varname>, just <varname>$a</varname>. 
   </para>
   <simpara>
    Again, it might be useful to think about this as analogous to Unix
    <command>unlink</command> call.
   </simpara>
  </sect1>

  <sect1 id="language.references.spot">
   <title>Referenzen entdecken</title>
   <simpara>
    Many syntax constructs in PHP are implemented via referencing
    mechanisms, so everything told above about reference binding also
    apply to these constructs. Some constructs, like passing and
    returning by-reference, are mentioned above. Other constructs that
    use references are:
   </simpara>

   <sect2 id="references.global">
    <title><literal>global</literal> References</title>
    <para>
     When you declare variable as <command>global $var</command> you
     are in fact creating reference to a global variable. That means,
     this is the same as:
     <informalexample>
      <programlisting role="php">
$var =&amp; $GLOBALS["var"];
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     That means, for example, that unsetting <varname>$var</varname>
     won't unset global variable.
    </simpara>
   </sect2>

   <sect2 id="references.this">
    <title><literal>$this</literal></title>
    <simpara>
     In an object method, <varname>$this</varname> is always reference
     to the caller object.
    </simpara>
   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
