<?xml version="1.0" encoding="iso-8859-1"?>
 <chapter id="language.variables">
  <title>Variablen</title>

  <sect1 id="language.variables.basics">
   <title>Grundlegendes</title>
   <simpara>
    Variablen werden in PHP dargestellt durch ein Dollar-Zeichen ($)
    gefolgt vom Namen der Variablen. Bei Variablen-Namen wird
    zwischen Groß- und Kleinschreibung unterschieden (case-sensitive).
   </simpara>

   <para>
    Variablen-Namen werden in PHP nach den gleichen Regeln wie
    andere Bezeichner erstellt. Ein gültiger Variablen-Name beginnt
    mit einem Buchstaben oder einem Unterstrich ("_"), gefolgt von
    einer beliebigen Anzahl von Buchstaben, Zahlen oder Unterstrichen.
    Als regulärer Ausdruck (regular expression) würde das wie folgt
    ausgedrückt: '[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*'.
   </para>

   <note>
    <simpara>
     Unserem Zweck entspricht also ein Buchstabe von a bis z bzw.
     A bis Z oder einem ASCII-Zeichen von 127 bis 255 (0x7f bis 0xff).
    </simpara>
   </note>

   <para>
    <informalexample>
     <programlisting role="php"> 
$var = "Du";
$vaR = "und";
$Var = "ich";
$vAr = "wir lernen PHP"
echo "$var $vaR $Var, $vAr"; // gibt "Du und ich, wir lernen PHP" aus

$4site  = 'nicht jetzt';     // ungültig, da Anfang eine Zahl
$_4site = 'nicht jetzt';     // gültig, da Unterstrich am Anfang
$täbyte = 'irgendwas';       // gültig, da 'ä' dem ASCII-Wert 228 entspricht
     </programlisting>
    </informalexample>
   </para>

   <para>
    Variablen werden in PHP 3 durch ihren Wert bestimmt. Das heisst,
    wenn sie einer Variablen einen Ausdruck zuweisen, wird der gesamte
    Inhalt des Originalausdrucks in die Zielvariable kopiert. Die
    Folge ist, dass eine Variable, die ihren Inhalt von einer anderen
    Variablen erhalten hat, ihren Inhalt behält, auch wenn sie danach
    den Inhalt der anderen (Quell- / Ursprungs-)Variablen ändern. Die
    Inhalte der Ziel- und Quellvariablen sind also insoweit unabhängig
    voneinander. Für weitere Informationen lesen sie bitte <link
    linkend="language.expressions">Expressions / Ausdrücke</link>.
   </para>
   <para>
    PHP 4 bietet eine andere Möglichkeit der Wertzuweisung bei
    Variablen: <emphasis>Zuweisung durch Referenzierung</emphasis>.
    Das bedeutet, dass der Wert der neuen Variablen eine Referenz zur
    Ursprungs-Variablen darstellt (mit anderen Worten: Der Wert ist
    ein Alias bzw. Zeiger auf den Inhalt der Ursprungsvariablen). Beide
    Variablen zeigen also auf die selbe(n) Speicherstelle(n).
    Änderungen der neuen Variablen ändern auch deren Ursprungs-
    Variable und umgekehrt. Der Wert / Inhalt wird also nicht kopiert. Die
    Übertragung geschieht dadurch auch schneller als in PHP 3. Dies wird
    sich aber nur bei umfangreichen Schleifen oder bei der Übertragung
    von grossen Arrays oder Objekten bemerkbar machen.
   </para>
   <para>
    Für die Zuweisung per Referenz müssen sie lediglich ein &amp;
    der (Ausgangs-, Quell-) Variablen voranstellen, die
    sie einer anderen Variablen zuweisen wollen. Der folgende Skript-
    Ausschnitt wird zweimal 'Mein Name ist Bob' ausgeben:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 'Bob';             // 'Bob' der Variablen $foo zuweisen.
$bar = &$foo;             // Zeiger auf $foo in $bar erzeugen.
$bar = "My name is $bar"; // $bar verändern...
echo $foo;                // $foo wurde dadurch ebenfalls verändert.
echo $bar;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Zu beachten ist, dass nur Variablenbezeichner referenziert
    werden können.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 25;
$bar = &$foo;     // Gültige Zuweisung.
$bar = &(24 * 7); // Ungültig, da kein Variablenbezeichner
                  // zugewiesen wird.
function test() {
    return 25;
}

$bar = &();   // Ungültig.
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="language.variables.predefined">
   <title>Vordefinierte Variablen</title>
   <simpara>
    PHP bietet jedem ausgeführtem Skript eine Vielzahl von
    vordefinierten Variablen an. Viele dieser Variablen können
    jedoch nicht vollständig erläutert werden, da sie abhängig
    sind vom Web-Server, der Version und dem Setup des Web-
    Servers sowie weiteren Faktoren. Einige dieser Variablen
    stehen nicht zur Verfügung, wenn PHP-Skripte per Kommando-
    Zeilen-Aufruf ausgeführt werden.
   </simpara>
   <simpara>
    Ungeachtet dieser Faktoren folgt nun eine Liste von
    vordefinierten Variablen innerhalb einer Basis-PHP 3-
    Installation als Modul und einer Basis-Installation des
    <ulink url="&url.apache;">Apache</ulink>-Web-Servers in der
    Vers. 1.3.6.
   </simpara>
   <simpara>
    Eine Liste aller vordefinierten Variablen (und weitere
    nützliche Informationen) erhalten sie durch Lesen der Infos
    zu (und den Gebrauch) der <function>phpinfo</function>-Funktion.
   </simpara>
   <note>
    <simpara>
     Diese Liste ist weder vollständig noch erhebt sie Anspruch
     auf Vollständigkeit. Sie dient lediglich als Anleitung zu den
     möglicherweise zu erwartenden Arten von vordefinierten
     Variablen und dem Zugriff darauf.
    </simpara>
   </note>

   <sect2 id="language.variables.predefined.apache">
    <title>Apache-Variablen</title>
    <simpara>
     Diese Variablen werden durch den <ulink
     url="&url.apache;">Apache</ulink>-Web-Server erzeugt. Sollten
     sie einen anderen Web-Server nutzen, gibt es keine Garantie,
     dass dieser die selben Variablen unterstützt. Es könnten
     einige sein; es könnten aber auch hier nicht aufgeführte sein.
     Viele dieser Variablen werden in den <ulink
     url="&url.cgispec;">CGI 1.1 Spezifikationen</ulink> aufgeführt.
     Darauf sollten sie vorbereitet sein.
    </simpara>
    <simpara>
     Beachten Sie, dass nur wenige, wenn überhaupt, dieser Variablen
     zur Verfügung stehen (oder tatsächlich eine beliebige Bedeutung haben),
     wenn Sie PHP per Kommandozeile aufrufen.
    </simpara>
    <para>
     <variablelist>
      <varlistentry>
       <term>$GATEWAY_INTERFACE</term>
       <listitem>
        <simpara>
         Die Revision der CGI-Spezifikation, die der Web-Server
         benutzt, z.B. 'CGI/1.1'.
       </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$SERVER_NAME</term>
       <listitem>
        <simpara>
         Der Host-Name des Web-Servers, der das Skript ausführt. Das
         kann auch der Name eines virtuellen Servers sein.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$SERVER_SOFTWARE</term>
       <listitem>
        <simpara>
         Der Identifikations-String des Web-Servers (aus den Headern),
         sobald er Anforderungen beantwortet.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$SERVER_PROTOCOL</term>
       <listitem>
        <simpara>
         Name und Revision des Informations-Protokolls, über das die
         Seite angefordert wurde, z.B. 'HTTP/1.0'.
       </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$REQUEST_METHOD</term>
       <listitem>
        <simpara>
         Welche Methode zum Zugriff auf die Seite benutzt wurde,
         z.B. 'GET', 'HEAD', 'POST', 'PUT'.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$QUERY_STRING</term>
       <listitem>
        <simpara>
         Der Abfrage-(Query-)String (falls vorhanden), mit dem auf
         die Seite zugegriffen wurde.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$DOCUMENT_ROOT</term>
       <listitem>
        <simpara>
         Das Verzeichnis des gerade ausgeführten Skripts aus Sicht
         des in der Konfigurations-Datei des Servers definierten
         Dokument-Wurzel-Verzeichnisses.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$HTTP_ACCEPT</term>
       <listitem>
        <simpara>
         Inhalt des <literal>Accept:</literal>-Headers der aktuellen
         Anforderung (so es einen solche Header gibt).
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$HTTP_ACCEPT_CHARSET</term>
       <listitem>
        <simpara>
         Inhalt des <literal>Accept-Charset:</literal>-Headers der
         aktuellen Anforderung (sofern es einen gibt).
         Beispiel: 'iso-8859-1,*,utf-8'.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$HTTP_ENCODING</term>
       <listitem>
        <simpara>
         Inhalt des <literal>Accept-Encoding:</literal>-Headers der
         aktuellen Anforderung (wenn es einen gibt).
         Beispiel: 'gzip'.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$HTTP_ACCEPT_LANGUAGE</term>
       <listitem>
        <simpara>
         Inhalt des <literal>Accept-Language:</literal>-Headers in
         der aktuellen Anforderung, sofern dieser Header existiert.
         Beispiel: 'en'.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$HTTP_CONNECTION</term>
       <listitem>
        <simpara>
         Inhalt des <literal>Connection:</literal>-Headers des
         aktuellen Request, so er vorhanden ist.
         Beispiel: 'Keep-Alive'.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$HTTP_HOST</term>
       <listitem>
       <simpara>
        Inhalt des <literal>Host:</literal>-Headers der aktuellen
        Anforderung, wenn er existiert.
       </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$HTTP_REFERER</term>
       <listitem>
        <simpara>
         Die Adresse (URL) - sofern vorhanden - der Seite, von
         der aus auf die aktuelle Seite gesprungen wurde. Dieser
         wird vom Browser des Benutzers gesetzt. Nicht alle Browser
         unterstützen dies.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$HTTP_USER_AGENT</term>
       <listitem>
        <simpara>
         Inhalt der <literal>User_Agent:</literal>-Header-Angabe
         der aktuellen Anfrage (wenn eine Angabe existiert). Dabei
         handelt es sich um eine Zeichenkette, welche der Browser
         benennt, mit dem die aktuelle Seite aufgerufen
         wurde, z.B. <computeroutput>Mozilla/4.5 [en] (X11; U;
         Linux 2.2.9 i586)</computeroutput>. Abgesehen von anderen
         Dingen können sie diesen Wert zusammen mit der
         <function>get_browser</function> Funktion dazu verwenden,
         ihre Web-Seiten in Abhängigkeit von den Möglichkeiten des
         jeweils benutzten Browsers anzeigen zu lassen.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$REMOTE_ADDR</term>
       <listitem>
        <simpara>
         Die IP-Adresse, von der aus gerade auf die Web-Seite
         zugegriffen wird.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$REMOTE_PORT</term>
       <listitem>
        <simpara>
         Der Port, der zum Zugriff auf ihren Web-Server seitens
         des Anwender-Computers benutzt wird.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$SCRIPT_FILENAME</term>
       <listitem>
       <simpara>
         Der absolute Pfadname des gerade ausgeführten Skripts.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$SERVER_ADMIN</term>
       <listitem>
        <simpara>
         Der Inhalt der in der Konfigurations-Datei des Web-Servers
         (Apache) stehenden Angabe zum SERVER_ADMIN. Bei virtuellen
         Hosts der dafür eingetragene Wert.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$SERVER_PORT</term>
       <listitem>
        <simpara>
         Der vom Server für den Web-Server benutzte Kommunikations-
         Port (normalerweise '80'). Verwenden sie z.B. SSL, wird
         dieser Port derjenige sein, den sie für sicheres HTTP
         definiert haben.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$SERVER_SIGNATURE</term>
       <listitem>
        <simpara>
         Sofern eingeschaltet, enthält diese Zeichenkette die Server-
         Version und den virtuellen Host-Namen. Sie wird den durch
         den Server generierten Seiten hinzu gefügt.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$PATH_TRANSLATED</term>
       <listitem>
        <simpara>
         In Abhängigkeit vom Datei- / File-System der Pfad des
         aktuellen Skripts, nachdem der Server das virtuelle
         Mapping in ein reales Mapping umgesetzt hat (nicht der
         Dokument-Wurzel-Pfad).
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$SCRIPT_NAME</term>
       <listitem>
        <simpara>
         Enthält den Pfad des aktuellen Skripts. Nützlich für
         Seiten, die auf sich selbst verweisen müssen.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>$REQUEST_URI</term>
       <listitem>
        <simpara>
         Die URI, die durch den Zugriff auf die aktuelle Seite
         gegeben ist, z.B. '/index.html'.
        </simpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </sect2>

   <sect2 id="language.variables.predefined.environment">
    <title>Umgebungs- / Environment-Variablen</title>
    <simpara>
     Diese Variablen werden aus der Umgebung, in der PHP läuft, in
     den globalen Namensbereich von PHP importiert. Viele werden
     durch die jeweilige Shell, in der PHP läuft, unterstützt bzw.
     gebildet. Da es verschiedenste Systemumgebungen mit den 
     unterschiedlichsten Shell`s gibt, ist es nicht möglich, eine
     abschließende Liste der definierten Umgebungs-Variablen
     aufzustellen. Lesen sie deshalb in der Anleitung zu ihrer
     Shell nach, um eine Liste dieser systembezogenen Variablen
     zu erhalten.
    </simpara>
    <simpara>
     Andere Umgebungs-Variablen beinhalten die CGI-Variablen,
     die ohne Rücksicht darauf, ob PHP als Web-Server-Modul
     oder im CGI-Modus läuft, gesetzt werden.
    </simpara>
   </sect2>

   <sect2 id="language.variables.predefined.php">
    <title>PHP-Variablen</title>
    <simpara>
     Diese Variablen werden durch PHP selbst erzeugt.
     <varname>$HTTP_*_VARS</varname> Variablen stehen nur zur Verfügung,
     wenn die Option <link linkend="ini.track-vars">track_vars</link> in der
     php.ini auf "on" gesetzt ist. Wenn dies der Fall ist, werden diese Variablen
     immer gesetzt, selbst wenn es leere Arrays sind. Das verhindert, dass ein
     böswilliger Nutzer diese Variablen manipuliert.
    </simpara>

    <note>
     <para>
      Seit PHP 4.0.3 ist <link
      linkend="ini.track-vars">track_vars</link> immer aktiviert,
      ohne Rücksicht auf die Einstellungen in der Konfigurationsdatei.
     </para>
    </note>

    <note>
     <para>
      Die neuen "Superglobals" stehen seit der PHP Version 4.1.0. zur
      Verfügung. Im  <ulink url="&url.php.release4.1.0;">4.1.0 Release
      Announcement</ulink> können Sie mehr Details nachlesen.
      Dieses sind die Arrays
      <varname>$_GET</varname>, <varname>$_POST</varname>,
      <varname>$_ENV</varname>, <varname>$_SERVER</varname>,
      <varname>$_COOKIE</varname>, <varname>$_REQUEST</varname>
      <varname>$_FILES</varname> und <varname>$_SESSION</varname>
      und werden informell als <emphasis>Superglobals</emphasis> bezeichnet,
      weil sie immer zur Verfügung stehen, ohne Berücksichtigung des
      Geltungsbereichs.Damit sind die alten, beziehungsweise die 
      <varname>$HTTP_*_VARS</varname> Arrays veraltet.
     </para>
    </note>

    <para>
     Wenn <link linkend="ini.register-globals">register_globals</link>
     aktiviert ist,stehen auch diese Variablen im globalen Namensbereich
     des Skripts zur Verfügung; z.B. getrennt von den Arrays
     <varname>$HTTP_*_VARS</varname> und <varname>$_*</varname>.
     Verwandte Informationen erhalten Sie im Kapitel über Sicherheit
     unter dem Abschnitt <link linkend="security.registerglobals">
     Verwendung von Register Globals</link>.
    </para>

    <para>
     <variablelist>
      <varlistentry>
       <term>$argv</term>
       <listitem>
        <simpara>
         Ein Array von Argumenten, die dem Skript übergeben
         werden. Wird das Skript an der Befehlszeile aufgerufen,
         ermöglicht dies C-ähnlichen Zugriff auf die Kommando-
         Zeilen-Parameter. Beim Aufruf per GET-Methode enthält
         dieses Array die Abfragewerte.
        </simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>$argc</term>
       <listitem>
        <simpara>
         Anzahl der per Kommando-Zeile dem Skript übergebenen
         Parameter (wenn von dort aufgerufen).
        </simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>$PHP_SELF</term>
       <listitem>
        <simpara>
         Der Dateiname des gerade ausgeführten Skripts, relativ
         zum Wurzel-Verzeichnis des Dokuments. Bei Kommando-Zeilen-
         Aufrufen ist diese Variable nicht verfügbar.
        </simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>$HTTP_COOKIE_VARS</term>
       <listitem>
        <simpara>
         Ein assoziatives Array von Variablen, das dem aktuellen Skript
         über HTTP-Cookies übergeben wurde.
        </simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>$_COOKIE</term>
       <listitem>
        <simpara>
         Ein assoziatives Array von Variablen, das dem aktuellen Skript
         über HTTP-Cookies übergeben wurde. Automatisch global in jedem
         Geltungsbereich. Eingeführt in PHP 4.1.0.
        </simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>$HTTP_GET_VARS</term>
       <listitem>
        <simpara>
         Ein assoziatives Array von Variablen, das dem aktuellen
         Skript per HTTP-GET-Methode übergeben wurde.
        </simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>$_GET</term>
       <listitem>
        <simpara>
         Ein assoziatives Array von Variablen, das dem aktuellen
         Skript per HTTP-GET-Methode übergeben wurde.Automatisch global in
         jedem Geltungsbereich. Eingeführt in PHP 4.1.0.
        </simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>$HTTP_POST_VARS</term>
       <listitem>
        <simpara>
         Ein assoziatives Array aus Varaiblen, welches dem aktuellen
         Skript per HTTP-POST-Methode übergeben wurde.
        </simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>$_POST</term>
       <listitem>
        <simpara>
         Ein assoziatives Array aus Variablen, welches dem aktuellen
         Skript per HTTP-POST-Methode übergeben wurde. Automatisch global in
         jedem Geltungsbereich. Eingeführt in PHP 4.1.0.
        </simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>$HTTP_POST_FILES</term>
       <listitem>
        <simpara>
         Ein assoziatives Array aus Variablen, das Informationen über
         per HTTP POST-Methode hochgeladene Dateien enthält. Siehe <link
         linkend="features.file-upload.post-method">Dateiuploads mit POST</link>
         für Informationen über den Inhalt der
         <varname>$HTTP_POST_FILES</varname>. Eingeführt in PHP 4.0.0.
        </simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>$_FILES</term>
       <listitem>
        <simpara>
         Ein assoziatives Array aus Variablen, das Informationen über
         per HTTP POST-Methode hochgeladene Dateien enthält. Siehe <link
         linkend="features.file-upload.post-method">Dateiuploads mit POST</link>
         für Informationen über den Inhalt der
         <varname>$_FILES</varname>.Automatisch global in jedem
         Geltungsbereich. Eingeführt in PHP 4.1.0.
        </simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>$HTTP_ENV_VARS</term>
       <listitem>
        <simpara>
         Ein assoziatives Array aus Variablen, die dem aktuellen Skript
         über die Umgebung zur Verfügung stehen.
        </simpara>
       </listitem>
      </varlistentry>

    <varlistentry>
       <term>$_ENV</term>
       <listitem>
        <simpara>
         Ein assoziatives Array aus Variablen, die dem aktuellen Skript
         über die Umgebung zur Verfügung stehen. Automatisch global in
         jedem Geltungsbereich. Eingeführt in PHP 4.1.0.
        </simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>$HTTP_SERVER_VARS</term>
       <listitem>
        <simpara>
         Ein assoziatives Array aus Variablen, die dem aktuellen Skript
         vom jeweiligen HTTP-Server übermittelt werden. Diese Variablen
         sind analog zu den oben beschriebenen Apache-Variablen.
        </simpara>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>$_SERVER</term>
       <listitem>
        <simpara>
         Ein assoziatives Array aus Variablen, die dem aktuellen Skript
         vom jeweiligen HTTP-Server übermittelt werden. Diese Variablen
         sind analog zu den oben beschriebenen Apache-Variablen. Automatisch
         global in jedem Geltungsbereich. Eingeführt in PHP 4.1.0.
        </simpara>
       </listitem>
      </varlistentry>

    <varlistentry>
       <term>$HTTP_SESSION_VARS</term>
       <listitem>
        <simpara>
         Ein assoziatives Array aus Session-Variablen, die dem aktuellen
         Skript übergeben wurden.
        </simpara>
       </listitem>
      </varlistentry>

    <varlistentry>
       <term>$_SESSION</term>
       <listitem>
        <simpara>
         Ein assoziatives Array aus Session-Variablen, die dem aktuellen
         Skript übergeben wurden. Automatisch global in jedem
         Geltungsbereich. Werden dem Array $_SESSION neue Einträge
         hinzugefügt, werden diese automatisch als Session-Variablen
         registriert, genau so als ob die Funktion
         <function>session_register</function> aufgerufen worden wäre.
         Eingeführt in PHP 4.1.0.
        </simpara>
       </listitem>
      </varlistentry>

    <varlistentry>
       <term>$_REQUEST</term>
       <listitem>
        <simpara>
         Ein assoziatives Array zusammengesetzt aus den GET, POST und Cookie
         Variablen. Mit anderen Worten - alle Informationen die vom Nutzer
         kommen und denen aus Sichtweise der Sicherheit nicht zu trauen ist.
         Automatisch global in jedem Geltungsbereich. Eingeführt in
         PHP 4.1.0.
        </simpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </sect2>
  </sect1>


  <sect1 id="language.variables.scope">
   <title>Geltungsbereich von Variablen</title>
   <simpara>
    Der Geltungsbereich einer Variablen ergibt sich aus dem
    Zusammenhang, in dem sie definiert wurde. Meistens besteht
    dieser aus einem einzigen Bereich. Dieser beinhaltet auch den
    Bereich für Dateien, die per "include"- oder "require"-Anweisung
    eingebunden wurden, z.B.:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
$a = 1;
include "b.inc";
]]>
    </programlisting>
   </informalexample>
   <simpara>
    Die Variable $a ist auch in der eingebundenen Datei
    <filename>b.inc</filename> verfügbar. In benutzerdefinierten Funktionen
    wird ein auf die Funktion beschränkter Geltungsbereich eingeführt. Jede in
    einer Funktion benutzte Variable ist zunächst auf den lokalen Bereich
    der Funktion beschränkt, z.B.:
   </simpara>
   <informalexample>
    <programlisting role="php"> 
<![CDATA[
$a = 1; // globaler Bereich

function test () { 
    echo $a; // Referenz auf einen lokalen Variablen-Bereich
} 

test ();
]]>
    </programlisting>
   </informalexample>
   <simpara>
    Dieses Skript erzeugt keine Bildschirm-Ausgabe, da sich die Echo-
    Anweisung auf eine lokale Variable namens <varname>$a</varname>
    bezieht und dieser kein Wert im lokalen Bezug zugewiesen worden ist.
    Dies ist ein kleiner Unterschied zu C, wo globale Variablen auch in
    Funktionen vorhanden sind, es sei denn, sie werden durch eine
    funktionsinterne Definition überschrieben. Das kann zu Problemen führen,
    denn in PHP müssen global geltende Variablen innerhalb von Funktionen als
    solche definiert werden. Ein Beispiel:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 2;

function Sum()
{
    global $a, $b;

    $b = $a + $b;
} 

Sum();
echo $b;
]]>
    </programlisting>
   </informalexample>
   <simpara>
    Das obige Skript gibt &quot;3&quot; aus. Durch das Deklararieren
    der Variablen <varname>$a</varname> und <varname>$b</varname>innerhalb
    der Funktion als global, weisen alle Referenzen zu beiden Variablen auf
    die nun globalen Werte. Es gibt keine Beschränkungen bei der Anzahl an
    globalen Variablen, die durch eine Funktion verändert werden können.
   </simpara>
   <simpara>
    Eine weitere Möglichkeit besteht in der Verwendung des speziellen
    <varname>$GLOBALS</varname> PHP-Array. Das obige Beispiel kann damit
    auch so  geschrieben werden:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 2;

function Sum()
{
    $GLOBALS["b"] = $GLOBALS["a"] + $GLOBALS["b"];
} 

Sum();
echo $b;
]]>
    </programlisting>
   </informalexample>
   <simpara>
    Das <varname>$GLOBALS</varname>-Array ist ein assoziatives Array mit dem
    Bezeichner der globalen Variablen als Schlüssel und dem Inhalt dieser
    Variablen als Wert des Array-Elements.
   </simpara>
   <simpara>
    Ein weiterer wichtiger Anwendungszweck von Variablen-Bereichen
    ist die <emphasis>static</emphasis>-Variable. Eine statische
    Variable existiert nur in einem lokalen Funktions-Bereich, der
    Wert geht beim Verlassen dieses Bereichs aber nicht verloren.
    Schauen sie das folgende Beispiel an:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
function test ()
{
    $a = 0;
    echo $a;
    $a++;
}
]]>
    </programlisting>
   </informalexample>
   <simpara>
    Diese Funktion ist sinnlos, da sie bei jedem Aufruf <varname>$a</varname>
    auf <literal>0</literal> setzt und &quot;0&quot; ausgibt. Die Anweisung
    $a++, welche den Wert erhöht, macht keinen Sinn, da der Wert von
    <varname>$a</varname> beim Verlassen der Funktion verloren geht. Um eine
    sinnvolle Zählfunktion zu implementieren, die ihren aktuell gesetzten Wert
    nicht vergisst, müssen sie die Variable <varname>$a</varname>als "static"
    deklarieren:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
function test()
{
    static $a = 0;
    echo $a;
    $a++;
}
]]>
    </programlisting>
   </informalexample>
   <simpara>
    Jetzt wird bei jedem Aufruf der test()-Funktion der aktuelle
    Wert von <varname>$a</varname> ausgegeben und dann um 1 erhöht.
   </simpara>
   <simpara>
    Static-Variablen ermöglichen auch einen Weg zum Umgang mit
    rekursiven Funktionen. Das sind Funktionen, die sich selbst
    aufrufen. Hierbei besteht die Gefahr, so genannte Endlos-
    Schleifen zu programmieren. Sie müssen also einen Weg vorsehen,
    diese Rekursion zu beenden. Die folgende einfache Funktion zählt
    rekursiv bis 10. Die statische Variable <varname>$count</varname>
    wird benutzt, um die Rekursion zu beenden:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
function test()
{
    static $count = 0;

    $count++;
    echo $count;
    if ($count < 10) {
        test ();
    }
    $count--;
}
]]>
    </programlisting>
   </informalexample>
  </sect1>

  <sect1 id="language.variables.variable">
   <title>Variable Variablen</title>
   <simpara>
    Manchmal ist es komfortabel, variable Variablen-Bezeichner zu
    benutzen. Das bedeutet, einen Variablen-Namen zu setzen und
    dynamisch zu gebrauchen. Eine normale Variable wird wie folgt
    gebildet:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
$a = "Hallo";
]]>
    </programlisting>
   </informalexample>
   <simpara>
    Eine variable Variable nimmt den Wert einer Variablen und
    behandelt ihn als Bezeichner der Variablen. Im obigen Beispiel
    kann <emphasis>Hallo</emphasis> als Variablen-Name gebraucht
    werden, indem man zwei $-Zeichen benutzt, also schreibt:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
$$a = "Welt";
]]>
    </programlisting>
   </informalexample>
   <simpara>
    Nun existieren in der PHP-Symbol-Struktur zwei definierte und
    gespeicherte Variablen: <varname>$a</varname> mit dem Inhalt "Hallo"
    und <varname>$Hallo</varname> mit dem Inhalt "Welt". Deshalb wird die
    Anweisung
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
echo "$a ${$a}";
]]>
    </programlisting>
   </informalexample>
   <simpara>
    zur genau gleichen Ausgabe führen wie:
   </simpara>
   <informalexample>
    <programlisting>
<![CDATA[
echo "$a $Hallo";
]]>
    </programlisting>
   </informalexample>
   <simpara>
    also zu: <computeroutput>Hallo Welt</computeroutput>.
   </simpara>
   <simpara>
    Wenn sie variable Variablen mit Arrays verwenden, müssen sie
    eine Doppeldeutigkeit beachten. Wenn sie nämlich
    <varname>$$a[1]</varname> schreiben, dann muss der Parser wissen, ob Sie
    <varname>$a[1]</varname> als Variable oder <varname>$$a</varname> als
    Variable und dann [1] als Index dieser Variablen verwenden wollen bzw.
    gemeint haben. Die Syntax zur Lösung dieser Doppeldeutigkeit: Verwenden
    Sie im ersten Fall <varname>${$a[1]}</varname> und im zweiten Fall
    <varname>${$a}[1]</varname>.
   </simpara>
  </sect1>

  <sect1 id="language.variables.external">
   <title>Variablen ausserhalb von PHP</title>

   <sect2 id="language.variables.external.form">
    <title>HTML-Formulare (GET and POST)</title>
    <simpara>
     Sobald ein Formular an ein PHP-Skript übergeben wird, wird
     jede Variable dieses Formulars dem Skript automatisch 
     verfügbar gemacht. Dafür sorgt PHP.
     Falls die Konfigurationsoption
     <link linkend="ini.track-vars">track_vars</link> auf "on" gesetzt ist,
     werden diese Variablen in diesen assoziativen Arrays abgelegt
     <varname>$HTTP_POST_VARS</varname>,
     <varname>$HTTP_GET_VARS</varname> und/oderr
     <varname>$HTTP_POST_FILES</varname>, entsprechend der Quelle, aus der
     die fragliche Variable kommt.
    </simpara>
     
    <para>
     Für weitere Informationen über diese Variablen lesen Sie bitte den
     Abschnitt über <link linkend="language.variables.predefined">
     Vordefinierte Variablen</link>.
    </para>     
     
    <para>
    <example>
     <title>Einfache Formular-Variablen</title>
     <programlisting role="php">
<![CDATA[
<form action="foo.php" method="post">
    Name: <input type="text" name="username"><br>
    <input type="submit">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Wird dieses Formular abgeschickt, steht der Wert des Textfeldes in der
    Variable <varname>$HTTP_POST_VARS['username']</varname> zur Verfügung.
    Wenn in der Konfigurationsdatei die Option
    <link linkend="ini.register-globals">register_globals</link>
    auf "on" gesetzt ist, steht die Variable auch als
    <varname>$username</varname> global zur Verfügung.
   </simpara>

    <note>
     <para>
      Die Konfigurationseinstellung zu
      <link linkend="ini.magic-quotes-gpc">magic_quotes_gpc</link> 
      betrifft Get, Post and Cookie Werte. Ist diese Einstellung aktiv
      wird der Wert (It's "PHP!") automatisch zu (It\'s \"PHP!\").
      Escaping ist notwendig, wenn Sie ihre Daten in eine Datenbank einfügen
      wollen. Siehe auch: <function>addslashes</function>,
      <function>stripslashes</function> und 
      <link linkend="ini.magic-quotes-sybase">magic_quotes_sybase</link>.
     </para>
    </note>


   <simpara>
    Im Zusammenhang mit Formular-Variablen versteht PHP auch
    Arrays (siehe auch die <link linkend="faq.html">verwandte Faq</link>).
    Sie können z.B. die betreffenden Variablen gruppieren oder dieses
    Leistungsmerkmal nutzen, um Werte aus Mehrfach-Auswahl-Bereichen
    zu erhalten.
   </simpara>
   <para>
    <example>
     <title>Komplexere Formular-Variablen</title>
      <programlisting role="php">
<![CDATA[
<form action="array.php" method="post">
    Name:  <input type="text" name="personal[name]"><br>
    Email: <input type="text" name="personal[email]"><br>
    Bier: <br>
    <select multiple name="bier[]">
        <option value="binding">Binding
        <option value="warsteiner">Warsteiner
        <option value="stauder">Stauder
        <option value="stuttgarter">Stuttgarter Schwabenbräu
    </select>
    <input type="submit">
</form>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     In PHP 3 ist die Verwendung von Arrays in Formularvariablen auf
     eindimensionale Arrays beschränkt. In PHP 4 besteht diese Einschränkung
     nicht mehr.
    </para>

    <sect3 id="language.variables.external.form.submit">
     <title>IMAGE SUBMIT Variablen-Bezeichner</title>
     <simpara>
      Zur Übertragung eines Formulars kann auch ein Bild (Image)
      statt eines Übertragungs-Schalters (Submit-Button) benutzt
      werden, dessen Tag wie folgt aussieht:
     </simpara>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<input type="image" src="image.gif" name="sub">
]]>
      </programlisting>
     </informalexample>
     <simpara>
      Klickt der Benutzer irgendwo auf das Bild, wird das entsprechende
      Formular an den Web-Server übertragen. Hierbei sind zwei
      zusätzliche Variablen vorhanden, sub_x und sub_y. Diese enthalten
      die Koordinaten des Klick-Punktes innerhalb des Bildes. Die
      Erfahreneren werden sagen, dass die Variablen, die vom Browser gesendet
      werden einen Punkt enthalten statt eines Unterstrichs. Dieser Punkt
      wird von PHP automatisch in einen Unterstrich verwandelt.
     </simpara>
    </sect3>

   </sect2>

   <sect2 id="language.variables.external.cookies">
    <title>HTTP-Cookies</title>
    <simpara>
     PHP unterstützt HTTP-Cookies, wie sie in <ulink
     url="&spec.cookies;">Netscape's Spec</ulink> definiert sind.
     Cookies ermöglichen die Daten-Speicherung innerhalb der jeweiligen
     Browser-Umgebung zur Weiterleitung oder wiederholten Identifikation von
     Benutzern. Sie können Cookies erzeugen, indem sie die Funktion
     <function>setcookie</function> benutzen. Cookies sind Teil des
     HTTP-Headers, deshalb muss die setcookie-Funktion aufgerufen werden,
     bevor irgendeine Ausgabe an den Browser gesendet wird. Dabei handelt es
     sich um die gleiche Einschränkung, die auch für die
     <function>header</function>-Funktion gilt. Alle Cookies, die der Client
     an sie sendet werden in PHP-Variablen umgesetzt, genau wie die Daten
     bei den GET- und POST-Methoden.
    </simpara>
    <simpara>
     Wenn sie einem einzelnen Cookie mehrere Wert zuweisen wollen
     müssen sie dem Cookie-Namen <emphasis>[]</emphasis> hinzufügen.
     Z.B.:
    </simpara>
    <informalexample>
     <programlisting role="php">
<![CDATA[
SetCookie ("MeinCookie[]", "Ich teste", time()+3600);
]]>
     </programlisting>
    </informalexample>
    <simpara>
     Bedenken sie, dass ein Cookie ein vorhergehendes Cookie
     gleichen Namens überschreibt, es sei denn, der Pfad oder
     die Domain ist anders. Für eine Warenkorb-Anwendung können
     Sie deshalb z.B. einen Zähler bilden und diesen weiterleiten:
    </simpara>
    <example>
     <title>SetCookie-Beispiel</title>
     <programlisting role="php">
<![CDATA[
$Count++;
setcookie("Count", $Count, time()+3600);
setcookie("Cart[$Count]", $item, time()+3600);
]]>
     </programlisting>
    </example>
   </sect2>

   <sect2 id="language.variables.external.environment">
    <title>Umgebungs- / Environment-Variablen</title>

    <para>
     PHP sorgt automatisch für die Verfügbarkeit der Umgebungs-
     Variablen als normale PHP-Variablen.
     <informalexample>
      <programlisting role="php">
<![CDATA[
echo $HOME;  /* Zeigt die HOME-Umgebungs-Variable (sofern gesetzt). */
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Da Informationen per GET, POST und Cookie-Mechanismen übergeben
     werden, ist es manchmal das Beste, Umgebungs-Variablen explizit
     auszulesen. Dadurch wird die richtige Version eingelesen. Hierfür
     kann die <function>getenv</function>-Funktion genutzt werden. Den
     Wert einer Umgebungs-Variablen können Sie per <function>putenv</function>-
     Funktion setzen.
    </para>
   </sect2>

   <sect2 id="language.variables.external.dot-in-names">
    <title>Punkte in eingelesenen Variablen-Bezeichnern</title>
    <para>
     Normalerweise verändert PHP die Variablen-Bezeichner nicht,
     wenn sie einem Skript übergeben werden. Es sollte aber beachtet
     werden, dass der Punkt (".") kein gültiger Bestandteil eines
     Variablen-Bezeichners ist. Deshalb achten sie auf folgendes:
     <programlisting role="php">
<![CDATA[
$varname.ext;  /* ungültiger Variablen-Bezeichner */
]]>
     </programlisting>
     Der PHP-Parser sieht eine Variable namens <varname>$varname</varname>,
     gefolgt von einem Zeichenketten-Verbindungs-Operator, dieser wiederrum
     gefolgt von der offenen Zeichenkette 'ext' (also nicht eingegrenzt
     durch '"' und auch keinem Schlüssel oder reserviertem Bezeichner
     entsprechend). Das kann natürlich nicht zum gewünschten Ergebnis
     führen.
    </para>
    <para>
     Deshalb ist es wichtig zu wissen, dass PHP in den ihm übergebenen
     Variablen alle Punkte (.) automatisch durch einen 
     Unterstrich (_) ersetzt.
    </para>
   </sect2>

   <sect2  id="language.variables.determining-type-of">
    <title>Bestimmung des Variablen-Typs</title>
    <para>
     Da PHP den Typ der Variablen bestimmt und (im Allgemeinen) selbst
     eine entsprechende Umformung vornimmt, ist es nicht immer klar,
     welchen Typ eine Variable gerade hat. PHP beinhaltet einige
     Funktionen, die dies herausfinden. Als da sind:
     <function>gettype</function>, <function>is_long</function>,
     <function>is_double</function>, <function>is_string</function>,
     <function>is_array</function> und
     <function>is_object</function>.
    </para>
   </sect2>

  </sect1>
     
 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

