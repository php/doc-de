<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 337865 Maintainer: POli Bahn Status: wip -->
<!-- Reviewed: no -->

<chapter xml:id="language.generators" xmlns="http://docbook.org/ns/docbook">
 <title>Generatoren</title>

 <sect1 xml:id="language.generators.overview">
  <title>Generatoren Übersicht</title>
  <?phpdoc print-version-for="generators"?>

  <para>
   Generatoren stellen einen einfachen Weg bereit einfache 
   <link linkend="language.oop5.iterations">Iterationen</link> zu erstellen, 
   ohne den Overhead oder die Komplexität zur Erstellung einer Klasse zu haben, 
   die das <classname>Iterator</classname> Interface implementieren.
  </para>

  <para>
   Ein Generator ermöglicht es Code zu schreiben, der &foreach; nutzt, um über
   ein Set von Daten zu iterieren, ohne ein Array im Speicher zu erzeugen,
   was zur Überschreitung des Speicherlimits führen kann oder beträchtliche
   Prozessorzeit benötigt. Alternativ können Sie eine Generatorfunktion
   schreiben, die der normalen <link
   linkend="functions.user-defined">Funktion</link> entspricht, bei der aber
   keine einmalige <link linkend="functions.returning-values">Rückgabe</link>
   erfolgt, sondern der Generator so oft wie nötig einen Wert produziert
   (siehe &yield;), um die Werte zu liefern, über die iteriert werden soll.
  </para>

  <para>
   Ein einfaches Beispiel dazu ist, die <function>range</function>-Funktion
   durch einen Generator neu implementieren. Die
   Standard-<function>range</function>-Funktion generiert und liefert Arrays,
   welche jeden Wert enthalten, was große Arrays zur Folge haben kann: zum
   Beispiel hat der Aufruf <command>range(0, 1000000)</command> zur Folge,
   dass weit über 100 MB an Speicher benötigt werden.
  </para>

  <para>
   Als Alternative können wir einen <literal>xrange()</literal> Generator 
   implementieren, welcher immer nur genug Speicher benötigt, um ein
   <classname>Iterator</classname>-Objekt zu erzeugen, und verfolgt den
   aktuellen Zustand des Generators intern, was weniger als 1 Kilobyte
   benötigt.
  </para>

  <example>
   <title>Implementierung einer <function>range</function> als ein Generator</title>
   <programlisting role="php">
<![CDATA[
<?php
function xrange($start, $limit, $step = 1) {
    if ($start < $limit) {
        if ($step <= 0) {
            throw new LogicException('Schrittweite muss +ve sein');
        }

        for ($i = $start; $i <= $limit; $i += $step) {
            yield $i;
        }
    } else {
        if ($step >= 0) {
            throw new LogicException('Schrittweite muss -ve sein');
        }

        for ($i = $start; $i >= $limit; $i += $step) {
            yield $i;
        }
    }
}

/*
 * Hinweis: beide unteren Funktionen range() und xrange() 
 * erzeugen die gleiche Ausgabe.
 */

echo 'Einstellige ungerade Zahl aus range():  ';
foreach (range(1, 9, 2) as $zahl) {
    echo "$zahl ";
}
echo "\n";

echo 'Einstellige ungerade Zahl aus xrange(): ';
foreach (xrange(1, 9, 2) as $zahl) {
    echo "$zahl ";
}
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Einstellige ungerade Zahl aus range():  1 3 5 7 9 
Einstellige ungerade Zahl aus xrange(): 1 3 5 7 9 
]]>
   </screen>
  </example>

  <sect2 xml:id="language.generators.object">
   <title><classname>Generator</classname> Objekte</title>
   <para>
    Beim ersten Aufruf einer Generatorfunktion wird ein Objekt der internen
    <classname>Generator</classname>-Klasse zurückgeliefert. Dieses Objekt
    implementiert das <classname>Iterator</classname>-Interface in gleicher
    Weise wie es ein forward-only Iterator-Objekt machen würde und stellt
    Methoden zur Verfügung, die aufgerufen werden können, um den Zustand des
    Generators, einschließlich des Sendens von Werten an ihn und des
    Zurückgebens von Werten von ihm, zu manipulieren.
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="language.generators.syntax">
  <title>Generator Syntax</title>

  <para>
   Eine Generatorfunktion sieht genau so aus wie eine normale Funktion mit
   Ausnahme, dass nicht ein Wert zurückgeliefert wird, sondern ein Generator
   liefert so viele Werte zurück, wie nötig sind (Stichwort: &yield;).
  </para>

  <para>
   Wenn eine Generatorfunktion aufgerufen wird, wird ein Objekt
   zurückgeliefert. Wenn Sie über dieses Objekt iterieren (zum Beispiel, via
   einer &foreach;-Schleife), wird PHP die Generatorfunktion so oft aufrufen,
   wie Werte benötigt werden, dann wird der Status des Generators gesichert,
   so dass fortgefahren werden kann, wenn der nächste Wert benötigt wird.
  </para>

  <para>
   Sobald keine weiteren Werte zurückgeliefert werden können, kann die
   Generatorfunktion einfach beendet werden, und der rufende Code wird
   fortgesetzt als gäbe es keine weiteren Werte in einem Array.
  </para>

  <note>
   <para>
    Ein Generator kann keine Werte zurückliefern: macht man dies, wird ein
    Kompilierungsfehler zurückgeliefert. Eine leere <command>return</command>
    Anweisung ist eine gültige Syntax innerhalb eines Generators und wird den
    Generator beenden.
   </para>
  </note>

  <sect2 xml:id="control-structures.yield">
   <title><command>yield</command> Schlüsselwort</title>

   <para>
    Das Herz einer Generatorfunktion ist das
    <command>yield</command>-Schlüsselwort. In seiner einfachsten Form sieht
    das yield-Schlüsselwort wie eine return Anweisung aus, ausser dass die
    Ausführung mit der Rückgabe nicht beendet wird, sondern yield vielmehr
    einen Wert für den Code bereitstellt über den der Generator schleift, und
    solange die Generatorfunktion pausiert.
   </para>

   <example>
    <title>Ein einfaches Beispiel zum produzieren (yielding) von Werten</title>
    <programlisting role="php">
<![CDATA[
<?php
function generiere_eins_bis_drei() {
    for ($i = 1; $i <= 3; $i++) {
        // Hinweis: $i bleibt zwischen den yields erhalten.
        yield $i;
    }
}

$generator = generiere_eins_bis_drei();
foreach ($generator as $wert) {
    echo "$wert\n";
}
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
1
2
3
]]>
    </screen>
   </example>

   <note>
    <para>
     Intern werden sequentielle Integer-Schlüssel mit den produzieren Werten
     verknüpft, so wie mit einem nicht-assoziativem Array.
    </para>
   </note>

   <caution>
    <para>
     Wenn Sie yield in einem Anweisungskontext nutzen (beispielsweise auf der
     rechten Seite einer Zuweisung), dann müssen Sie die yield-Anweisung in
     PHP 5 innerhalb von Klammern schreiben. Beispielsweise ist folgender
     Befehl gültig:
    </para>

    <informalexample>
     <programlisting role="php">
<![CDATA[
      $daten = (yield $wert);
]]>
     </programlisting>
    </informalexample>

    <para>
     Dieser Befehl ist aber nicht gültig, und wird in PHP 5 mit einem
     Syntaxfehler beendet:
    </para>

    <informalexample>
     <programlisting role="php">
<![CDATA[
      $daten = yield $wert;
]]>
     </programlisting>
    </informalexample>

    <para>
     Für PHP 7 gilt die Klammerregel nicht.
    </para>

    <para>
     Diese Syntax kann in Verbindung mit der
     <methodname>Generator::send</methodname>-Methode verwendet werden.
    </para>
   </caution>

   <sect3 xml:id="control-structures.yield.associative">
    <title>Produzieren von Werten mit Schlüsseln</title>

    <para>
     PHP unterstützt ebenfalls assoziative Arrays, und Generatoren
     unterscheiden sich nicht davon. Als Ergänzung einfacher produzierter
     Werte, wie oben gezeigt, können Sie zur gleichen Zeit auch einen
     Schlüssel zurückliefern.
    </para>

    <para>
     Die Syntax für das Produzieren eines Schlüssel/Wert-Paares ist sehr
     ähnlich wie die Definition von assoziativen Arrays. Siehe unten.
    </para>

    <example>
     <title>Produzieren eines Schlüssel/Wert Paares</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Die Eingabe sind Semikolon getrennte Felder, mit dem ersten Feld
 * welches als ID und Schlüssel genutzt wird.
 */

$eingabe = <<<'EOF'
1;PHP;mag Dollarzeichen
2;Python;mag Leerzeichen
3;Ruby;mag Blöcke
EOF;

function eingabe_parser($eingabe) {
    foreach (explode("\n", $eingabe) as $zeile) {
        $felder = explode(';', $zeile);
        $id = array_shift($felder);

        yield $id => $felder;
    }
}

foreach (eingabe_parser($eingabe) as $id => $felder) {
    echo "$id:\n";
    echo "    $felder[0]\n";
    echo "    $felder[1]\n";
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
1:
    PHP
    mag Dollarzeichen
2:
    Python
    mag Leerzeichen
3:
    Ruby
    mag Blöcke
]]>
     </screen>
    </example>

    <caution>
     <para>
      Wie oben gezeigt mit dem zurückliefern einfacher Werte, muss man beim
      Produzieren eines Schlüssel/Wert Paares im Zuweisungskontext den
      yield-Befehl einklammern:
     </para>

     <informalexample>
      <programlisting role="php">
<![CDATA[
      $daten = (yield $schluessel => $wert);
]]>
      </programlisting>
     </informalexample>
    </caution>
   </sect3>

   <sect3 xml:id="control-structures.yield.null">
    <title>Produzieren von null-Werten</title>

    <para>
     Yield kann ohne ein Argument aufgerufen werden, um ein &null; Wert mit
     einem automatischen Schlüssel zurückzuliefern.
    </para>

    <example>
     <title>Produzieren von &null;s</title>
     <programlisting role="php">
<![CDATA[
<?php
function generiere_drei_nulls() {
    foreach (range(1, 3) as $i) {
        yield;
    }
}

var_dump(iterator_to_array(generiere_drei_nulls()));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
array(3) {
  [0]=>
  NULL
  [1]=>
  NULL
  [2]=>
  NULL
}
]]>
     </screen>
    </example>
   </sect3>

   <sect3 xml:id="control-structures.yield.references">
    <title>Produzieren durch Referenzen</title>

    <para>
     Generatorfunktionen sind genauso in der Lage Werte durch Referenzen 
     zurückzuliefern wie durch Werte. Dies kann in gleicher weise erfolgen wie
     <link linkend="functions.returning-values">zurückliefern von Referenzen
     aus Funktionen</link>: dies geschieht durch voranstellen eines
     kaufmännisches Unds zum Funktionsnamen.
    </para>

    <example>
     <title>Produzieren von Werten durch Referenzen</title>
     <programlisting role="php">
<![CDATA[
<?php
function &generiere_referenz() {
    $wert = 3;

    while ($wert > 0) {
        yield $wert;
    }
}

/*
 * Hinweis: wir können $nummer innerhalb der Schleife ändern, und weil der
 * Generator Referenzen zurückliefert, wird $wert innerhalb von
 * generiere_referenz() verändert.
 */
foreach (generiere_referenz() as &$nummer) {
    echo (--$nummer).'... ';
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
2... 1... 0... 
]]>
     </screen>
    </example>
   </sect3>

   <sect3 xml:id="control-structures.yield.from">
    <title>Generator delegation via <command>yield from</command></title>

    <para>
     In PHP 7, generator delegation allows you to yield values from another
     generator, <classname>Traversable</classname> object, or
     <type>array</type> by using the <command>yield from</command> keyword.
     The outer generator will then yield all values from the inner generator,
     object, or array until that is no longer valid, after which execution
     will continue in the outer generator.
    </para>

    <para>
     If a generator is used with <command>yield from</command>, the
     <command>yield from</command> expression will also return any value
     returned by the inner generator.
    </para>

    <example>
     <title>Basic use of <command>yield from</command></title>
     <programlisting role="php">
<![CDATA[
<?php
function count_to_ten() {
    yield 1;
    yield 2;
    yield from [3, 4];
    yield from new ArrayIterator([5, 6]);
    yield from seven_eight();
    yield 9;
    yield 10;
}

function seven_eight() {
    yield 7;
    yield from eight();
}

function eight() {
    yield 8;
}

foreach (count_to_ten() as $num) {
    echo "$num ";
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
1 2 3 4 5 6 7 8 9 10 
]]>
     </screen>
    </example>

    <example>
     <title><command>yield from</command> and return values</title>
     <programlisting role="php">
<![CDATA[
<?php
function count_to_ten() {
    yield 1;
    yield 2;
    yield from [3, 4];
    yield from new ArrayIterator([5, 6]);
    yield from seven_eight();
    return yield from nine_ten();
}

function seven_eight() {
    yield 7;
    yield from eight();
}

function eight() {
    yield 8;
}

function nine_ten() {
    yield 9;
    return 10;
}

$gen = count_to_ten();
foreach ($gen as $num) {
    echo "$num ";
}
echo $gen->getReturn();
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
1 2 3 4 5 6 7 8 9 10
]]>
     </screen>
    </example>
   </sect3>
  </sect2>
 </sect1>

 <sect1 xml:id="language.generators.comparison">
  <title>Vergleich von Generatoren mit <classname>Iterator</classname>-Objekten</title>

  <para>
   Die erste Verbesserung von Generatoren ist ihre Einfachheit. Viel weniger
   überladener Code muss geschrieben werden als im Vergleich zur
   Implementierung einer <classname>Iterator</classname>-Klasse und der Code
   ist generell einfacher zu lesen. Als Beispiel dienen folgende äquivalente
   Funktion und Klasse:
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
function leseZeilenVonDatei($dateiName) {
    if (!$dateiHandle = fopen($dateiName, 'r')) {
        return;
    }
 
    while (false !== $zeile = fgets($dateiHandle)) {
        yield $zeile;
    }
 
    fclose($dateiHandle);
}

// im Gegensatz zu...

class LineIterator implements Iterator {
    protected $dateiHandle;
 
    protected $zeile;
    protected $i;
 
    public function __construct($dateiName) {
        if (!$this->dateiHandle = fopen($dateiName, 'r')) {
            throw new RuntimeException('Kann Datei "' . $dateiName . '" nicht öffnen');
        }
    }
 
    public function rewind() {
        fseek($this->dateiHandle, 0);
        $this->zeile = fgets($this->dateiHandle);
        $this->i = 0;
    }
 
    public function gueltig() {
        return false !== $this->zeile;
    }
 
    public function aktuelle() {
        return $this->zeile;
    }
 
    public function schluessel() {
        return $this->i;
    }
 
    public function naechste() {
        if (false !== $this->zeile) {
            $this->zeile = fgets($this->dateiHandle);
            $this->i++;
        }
    }
 
    public function __destruct() {
        fclose($this->dateiHandle);
    }
}
?>
]]>
   </programlisting>
  </informalexample>

  <para>
   Diese Flexibilität kommt nicht ohne Kosten, nichts desto trotz: Generatoren
   sind forward-only Iteratoren, und können nicht zurückgesetzt werden, wenn
   sie einmal gestartet wurden. Das heißt ausserdem das der selbe Generator
   nicht mehrfach iteriert werden kann: der Generator muss entweder durch
   einen erneuten Aufruf der Funktion neu erstellt werden, oder muss durch das 
   <link linkend="language.oop5.cloning">clone</link>-Schlüsselwort geklont
   werden.
  </para>
 </sect1>
</chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
