<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 337865 Maintainer: POli Bahn Status: ready -->
<!-- Reviewed: no -->

<chapter xml:id="language.generators" xmlns="http://docbook.org/ns/docbook">
 <title>Generatoren</title>

 <sect1 xml:id="language.generators.overview">
  <title>Generatoren Übersicht</title>
  <?phpdoc print-version-for="generators"?>

  <para>
   Generatoren bieten eine einfache Möglichkeit, um einfache <link
   linkend="language.oop5.iterations">Iterationen</link> zu erstellen, ohne
   den Overhead oder die Komplexität zur Erstellung einer Klasse zu haben, 
   die das <classname>Iterator</classname>-Interface implementieren.
  </para>

  <para>
   Ein Generator ermöglicht es Code zu schreiben, der &foreach; nutzt, um über
   ein Set von Daten zu iterieren, ohne ein Array im Speicher zu erzeugen,
   was zur Überschreitung des Speicherlimits führen kann oder beträchtliche
   Prozessorzeit benötigt. Alternativ können Sie eine Generatorfunktion
   schreiben, die einer normalen <link
   linkend="functions.user-defined">Funktion</link> entspricht, bei der aber
   keine einmalige <link linkend="functions.returning-values">Rückgabe</link>
   erfolgt, sondern der Generator so oft wie nötig einen Wert abgibt
   (Stichwort: &yield;), um die Werte zu liefern, über die iteriert werden
   soll.
  </para>

  <para>
   Ein einfaches Beispiel dazu ist, die <function>range</function>-Funktion
   durch einen Generator neu implementieren. Die
   Standard-<function>range</function>-Funktion generiert und liefert Arrays,
   welche jeden Wert enthalten, was große Arrays zur Folge haben kann: zum
   Beispiel hat der Aufruf <command>range(0, 1000000)</command> zur Folge,
   dass weit über 100 MB an Speicher benötigt werden.
  </para>

  <para>
   Als Alternative können wir einen <literal>xrange()</literal>-Generator 
   implementieren, welcher immer nur genug Speicher benötigt, um ein
   <classname>Iterator</classname>-Objekt zu erzeugen und intern den aktuellen
   Zustand des Generators zu verfolgen, was sich als weniger als 1 Kilobyte
   herausstellt.
  </para>

  <example>
   <title>Implementierung von <function>range</function> als Generator</title>
   <programlisting role="php">
<![CDATA[
<?php
function xrange($start, $limit, $step = 1) {
    if ($start < $limit) {
        if ($step <= 0) {
            throw new LogicException('Schrittweite muss +ve sein');
        }

        for ($i = $start; $i <= $limit; $i += $step) {
            yield $i;
        }
    } else {
        if ($step >= 0) {
            throw new LogicException('Schrittweite muss -ve sein');
        }

        for ($i = $start; $i >= $limit; $i += $step) {
            yield $i;
        }
    }
}

/*
 * Hinweis: beide unteren Funktionen range() und xrange() 
 * erzeugen die gleiche Ausgabe.
 */

echo 'Einstellige ungerade Zahl aus range():  ';
foreach (range(1, 9, 2) as $zahl) {
    echo "$zahl ";
}
echo "\n";

echo 'Einstellige ungerade Zahl aus xrange(): ';
foreach (xrange(1, 9, 2) as $zahl) {
    echo "$zahl ";
}
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Einstellige ungerade Zahl aus range():  1 3 5 7 9 
Einstellige ungerade Zahl aus xrange(): 1 3 5 7 9 
]]>
   </screen>
  </example>

  <sect2 xml:id="language.generators.object">
   <title><classname>Generator</classname>-Objekte</title>
   <para>
    Beim ersten Aufruf einer Generatorfunktion wird ein Objekt der internen
    <classname>Generator</classname>-Klasse zurückgegeben. Dieses Objekt
    implementiert das <classname>Iterator</classname>-Interface in gleicher
    Weise wie es ein forward-only Iterator-Objekt machen würde und stellt
    Methoden zur Verfügung, die aufgerufen werden können, um den Zustand des
    Generators zu manipulieren, einschließlich des Sendens von Werten an ihn
    und der Rückgabe von Werten von ihm.
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="language.generators.syntax">
  <title>Generator Syntax</title>

  <para>
   Eine Generatorfunktion sieht genau so aus wie eine normale Funktion mit
   der Ausnahme, dass ein Generator statt eines Wertes so viele Werte wie
   nötig zurückgibt (Stichwort: &yield;).
  </para>

  <para>
   Wenn eine Generatorfunktion aufgerufen wird, wird ein Objekt zurückgegeben.
   Wenn Sie über dieses Objekt iterieren (zum Beispiel, via
   &foreach;-Schleife), wird PHP die Generatorfunktion so oft aufrufen, wie
   Werte benötigt werden. Dann wird der Status des Generators gesichert,
   sodass fortgefahren werden kann, wenn der nächste Wert benötigt wird.
  </para>

  <para>
   Sobald keine weiteren Werte zurückgegeben werden können, kann die
   Generatorfunktion einfach beendet werden, und der rufende Code wird
   fortgesetzt, als gäbe es keine weiteren Werte in einem Array.
  </para>

  <note>
   <para>
    Ein Generator kann keine Werte zurückgeben: macht man dies, wird ein
    Kompilierungsfehler zurückgegeben. Eine leere
    <command>return</command>-Anweisung ist eine gültige Syntax innerhalb
    eines Generators und wird den Generator beenden.
   </para>
  </note>

  <sect2 xml:id="control-structures.yield">
   <title><command>yield</command>-Schlüsselwort</title>

   <para>
    Das Herz einer Generatorfunktion ist das
    <command>yield</command>-Schlüsselwort. In seiner einfachsten Form sieht
    das yield-Schlüsselwort wie eine return-Anweisung aus, ausser dass die
    Ausführung mit der Rückgabe nicht beendet wird, sondern yield stattdessen
    bei der Schleife über den Generator einen Wert für den Code bereitstellt
    und solange die Ausführung der Generatorfunktion anhält.
   </para>

   <example>
    <title>Ein einfaches Beispiel zum abliefern (yielding) von Werten</title>
    <programlisting role="php">
<![CDATA[
<?php
function generiere_eins_bis_drei() {
    for ($i = 1; $i <= 3; $i++) {
        // Hinweis: $i bleibt zwischen den yields erhalten.
        yield $i;
    }
}

$generator = generiere_eins_bis_drei();
foreach ($generator as $wert) {
    echo "$wert\n";
}
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
1
2
3
]]>
    </screen>
   </example>

   <note>
    <para>
     Intern werden sequentielle Integer-Schlüssel mit den abgelieferten Werten
     verknüpft, so wie mit einem nicht-assoziativen Array.
    </para>
   </note>

   <caution>
    <para>
     Wenn Sie yield in einem Anweisungskontext nutzen (beispielsweise auf der
     rechten Seite einer Zuweisung), dann müssen Sie die yield-Anweisung in
     PHP 5 innerhalb von Klammern schreiben. Beispielsweise ist folgender
     Befehl gültig:
    </para>

    <informalexample>
     <programlisting role="php">
<![CDATA[
      $daten = (yield $wert);
]]>
     </programlisting>
    </informalexample>

    <para>
     Aber dieser Befehl ist nicht gültig und wird in PHP 5 mit einem
     Syntaxfehler beendet:
    </para>

    <informalexample>
     <programlisting role="php">
<![CDATA[
      $daten = yield $wert;
]]>
     </programlisting>
    </informalexample>

    <para>
     Für PHP 7 gilt die Klammerregel nicht.
    </para>

    <para>
     Diese Syntax kann in Verbindung mit der
     <methodname>Generator::send</methodname>-Methode verwendet werden.
    </para>
   </caution>

   <sect3 xml:id="control-structures.yield.associative">
    <title>Produzieren von Werten mit Schlüsseln</title>

    <para>
     PHP unterstützt ebenfalls assoziative Arrays, und Generatoren
     unterscheiden sich nicht davon. Als Ergänzung zum Produzieren einfacher
     Werte, wie oben gezeigt, können Sie zur gleichen Zeit auch einen
     Schlüssel abliefern.
    </para>

    <para>
     Die Syntax für das Produzieren eines Schlüssel/Wert-Paares ist sehr
     ähnlich wie die Definition von assoziativen Arrays. Siehe unten.
    </para>

    <example>
     <title>Produzieren eines Schlüssel/Wert-Paares</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Die Eingabe sind Semikolon getrennte Felder, mit dem ersten Feld
 * welches als ID und Schlüssel genutzt wird.
 */

$eingabe = <<<'EOF'
1;PHP;mag Dollarzeichen
2;Python;mag Leerzeichen
3;Ruby;mag Blöcke
EOF;

function eingabe_parser($eingabe) {
    foreach (explode("\n", $eingabe) as $zeile) {
        $felder = explode(';', $zeile);
        $id = array_shift($felder);

        yield $id => $felder;
    }
}

foreach (eingabe_parser($eingabe) as $id => $felder) {
    echo "$id:\n";
    echo "    $felder[0]\n";
    echo "    $felder[1]\n";
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
1:
    PHP
    mag Dollarzeichen
2:
    Python
    mag Leerzeichen
3:
    Ruby
    mag Blöcke
]]>
     </screen>
    </example>

    <caution>
     <para>
      Wie oben mit dem Zurückgeben einfacher Werte gezeigt, muss man beim
      Produzieren eines Schlüssel/Wert-Paares im Zuweisungskontext den
      yield-Befehl einklammern:
     </para>

     <informalexample>
      <programlisting role="php">
<![CDATA[
      $daten = (yield $schluessel => $wert);
]]>
      </programlisting>
     </informalexample>
    </caution>
   </sect3>

   <sect3 xml:id="control-structures.yield.null">
    <title>Produzieren von null-Werten</title>

    <para>
     Yield kann ohne ein Argument aufgerufen werden, um einen &null;-Wert mit
     einem automatischen Schlüssel zurückzugeben.
    </para>

    <example>
     <title>Produzieren von &null;s</title>
     <programlisting role="php">
<![CDATA[
<?php
function generiere_drei_nulls() {
    foreach (range(1, 3) as $i) {
        yield;
    }
}

var_dump(iterator_to_array(generiere_drei_nulls()));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
array(3) {
  [0]=>
  NULL
  [1]=>
  NULL
  [2]=>
  NULL
}
]]>
     </screen>
    </example>
   </sect3>

   <sect3 xml:id="control-structures.yield.references">
    <title>Produzieren durch Referenzen</title>

    <para>
     Generatorfunktionen sind genauso in der Lage Werte durch Referenzen 
     zurückzugeben, wie durch Werte. Dies kann in gleicher Weise erfolgen, wie
     beim <link linkend="functions.returning-values">zurückgeben von
     Referenzen aus Funktionen</link>: dies geschieht durch Voranstellen eines
     kaufmännischen Unds zum Funktionsnamen.
    </para>

    <example>
     <title>Produzieren von Werten durch Referenzen</title>
     <programlisting role="php">
<![CDATA[
<?php
function &generiere_referenz() {
    $wert = 3;

    while ($wert > 0) {
        yield $wert;
    }
}

/*
 * Hinweis: wir können $nummer innerhalb der Schleife ändern,
 * und weil der Generator Referenzen zurückgibt, wird $wert
 * innerhalb von generiere_referenz() verändert.
 */
foreach (generiere_referenz() as &$nummer) {
    echo (--$nummer).'... ';
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
2... 1... 0... 
]]>
     </screen>
    </example>
   </sect3>

   <sect3 xml:id="control-structures.yield.from">
    <title>Generatordelegation via <command>yield from</command></title>

    <para>
     In PHP 7 ermöglicht die Generatordelegation mittels <command>yield
     from</command>-Ausdruck Werte von einem anderen Generator,
     <classname>Traversable</classname>-Ojekt oder <type>array</type>
     abliefern zu lassen. Der äußere Generator liefert dann alle Werte vom
     inneren Generator, Objekt oder Array ab, bis dieser nicht mehr gültig
     ist und die Ausführung mit dem äußeren Generator fortfährt.
    </para>

    <para>
     Falls ein Generator mit <command>yield from</command> verwendet wird,
     gibt der <command>yield from</command>-Ausdruck auch alle Werte zurück,
     die vom inneren Generator zurückgegeben werden.
    </para>

    <example>
     <title>Grundlegende Verwendung von <command>yield from</command></title>
     <programlisting role="php">
<![CDATA[
<?php
function zaehle_bis_zehn() {
    yield 1;
    yield 2;
    yield from [3, 4];
    yield from new ArrayIterator([5, 6]);
    yield from sieben_acht();
    yield 9;
    yield 10;
}

function sieben_acht() {
    yield 7;
    yield from acht();
}

function acht() {
    yield 8;
}

foreach (zaehle_bis_zehn() as $zahl) {
    echo "$zahl ";
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
1 2 3 4 5 6 7 8 9 10 
]]>
     </screen>
    </example>

    <example>
     <title><command>yield from</command> und Rückgabewerte</title>
     <programlisting role="php">
<![CDATA[
<?php
function zaehle_bis_zehn() {
    yield 1;
    yield 2;
    yield from [3, 4];
    yield from new ArrayIterator([5, 6]);
    yield from sieben_acht();
    return yield from neun_zehn();
}

function sieben_acht() {
    yield 7;
    yield from acht();
}

function acht() {
    yield 8;
}

function neun_zehn() {
    yield 9;
    return 10;
}

$gen = zaehle_bis_zehn();
foreach ($gen as $zahl) {
    echo "$zahl ";
}
echo $gen->getReturn();
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
1 2 3 4 5 6 7 8 9 10
]]>
     </screen>
    </example>
   </sect3>
  </sect2>
 </sect1>

 <sect1 xml:id="language.generators.comparison">
  <title>Vergleich von Generatoren mit <classname>Iterator</classname>-Objekten</title>

  <para>
   Die erste Verbesserung von Generatoren ist ihre Einfachheit. Viel weniger
   überladener Code muss geschrieben werden als im Vergleich zur
   Implementierung einer <classname>Iterator</classname>-Klasse und der Code
   ist generell einfacher zu lesen. Als Beispiel dienen folgende äquivalente
   Funktion und Klasse:
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
function leseZeilenVonDatei($dateiName) {
    if (!$dateiHandle = fopen($dateiName, 'r')) {
        return;
    }
 
    while (false !== $zeile = fgets($dateiHandle)) {
        yield $zeile;
    }
 
    fclose($dateiHandle);
}

// im Gegensatz zu...

class LineIterator implements Iterator {
    protected $dateiHandle;
 
    protected $zeile;
    protected $i;
 
    public function __construct($dateiName) {
        if (!$this->dateiHandle = fopen($dateiName, 'r')) {
            throw new RuntimeException('Kann Datei "' . $dateiName . '" nicht öffnen');
        }
    }
 
    public function rewind() {
        fseek($this->dateiHandle, 0);
        $this->zeile = fgets($this->dateiHandle);
        $this->i = 0;
    }
 
    public function gueltig() {
        return false !== $this->zeile;
    }
 
    public function aktuelle() {
        return $this->zeile;
    }
 
    public function schluessel() {
        return $this->i;
    }
 
    public function naechste() {
        if (false !== $this->zeile) {
            $this->zeile = fgets($this->dateiHandle);
            $this->i++;
        }
    }
 
    public function __destruct() {
        fclose($this->dateiHandle);
    }
}
?>
]]>
   </programlisting>
  </informalexample>

  <para>
   Diese Flexibilität kommt allerdings nicht ohne Preis: Generatoren sind
   forward-only-Iteratoren, und können nicht zurückgesetzt werden, wenn sie
   einmal gestartet wurden. Das heißt außerdem, dass der selbe Generator nicht
   mehrfach iteriert werden kann: der Generator muss entweder durch einen
   erneuten Aufruf der Funktion neu erstellt werden, oder muss durch das 
   <link linkend="language.oop5.cloning">clone</link>-Schlüsselwort geklont
   werden.
  </para>
 </sect1>
</chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
