<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.35 $ -->
<!-- EN-Revision: 1.82 Maintainer: betz Status: ready -->
 <chapter id="language.types">
  <title>Typen</title>

  <sect1 id="language.types.intro">
  <title>Einführung</title>
  <simpara>
   PHP unterstützt acht primitive Typen.
  </simpara>

  <para>
   Vier skalare Typen:
   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.boolean">Boolean</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.integer">Integer</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.float">Fließkomma-Zahl (float)</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.string">String / Zeichenkette</link>
     </simpara>
    </listitem>

   </itemizedlist>

   Zwei zusammengesetzte Typen:

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.array">Array</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.object">Object</link>
     </simpara>
    </listitem>

   </itemizedlist>

   Und zuletzt zwei spezielle Typen:

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.resource">Resource</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.null">NULL</link>
     </simpara>
    </listitem>

   </itemizedlist>
  </para>

  <note>
   <simpara>
    In diesem Manual werden Sie oft <literal>mixed</literal> Parameter
    finden. Diese Pseudo-Typen weisen darauf hin, dass es mehrere Möglichkeiten
    für diesen Parameter gibt.
   </simpara>
  </note>



  <simpara>
   Der Typ einer Variabalen wird normalerweise nicht vom Programmierer
   bestimmt. Zur Laufzeit von PHP wird entschieden, welchen Typs eine
   Variable ist, abhängig vom Zusammenhang in dem die Variable benutzt wird.
  </simpara>
  <note>
   <simpara>
    Um den Typ und den Wert eines bestimmten
    <link linkend="language.expressions">Ausdrucks (Expression)</link>
    zu überprüfen, können Sie <function>var_dump</function> benutzen.
   </simpara>
   <simpara>
    Wenn Sie zur Fehlersuche einfach nur eine lesbare Darstellung
    eines Typs benötigen, benutzen Sie <function>gettype</function>.
    Um auf einen bestimmten Typ zu prüfen, sollten Sie <emphasis>nicht</emphasis>
    <function>gettype</function> benutzen. Stattdessen sollten Sie die
    <literal>is_<replaceable>type</replaceable></literal> Funktionen verwenden.
   </simpara>
  </note>
   <simpara>
    Wenn sie die Umwandlung in einen bestimmten Variablen-Typ erzwingen
    wollen, erreichen Sie dies entweder durch
    <link linkend="language.types.typecasting">cast</link> oder durch
    Gebrauch der Funktion <function>settype</function>.
   </simpara>
  <simpara>
   Beachten Sie, dass sich eine Variable in bestimmten Situationen
   unterschiedlich verhalten kann, abhängig vom Typ dem die Variable zu dem
   Zeitpunkt entspricht. Weitere Informationen entnehmen Sie dem Abschnitt zur
   <link linkend="language.types.type-juggling">Typ-Veränderung</link>.
  </simpara>
  </sect1>

   <sect1 id="language.types.boolean">
    <title>Boolscher Typ</title>
    
    <simpara>
     Das ist der einfachste Typ. Ein <type>boolean</type> drückt einen
     Wahrheitswert aus. Dieser kann entweder &true; oder &false; sein.
    </simpara>

    <note>
     <simpara>
      Der boolsche Typ wurde in PHP 4 eingeführt.
     </simpara>
    </note>

    <sect2 id="language.types.boolean.syntax">
     <title>Syntax</title>
     <para>
      Um einen boolschen Typ wörtlich anzugeben, benutzen Sie entweder 
      das Schlüsselwort &true; oder &false;.
      Beide unterscheiden sich nicht bezüglich der Groß- und Kleinschreibung.
     <informalexample>
       <programlisting role="php">
<![CDATA[
$foo = True; // $foo wird der Wert TRUE zugewiesen
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Üblicherweise verwenden Sie einen der 
      <link linkend="language.operators">Operatoren</link>, der Ihnen
      einen <type>boolean</type> Wert liefert, den Sie dann an eine der
      <link linkend="control-structures">Kontroll-Strukturen</link> weiterreichen.
      <informalexample>
       <programlisting role="php">
<![CDATA[
// == ist ein Vergleichs-Operator der einen boolschen Wert liefert
if ($action == "show_version") {
    echo "Die Version ist 1.23";
}

// Das ist nicht notwendig:
if ($show_separators == TRUE) {
    echo "<hr>\n";
}

// weil Sie einfach folgendes schreiben können:
if ($show_separators) {
    echo "<hr>\n";
}
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>

    <sect2 id="language.types.boolean.casting">
     <title>Umwandlung nach boolean</title>
      <simpara>
       Um einen Wert ausdrücklich nach <type>boolean</type> zu konvertieren
       benutzen Sie entweder die Umwandlung mittels
       <literal>(bool)</literal> oder <literal>(boolean)</literal>.
       In den allermeisten Fällen ist es jedoch nicht notwendig die
       Umwandlung selbst vorzunehmen. Ein Wert wird automatisch konvertiert,
       falls ein Operator, eine Funktion oder eine Kontrollstruktur ein
       <type>boolean</type> Argument erfordert.
      </simpara>
      <simpara>
       Siehe auch
      <link linkend="language.types.type-juggling">Typ-Veränderung</link>.
      </simpara>
      
      <para>
       Bei der Umwandlung nach <type>boolean</type> werden folgende Werte
       als &false; angesehen:

       <itemizedlist>

        <listitem>
         <simpara>das <link linkend="language.types.boolean">boolean</link> 
          &false;
         </simpara>
        </listitem>

        <listitem>
         <simpara>die
          <link linkend="language.types.integer">Integer</link> 0 (Null)
         </simpara>
        </listitem>

        <listitem>
         <simpara>die
          <link linkend="language.types.float">Fließkomma-Zahl</link> 0.0 (Null)
         </simpara>
        </listitem>

        <listitem>
         <simpara>die leere
          <link linkend="language.types.string">Zeichenkette</link>
          und die
          <link linkend="language.types.string">Zeichenkette</link> "0"
         </simpara>
        </listitem>

        <listitem>
         <simpara>ein <link linkend="language.types.array">Array</link>
          ohne Elemente
         </simpara>
        </listitem>

        <listitem>
         <simpara>ein <link linkend="language.types.object">Objekt</link>
          ohne Elemente
         </simpara>
        </listitem>

        <listitem>
         <simpara>der spezielle Type
          <link linkend="language.types.null">NULL</link>
          (einschließlich nicht definierter Variablen)
         </simpara>
        </listitem>

       </itemizedlist>

       Jeder andere Wert wird als &true; angesehen (einschließlich jeder
       <link linkend="language.types.resource">Resource</link>).
       <warning>
        <simpara>
         <literal>-1</literal> wird als 
         &true; angesehen, wie jede andere Zahl ungleich Null
         (egal ob negativ oder positiv)!
        </simpara>
       </warning>
      </para>
     
    </sect2>

   </sect1>

  <sect1 id="language.types.integer">
   <title>Integer Typen</title>

    <simpara>
     Ein <type>Integer</type> ist eine Nummer aus der Menge
     Z = {..., -2, -1, 0, 1, 2, ...}.
    </simpara>

    <para>
     Siehe auch:
     <link linkend="ref.gmp">Ganzzahlen beliebiger Länge</link> und
     <link linkend="language.types.float">Fließkomma-Zahlen</link>
    </para>

    <sect2 id="language.types.integer.syntax">
     <title>Syntax</title>
     <simpara>
      Ganzzahlen können in dezimaler (10-basierter), hexadezimaler
      (16-basierter) oder oktaler (8-basierter) Schreibweise angegeben
      werden, wahlweise mit einem vorangestellten Zeichen (- oder +).
     </simpara>
     <para>
      Wenn Sie die oktale Schreibweise verwenden, müssen Sie die Zahl mit
      einer vorangestellten Null <literal>0</literal> schreiben; in
      hexadezimaler Schreibweise müssen Sie vor die Zahl ein
      <literal>0x</literal> schreiben.
      <example>
       <title>Integer Literale</title>
       <programlisting role="php">
<![CDATA[
$a = 1234; // Dezimalzahl
$a = -123; // eine negative Zahl
$a = 0123; // Oktalzahl (entspricht 83 dezimal)
$a = 0x1A; // Hexadezimalzahl (entspricht 26 dezimal)
]]>
       </programlisting>
      </example>
      Die Größe eines Integer-Wertes ist plattformabhängig, ein
      Maximalwert von ungefähr zwei Milliarden ist jedoch üblich.
      (Vorzeichenbehafteter 32-Bit-Wert). PHP unterstützt keine 
      vorzeichenlose Integer-Werte.
     </para>
    </sect2>
   
    <sect2 id="language.types.integer.overflow">
     <title>Integer Überlauf</title>
     <para>
      Wenn Sie eine Zahl jenseits der Grenzen des Typs <type>Integer</type>
      angeben, wird diese stattdessen als Typ <type>float</type> interpretiert.
      Wenn Sie eine Operation ausführen, deren Ergebnis eine Zahl
      jenseits der Grenzen des Typs <type>Integer</type> ist, wird ebenso eine
      Zahl vom Typ <type>float</type> zurückgegeben.

      <informalexample>
       <programlisting role="php">
<![CDATA[
$large_number =  2147483647;
var_dump($large_number);
// Ausgabe: int(2147483647)

$large_number =  2147483648;
var_dump($large_number);
// Ausgabe: float(2147483648)

// das gilt auch für Integers in hexadezimaler Schreibweise:
var_dump( 0x80000000 );
// Ausgabe: float(2147483648)

$million = 1000000;
$large_number =  50000 * $million;
var_dump($large_number);
// Ausgabe: float(50000000000)
]]>
       </programlisting>
      </informalexample>
      <warning>
       <simpara>
        Bedauerlicherweise gab es einen Bug in PHP, der die korrekte
        Funktionsweise verhinderte, wenn negative Zahlen verwendet wurden.
        Ein Beispiel: Bei der Ausführung von
        <literal>-50000 * $million</literal> war das Ergebnis
        <literal>-429496728</literal>. Sind beide Operanden positiv gibt
        gibt es keine Probleme.
       </simpara>
       <simpara>
        Dieses Problem ist in PHP 4.1.0 behoben.
       </simpara>
      </warning>
     </para>
     <para>
      In PHP gibt es keinen Operator für Integer Divisonen.
      <literal>1/2</literal> ergibt <type>float</type>
      <literal>0.5</literal>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
var_dump( 25/7 );
// Ausgabe: float(3.5714285714286)
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>
   

    <sect2 id="language.types.integer.casting">
     <title>Umwandlung nach Integer</title>
      <simpara>
       Um einen Wert ausdrücklich nach <type>integer</type> zu konvertieren
       benutzen Sie entweder die Umwandlung mittels
       <literal>(int)</literal> oder <literal>(integer)</literal>.
       In den allermeisten Fällen ist es jedoch nicht notwendig die
       Umwandlung selbst vorzunehmen. Ein Wert wird automatisch konvertiert,
       falls ein Operator, eine Funktion oder eine Kontrollstruktur ein
       <type>integer</type> Argument erfordert.
      </simpara>
      <simpara>
       Siehe auch <link linkend="language.types.type-juggling">Typ-Veränderung</link>.
      </simpara>
      
      <sect3 id="language.types.integer.casting.from-boolean">
       <title>Von
        <link linkend="language.types.boolean">Booleans</link>
       </title>
       <simpara>
        &false; ergibt
        <literal>0</literal> (Null), und &true; 
        ergibt <literal>1</literal> (eins).
       </simpara>
      </sect3>

      <sect3 id="language.types.integer.casting.from-float">
       <title>Von
        <link linkend="language.types.float">Fließkomma-Zahlen</link>
       </title> 
       <simpara>
        Bei der Umwandlung von <type>float</type> nach integer wird die Zahl
        <emphasis>in Richtung Null</emphasis> gerundet.
       </simpara>
       
       <para>
        Wenn der float jenseits der Grenzen von integer liegt
       (üblicherweise <literal>+/- 2.15e+9 = 2^31</literal>), 
        ist das Ergebnis nicht definiert, weil float nicht genug
        Präzision besitzt um ein genaues integer Ergebnis zu liefern.
        Keine Warnung, nicht einmal eine Notiz wird in diesem Fall ausgegeben.
       </para>
       
       <warning>
       <para>
        Wandeln Sie nie einen Teil eines Ausdrucks nach <type>integer</type> um,
        da dies manchmal zu unerwarteten Ergebnissen führen kann.
        <informalexample>
         <programlisting role="php">
<![CDATA[
echo (int) ( (0.1+0.7) * 10 ); // Ausgabe: 7!
]]>
         </programlisting>
        </informalexample>
        Für mehr Informationen schauen Sie unter
        <link linkend="warn.float-precision">Warnung über float-Präzision</link>
        nach.
       </para>
       </warning>
      </sect3>
      
      <sect3 id="language.types.integer.casting.from-string">
       <title>Von Zeichenketten/ Strings</title>
       <simpara>
        Siehe
        <link linkend="language.types.string.conversion">String Umwandlung</link>
       </simpara>
      </sect3>
      
      <sect3 id="language.types.integer.casting.from-other">
       <title>Von anderen Typen</title>
       <para>
        <caution>
         <simpara>
          Das Verhalten bei der Umwandlung nach integer ist für andere
          Typen nicht definiert. Zum gegenwärtigen Zeitpunkt ist das Verhalten
          so, als ob der Wert zuerst nach
          <link linkend="language.types.boolean.casting">boolean</link>
          konvertiert wird. Auf jeden Fall sollten Sie sich auf dieses Verhalten
          <emphasis>nicht</emphasis> verlassen. Es kann sich ohne Ankündigung
          ändern.
         </simpara>
        </caution>
       </para>
      </sect3>
      
    </sect2>
  </sect1>

   
  <sect1 id="language.types.float">
   <title>Fließkomma-Zahlenwerte</title>
   <para>
    Fließkomma-Zahlenwerte ("floats", "doubles" oder "reelle Zahlen")
    können durch eine der folgenden Anweisungen zugewiesen werden:
    <informalexample>
     <programlisting role="php">
$a = 1.234;
$a = 1.2e3;
$a = 7E-10;
     </programlisting>
    </informalexample>
    Die Größe einer Fließkomma-Zahl ist plattformabhängig, dennoch
    stellt ein Maximum von ~1.8e308 mit einer Genauigkeit von 14
    Nachkomma-Stellen einen üblichen Wert dar (das entspricht 64-Bit im
    IEEE-Format).
   </para>
   <warning id="warn.float-precision">
    <title>Fließkomma Präzision</title>
    <para>
     Es ist ziemlich normal, dass einfache Dezimalzahlen wie
     <literal>0.1</literal> oder <literal>0.7</literal> nicht in ihre
     internen binären Entsprechungen konvertiert werden können, ohne
     einen kleinen Teil ihrer Genauigkeit zu verlieren. Das kann zu
     verwirrenden Ergebnissen führen. So wird <literal>floor((0.1 +
     0.7) * 10)</literal> normalerweise <literal>7</literal> statt des
     erwarteten Wertes <literal>8</literal> zurück geben (als Ergebnis
     der internen Entsprechung von <literal>7.9999999999...</literal>.
    </para>
    <para>
     Das gründet sich auf die Tatsache, dass es unmöglich ist, manche
     Dezimal-Zahlen durch eine endliche Anzahl an Nachkomma-Stellen
     darzustellen. Dem Wert <literal>1/3</literal> entspricht z.B. der interne
     Wert von <literal>0.3333333. . .</literal>.
    </para>
    <para>
     Deshalb sollten Sie nie den Ergebnissen von Fließkomma-Operationen
     bis auf die letzte Nachkomma-Stelle trauen und nie solche auf
     Gleichheit prüfen. Benötigen Sie wirklich eine größere Genauigkeit,
     sollten sie die
     <link linkend="ref.bc"> mathematischen Funktionen beliebiger Genauigkeit</link>
     oder die <link linkend="ref.gmp">Gmp</link> Funktionen benutzen.
    </para>
   </warning>
  </sect1>
   
  <sect1 id="language.types.string">
   <title>Strings / Zeichenketten</title>
   <para>
    Ein <type>String</type> ist eine Folge von Zeichen. In PHP entspricht
    ein Zeichen einem Byte, das heißt, dass exakt 256 unterschiedliche Zeichen
    möglich sind. Das impliziert auch, dass PHP keine native Unterstützung
    für Unicode bietet.
   </para>
   <note>
    <simpara>
     Für einen String stellt die Länge kein Problem dar. Von PHP-Seite aus
     gibt es keine praktische Grenze für die Größe eines Strings. Daher gibt
     es keinen Grund sich Sorgen über lange Strings zu machen.
    </simpara>
   </note>

   <sect2 id="language.types.string.syntax">
    <title>Syntax</title>
    <para>
     Ein String kann auf drei verschiedene Weisen geschrieben werden.

     <itemizedlist>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">Einfache Anführungszeichen (single quoted)</link>
       </simpara>
      </listitem>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">Doppelte Anführungszeichen (double quoted)</link>
       </simpara>
      </listitem>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">Heredoc Syntax</link>
       </simpara>
      </listitem>

     </itemizedlist>
    </para>

    <sect3 id="language.types.string.syntax.single">
     <title>Einfache Anführungszeichen (Single quoted)</title>
     <para>
      Der leichteste Weg einen einfachen String zu schreiben, ist der
      Einschluss in einfache Anführungszeichen
      (das Zeichen <literal>'</literal>).
     </para>
     <para>
      Um ein einfaches Anführungszeichen wörtlich auszugeben, muss dieses
      mit einem Backslash (<literal>\</literal>) escaped werden, wie in
      vielen anderen Programmiersprachen auch. Wenn Sie innerhalb eines
      Strings einen Backslash vor einem einfachen Anführungszeichen oder am
      Ende eines Strings ausgeben wollen, müssen Sie diesen verdoppeln.
      Beachten Sie: wenn Sie versuchen irgendwelche anderen Zeichen zu
      escapen, wird der Backslash ebenfalls ausgegeben! Daher besteht für
      gewöhnlich keine Notwendigkeit den Backslash selbst zu escapen.
      <note>
       <simpara>
        In PHP 3 wird eine Warnung auf der Stufe <literal>E_NOTICE</literal>
        ausgegeben, wenn das passiert.
       </simpara>
      </note>
      <note>
       <simpara>
        Anders als bei den zwei anderen Schreibweisen werden Variablen
        innerhalb von single-quoted Strings
        <emphasis>nicht</emphasis> ausgewertet.
       </simpara>
      </note>
      <informalexample>
       <programlisting role="php">
<![CDATA[
echo 'Das ist ein einfacher String';
echo 'Sie können ebenso einen Zeilenumbruch einfügen,
auf diese Art.';

echo 'Arnold sagte einmal: "I\'ll be back"';
// Ausgabe: ... "I'll be back"

echo 'Sind Sie sicher, dass Sie C:\\*.* löschen wollen?';
// Ausgabe: ... dass Sie C:\*.* löschen wollen?

echo 'Sind Sie sicher, dass Sie C:\*.* löschen wollen?';
// Ausgabe: ... dass Sie C:\*.* löschen wollen?

echo 'Ich versuche einen Zeilenumbruch an diesem Punkt: \n ein Zeilenumbruch';
// Ausgabe: ... diesem Punkt: \n ein Zeilenumbruch'

$var = "nur zum Vergnügen";
echo 'Das mache ich $var';
// Ausgabe: Das mache ich $var
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect3>

    <sect3 id="language.types.string.syntax.double">
     <title>Doppelte Anführungszeichen (Double quoted)</title>
     <para>
      Wenn ein String in doppelten Anführungszeichen (") eingeschlossen ist,
      versteht PHP mehr Escape-Folgen für spezielle Zeichen:
     </para>
     <table>
      <title>Nicht ausgewertete / übergangene Zeichen:</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Zeichenfolge</entry>
         <entry>Bedeutung</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>\n</literal></entry>
         <entry>Zeilenvorschub (LF oder 0x0A als ASCII-Code)</entry>
        </row>
        <row>
         <entry><literal>\r</literal></entry>
         <entry>Wagenrücklauf (CR oder 0x0D als ASCII-Code)</entry>
        </row>
        <row>
         <entry><literal>\t</literal></entry>
         <entry>horizontaler Tabulator (HT oder 0x09 als ASCII-Code</entry>
        </row>
        <row>
         <entry><literal>\\</literal></entry>
         <entry>Backslash / Rückstrich</entry>
        </row>
        <row>
         <entry><literal>\$</literal></entry>
         <entry>Dollar-Symbol</entry>
        </row>
        <row>
         <entry><literal>\"</literal></entry>
         <entry>doppelte Anführungszeichen</entry>
        </row>
        <row>
         <entry><literal>\[0-7]{1,3}</literal></entry>
         <entry>
          die Zeichenfolge, die dem regulären Ausdruck entspricht
          ist ein Zeichen in Oktal-Schreibweise
         </entry>
        </row>
        <row>
         <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
         <entry>
          die Zeichenfolge, die dem regulären Ausdruck entspricht
          ist ein Zeichen in Hexadezimal-Schreibweise
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
     <para>
      Noch einmal: wenn Sie versuchen, irgend ein anderes Zeichen zu escapen
      wird der Backslash ebenfalls ausgegeben!
     </para>
     <para>
      Der wichtigste Vorteil von double-quoted Strings ist die Tatsache,
      dass Variablennamen ausgewertet werden. Für Details siehe
      <link linkend="language.types.string.parsing">String Analyse (parsing)</link>
     </para>
    </sect3>

    <sect3 id="language.types.string.syntax.heredoc">
     <title>Heredoc</title>
     <simpara>
     Eine andere Möglichkeit Strings einzufassen, besteht im Gebrauch
     der heredoc-Syntax ("&lt;&lt;&lt;"). Hierfür ist nach
     <literal>&lt;&lt;&lt;</literal> ein Bezeichner zu setzen. Nun folgt
     der eigentliche String und dann derselbe Bezeichner um den String
     abzuschließen.
     </simpara>     
     <simpara>
      Der schließende Bezeichner <emphasis>muss</emphasis>
      in der ersten Spalte der Zeile stehen. Die verwendeten Bezeichner
      müssen den gleichen Regeln entsprechen wie alle anderen PHP-Labels auch:
      Sie dürfen lediglich alphanumerische Zeichen und den Unterstrich enthalten
      und müssen mit einem Unterstrich oder einem Buchstaben beginnen.
     </simpara>
     
     <warning>
      <simpara>
       Es ist sehr wichtig zu beachten, dass die Zeile mit dem schließenden
       Bezeichner keine anderen Zeichen enthält, ausgenommen
       <emphasis>möglicherweise</emphasis> ein Semikolon
       (<literal>;</literal>).
       Das bedeuted im Besonderen, dass der Bezeichner
       <emphasis>nicht eingerückt werden darf</emphasis> und es dürfen
       keine Leerzeichen oder Tabulatoren vor oder nach dem Semikolon stehen.
      </simpara>
      <simpara>
       Wahrscheinlich der unangenehmste Umstand ist der, dass ebenso kein
       Wagenrücklauf (<literal>\r</literal>) am Ende dieser Zeile stehen darf,
       nur ein Zeilenvorschub (<literal>\n</literal>).
       Da Microsoft Windows die Folge <literal>\r\n</literal> als
       Zeilenabschlusszeichen benutzt, kann Ihre heredoc-Syntax nicht
       funktionieren, wenn Sie Ihr Skript mit einem Editor unter Windows
       schreiben. Die meisten Programmier-Editoren bieten jedoch die
       Möglichkeit, Ihre Dateien mit einem UNIX Zeilenende zu speichern.
      </simpara>
     </warning>

     <para>
      Heredoc-Text funktioniert wie ein String innnerhalb doppelter
      Anführungszeichen, nur ohne doppelte Anführungszeichen.
      Anführungszeichen innerhalb von heredoc-Texten müssen
      also keiner Sonderbehandlung (escapen) unterzogen werden, aber Sie
      können dennoch die oben aufgeführten Escape-Anweisungen verwenden.
      Variablen werden ausgewertet, aber besondere Aufmerksamkeit muss komplexen
      Variablen gewidmet werden, genau wie bei Strings.
      <example> 
       <title>
        Beispiel zur String-Festlegung per "heredoc"-Methode:
       </title>
       <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Beispiel eines Strings
über mehrere Script-Zeilen
durch Gebrauch der heredoc-Syntax.
EOD;

/* komplexeres Beispiel, mit Variablen */
class foo {
    var $foo;
    var $bar;

    function foo() {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'Mein Name';

echo <<<EOT
Mein Name ist "$name". Ich schreibe einige $foo->foo.
Nun schreibe ich gerade einige {$foo->bar[1]}.
Dies sollte ein großes 'A' schreiben: \x41
EOT;
?>
]]>
       </programlisting>
      </example>
     </para>
  
     <note>
      <para>
       Die heredoc Unterstützung wurde in PHP 4 eingeführt.
      </para>
     </note>
    </sect3>

    <sect3 id="language.types.string.parsing">
     <title>Variablen-Analyse (parsing)</title>
     <simpara>
      Wird ein String in doppelten Anführungszeichen oder mit heredoc angegeben,
      werden enthaltene Variablen ausgewertet (geparst).
     </simpara>
     <simpara>
      Es gibt zwei Syntax-Typen, eine
      <link linkend="language.types.string.parsing.simple">einfache</link>
      und eine
      <link linkend="language.types.string.parsing.complex">komplexe</link>.
      Die einfache Syntax ist die geläufigste und bequemste. Sie bietet die
      Möglichkeit eine Variable, einen Array-Wert oder eine Objekt-Eigenschaft
      auszuwerten (parsen).
     </simpara>
     <simpara>
      Die komplexe Syntax wurde in PHP 4 eingeführt und ist an den
      geschweiften Klammern <literal>{}</literal>erkennbar, die
      den Ausdruck umschließen.
     </simpara>
     <sect4 id="language.types.string.parsing.simple">
      <title>Einfache Syntax</title>
      <simpara>
       Sobald ein Dollarzeichen (<literal>$</literal>) auftaucht, wird
       der Parser versuchen, gierig so viele Zeichen wie möglich zu bekommen,
       um einen gültigen Variablennamen zu bilden. Schließen Sie Ihren
       Varaiblennamen in geschweifte Klammern ein, wenn Sie ausdrücklich das
       Ende des Namens angeben wollen.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
$beer = 'Heineken';
echo "$beer's Geschmack ist großartig";  // funktioniert, "'" ist kein gültiges
                                         // Zeichen für einen Variablennamen
echo "Er hat einige $beers getrunken";   // funktioniert nicht, 's' ist ein gültiges
                                         // Zeichen für einen Variablennamen
echo "Er hat einige ${beer}s getrunken"; // funktioniert
]]>
       </programlisting>
      </informalexample>
      <simpara>
       Auf ähnliche Weise können Sie erreichen, dass ein Array-Index
       oder eine Objekt-Eigenschaft ausgewertet wird. Bei Array-Indizes
       markiert die schließende eckige Klammer (<literal>]</literal>) das
       Ende des Index. Für Objekt-Eigenschaften gelten die gleichen Regeln
       wie bei einfachen Variablen, obwohl es bei Objekt-Eigenschaften keinen
       Trick gibt, wie dies bei Variablen der Fall ist.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
$früchte = array( 'Erdbeere' => 'rot' , 'Banane' => 'gelb' );

// Beachten Sie: außerhalb von String-Anführungszeichen funktioniert das anders.
echo "Eine Banane ist $früchte[Banane].";

echo "Dieses Quadrat ist $quadrat->breite Meter breit.";

// Funktioniert nicht. Für eine Lösung siehe die komplexe Syntax.
echo "Dieses Quadrat ist $quadrat->breite00 Zentimeter breit.";

]]>
       </programlisting>
      </informalexample>
      <simpara>
       Für irgendetwas Komplexeres sollten Sie die komplexe Syntax nutzen.
      </simpara>
     </sect4>
     <sect4 id="language.types.string.parsing.complex">
      <title>Komplexe (geschweifte) Syntax</title>
      <simpara>
       Diese wird nicht komplex genannt, weil etwa die Syntax komplex ist,
       sondern weil Sie auf diesem Weg komplexe Ausdrücke einbeziehen können.
     </simpara>
     <simpara>
      Tatsächlich können Sie jeden beliebigen Wert einbeziehen, der im
      Namensbereich in Strings gültig ist. Schreiben Sie den Ausdruck einfach
      auf die gleiche Art und Weise, wie außerhalb des Strings, und
      umschließen diesen mit { und }. Da Sie '{' nicht escapen können, wird 
      diese Syntax nur erkannt, wenn auf { unmittelbar $ folgt.
      (Benutzen Sie "{\$" oder "\{$" um ein wörtliches "{$" zu erhalten.)
      Einige Beispiele, um dies zu verdeutlichen:
     </simpara>
     <informalexample>
      <programlisting role="php">
<![CDATA[
$great = 'fantastisch';
echo "Das ist { $great}"; // funktioniert nicht, Ausgabe: Das ist { fantastisch}
echo "Das ist {$great}";  // funktioniert, Ausgabe: Das ist fantastisch
echo "Dieses Quadrat ist {$square->width}00 Zentimeter breit."; 
echo "Das funktioniert: {$arr[4][3]}";

// Das ist aus dem gleichen Grund falsch
// wie $foo[bar] außerhalb eines Strings falsch ist.
echo "Das ist falsch: {$arr[foo][3]}";

echo "So sollten Sie es machen: {$arr['foo'][3]}";
echo "Sie können sogar schreiben {$obj->values[3]->name}";
echo "Das ist der Wert der Variable mit Namen $name: {${$name}}";
]]>
       </programlisting>
      </informalexample>
     </sect4>
    </sect3>
    
    <sect3 id="language.types.string.substr">
     <title>Zugriff auf Zeichen in Strings</title>
     <para>
      Auf Zeichen innerhalb von Strings kann durch die Angabe des
      nullbasierten Offsets in geschweiften Klammern nach dem String,
      auf das gewünschte Zeichen zugegriffen werden.
     </para>
     <note>
      <simpara>
       Für Abwärtskompatibilität können Sie immer noch die Array-Klammern verwenden.
       Diese Syntax wird jedoch seit PHP 4 missbilligt.
      </simpara>
     </note>
     <para>
      <example>
       <title>Einige String-Beispiele</title>
       <programlisting role="php">
<![CDATA[
<?php
// Zuweisung eines Strings.
$str = "Dies ist eine Zeichenkette";

// Erweiterung dieses Strings.
$str = $str . " mit etwas zusätzlichem Text";

// andere Möglichkeit zum Erweitern incl. Anweisung für Neue-Zeile.
$str .= " und einer neuen Zeile am Ende.\n";

/* 
Nach diesen drei Operationen enthält $str:
"Dies ist eine Zeichenkette mit etwas zusätzlichem Text und einer neuen Zeile am Ende.\n."
*/

// Dieser String wird am Ende zu: '<p>Nummer: 9</p>'
$num = 9;
$str = "<p>Nummer: $num</p>";

// Dieser wird zu '<p>Nummer: $num</p>'
$num = 9;
$str = '<p>Nummer: $num</p>';

// Das erste Zeichen eines Strings.
$str = 'Das ist ein Test.'
$first = $str{0};                // $first enthält "D"

// Das letzte Zeichen eines Strings.
$str = 'Das ist immer noch ein Test.'
$last = $str{strlen($str)-1};    // $last enthält "."
?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>

   </sect2><!-- end syntax -->

   <sect2 id="language.types.string.useful-funcs">
    <title>Nützliche Funktionen</title><!-- and operators -->
    <para>
     Zeichenketten / Strings können mittels des '.'(dot)-Operators
     miteinander verbunden werden. Beachten Sie, dass
     dafür nicht der '+' (Additions)-Operator verwendet werden kann
     Für mehr Informationen schauen Sie bitte unter den
     <link linkend="language.operators.string">Zeichenketten-Operatoren</link>
     nach.
    </para>
    <para>
     Es gibt eine Menge nützlicher Funktionen zur String-Manipulation.
    </para>
    <simpara>
     Für allgemeine Funktionen schauen Sie sich den Abschnitt über
     <link linkend="ref.strings">String Funktionen</link> an,
     und für fortgeschrittenes Suchen &amp; Ersetzen die Funktionen zu
     Regulären Ausdrücken (in zwei Ausführungen: 
     <link linkend="ref.pcre">Perl Kompatibel</link> und 
     <link linkend="ref.regex">POSIX erweitert</link>).
    </simpara>
    <simpara>
     Weiterhin gibt es auch noch
     <link linkend="ref.url">Funktionen für URL-Strings</link>,
     und Funktionen zum Verschlüsseln/Entschlüsseln von Strings
     (<link linkend="ref.mcrypt">mcrypt</link> und 
     <link linkend="ref.mhash">mhash</link>).
    </simpara>
    <simpara>
     Schließlich, falls Sie immer noch nicht das gefunden haben wonach
     Sie suchen, schauen Sie unter den 
     <link linkend="ref.ctype">Zeichen-Typen Funktionen</link> nach.
    </simpara>
   </sect2>

   <sect2 id="language.types.string.conversion">
    <title>Umwandlung von Zeichenketten / Strings</title>

    <simpara>
     Sobald ein String als numerischer Wert ausgewertet wird, wird der
     resultierende Wert und Typ wie folgt festgelegt.
    </simpara>
    <simpara>
     Der String wird als <type>float</type> ausgewertet, wenn er eines der
     Zeichen '.', 'e' oder 'E' enthält. Ansonsten wird er als Integer-Wert
     interpretiert.
    </simpara>
    <para>
     Der Wert wird durch den Anfangsteil des Strings bestimmt.
     Sofern der String mit gültigen numerischen Daten beginnt, werden diese
     als Wert benutzt. Andernfalls wird der Wert 0 (Null)
     sein. Gültige numerische Daten sind ein optionales Vorzeichen,
     gefolgt von einer oder mehreren Zahlen (optional mit einem
     Dezimalpunkt). Wahlweise kann auch ein Exponent angegeben
     werden. Der Exponent besteht aus einem 'e' oder 'E', gefolgt von einer
     oder mehreren Zahlen.
    </para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$foo = 1 + "10.5";               // $foo ist float   (11.5)
$foo = 1 + "-1.3e3";             // $foo ist float   (-1299)
$foo = 1 + "bob-1.3e3";          // $foo ist integer (1)
$foo = 1 + "bob3";               // $foo ist integer (1)
$foo = 1 + "10 Kleine Schweine"; // $foo ist integer (11)
$foo = 4 + "10.2 Ferkel";        // $foo ist float   (14.2)
$foo = "10 Schweine " + 1;       // $foo ist integer (11)
$foo = "10.0 Schweine " + 1;     // $foo ist float   (11)
$foo = "10.0 Schweine " + 1.0;   // $foo ist float (11)
]]>
     </programlisting>
    </informalexample>
    <simpara>
     Weitere Informationen über solche Umwandlungen finden Sie in
     den UNIX Manualseiten unter strtod(3).
    </simpara>
    <para>
     Wenn Sie irgendein Beispiel dieses Abschnitts testen wollen, können Sie
     dieses per "Copy und Paste" übernehmen. Fügen Sie die folgende Zeile 
     Ihrem Skript hinzu und Sie sehen selbst was passiert: 
     <informalexample>
      <programlisting role="php">
<![CDATA[
echo "\$foo==$foo; Typ ist " . gettype ($foo) . "<br />\n";
]]>
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1><!-- end string -->

  <sect1 id="language.types.array">
   <title>Arrays</title>

   <para>
    Ein Array in PHP ist eigentlich eine geordnete Abbildung. Eine Abbildung
    ist ein Typ der <emphasis>Werte</emphasis> auf 
    <emphasis>Schlüssel</emphasis> abbildet. Dieser Typ ist auf mehrere Arten
    optimiert, so dass Sie ihn auf verschiedene Weise benutzen können:
    als reales Array, als Liste (Vektor), als Hash-Tabelle (das ist eine
    praktische Anwendung einer Abbildung), als Verzeichnis, als Sammlung,
    als Stapel (Stack), als Warteschlange (Queue) und möglicherweise mehr.
    Da Sie ein weiteres PHP-Array als Wert benutzen können, ist es ziemlich
    einfach möglich Baumstrukturen zu simulieren.
   </para>
   <para>
    Die Erklärung dieser Strukturen sprengt den Rahmen dieses Handbuchs,
    aber Sie finden zumindest ein Beispiel für jede dieser
    Strukturen. Für weitergehende Informationen verweisen wir auf externe
    Literatur zu diesem breit gefächerten Thema.
   </para>

   <sect2 id="language.types.array.syntax">
    <title>Syntax</title>

    <sect3 id="language.types.array.syntax.array-func">
     <title>Angabe mit <function>array</function></title>
     <para>
      Ein <type>array</type> kann mit Hilfe des Sparchkonstrukts
      <function>array</function> erzeugt werden. Es benötigt eine bestimmte
      Anzahl von Komma-getrennten
      <literal><replaceable>Schlüssel</replaceable> =&gt; <replaceable>Wert
      </replaceable></literal> Paaren.
     </para>
     <para>
      Ein <varname>Schlüssel</varname> ist entweder eine nicht-negative
      Zahl vom Typ <type>integer</type> oder ein <type>string</type>.
      Wenn ein Schlüssel die Standard-Darstellung einer nicht-negativen
      <type>integer</type> Zahl ist, wird es als solche interpretiert werden,
      (z.B. <literal>'8'</literal> wird als <literal>8</literal> interpretiert
      während <literal>'08'</literal> als <literal>'08'</literal>
      interpretiert werden wird).
     </para>
     <para>
      Ein Wert kann irgendetwas sein.
     </para>
     <para>
      Falls Sie einen Schlüssel weglassen, wird das Maximum der Integer-
      Indizes gennnommen und der neue Schlüssel wird dieses Maximum + 1 sein.
      Falls es bis dahin keine Integer-Indizes gibt, wird der Schlüssel zu
      <literal>0</literal> (Null). Falls Sie einen Schlüssel angeben dem 
      schon ein Wert zugeordnet wurde, wird dieser Wert überschrieben.
     </para>

     <para>
      <synopsis>
array( <optional> <replaceable>Schlüssel</replaceable> =&gt; </optional> <replaceable
>Wert</replaceable>
     , ...
     )
// <replaceable>Schlüssel</replaceable> ist entweder ein <type>string</type
                        > oder ein nicht-negativer <type>integer</type>
// <replaceable>Wert</replaceable> kann irgendetwas sein.
      </synopsis>
     </para>
    </sect3>

    <sect3 id="language.types.array.syntax.modifying">
     <title>Erzeugen / Verändern mit der eckigen Klammer-Syntax</title>
     <para>
      Sie können ein bestehendes Array durch explizites Zuweisen von Werten
      verändern.
     </para>
     <para>
      Weisen Sie dem Array Werte zu indem Sie den Schlüssel in eckigen
      Klammern angeben. Sie können den Schlüssel auch weglassen. In diesem
      Fall schreiben Sie einfach ein leeres Klammerpaar
      ("<literal>[]</literal>") hinter den Variablennamen.
      <synopsis>
$arr[<replaceable>Schlüssel</replaceable>] = <replaceable>Wert</replaceable>;
$arr[] = <replaceable>Wert</replaceable>;
// <replaceable>Schlüssel</replaceable> ist entweder ein <type>string</type
                        > oder ein nicht-negativer <type>integer</type>
// <replaceable>Wert</replaceable> kann irgendetwas sein.
      </synopsis>
      Falls <varname>$arr</varname> bis dahin nicht existiert, wird es
      erzeugt. Das ist also eine alternative Syntax um ein Array zu erzeugen.
      Um einen bestimmten Wert zu ändern, weisen Sie diesem einfach einen
      neuen Wert zu. Wenn Sie ein Schlüssel/Wert Paar entfernen möchten,
      benutzen Sie <function>unset</function>.
      
     </para>

    </sect3>
    

   </sect2><!-- end syntax -->


   <sect2 id="language.types.array.useful-funcs">
    <title>Nützliche Funktionen</title>
    <para>
     Es gibt viele nützliche Funktionen um mit Arrays zu arbeiten.
     Schauen Sie unter dem Abschnitt
     <link linkend="ref.array">Array Funktionen</link> nach.
    </para>
    <note>
     <para>
      Mit <function>unset</function> können Sie Schlüssel eines Arrays
      löschen. Halten Sie sich vor Augen, dass das Array NICHT neu indiziert
      wird.
      <informalexample>
       <programlisting role="php">
<![CDATA[
$a = array( 1 => 'eins', 2 => 'zwei', 3 => 'drei' );
unset( $a[2] );

/* erzeugt ein Array das wie folgt definiert worden wäre:
   $a = array( 1=>'eins', 3=>'drei');
   und NICHT
   $a = array( 1 => 'eins', 2 => 'drei');
*/
]]>
      </programlisting>
     </informalexample>
     
     </para>    
    </note> 
    <para>
     Die <link linkend="control-structures.foreach">foreach</link> 
     Kontrollstruktur gibt es speziell für Arrays. Damit ist es leicht
     ein Array zu durchlaufen.
    </para>
    
    
   </sect2>

   <sect2 id="language.types.array.donts">
    <title>Array do's und don'ts</title>

    <sect3 id="language.types.array.foo-bar">
     <title>Warum ist <literal>$foo[bar]</literal> falsch?</title>
     <para>
      Sie sollten immer Anführungszeichen für einen assoziativen Index
      eines Arrays benutzen. Zum Beispiel sollten Sie $foo['bar'] und nicht
      $foo[bar] benutzen. Aber warum ist $foo[bar] falsch?
      Vieleicht kennen Sie folgende Syntax aus alten Skripts:
      <informalexample>
       <programlisting role="php">
<![CDATA[
$foo[bar] = 'Feind';
echo $foo[bar];
// usw
]]>
       </programlisting>
      </informalexample>
      Es ist falsch, funktioniert aber. Warum ist es dann falsch?
      Der Grund ist, dass dieser Code eine undefinierte Konstante enthält
      (bar) anstatt eines Strings ('bar'- beachten Sie die
      Anführungszeichen) und PHP könnte in Zukunft Konstanten definieren,
      die unglücklicherweise für Ihren Code, den gleichen Namen verwenden.
      Es funktioniert, weil die undefinierte Konstante in einen String mit
      gleichem Namen umgewandelt wird.
     </para>
     <para>
      Wie im Abschnitt <link linkend="language.types.array.syntax">Syntax</link>
      ausgeführt, muss zwischen den eckigen Klammern
      ('<literal>[</literal>' und '<literal>]</literal>') ein Ausdruck stehen.
      Das heißt, dass Sie Dinge ähnlich diesen schreiben können:
      <informalexample>
       <programlisting role="php">
<![CDATA[
echo $arr[ foo(true) ];        
]]>
       </programlisting>
      </informalexample>
      Das ist ein Beispiel dafür, wie Sie den Rückgabewert einer Funktion als
      Array-Index verwenden können. Ebenso kennt PHP Konstanten, vielleicht
      haben Sie die <literal>E_*</literal> Konstanten schon einmal gesehen.
      <informalexample>
       <programlisting role="php">
<![CDATA[
$error_descriptions[E_ERROR]   = "Ein schwerwiegender Fehler ist aufgetreten";
$error_descriptions[E_WARNING] = "PHP hat eine Warnung ausgegeben";
$error_descriptions[E_NOTICE]  = "Das ist nur eine informelle Notiz";
]]>
       </programlisting>
      </informalexample>
      Beachten Sie, dass <literal>E_ERROR</literal> ebenso ein gültiger
      Bezeichner ist, genau wie <literal>bar</literal> im ersten Beispiel.
      Das letzte Beispiel entspricht aber tatsächlich dem folgendem Code:
      <informalexample>
       <programlisting role="php">
<![CDATA[
$error_descriptions[1] = "Ein schwerwiegender Fehler ist aufgetreten";
$error_descriptions[2] = "PHP hat eine Warnung ausgegeben";
$error_descriptions[8] = "Das ist nur eine informelle Notiz";
]]>
       </programlisting>
      </informalexample>
      weil <literal>E_ERROR</literal> gleich <literal>1</literal> ist, usw.
     </para>
     <para>
      Aber wie ist es dann möglich dass <literal>$foo[bar]</literal>
      funktioniert? Es funktioniert, weil <literal>bar</literal> aufgrund
      seiner Syntax als Konstante ausgewertet wird. In diesem Fall jedoch
      existiert keine Konstane mit dem Namen <literal>bar</literal>. PHP
      nimmt an, dass Sie <literal>bar</literal> wörtlich gemeint haben, wie
      den String <literal>'bar'</literal>, aber vergessen haben, die 
      Anführungszeichen zu setzen.
     </para>
     <sect4>
      <title>Aber warum ist es schlecht?</title>
      <para>
       Eines Tages könnte sich das PHP Team entscheiden eine weitere
       Konstante oder ein Schlüsselwort hinzuzufügen und dann geraten Sie in
       Schwierigkeiten. Zum Beispiel können Sie bereits die Wörter
       <literal>empty</literal> und <literal>default</literal> auf diese Art
       nicht benutzen, weil es speziele Schlüsselwörter sind.
      </para>
      <note>
       <simpara>
        Wenn Sie
        <link linkend="function.error-reporting">error_reporting</link>
        auf <literal>E_ALL</literal> setzen, werden Sie bemerken, dass PHP
        jedesmal Notices ausgibt, wenn Sie einen
        <literal>index</literal> benutzen, der nicht definiert wurde.
        (Fügen Sie die Zeile <literal>error_reporting(E_ALL);</literal>
        in Ihr Skript ein).
       </simpara>
      </note>
      <note>
       <simpara>
        Innerhalb eines <type>string</type> in doppelten Anführunfszeichen
        gilt eine andere Syntax. Für mehr Details schauen Sie unter
        <link linkend="language.types.string.parsing">
        Variablen-Analyse in Strings</link> nach.
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>

   <sect2 id="language.types.array.examples">
    <title>Beispiele</title>
    <para>
     Der Array-Typ in PHP ist sehr vielseitig. Hier folgen einige Beispiele
     um Ihnen die Mächtigkeit von Arrays zu veranschaulichen.
    </para>
    <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
// Das hier
$a = array('Farbe'     => 'rot'
          ,'Geschmack' => 'süß'
          ,'Form'      => 'rund'
          ,'Name'      => 'Apfel'
          ,4                  // Schlüssel ist 0
          );

// ist komplett gleichwertig mit
$a['Farbe']     = 'rot';
$a['Geschmack'] = 'süß';
$a['Form']      = 'rund';
$a['Name']      = 'Apfel';
$a[]            = 4;          // Schlüssel ist 0

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
/* ergibt das Array: array( 0 => 'a' , 1 => 'b' , 2 => 'c' ),
   oder einfacher: array('a', 'b', 'c')
*/
]]>
       </programlisting>
      </informalexample>
     </para>
    
    <example>
     <title>Verwenden von <function>array</function></title>
     <programlisting role="php">
<![CDATA[
// Array als (Eigenschafts-)Abbildung
$map = array('version'    => 4
            ,'OS'         => 'Linux'
            ,'Sprache'    => 'englisch'
            ,'short_tags' => true
            );
            
// strikt numerische Schlüssel
$array = array(7
              ,8
              ,0
              ,156
              ,-10
              );
// Dies entspricht: array( 0 => 7, 1 => 8, ...)

// wechselnde Schlüssel
$wechselnd = array(10          // Schlüssel: 0
                  ,5    =>  6
                  ,3    =>  7
                  ,'a'  =>  4
                  ,11          // Schlüssel: 6 (Maximum der Integer-Indices war 5)
                  ,'8'  =>  2  // Schlüssel: 8 (integer!)
                  ,'02' => 77  // Schlüssel: '02'
                  ,0    => 12  // 10 wird mit dem neuen Wert 12 überschrieben
                  );
                  
// leeres Array
$leer = array();         
]]>
     </programlisting>
    </example>

    <example id="language.types.array.examples.loop">
     <title>Sammlung</title>
     <programlisting role="php">
<![CDATA[
$farben = array('rot','blau','grün','gelb');

foreach ($farben as $farbe) {
    echo "Gefällt Ihnen $farbe?\n";
}

/* Ausgabe:
Gefällt Ihnen rot?
Gefällt Ihnen blau?
Gefällt Ihnen grün?
Gefällt Ihnen gelb?
*/
]]>
     </programlisting>
    </example>
    
    <para>
     Beachten Sie, dass es gegenwärtig nicht möglich ist die Werte eines
     Arrays direkt in einer solchen Schleife zu ändern.
     Eine Lösung ist folgendes: 
     <example id="language.types.array.examples.changeloop">
      <title>Sammlung</title>
      <programlisting role="php">
<![CDATA[
foreach ($farben as $key => $farbe) {
    // funktioniert nicht:
    //$farbe = strtoupper($farbe);
    
    //funktioniert:
    $farben[$key] = strtoupper($farbe);
}
print_r($farben);

/* Ausgabe:
Array
(
    [0] => ROT
    [1] => BLAU
    [2] => GRÜN
    [3] => GELB
)
*/
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Dieses Beispiel erzeugt ein Array, dessen Schlüssel bei eins beginnt.
     <example>
      <title>1-basierter Index</title>
      <programlisting role="php">
<![CDATA[
$erstes_viertel  = array(1 => 'Januar', 'Februar', 'März');
print_r($erstes_viertel);

/* Ausgabe:
Array 
(
    [1] => 'Januar'
    [2] => 'Februar'
    [3] => 'März'
)
*/
]]>   
      </programlisting>
     </example>
    </para>
    <example>
     <title>Füllen eines realen Arrays</title>
     <programlisting role="php">
<![CDATA[
// Füllen eines Arrays mit allen Inhalten eines Verzeichnisses
$handle = opendir('.');
while ($file = readdir($handle)) 
{
    $files[] = $file;
}
closedir($handle); 
]]>
     </programlisting>
    </example>
    <para>
     Arrays sind geordnet. Diese Ordnung können Sie mit Hilfe verschiedener
     Sortierfunktionen verändern. Für mehr Informationen schauen Sie unter
     dem Abschnitt zu den <link linkend="ref.array">Array Funktionen</link>
     nach.
    </para>
    <example>
     <title>Sortien eines Array</title>
     <programlisting role="php">
<![CDATA[
sort($files);
print_r($files);
]]>
     </programlisting>
    </example>
    <para>
     Weil der Wert eines Arrays irgendetwas sein kann, kann dieser Wert
     wiederum ein Array sein. Somit können Sie rekursive und multidimensionale
     Arrays erzeugen.
    </para>
    <example>
     <title>Rekursive and multidimensionale Arrays</title>
     <programlisting role="php">
<![CDATA[
$fruits = array ( "früchte"  => array("a" => "Orange"
                                     ,"b" => "Banane"
                                     ,"c" => "Apfel"
                                     )
                , "nummern"  => array(1
                                     ,2
                                     ,3
                                     ,4
                                     ,5
                                     ,6
                                     )
                , "löcher"   => array("erstens"
                                     ,5 => "zweitens"
                                     ,"drittens"
                                     )
                );
]]>
     </programlisting>
    </example>
   </sect2>
  </sect1>

  <sect1 id="language.types.object">
   <title>Objekte</title>

   <sect2 id="language.types.object.init">
    <title>Objekt-Initialisierung</title>

    <para>
     Um ein Objekt zu initialisieren benutzen sie die Angabe
     <literal>new</literal>, dadurch wird das Objekt einer
     Variablen-Instanz zugewiesen.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class foo {
    function do_foo() { 
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar->do_foo();
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Für eine ausführliche Darstellung lesen Sie das Kapitel
     <link linkend="language.oop">Klassen und Objekte</link>
    </simpara>
   </sect2>
  </sect1>

  <sect1 id="language.types.resource">
   <title>Resource</title>
    
    <para>
     Eine Resource ist eine spezielle Variable, die eine Referenz auf eine
     externe Resource enthält. Resourcen werden von bestimmten Funktionen
     erzeugt und benutzt. Eine Liste dieser Funktionen und der entsprechenden
     Resource-Typen finden Sie im <link linkend="resource">Anhang</link>.
    </para>
    
    <note>
     <simpara>
      Der Resource-Typ wurde in PHP 4 eingeführt.
     </simpara>
    </note>

    <sect2 id="language.types.resource.self-destruct">
     <title>Freigabe von Resourcen</title>
    
    <para>
     Aufgrund des Reference-Counting Systems, das mit PHP 4's Zend-Egine
     eingeführt wurde, wird automatisch entdeckt, wenn auf eine Resource
     nicht mehr zugegriffen wird (wie in Java). Wenn dies der Fall ist
     werden alle Resourcen, die für diese Resource in Gebrauch waren, durch
     den "Müllsammler" (garbage collector) freigegeben. Aus diesem Grund ist
     es selten jemals notwendig, Speicher manuell durch Aufruf von 
     free_result-Funktionen freizugeben.
     <note>
      <simpara>
       Persistente Datenbank-Links stellen einen Sonderfall dar, sie werden
       durch den gc (garbage collector) <emphasis>nicht</emphasis> zerstört.
       Siehe auch
       <link linkend="features.persistent-connections">Persistente Datenbankverbindungen</link>.
      </simpara>
     </note>
    </para>
    
   </sect2>
  </sect1>
    
  <sect1 id="language.types.null">
   <title>NULL</title>
    
   <para>
    Der spezielle &null; Wert steht dafür, dass eine Varaiable keinen Wert hat.
    &null; ist der einzig mögliche Wert des Typs <type>NULL</type>.
   </para>
    <note>
     <simpara>
      Der Null-Typ wurde in PHP 4 eingeführt.
     </simpara>
    </note>
    
   <sect2 id="language.types.null.syntax">
    <title>Syntax</title>
    <para>
     Es gibt nur einen Wert des Typs &null;, das Schlüsselwort &null;.
     Groß-/Kleinschreibung spielt keine Rolle.
     <informalexample>
      <programlisting role="php">
$var = NULL;       
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  
  </sect1>



  <sect1 id="language.types.type-juggling">
   <title>Typen-Tricks</title>

   <simpara>
    PHP erfordert (bzw. unterstützt) keine explizite Typ-Definitionen
    bei der Deklaration von Variablen; der Typ einer Variablen wird
    durch den Zusammenhang bestimmt in dem die Variable benutzt wird.
    Das bedeutet, dass bei der Zuweisung einer Zeichenkette / eines
    Strings zu einer Variablen <parameter>var</parameter> diese
    Variable <parameter>var</parameter> zum Typ String wird.
    Sollten Sie dananch der Variablen <parameter>var</parameter> einen
    Integer-Wert zuweisen, wird sie zu einem Integer-Typ.
   </simpara>
   <para>
    Ein Beispiel für die automatische Typ-Konvertierung von PHP ist
    der Plus-Operator '+'. Ist einer der zu addierenden Werte vom Typ
    <type>float</type>, werden alle Werte als float-Typ gbehandelt. Auch das
    Ergebnis der Addition wird vom Typ float sein. Andernfalls
    werden die Werte als <type>integer</type>-Typen angesehen und das
    Ergebnis wird ebenfalls vom Typ Integer sein. Beachten Sie, dass
    hierdurch NICHT der Typ der Operanden selbst beeinflusst
    wird; der Unterschied liegt einzig und allein in der Auswertung
    dieser Operanden.
    <informalexample>
     <programlisting role="php">
$foo = "0";                         // $foo ist vom Typ String (ASCII 48)
$foo += 2;                          // $foo ist jetzt vom Typ Integer (2)
$foo = $foo + 1.3;                  // $foo ist nun vom Typ float (3.3)
$foo = 5 + "10 Sehr kleine Ferkel"; // $foo ist vom Typ Integer (15)
$foo = 5 + "10 Kleine Schweine";    // $foo ist vom Typ Integer (15)
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Wenn Ihnen die beiden letzten Beispiele merkwürdig erscheinen, beachten
    Sie die <link linkend="language.types.string.conversion">
    String-Umwandlung</link>.
   </simpara>
   <simpara>
    Wenn Sie die Auswertung einer Variablen als einen speziellen Typ
    erzwingen wollen, beachten sie den Abschnitt in <link
    linkend="language.types.typecasting">Typ-Umwandlung</link>. Wollen Sie
    den Typ einer Variable ändern, schauen Sie bei
    <function>settype</function> nach.
   </simpara>
   <para>
    Um die Beispiele dieses Kapitels auszuprobieren, können Sie die Funktion
    <function>var_dump</function> verwenden.
   </para>
   <note>
    <para>
     Das Verhalten einer automatischen Umwandlung zum Typ Array ist zur Zeit
     nicht definiert.
     <informalexample>
      <programlisting role="php">
$a = 1;       // $a ist ein Integer-Wert
$a[0] = "f";  // $a wird zum Array, $a[0] enthält "f"
      </programlisting>
     </informalexample>
    </para>
    <para>
     Weil das o.a. Beispiel so aussieht, als ob $a ein Array wird,
     dessen erstes Element ein 'f' enthält, bedenken Sie folgendes:
     <informalexample>
      <programlisting role="php">
$a = "1";     // $a ist ein String
$a[0] = "f";  // Was ist mit den String-Offsets? Was passiert?
      </programlisting>
     </informalexample>
    </para>
    <para>
     Weil PHP die Indizierung innerhalb von Strings mittels der
     gleichen Syntax wie bei der Array-Indizierung unterstützt, führt
     das o.a. Beispiel zu einem Problem: Soll $a zu einem Array
     werden, dessen erstes Element ein "f" ist oder soll "f" das erste
     Zeichen des Strings $a werden?
    </para>
    <para>
     Aus diesem Grund ist das Ergebnis der automatischen Umwandlung
     seit PHP 3.0.12 und auch in PHP 4.0b3-RC4 nicht definiert. Lösungen
     werden noch dikutiert.
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>Typ-Umwandlung</title>

    <para>
     Typ-Umwandlung in PHP funktioniert vielfach wie in C: Der Name
     des gewünschten Typs wird vor der umzuwandelnden Variablen in
     Klammern gesetzt.
     <informalexample>
      <programlisting>
$foo = 10;           // $foo ist ein Integer-Wert
$bar = (float) $foo; // $bar ist vom Typ float
      </programlisting>
     </informalexample>
    </para>
    <para>
     Folgende Umwandlungen sind möglich:
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - nach integer</simpara>
      </listitem>
      <listitem>
       <simpara>(bool), (boolean) - nach boolean</simpara>
      </listitem>
      <listitem><simpara>(float), (double), (real) - nach float</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - nach string</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - nach array</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - Wandlung zum Objekt
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
    <note>
     <simpara>
      Ansttat eine Variable in einen String umzuwandeln, können Sie die
      Variable auch in doppelte Anführungszeichen einschließen.
     </simpara>
    </note>
    <para>
     Beachten sie, dass Tabulatoren und Leerzeichen innerhalb der
     Klammern erlaubt sind. Deshalb sind die folgenden Beispiele
     identisch:
     <informalexample>
      <programlisting role="php">
$foo = (int) $bar;
$foo = ( int ) $bar;
      </programlisting>
     </informalexample>
    </para>
    <para>
     Es ist nicht immer offenkundig, was bei der Typ-Umwandlung
     geschieht. Für weitere Informationen schauen Sie unter folgenden
     Abschnitten nach:
     <itemizedlist>
      <listitem>
       <simpara><link linkend="language.types.boolean.casting">Umwandlung
        nach boolean</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.integer.casting">Umwandlung
        nach integer</link></simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Wenn Sie eine Umwandlung eines Arrays zu einem String vornehmen oder
     erzwingen, ist das Ergebnis das Wort <literal>Array</literal>. Wenn
     Sie eine Umwandlung eines Objekts zu einem String vornehmen oder
     erzwingen, ist das Ergebnis das Wort <literal>Objekt</literal>.
    </para>
    <para>
     Bei der Umwandlung einer skalaren oder String-Variablen zu einem Array wird
     die Variable das erste Element des Arrays:
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$arr = (array) $var;
echo $arr[0];        // gibt 'ciao' aus
      </programlisting>
     </informalexample>
    </para>
    <para>
     Sobald eine skalare oder String-Variable in ein Objekt gewandelt
     wird, wird die Variable zu einem Attribut des Objekts; der
     Eigenschafts-Name wird 'scalar':
     <informalexample>
      <programlisting role="php">
<![CDATA[
$var = 'ciao';
$obj = (object) $var;
echo $obj->scalar;   // gibt 'ciao' aus
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
