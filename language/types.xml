<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.42 $ -->
<!-- EN-Revision: 1.134 Maintainer: betz Status: ready -->
<!-- CREDITS: samesch -->
 <chapter id="language.types">
  <title>Typen</title>

  <sect1 id="language.types.intro">
   <title>Einführung</title>
   <simpara>
    PHP unterstützt acht primitive Typen.
   </simpara>

   <para>
    Vier skalare Typen:
    <itemizedlist>

     <listitem>
      <simpara>
       <type>Boolean</type>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <type>Integer</type>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <type>Fließkomma-Zahl (float)</type>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <type>String / Zeichenkette</type>
      </simpara>
     </listitem>

    </itemizedlist>

    Zwei zusammengesetzte Typen:

    <itemizedlist>

     <listitem>
      <simpara>
       <type>Array</type>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <type>Object</type>
      </simpara>
     </listitem>

    </itemizedlist>

    Und zuletzt zwei spezielle Typen:

    <itemizedlist>

     <listitem>
      <simpara>
       <type>Resource</type>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <type>NULL</type>
      </simpara>
     </listitem>

    </itemizedlist>

    Für die bessere Lesbarkeit führt dieses Handbuch ein paar <link
    linkend="language.pseudo-types">Pseudo-Typen</link> ein:

    <itemizedlist>

     <listitem>
      <simpara>
       <link linkend="language.types.mixed">Mixed</link>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <link linkend="language.types.number">Number</link>
      </simpara>
     </listitem>

     <listitem>
      <simpara>
       <link linkend="language.types.mixed">Callback</link>
      </simpara>
     </listitem>

    </itemizedlist>
    Sie werden auch ein paar Hinweise auf den Typ "Double" finden.
    Betrachten Sie Double als dasselbe wie Float. Die beiden
    Bezeichnungen existieren nur aus historischen Gründen.
   </para>
   <simpara>
    Der Typ einer Variablen wird normalerweise nicht vom
    Programmierer bestimmt. Zur Laufzeit von PHP wird entschieden,
    welchen Typs eine Variable ist, abhängig vom Zusammenhang in dem
    die Variable benutzt wird.
   </simpara>
   <note>
    <simpara>
     Um den Typ und den Wert eines bestimmten <link
     linkend="language.expressions">Ausdrucks (Expression)</link> zu
     überprüfen, können Sie <function>var_dump</function> benutzen.
    </simpara>
    <para>
     Wenn Sie zur Fehlersuche einfach nur eine lesbare Darstellung
     eines Typs benötigen, benutzen Sie <function>gettype</function>.
     Um auf einen bestimmten Typ zu prüfen, sollten Sie
     <emphasis>nicht</emphasis> <function>gettype</function> benutzen.
     Stattdessen sollten Sie die
     <literal>is_<replaceable>type</replaceable></literal> Funktionen
     verwenden.  Ein paar Beispiele:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$bool = TRUE;   // ein Boolean (Wahrheitswert)
$str  = "foo";  // ein String (Zeichenkette)
$int  = 12;     // ein Integer (Ganzzahl)

echo gettype($bool); // gibt "boolean" aus
echo gettype($str);  // gibt "string" aus

// Falls es ein Integer ist, erhöhe ihn um vier
if (is_int($int)) {
    $int += 4;
}

// Falls $bool ein String ist, gebe ihn aus
// (gibt überhaupt nichts aus)
if (is_string($bool)) {
    echo "String: $bool";
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </note>
   <simpara>
    Wenn sie die Umwandlung in einen bestimmten Variablen-Typ
    erzwingen wollen, erreichen Sie dies entweder durch <link
    linkend="language.types.typecasting">Typ-Umwandlung</link> oder
    durch Gebrauch der Funktion <function>settype</function>.
   </simpara>
   <simpara>
    Beachten Sie, dass eine Variable abhängig vom Typ, dem die
    Variable zu dem Zeitpunkt entspricht, in bestimmten Situationen
    unterschiedlich ausgewertet werden kann. Weitere Informationen
    entnehmen Sie dem Abschnitt zur <link
    linkend="language.types.type-juggling">Typ-Veränderung</link>.
    Schauen Sie sich außerdem <link linkend="types.comparisons">PHP
    type comparison tables</link> an, wenn Sie an Beispielen
    verschiedener typenbezogener Vergleiche interessiert sind.
   </simpara>
  </sect1>

  <sect1 id="language.types.boolean">
   <title>Boolscher Typ</title>

   <simpara>
    Das ist der einfachste Typ. Ein <type>boolean</type> drückt einen
    Wahrheitswert aus. Dieser kann entweder &true; oder &false; sein.
   </simpara>

   <note>
    <simpara>
     Der boolsche Typ wurde in PHP 4 eingeführt.
    </simpara>
   </note>

   <sect2 id="language.types.boolean.syntax">
    <title>Syntax</title>
    <para>
     Um einen boolschen Typ wörtlich anzugeben, benutzen Sie entweder
     das Schlüsselwort &true; oder &false;.  Beide unterscheiden sich
     nicht bezüglich Groß- und Kleinschreibung.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = True; // $foo wird der Wert TRUE zugewiesen
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Üblicherweise verwenden Sie einen der <link
     linkend="language.operators">Operatoren</link>, der Ihnen einen
     <type>boolean</type> Wert liefert, den Sie dann an eine der <link
     linkend="control-structures">Kontroll-Strukturen</link>
     weiterreichen.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// == ist ein Vergleichs-Operator der auf Gleichheit überprüft und
// einen boolschen Wert liefert
if ($action == "show_version") {
    echo "Die Version ist 1.23";
}

// Das ist nicht notwendig...
if ($show_separators == TRUE) {
    echo "<hr>\n";
}

// ...weil Sie einfach schreiben können:
if ($show_separators) {
    echo "<hr>\n";
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>

   <sect2 id="language.types.boolean.casting">
    <title>Umwandlung nach boolean</title>
    <simpara>
     Um einen Wert ausdrücklich nach <type>boolean</type> zu
     konvertieren benutzen Sie entweder die Umwandlung mittels
     <literal>(bool)</literal> oder <literal>(boolean)</literal>. In
     den allermeisten Fällen ist es jedoch nicht notwendig die
     Umwandlung selbst vorzunehmen. Ein Wert wird automatisch
     konvertiert, falls ein Operator, eine Funktion oder eine
     Kontrollstruktur ein <type>boolean</type> Argument erfordern.
    </simpara>
    <simpara>
     Siehe auch <link
     linkend="language.types.type-juggling">Typ-Veränderung</link>.
    </simpara>

    <para>
     Bei der Umwandlung nach <type>boolean</type> werden folgende
     Werte als &false; angesehen:
     <itemizedlist>

      <listitem>
       <simpara>
        das <link linkend="language.types.boolean">boolean</link>
        &false; selbst
       </simpara>
      </listitem>

      <listitem>
       <simpara>
        die <link linkend="language.types.integer">Integer</link> 0
        (Null)
       </simpara>
      </listitem>

      <listitem>
       <simpara>
        die <link
        linkend="language.types.float">Fließkomma-Zahl</link> 0.0 (Null)
       </simpara>
      </listitem>

      <listitem>
       <simpara>die leere <link
        linkend="language.types.string">Zeichenkette</link> und die
        <link linkend="language.types.string">Zeichenkette</link> "0"
       </simpara>
      </listitem>

      <listitem>
       <simpara>
        ein <link linkend="language.types.array">Array</link> ohne
        Elemente
       </simpara>
      </listitem>

      <listitem>
       <simpara>
        ein <link linkend="language.types.object">Objekt</link> ohne
        Mitgliedsvariablen
       </simpara>
      </listitem>

      <listitem>
       <simpara>
        der spezielle Typ <link
        linkend="language.types.null">NULL</link> (einschließlich
        nicht definierter Variablen)
       </simpara>
      </listitem>

     </itemizedlist>

     Jeder andere Wert wird als &true; angesehen (einschließlich jeder
     <link linkend="language.types.resource">Resource</link>).
     <warning>
      <simpara>
       <literal>-1</literal> wird als &true; angesehen, wie jede
       andere Zahl ungleich Null (egal ob negativ oder positiv)!
      </simpara>
     </warning>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
echo gettype((bool) "");        // bool(falsch)
echo gettype((bool) 1);         // bool(wahr)
echo gettype((bool) -2);        // bool(wahr)
echo gettype((bool) "foo");     // bool(wahr)
echo gettype((bool) 2.3e5);     // bool(wahr)
echo gettype((bool) array(12)); // bool(wahr)
echo gettype((bool) array());   // bool(falsch)
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.integer">
   <title>Integer Typen</title>

   <simpara>
    Ein <type>Integer</type> ist eine Zahl aus der Menge Z = {..., -2,
    -1, 0, 1, 2, ...}.
   </simpara>

   <para>
    Siehe auch: <link linkend="ref.gmp">Ganzzahlen beliebiger Länge /
    GMP</link>, <link
    linkend="language.types.float">Fließkomma-Zahlen</link> und <link
    linkend="ref.bc">Mathematische Funktionen mit beliebiger
    Genauigkeit</link>
   </para>
   <sect2 id="language.types.integer.syntax">
    <title>Syntax</title>
    <simpara>
     Ganzzahlen können in dezimaler (10-basierter), hexadezimaler
     (16-basierter) oder oktaler (8-basierter) Schreibweise angegeben
     werden, wahlweise mit einem vorangestellten Zeichen (- oder +).
    </simpara>
    <para>
     Wenn Sie die oktale Schreibweise verwenden, müssen Sie die Zahl
     mit einer vorangestellten Null <literal>0</literal> schreiben; in
     hexadezimaler Schreibweise müssen Sie vor die Zahl ein
     <literal>0x</literal> schreiben.
     <example>
      <title>Integer Literale</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 1234; // Dezimalzahl
$a = -123; // eine negative Zahl
$a = 0123; // Oktalzahl (entspricht 83 dezimal)
$a = 0x1A; // Hexadezimalzahl (entspricht 26 dezimal)
?>
]]>
      </programlisting>
     </example>
     Formell ist die mögliche Struktur für Integer Literale:
     <informalexample>
      <programlisting>
<![CDATA[
dezimal     : [1-9][0-9]*
            | 0

hexadezimal : 0[xX][0-9a-fA-F]+

oktal       : 0[0-7]+

integer     : [+-]?dezimal
            | [+-]?hexadezimal
            | [+-]?oktal
]]>
      </programlisting>
     </informalexample>
     Die Größe eines Integer-Wertes ist plattformabhängig, ein
     Maximalwert von ungefähr zwei Milliarden ist jedoch üblich
     (vorzeichenbehafteter 32-Bit-Wert). PHP unterstützt keine
     vorzeichenlosen Integer-Werte.
    </para>
   </sect2>

   <sect2 id="language.types.integer.overflow">
    <title>Integer Überlauf</title>
    <para>
     Wenn Sie eine Zahl jenseits der Grenzen des Typs
     <type>Integer</type> angeben, wird diese stattdessen als Typ
     <type>float</type> interpretiert.  Wenn Sie eine Operation
     ausführen, deren Ergebnis eine Zahl jenseits der Grenzen des Typs
     <type>Integer</type> ist, wird ebenso eine Zahl vom Typ
     <type>float</type> zurückgegeben.

     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$grosse_zahl =  2147483647;
var_dump($grosse_zahl);
// Ausgabe: int(2147483647)

$grosse_zahl =  2147483648;
var_dump($grosse_zahl);
// Ausgabe: float(2147483648)

// das gilt auch für Integers in hexadezimaler Schreibweise:
var_dump( 0x80000000 );
// Ausgabe: float(2147483648)

$million = 1000000;
$grosse_zahl =  50000 * $million;
var_dump($grosse_zahl);
// Ausgabe: float(50000000000)
?>
]]>
      </programlisting>
     </informalexample>
     <warning>
      <simpara>
       Bedauerlicherweise gab es einen Bug in PHP, der die korrekte
       Funktionsweise verhinderte, wenn negative Zahlen verwendet
       wurden.  Ein Beispiel: Bei der Ausführung von <literal>-50000
       * $million</literal> war das Ergebnis
       <literal>-429496728</literal>. Sind beide Operanden positiv
       gibt es keine Probleme.
      </simpara>
      <simpara>
       Dieses Problem ist in PHP 4.1.0 behoben worden.
      </simpara>
     </warning>
    </para>
    <para>
     In PHP gibt es keinen Operator für Integer-Divisonen.
     <literal>1/2</literal> ergibt <type>float</type>
     <literal>0.5</literal>.  Sie können den Wert in einen Integer
     umwandeln, um ihn immer abzurunden oder die Funktion
     <function>round</function> benutzen.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
var_dump(25/7);         // float(3.5714285714286)
var_dump((int) (25/7)); // int(3)
var_dump(round(25/7));  // float(4)
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>

   <sect2 id="language.types.integer.casting">
    <title>Umwandlung nach integer</title>
    <simpara>
     Um einen Wert ausdrücklich nach <type>integer</type> zu
     konvertieren, benutzen Sie entweder die Umwandlung mittels
     <literal>(int)</literal> oder <literal>(integer)</literal>. In
     den allermeisten Fällen ist es jedoch nicht notwendig die
     Umwandlung selbst vorzunehmen. Ein Wert wird automatisch
     konvertiert, falls ein Operator, eine Funktion oder eine
     Kontrollstruktur ein <type>integer</type> Argument erfordern.
     Sie können einen Wert auch mit der Funktion
     <function>intval</function> in einen Integer umwandeln.
    </simpara>
    <simpara>
     Siehe auch <link
     linkend="language.types.type-juggling">Typ-Veränderung</link>.
    </simpara>

    <sect3 id="language.types.integer.casting.from-boolean">
     <title>
      Von <link linkend="language.types.boolean">Booleans</link>
     </title>
     <simpara>
      &false; ergibt <literal>0</literal> (Null), und &true; ergibt
      <literal>1</literal> (Eins).
     </simpara>
    </sect3>

    <sect3 id="language.types.integer.casting.from-float">
     <title>
      Von <link
      linkend="language.types.float">Fließkomma-Zahlen</link>
     </title>
     <simpara>
      Bei der Umwandlung von <type>float</type> nach integer wird die
      Zahl <emphasis>in Richtung Null</emphasis> gerundet.
     </simpara>

     <para>
      Wenn der float jenseits der Grenzen von integer liegt
      (üblicherweise <literal>+/- 2.15e+9 = 2^31</literal>), ist das
      Ergebnis nicht definiert, weil float nicht genug Präzision
      besitzt um ein genaues integer Ergebnis zu liefern. Keine
      Warnung, nicht einmal eine Notiz wird in diesem Fall ausgegeben.
     </para>

     <warning>
      <para>
       Wandeln Sie nie einen Teil eines Ausdrucks nach
       <type>integer</type> um, da dies manchmal zu unerwarteten
       Ergebnissen führen kann.
       <informalexample>
        <programlisting role="php">
<![CDATA[
<?php
echo (int) ( (0.1+0.7) * 10 ); // Ausgabe: 7!
?>
]]>
        </programlisting>
       </informalexample>
       Für mehr Informationen schauen Sie unter <link
       linkend="warn.float-precision">Warnung über
       float-Präzision</link> nach.
      </para>
     </warning>
    </sect3>

    <sect3 id="language.types.integer.casting.from-string">
     <title>Von Zeichenketten / Strings</title>
     <simpara>
      Siehe <link
      linkend="language.types.string.conversion">Umwandlung von
      Strings in Zahlen</link>
     </simpara>
    </sect3>

    <sect3 id="language.types.integer.casting.from-other">
     <title>Von anderen Typen</title>
     <para>
      <caution>
       <simpara>
        Das Verhalten bei der Umwandlung nach integer ist für andere
        Typen nicht definiert. Zum gegenwärtigen Zeitpunkt ist das
        Verhalten so, als ob der Wert zuerst nach <link
        linkend="language.types.boolean.casting">boolean</link>
        konvertiert wird. Auf jeden Fall sollten Sie sich auf dieses
        Verhalten <emphasis>nicht</emphasis> verlassen. Es kann sich
        ohne Ankündigung ändern.
       </simpara>
      </caution>
     </para>
    </sect3>
   </sect2>
  </sect1>

  <sect1 id="language.types.float">
   <title>Fließkomma-Zahlenwerte</title>
   <para>
    Fließkomma-Zahlenwerte ("floats", "doubles" oder "reelle Zahlen")
    können durch eine der folgenden Anweisungen zugewiesen werden:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1.234;
$a = 1.2e3;
$a = 7E-10;
?>
]]>
     </programlisting>
    </informalexample>
    Formell:
    <informalexample>
     <programlisting role="php">
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM ( ({LNUM} | {DNUM}) [eE][+-]? {LNUM})
     </programlisting>
    </informalexample>
    Die Größe einer Fließkomma-Zahl ist plattformabhängig, dennoch
    stellt ein Maximum von ~1.8e308 mit einer Genauigkeit von 14
    Nachkomma-Stellen einen üblichen Wert dar (das entspricht 64-Bit
    im IEEE-Format).
   </para>

   <warning id="warn.float-precision">
    <title>Fließkomma Präzision</title>
    <para>
     Es ist ziemlich normal, dass einfache Dezimalzahlen wie
     <literal>0.1</literal> oder <literal>0.7</literal> nicht in ihre
     internen binären Entsprechungen konvertiert werden können, ohne
     einen kleinen Teil ihrer Genauigkeit zu verlieren. Das kann zu
     verwirrenden Ergebnissen führen. So wird <literal>floor((0.1 +
     0.7) * 10)</literal> normalerweise <literal>7</literal> statt des
     erwarteten Wertes <literal>8</literal> zurück geben (als Ergebnis
     der internen Entsprechung von <literal>7.9999999999...</literal>.
    </para>
    <para>
     Das gründet sich auf die Tatsache, dass es unmöglich ist, manche
     Dezimal-Zahlen durch eine endliche Anzahl an Nachkomma-Stellen
     darzustellen. Dem Wert <literal>1/3</literal> entspricht z.B.
     der interne Wert von <literal>0.3333333. . .</literal>.
    </para>
    <para>
     Deshalb sollten Sie nie den Ergebnissen von
     Fließkomma-Operationen bis auf die letzte Nachkomma-Stelle trauen
     und nie solche auf Gleichheit prüfen. Benötigen Sie wirklich eine
     größere Genauigkeit, sollten sie die <link
     linkend="ref.bc">mathematischen Funktionen beliebiger
     Genauigkeit</link> oder die <link linkend="ref.gmp">Gmp</link>
     Funktionen benutzen.
    </para>
   </warning>

   <sect2 id="language.types.float.casting">
    <title>Umwandlung nach float</title>

    <para>
     Für Informationen darüber, wann und wie Strings in Float
     umgewandelt werden, lesen Sie bitte den Abschnitt <link
     linkend="language.types.string.conversion">Umwandlung von Strings
     in Zahlen</link>. Für die Werte anderer Typen ist die Umwandlung
     diesselbe, wie wenn der Wert in eine Ganzzahl und dann in einen
     Float umgewandelt worden wäre. Für weitere Informationen siehe
     Abschnitt <link
     linkend="language.types.integer.casting">Umwandlung nach
     integer</link>.
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.string">
   <title>Strings / Zeichenketten</title>
   <para>
    Ein <type>String</type> ist eine Folge von Zeichen. In PHP
    entspricht ein Zeichen einem Byte, das heißt, dass exakt 256
    unterschiedliche Zeichen möglich sind. Das impliziert auch, dass
    PHP keine native Unterstützung für Unicode bietet. Siehe
    <function>utf8_encode</function> und
    <function>utf8_decode</function> für etwas Unicode-Unterstützung.
   </para>
   <note>
    <simpara>
     Für einen String stellt die Länge kein Problem dar. Von PHP-Seite
     aus gibt es keine praktische Grenze für die Größe eines Strings.
     Daher gibt es keinen Grund sich Sorgen über lange Strings zu
     machen.
    </simpara>
   </note>

   <sect2 id="language.types.string.syntax">
    <title>Syntax</title>
    <para>
     Ein String kann auf drei verschiedene Weisen geschrieben werden.

     <itemizedlist>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">Einfache
        Anführungszeichen (single quoted)</link>
       </simpara>
      </listitem>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">Doppelte
        Anführungszeichen (double quoted)</link>
       </simpara>
      </listitem>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">Heredoc
        Syntax</link>
       </simpara>
      </listitem>

     </itemizedlist>
    </para>

    <sect3 id="language.types.string.syntax.single">
     <title>Einfache Anführungszeichen (Single quoted)</title>
     <para>
      Der leichteste Weg einen einfachen String zu schreiben, ist der
      Einschluss in einfache Anführungszeichen (das Zeichen
      <literal>'</literal>).
     </para>
     <para>
      Um ein einfaches Anführungszeichen wörtlich auszugeben, muss
      dieses, wie in vielen anderen Programmiersprachen auch mit einem
      Backslash (<literal>\</literal>) escaped werden. Wenn Sie
      innerhalb eines Strings einen Backslash vor einem einfachen
      Anführungszeichen oder am Ende eines Strings ausgeben wollen,
      müssen Sie diesen verdoppeln.  Beachten Sie: wenn Sie versuchen
      irgendwelche anderen Zeichen zu escapen, wird der Backslash
      ebenfalls ausgegeben! Daher besteht für gewöhnlich keine
      Notwendigkeit den Backslash selbst zu escapen.
      <note>
       <simpara>
        In PHP 3 wird eine Warnung der Stufe
        <literal>E_NOTICE</literal> ausgegeben, wenn das passiert.
       </simpara>
      </note>
      <note>
       <simpara>
        Anders als bei den zwei anderen Schreibweisen werden <link
        linkend="language.variables">Variablen</link> und
        escape-Sequenzen für spezielle Zeichen innerhalb von
        single-quoted Strings <emphasis>nicht</emphasis> ausgewertet.
       </simpara>
      </note>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo 'Das ist ein einfacher String';

echo 'Sie können auf diese Weise auch Zeilenumbrüche
innerhalb von Strings verwenden, wenn
Ihnen danach ist';

// Ausgabe: Arnold sagte einmal: "I'll be back"
echo 'Arnold sagte einmal: "I\'ll be back"';

// Ausgabe: Sie haben C:\*.* gelöscht?
echo 'Sie haben C:\\*.* gelöscht?';

// Ausgabe: Sie haben C:\*.* gelöscht?
echo 'Sie haben C:\*.* gelöscht?';

// Ausgabe: Das wird nicht ausgewertet: \n ein Zeilenumbruch
echo 'Das wird nicht ausgewertet: \n ein Zeilenumbruch';

// Ausgabe: Variablen werden auch $nicht $ausgewertet
echo 'Variablen werden auch $nicht $ausgewertet';
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect3>

    <sect3 id="language.types.string.syntax.double">
     <title>Doppelte Anführungszeichen (Double quoted)</title>
     <para>
      Wenn ein String in doppelten Anführungszeichen (")
      eingeschlossen ist, versteht PHP mehr Escape-Folgen für
      spezielle Zeichen:
     </para>
     <table>
      <title>Nicht ausgewertete / übergangene Zeichen:</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Zeichenfolge</entry>
         <entry>Bedeutung</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>\n</literal></entry>
         <entry>Zeilenvorschub (LF oder 0x0A als ASCII-Code)</entry>
        </row>
        <row>
         <entry><literal>\r</literal></entry>
         <entry>Wagenrücklauf (CR oder 0x0D als ASCII-Code)</entry>
        </row>
        <row>
         <entry><literal>\t</literal></entry>
         <entry>
          horizontaler Tabulator (HT oder 0x09 als ASCII-Code)
         </entry>
        </row>
        <row>
         <entry><literal>\\</literal></entry>
         <entry>Backslash / Rückstrich</entry>
        </row>
        <row>
         <entry><literal>\$</literal></entry>
         <entry>Dollar-Symbol</entry>
        </row>
        <row>
         <entry><literal>\"</literal></entry>
         <entry>doppelte Anführungszeichen</entry>
        </row>
        <row>
         <entry><literal>\[0-7]{1,3}</literal></entry>
         <entry>
          die Zeichenfolge, die dem regulären Ausdruck entspricht ist
          ein Zeichen in Oktal-Schreibweise
         </entry>
        </row>
        <row>
         <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
         <entry>
          die Zeichenfolge, die dem regulären Ausdruck entspricht ist
          ein Zeichen in Hexadezimal-Schreibweise
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
     <para>
      Noch einmal: wenn Sie versuchen, irgend ein anderes Zeichen zu
      escapen wird der Backslash ebenfalls ausgegeben!
     </para>
     <para>
      Das wichtigste Merkmal von double-quoted Strings ist die
      Tatsache, dass Variablennamen ausgewertet werden. Für Details
      siehe <link linkend="language.types.string.parsing">String
      Analyse (parsing)</link>
     </para>
    </sect3>

    <sect3 id="language.types.string.syntax.heredoc">
     <title>Heredoc</title>
     <simpara>
      Eine andere Möglichkeit Strings einzufassen, besteht im Gebrauch
      der heredoc-Syntax ("&lt;&lt;&lt;"). Hierfür ist nach
      <literal>&lt;&lt;&lt;</literal> ein Bezeichner zu setzen. Nun
      folgt der eigentliche String und dann derselbe Bezeichner um den
      String abzuschließen.
     </simpara>
     <simpara>
      Der schließende Bezeichner <emphasis>muss</emphasis> in der
      ersten Spalte der Zeile stehen. Die verwendeten Bezeichner
      müssen den gleichen Regeln entsprechen wie alle anderen
      PHP-Labels auch: Sie dürfen lediglich alphanumerische Zeichen
      und den Unterstrich enthalten und müssen mit einem Unterstrich
      oder einem Buchstaben beginnen.
     </simpara>

     <warning>
      <simpara>
       Es ist sehr wichtig zu beachten, dass die Zeile mit dem
       schließenden Bezeichner keine anderen Zeichen enthält,
       ausgenommen <emphasis>möglicherweise</emphasis> ein Semikolon
       (<literal>;</literal>). Das bedeuted im Besonderen, dass der
       Bezeichner <emphasis>nicht eingerückt werden darf</emphasis>
       und es dürfen keine Leerzeichen oder Tabulatoren vor oder nach
       dem Semikolon stehen. Außerdem ist es wichtig, zu beachten,
       dass das erste Zeichen vor dem schließenden Bezeichner ein der
       Definition Ihres Betriebssystems entsprechender Zeilenvorschub,
       sein muss. Das ist zum Beispiel auf einem Macintosh ein
       <literal>\r</literal>.
      </simpara>
      <simpara>
       Falls diese Regel gebrochen wird und der schließende Bezeichner
       nicht "sauber" ist, wird er nicht als schließender Bezeichner
       betrachtet und PHP wird weiter danach suchen. Wird in diesem
       Fall kein korrekter schließender Bezeichner gefunden, gibt es
       einen Parser-Fehler mit der Zeilennummer vom Ende des Skripts.
      </simpara>
     </warning>

     <para>
      Heredoc-Text funktioniert wie ein String innnerhalb doppelter
      Anführungszeichen, nur ohne doppelte Anführungszeichen.
      Anführungszeichen innerhalb von heredoc-Texten müssen also
      keiner Sonderbehandlung (escapen) unterzogen werden, aber Sie
      können dennoch die oben aufgeführten Escape-Anweisungen
      verwenden. Variablen werden ausgewertet, aber besondere
      Aufmerksamkeit muss komplexen Variablen gewidmet werden, genau
      wie bei Strings.
      <example>
       <title>
        Beispiel zur String-Festlegung per "heredoc"-Methode:
       </title>
       <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Beispiel eines Strings
über mehrere Script-Zeilen
durch Gebrauch der heredoc-Syntax.
EOD;

/* komplexeres Beispiel, mit Variablen */
class foo {
    var $foo;
    var $bar;

    function foo() {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'Mein Name';

echo <<<EOT
Mein Name ist "$name". Ich schreibe einige $foo->foo.
Nun schreibe ich gerade einige {$foo->bar[1]}.
Dies sollte ein großes 'A' schreiben: \x41
EOT;
?>
]]>
       </programlisting>
      </example>
     </para>

     <note>
      <para>
       Die heredoc Unterstützung wurde in PHP 4 eingeführt.
      </para>
     </note>
    </sect3>

    <sect3 id="language.types.string.parsing">
     <title>Variablen-Analyse (parsing)</title>
     <simpara>
      Wird ein String in doppelten Anführungszeichen oder mit heredoc
      angegeben, werden enthaltene <link
      linkend="language.variables">Variablen</link> ausgewertet
      (geparst).
     </simpara>
     <simpara>
      Es gibt zwei Syntax-Typen: eine <link
      linkend="language.types.string.parsing.simple">einfache</link>
      und eine <link
      linkend="language.types.string.parsing.complex">komplexe</link>.
      Die einfache Syntax ist die geläufigste und bequemste. Sie
      bietet die Möglichkeit eine Variable, einen
      <type>Array</type>-Wert oder eine
      <type>Objekt</type>-Eigenschaft auszuwerten (parsen).
     </simpara>
     <simpara>
      Die komplexe Syntax wurde in PHP 4 eingeführt und ist an den
      geschweiften Klammern <literal>{}</literal>erkennbar, die den
      Ausdruck umschließen.
     </simpara>

     <sect4 id="language.types.string.parsing.simple">
      <title>Einfache Syntax</title>
      <simpara>
       Sobald ein Dollarzeichen (<literal>$</literal>) auftaucht, wird
       der Parser versuchen, gierig so viele Zeichen wie möglich zu
       bekommen, um einen gültigen Variablennamen zu bilden.
       Schließen Sie Ihren Varaiblennamen in geschweifte Klammern ein,
       wenn Sie ausdrücklich das Ende des Namens angeben wollen.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$beer = 'Heineken';
echo "$beer's Geschmack ist großartig";  // funktioniert, "'" ist kein gültiges
                                         // Zeichen für einen Variablennamen
echo "Er hat einige $beers getrunken";   // funktioniert nicht, 's' ist ein gültiges
                                         // Zeichen für einen Variablennamen
echo "Er hat einige ${beer}s getrunken"; // funktioniert
echo "Er hat einige {$beer}s getrunken"; // funktioniert
?>
]]>
       </programlisting>
      </informalexample>
      <simpara>
       Auf ähnliche Weise können Sie erreichen, dass ein
       <type>Array</type>-Index oder eine
       <type>Objekt</type>-Eigenschaft ausgewertet wird. Bei
       Array-Indizes markiert die schließende eckige Klammer
       (<literal>]</literal>) das Ende des Index. Für
       Objekt-Eigenschaften gelten die gleichen Regeln wie bei
       einfachen Variablen, obwohl es bei Objekt-Eigenschaften keinen
       Trick gibt, wie dies bei Variablen der Fall ist.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Diese Beispiele sind spezifisch für die Verwendung von Arrays
// innerhalb von Strings. Setzen sie die String-Schlüssel Ihrer Arrays
// außerhalb von Strings immer in Anführungszeichen und verwenden Sie
// außerhalb von Strings auch keine {geschweiften Klammern}.

// Wir lassen uns alle Fehlermeldungen anzeigen
error_reporting(E_ALL);

$früchte = array('Erdbeere' => 'rot' , 'Banane' => 'gelb');

// Funktioniert aber beachten Sie: außerhalb von
// String-Anführungszeichen funktioniert das anders
echo "Eine Banane ist $früchte[Banane].";

// Funktioniert
echo "Eine Banane ist {$früchte['Banane']}.";

// Funktioniert, aber PHP sucht, wie unten beschrieben, zuerst nach
// einer Konstanten namens Banane.
echo "Eine Banane ist {$früchte[Banane]}.";

// Funktioniert nicht; verwenden Sie geschweifte Klammern. Das
// erzeugt einen Parser-Fehler.
echo "Eine Banane ist $früchte['Banane'].";

// Funktioniert
echo "Eine Banane ist " . $früchte['Banane'] . ".";

// Funktioniert
echo "Dieses Quadrat ist $quadrat->breite Meter breit.";

// Funktioniert nicht. Für eine Lösung siehe die komplexe Syntax.
echo "Dieses Quadrat ist $quadrat->breite00 Zentimeter breit.";
?>
]]>
       </programlisting>
      </informalexample>
      <simpara>
       Für irgendetwas Komplexeres sollten Sie die komplexe Syntax
       nutzen.
      </simpara>
     </sect4>

     <sect4 id="language.types.string.parsing.complex">
      <title>Komplexe (geschweifte) Syntax</title>
      <simpara>
       Diese wird nicht komplex genannt, weil etwa die Syntax komplex
       ist, sondern weil Sie auf diesem Weg komplexe Ausdrücke
       einbeziehen können.
      </simpara>
      <simpara>
       Tatsächlich können Sie jeden beliebigen Wert einbeziehen, der
       im Namensbereich in Strings gültig ist. Schreiben Sie den
       Ausdruck einfach auf die gleiche Art und Weise, wie außerhalb
       des Strings, und umschließen diesen mit { und }. Da Sie '{'
       nicht escapen können, wird diese Syntax nur erkannt, wenn auf {
       unmittelbar $ folgt.  (Benutzen Sie "{\$" oder "\{$" um ein
       wörtliches "{$" zu erhalten.) Einige Beispiele, um dies zu
       verdeutlichen:
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Wir lassen uns alle Fehlermeldungen anzeigen
error_reporting(E_ALL);

$great = 'fantastisch';

// Funktioniert nicht, Ausgabe: Das ist { fantastisch}
echo "Das ist { $great}";

// Funktioniert, Ausgabe: Das ist fantastisch
echo "Das ist {$great}";
echo "Das ist ${great}";

// Funktioniert
echo "Dieses Quadrat ist {$square->width}00 Zentimeter breit.";

// Funktioniert
echo "Das funktioniert: {$arr[4][3]}";

// Das ist aus dem gleichen Grund falsch
// wie $foo[bar] außerhalb eines Strings falsch ist. Mit
// anderen Worten, es funktioniert zwar, aber weil PHP
// zunächst nach einer Konstanten namens foo sucht, gibt
// es einen Fehler der Stufe E_NOTICE (undefined constant)
// aus.
echo "Das ist falsch: {$arr[foo][3]}";

// Funktioniert. Benutzen Sie bei der Verwendung
// mehrdimensionaler Arrays innerhalb von Strings immer
// Klammern um die Arrays.
echo "Das funktioniert: {$arr['foo'][3]}";

// Funktioniert
echo "Das funktioniert: " . $arr['foo'][3];

echo "Sie können sogar schreiben {$obj->values[3]->name}";

echo "Das ist der Wert der Variable mit Namen $name: {${$name}}";
?>
]]>
       </programlisting>
      </informalexample>
     </sect4>
    </sect3>

    <sect3 id="language.types.string.substr">
     <title>Zugriff und Modifikation von Zeichen in Strings</title>
     <para>
      Innerhalb von Zeichenketten (strings) kann durch die Angabe des
      nullbasierten Offsets in geschweiften Klammern nach dem String auf das
      gewünschte Zeichen zugegriffen oder dieses modifiziert werden.
     </para>
     <note>
      <simpara>
       Für Abwärtskompatibilität können Sie für den selben Zweck immer
       noch die Array-Klammern verwenden. Diese Syntax wird jedoch
       seit PHP 4 missbilligt.
      </simpara>
     </note>
     <para>
      <example>
       <title>Einige String-Beispiele</title>
       <programlisting role="php">
<![CDATA[
<?php
// Das erste Zeichen eines Strings.
$str = 'Das ist ein Test.'
$erstes = $str{0};                // $erstes enthält "D"

// Das dritte Zeichen eines Strings.
$drittes = $str{2};

// Das letzte Zeichen eines Strings.
$str = 'Das ist immer noch ein Test.'
$letztes = $str{strlen($str)-1};    // $letztes enthält "."

// Das letzte Zeichen eines Strings verändern
  	$str = 'Schau auf die Straßi';
  	$str{strlen($str)-1} = 'e';

?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>

   </sect2><!-- end syntax -->

   <sect2 id="language.types.string.useful-funcs">
    <title>Nützliche Funktionen und Operatoren</title>
    <para>
     Strings können mittels des '.'(dot)-Operators miteinander
     verbunden werden. Beachten Sie, dass dafür nicht der '+'
     (Additions)-Operator verwendet werden kann. Für mehr
     Informationen schauen Sie bitte unter den <link
     linkend="language.operators.string">Zeichenketten-Operatoren</link>
     nach.
    </para>
    <para>
     Es gibt eine Menge nützlicher Funktionen zur String-Manipulation.
    </para>
    <simpara>
     Für allgemeine Funktionen schauen Sie sich den Abschnitt über
     <link linkend="ref.strings">String Funktionen</link> an, und für
     fortgeschrittenes Suchen &amp; Ersetzen die Funktionen zu
     Regulären Ausdrücken (in zwei Ausführungen: <link
     linkend="ref.pcre">Perl Kompatibel</link> und <link
     linkend="ref.regex">POSIX erweitert</link>).
    </simpara>
    <simpara>
     Weiterhin gibt es auch noch <link linkend="ref.url">Funktionen
     für URL-Strings</link>, und Funktionen zum
     Verschlüsseln/Entschlüsseln von Strings (<link
     linkend="ref.mcrypt">mcrypt</link> und <link
     linkend="ref.mhash">mhash</link>).
    </simpara>
    <simpara>
     Schließlich, falls Sie immer noch nicht das gefunden haben wonach
     Sie suchen, schauen Sie unter den <link
     linkend="ref.ctype">Zeichen-Typen Funktionen</link> nach.
    </simpara>
   </sect2>

   <sect2 id="language.types.string.casting">
    <title>Umwandlung nach string</title>

    <para>
     Sie können einen Wert mit der
     <literal>(string)</literal>-Umwandlung oder mit der Funktion
     <function>strval</function> in einen String umwandeln. Die
     Umwandlung in einen String wird im dem Bereich eines Ausdrucks,
     in dem ein String benötigt wird, automatisch für Sie vorgenommen.
     Dies geschieht, wenn Sie die Funktionen <function>echo</function>
     oder <function>print</function> benutzen oder wenn Sie den Wert
     einer Variablen mit einem String vergleichen. Die Abschnitte über
     <link linkend="language.types">Typen</link> und <link
     linkend="language.types.type-juggling">Typen-Tricks</link>
     verdeutlichen das folgende. Siehe auch
     <function>settype</function>.
    </para>

    <para>
     Ein <type>Boolean</type> &true;-Wert wird in den String
     <literal>"1"</literal> umgewandelt, der &false;-Wert wird als
     <literal>""</literal> (leerer String) dargestellt. Dadurch können
     Sie Boolean- und String-Werte ineinander umwandeln.
    </para>
    <para>
     Ein <type>Integer</type> oder eine Fließkommazahl
     (<type>Float</type>) wird in einen String umgewandelt, der die
     Zahl durch seine Ziffern darstellt (bei Fließkommazahlen
     inklusive Exponententeil).
    </para>
    <para>
     Arrays werden immer in den String <literal>"Array"</literal>
     umgewandelt. Sie können also den Inhalt eines <type>Arrays</type>
     nicht mit <function>echo</function> oder
     <function>print</function> ausgeben, um zu sehen, was es enthält.
     Um ein Element anzuschauen, benötigen Sie etwas in der Art
     <literal>echo $arr['foo']</literal>. Siehe weiter unten für
     Hinweise zur Ausgabe/Ansicht des kompletten Inhalts.
    </para>
    <para>
     Objekte werden immer in den String <literal>"Object"</literal>
     umgewandelt. Wenn Sie für die Fehlersuche die Werte der
     Mitgliedsvariablen eines <type>Objekts</type> ausgeben möchten,
     lesen Sie bitte die Abschnitte weiter unten. Benutzen Sie
     <function>get_class</function>, wenn Sie den Namen der Klasse
     erfahren möchten, von der ein Objekt eine Instanz ist.
    </para>
    <para>
     Ressourcen werden immer in Strings mit der Struktur
     <literal>"Resource id #1"</literal> umgewandelt, wobei
     <literal>1</literal> die eindeutige Nummer ist, die der
     <type>Resource</type> von PHP zur Laufzeit zugeordnet wurde.
     Benutzen Sie <function>get_resource_type</function>, wenn Sie
     wissen möchten, welchen Typs die Ressource ist.
    </para>
    <para>
     &null; wird immer in einen leeren String umgewandelt.
    </para>

    <para>
     Wie Sie oben erfahren haben, liefert Ihnen die Ausgabe von
     Arrays, Objekten oder Ressourcen keine brauchbaren Informationen
     über die Werte selbst. Schauen Sie sich für eine bessere
     Möglichkeit, sich Werte für die Fehlersuche ausgeben zu lassen,
     die Funktionen <function>print_r</function> und
     <function>var_dump</function> an.
    </para>

    <para>
     Sie können PHP-Werte auch in Strings umwandeln, um sie dauerhaft
     zu speichern. Diese Methode wird als Serialisierung bezeichnet
     und kann mit der Funktion <function>serialize</function>
     vorgenommen werden. Falls Ihr PHP über <link
     linkend="ref.wddx">WDDX</link>-Unterstützung verfügt, können Sie
     PHP-Werte auch in XML-Strukturen serialisieren.
    </para>
   </sect2>

   <sect2 id="language.types.string.conversion">
    <title>Umwandlung von Strings in Zahlen</title>

    <simpara>
     Sobald ein String als numerischer Wert ausgewertet wird, werden
     der resultierende Wert und der Typ wie folgt festgelegt.
    </simpara>
    <simpara>
     Der String wird als <type>float</type> ausgewertet, wenn er eines
     der Zeichen '.', 'e' oder 'E' enthält. Ansonsten wird er als
     Integer-Wert interpretiert.
    </simpara>
    <para>
     Der Wert wird durch den Anfangsteil des Strings bestimmt.  Sofern
     der String mit gültigen numerischen Daten beginnt, werden diese
     als Wert benutzt. Andernfalls wird der Wert 0 (Null) sein.
     Gültige numerische Daten sind ein optionales Vorzeichen, gefolgt
     von einer oder mehreren Zahlen (optional mit einem Dezimalpunkt).
     Wahlweise kann auch ein Exponent angegeben werden. Der Exponent
     besteht aus einem 'e' oder 'E', gefolgt von einer oder mehreren
     Zahlen.
    </para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";               // $foo ist float   (11.5)
$foo = 1 + "-1.3e3";             // $foo ist float   (-1299)
$foo = 1 + "bob-1.3e3";          // $foo ist integer (1)
$foo = 1 + "bob3";               // $foo ist integer (1)
$foo = 1 + "10 Kleine Schweine"; // $foo ist integer (11)
$foo = 4 + "10.2 Ferkel";        // $foo ist float   (14.2)
$foo = "10 Schweine " + 1;       // $foo ist integer (11)
$foo = "10.0 Schweine " + 1;     // $foo ist float   (11)
$foo = "10.0 Schweine " + 1.0;   // $foo ist float (11)
?>
]]>
     </programlisting>
    </informalexample>
    <simpara>
     Weitere Informationen über solche Umwandlungen finden Sie in den
     UNIX Manualseiten unter strtod(3).
    </simpara>
    <para>
     Wenn Sie irgendein Beispiel dieses Abschnitts testen wollen,
     können Sie dieses per "Copy und Paste" übernehmen. Fügen Sie die
     folgende Zeile Ihrem Skript hinzu und Sie sehen selbst was
     passiert:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; Typ ist " . gettype ($foo) . "<br />\n";
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Erwarten Sie nicht, den Code eines Zeichens zu bekommen, indem
     Sie es in einen Integer umwandeln (wie das z.B. in C der Fall
     wäre). Benutzen Sie die Funktionen <function>ord</function> und
     <function>chr</function>, um Zeichencodes und Zeichen ineinander
     umzuwandeln.
    </para>

   </sect2>
  </sect1><!-- end string -->

  <sect1 id="language.types.array">
   <title>Arrays</title>

   <para>
    Ein Array in PHP ist eigentlich eine geordnete Abbildung. Eine
    Abbildung ist ein Typ der <emphasis>Werte</emphasis> auf
    <emphasis>Schlüssel</emphasis> abbildet. Dieser Typ ist auf
    mehrere Arten optimiert, so dass Sie ihn auf verschiedene Weise
    benutzen können: als reales Array, als Liste (Vektor), als
    Hash-Tabelle (das ist eine praktische Anwendung einer Abbildung),
    als Verzeichnis, als Sammlung, als Stapel (Stack), als
    Warteschlange (Queue) und möglicherweise mehr. Da Sie ein weiteres
    PHP-Array als Wert benutzen können, ist es ziemlich einfach
    möglich Baumstrukturen zu simulieren.
   </para>
   <para>
    Die Erklärung dieser Datenstrukturen sprengt den Rahmen dieses
    Handbuchs, aber Sie finden zumindest ein Beispiel für jede dieser
    Strukturen. Für weitergehende Informationen verweisen wir auf
    externe Literatur zu diesem breit gefächerten Thema.
   </para>

   <sect2 id="language.types.array.syntax">
    <title>Syntax</title>

    <sect3 id="language.types.array.syntax.array-func">
     <title>Angabe mit <function>array</function></title>
     <para>
      Ein <type>array</type> kann mit Hilfe des Sparchkonstrukts
      <function>array</function> erzeugt werden. Es benötigt eine
      bestimmte Anzahl von Komma-getrennten
      <literal><replaceable>Schlüssel</replaceable> =&gt;
      <replaceable>Wert</replaceable></literal> Paaren.
     </para>
     <para>
      <synopsis>
array( <optional><replaceable>Schlüssel</replaceable> =&gt;</optional> <replaceable>Wert</replaceable>
     , ...
     )
// <replaceable>Schlüssel</replaceable> kann ein <type>Integer</type> oder <type>String</type> sein
// <replaceable>Wert</replaceable> kann irgendetwas sein
      </synopsis>
     </para>
     <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("foo" => "bar", 12 => true);

echo $arr["foo"]; // bar
echo $arr[12];    // 1
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Ein <varname>Schlüssel</varname> kann entweder ein
      <literal>integer</literal> oder ein <type>string</type> sein.
      Wenn ein Schlüssel die Standard-Darstellung einer
      <type>integer</type> Zahl ist, wird es als solche interpretiert
      werden, (z.B. <literal>"8"</literal> wird als
      <literal>8</literal> interpretiert, während
      <literal>"08"</literal> als <literal>"08"</literal>
      interpretiert werden wird). Es gibt in PHP keine
      unterschiedlichen Typen indizierter oder assoziativer Arrays.
      Es gibt nur einen Array-Typ, der sowohl Integer- als auch
      String-Indizes enthalten kann.
     </para>
     <para>
      Ein Wert kann jeder PHP-Typ sein.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("einarray" => array(6 => 5, 13 => 9, "a" => 42));

echo $arr["einarray"][6];    // 5
echo $arr["einarray"][13];   // 9
echo $arr["einarray"]["a"];  // 42
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Falls Sie für einen Wert keinen Schlüssel angeben, wird der
      größte der Ganzzahl-Indizes genommen und der neue Schlüssel wird
      dieses Maximum + 1 sein. Falls Sie einen Schlüssel angeben dem
      schon ein Wert zugeordnet wurde, wird dieser Wert überschrieben.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Dieses Array ist dasselbe wie ...
array(5 => 43, 32, 56, "b" => 12);

// ... dieses Array
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <warning>
      <simpara>
       Ab PHP 4.3.0 hat sich die oben beschriebene Generierung von
       Indizes geändert. Wenn Sie etwas an ein Array anhängen, in dem
       der größte Schlüssel negativ ist, wird der nächste Schlüssel
       jetzt Null (<literal>0</literal>) sein. Davor wäre der neue
       Index, genauso wie bei positiven Indizes, der größte vorhandene
       Schlüssel + 1 gewesen.
      </simpara>
     </warning>
     <para>
      Wenn Sie &true; als Schlüssel benutzen, wird dies als Schlüssel
      vom Typ <type>integer</type> <literal>1</literal> ausgewertet.
      Benutzen Sie &false; als Schlüssel, wird dies als Schlüssel vom
      Typ <type>integer</type> <literal>0</literal> ausgewertet. Die
      Benutzung von <literal>NULL</literal> als Schlüssel führt dazu,
      dass der Schlüssel als leerer String gewertet wird.  Verwenden
      Sie einen leeren String als Schlüssel, wird ein Schlüssel mit
      einem leeren String und seinem Wert erzeugt (oder
      überschrieben).  Das entspricht nicht der Verwendung von leeren
      Klammern.
     </para>
     <para>
      Sie können keine Arrays oder Objekte als Schlüssel benutzen.
      Der Versuch wird mit einer Warnung enden: <literal>Illegal
      offset type</literal>.
     </para>
    </sect3>

    <sect3 id="language.types.array.syntax.modifying">
     <title>
      Erzeugen / Verändern mit der eckigen Klammer-Syntax
     </title>
     <para>
      Sie können ein bestehendes Array durch explizites Zuweisen von
      Werten verändern.
     </para>
     <para>
      Weisen Sie dem Array Werte zu indem Sie den Schlüssel in eckigen
      Klammern angeben. Sie können den Schlüssel auch weglassen. In
      diesem Fall schreiben Sie einfach ein leeres Klammerpaar
      ("<literal>[]</literal>") hinter den Variablennamen.
      <synopsis>
$arr[<replaceable>Schlüssel</replaceable>] = <replaceable>Wert</replaceable>;
$arr[] = <replaceable>Wert</replaceable>;
// <replaceable>Schlüssel</replaceable> kann ein <type>integer</type> oder ein <type>string</type> sein
// <replaceable>Wert</replaceable> kann irgendetwas sein.
      </synopsis>
      Falls <varname>$arr</varname> bis dahin nicht existiert, wird es
      erzeugt. Das ist also eine alternative Syntax um ein Array zu
      erzeugen.  Um einen bestimmten Wert zu ändern, weisen Sie
      einfach einem Element, das Sie mit seinem Schlüssel
      spezifizieren, einen neuen Wert zu. Wenn Sie ein Schlüssel/Wert
      Paar entfernen möchten, benutzen Sie <function>unset</function>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array(5 => 1, 12 => 2);

$arr[] = 56;    // An dieser Stelle des Skrips ist das
                // dasselbe wie $arr[13] = 56;

$arr["x"] = 42; // Fügt dem Array ein neues Element mit
                // dem Schlüssel "x" hinzu

unset($arr[5]); // Entfernt das Element aus dem Array

unset($arr);    // Löscht das komplette Array
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <note>
      <para>
       Wie weiter oben schon erwähnt, wird, falls Sie die Klammern
       setzen ohne einen Schlüssel anzugeben, der größte der
       Integer-Indizes genommen und der neue Schlüssel wird dieses
       Maximum + 1 sein. Falls es noch keine Integer-Indizes gibt,
       wird der Schlüssel zu <literal>0</literal> (Null).  Falls Sie
       einen Schlüssel angeben dem schon ein Wert zugeordnet wurde,
       wird dieser Wert überschrieben.
      </para>
      <para>
       <warning>
        <simpara>
         Ab PHP 4.3.0 hat sich die oben beschriebene Generierung von
         Indizes geändert. Wenn Sie etwas an ein Array anhängen, in
         dem der größte Schlüssel negativ ist, wird der nächste
         Schlüssel jetzt Null (<literal>0</literal>) sein. Davor wäre
         der neue Index, genauso wie bei positiven Indizes, der größte
         vorhandene Schlüssel + 1 gewesen.
        </simpara>
       </warning>
      </para>
      <para>
       Beachten Sie, dass der hierbei verwendete größte
       Integer-Schlüssel <emphasis>im Array zu diesem Zeitpunkt nicht
       vorhanden sein muss</emphasis>. Er muss nur irgendwann im Array
       existiert haben, seitdem es zum letzten Mal neu indiziert
       wurde. Folgendes Beispiel zur Veranschaulichung:
      </para>

      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Wir erzeugen ein einfaches Array
$array = array(1, 2, 3, 4, 5);
print_r($array);

// Nun löschen wir alle Elemente, lassen das Array selbst
// aber intakt:
foreach ($array as $i => $wert) {
    unset($array[$i]);
}
print_r($array);

// Wir hängen ein Element an (beachten Sie, dass der neue Schlüssel 5
// ist, statt 0, wie sie vielleicht erwarten würden).
$array[] = 6;
print_r($array);

// Neu indizieren:
$array = array_values($array);
$array[] = 7;
print_r($array);
?>
]]>
       </programlisting>
       <para>
        Obiges Beispiel würde folgende Ausgabe erzeugen:
        <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
]]>
        </screen>
       </para>
      </informalexample>

     </note>
    </sect3>
   </sect2>

   <sect2 id="language.types.array.useful-funcs">
    <title>Nützliche Funktionen</title>
    <para>
     Es gibt viele nützliche Funktionen um mit Arrays zu arbeiten.
     Schauen Sie unter dem Abschnitt <link linkend="ref.array">Array
     Funktionen</link> nach.
    </para>
    <note>
     <para>
      Mit <function>unset</function> können Sie Schlüssel eines Arrays
      löschen. Halten Sie sich vor Augen, dass das Array NICHT neu
      indiziert wird. Wenn Sie nur "gewöhnliche Integer-Indizes" (bei
      Null beginnend, jeweils um eins steigend) verwenden, erreichen
      Sie die Neuindizierung durch Verwendung von
      <function>array_values</function>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$a = array(1 => 'eins', 2 => 'zwei', 3 => 'drei');
unset($a[2]);

/* erzeugt ein Array das wie folgt definiert worden wäre:
   $a = array(1 => 'eins', 3 => 'drei');
   und NICHT
   $a = array(1 => 'eins', 2 => 'drei');
*/

$b = array_values($a);
// Jetzt ist $b array(1 => 'eins', 2 =>'drei')
?>
]]>
       </programlisting>
      </informalexample>

     </para>
    </note>
    <para>
     Die <link linkend="control-structures.foreach">foreach</link>
     Kontrollstruktur gibt es speziell für Arrays. Damit ist es leicht
     ein Array zu durchlaufen.
    </para>
   </sect2>

   <sect2 id="language.types.array.donts">
    <title>Array do's und don'ts</title>

    <sect3 id="language.types.array.foo-bar">
     <title>Warum ist <literal>$foo[bar]</literal> falsch?</title>
     <para>
      Sie sollten immer Anführungszeichen für einen
      String-Literal-Index eines Arrays benutzen. Zum Beispiel
      sollten Sie $foo['bar'] und nicht
      $foo[bar] benutzen. Aber warum ist $foo[bar] falsch? Vieleicht
      kennen Sie folgende Syntax aus alten Skripts:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$foo[bar] = 'Feind';
echo $foo[bar];
// usw
?>
]]>
       </programlisting>
      </informalexample>
      Es ist falsch, funktioniert aber. Warum ist es dann falsch?  Der
      Grund ist, dass dieser Code statt eines Strings ('bar'- beachten
      Sie die Anführungszeichen) eine undefinierte Konstante (bar)
      enthält und PHP in Zukunft Konstanten definieren könnte, die,
      unglücklicherweise für Ihren Code, den gleichen Namen verwenden.
      Es funktioniert, weil PHP einen <emphasis>bloßen
      String</emphasis> (ein String ohne Anführungszeichen, der keinem
      bekannten Symbol entpricht) automatisch in einen String
      umwandelt, der den bloßen String enthält. Wenn beispielsweise
      keine Konstante namens <constant>bar</constant> definiert ist,
      ersetzt es PHP durch den String <literal>'bar'</literal> und
      verwendet diesen.
     </para>
     <note>
      <simpara>
       Das bedeutet nicht, dass Schlüssel <emphasis>immer</emphasis>
       in Anführungszeichen gesetzt werden müssen. Wenn Sie nämlich
       Schlüssel, die <link
       linkend="language.constants">Konstanten</link> oder <link
       linkend="language.variables">Variablen</link> sind, in
       Anführungszeichen setzen, werden diese von PHP nicht
       ausgewertet.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);

// Ein einfaches Array:
$array = array(1, 2);
$anzahl = count($array);
for ($i = 0; $i < $anzahl; $i++) {
    echo "\nÜberprüfe $i: \n";
    echo "Schlecht: " . $array['$i'] . "\n";
    echo "Gut: " . $array[$i] . "\n";
    echo "Schlecht: {$array['$i']}\n";
    echo "Gut: {$array[$i]}\n";
}
?>
]]>
       </programlisting>
      </informalexample>
      <para>
       Obiges Beispiel würde folgende Ausgabe erzeugen:
       <screen>
<![CDATA[
Überprüfe 0:
Notice: Undefined index:  $i in /path/to/script.html on line 9
Schlecht:
Gut: 1
Notice: Undefined index:  $i in /path/to/script.html on line 11
Schlecht:
Gut: 1

Überprüfe 1:
Notice: Undefined index:  $i in /path/to/script.html on line 9
Schlecht:
Gut: 2
Notice: Undefined index:  $i in /path/to/script.html on line 11
Schlecht:
Gut: 2
]]>
       </screen>
      </para>
     </note>
     <para>
      Weitere Beispiele zur Veranschaulichung dieses Sachverhalts:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// Wir lassen uns alle Fehlermeldungen anzeigen
error_reporting(E_ALL);

$arr = array('obst' => 'Apfel', 'gemuese' => 'Karotte');

// Richtig
print $arr['obst'];  // Apfel
print $arr['gemuese']; // Karotte

// Falsch. Es funktioniert, gibt aber wegen der undefinierten
// Konstante namens obst auch einen PHP-Fehler der Stufe E_NOTICE
// aus:
//
// Notice: Use of undefined constant obst - assumed 'obst' in...
print $arr[obst];    // Apfel

// Definieren wir nun eine Konstante um zu veranschaulichen was
// passiert. Wir weisen einer Konstanten namens obst den Wert
// 'gemuese' zu.
define('obst', 'gemuese');

// Beachten Sie jetzt den Unterschied
print $arr['obst'];  // Apfel
print $arr[obst];    // Karotte

// Folgendes ist in Ordnung, weil es innerhalb eines Strings ist.
// Innerhalb eines Strings wird nicht nach Konstanten gesucht und
// deshalb gibt es hier auch keinen E_NOTICE-Fehler.
print "Hallo $arr[obst]";      // Hallo Apfel

// Eine Ausnahme: innerhalb von Strings ermöglichen {Klammern}
// um Arrays, dass nach Konstanten gesucht wird
print "Hallo {$arr[obst]}";    // Hallo Karotte
print "Hallo {$arr['obst']}";  // Hallo Apfel

// Das funktioniert nicht und ergibt in etwa folgenden Parser-Fehler:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// Das gilt natürlich auch für die Verwendung von Autoglobalen in
// Strings
print "Hallo $arr['obst']";
print "Hallo $_GET['foo']";

// Eine andere Möglichkeit ist die Verkettung
print "Hallo " . $arr['obst']; // Hallo Apfel
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Wenn Sie <function>error_reporting</function> auf Fehler der
      Stufe <constant>E_NOTICE</constant> einstellen (beispielsweise
      durch setzen auf <constant>E_ALL</constant>), werden Sie diese
      Fehlermeldungen zu sehen bekommen. Standardmäßig ist <link
      linkend="ini.error-reporting">error_reporting</link> so
      eingestellt, dass sie nicht angezeigt werden.
     </para>
     <para>
      Wie im Abschnitt <link
      linkend="language.types.array.syntax">Syntax</link> ausgeführt,
      muss zwischen den eckigen Klammern ('<literal>[</literal>' und
      '<literal>]</literal>') ein Ausdruck stehen.  Das heißt, dass
      Sie Dinge ähnlich diesen schreiben können:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo $arr[somefunc($bar)];
?>
]]>
       </programlisting>
      </informalexample>
      Das ist ein Beispiel dafür, wie Sie den Rückgabewert einer
      Funktion als Array-Index verwenden können. Ebenso kennt PHP
      Konstanten. Vielleicht haben Sie die <literal>E_*</literal>
      Konstanten schon einmal gesehen.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[E_ERROR]   = "Ein schwerwiegender Fehler ist aufgetreten";
$error_descriptions[E_WARNING] = "PHP hat eine Warnung ausgegeben";
$error_descriptions[E_NOTICE]  = "Das ist nur eine informelle Notiz";
?>
]]>
       </programlisting>
      </informalexample>
      Beachten Sie, dass <literal>E_ERROR</literal> ebenso ein
      gültiger Bezeichner ist, genau wie <literal>bar</literal> im
      ersten Beispiel.  Das letzte Beispiel entspricht aber
      tatsächlich dem folgendem Code:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[1] = "Ein schwerwiegender Fehler ist aufgetreten";
$error_descriptions[2] = "PHP hat eine Warnung ausgegeben";
$error_descriptions[8] = "Das ist nur eine informelle Notiz";
?>
]]>
       </programlisting>
      </informalexample>
      weil <literal>E_ERROR</literal> gleich <literal>1</literal> ist,
      usw.
     </para>
     <para>
      Wie schon in den obigen Beispielen erklärt wurde, funktioniert
      <literal>$foo[bar]</literal> zwar, ist aber falsch. Es
      funktioniert, weil <literal>bar</literal> aufgrund seiner Syntax
      als Konstante ausgewertet wird. In diesem Fall jedoch existiert
      keine Konstane mit dem Namen <literal>bar</literal>. PHP nimmt
      an, dass Sie <literal>bar</literal> wörtlich gemeint haben, wie
      den String <literal>'bar'</literal>, aber vergessen haben, die
      Anführungszeichen zu setzen.
     </para>

     <sect4>
      <title>Aber warum ist es schlecht?</title>
      <para>
       Eines Tages könnte sich das PHP-Team entscheiden eine weitere
       Konstante oder ein Schlüsselwort hinzuzufügen oder Sie könnten
       eine weitere Konstante in Ihre Anwendung einfügen. Und dann
       geraten Sie in Schwierigkeiten. Zum Beispiel können Sie bereits
       die Wörter <literal>empty</literal> und
       <literal>default</literal> auf diese Art nicht benutzen, weil
       es speziele Schlüsselwörter sind.
      </para>
      <note>
       <simpara>
        Um es nochmals zu wiederholen, innerhalb eines Strings in
        doppelten Anführungszeichen ist es zulässig, Array-Indizes
        ohne Anführungszeichen zu schreiben, weshalb
        <literal>"$foo[bar]"</literal> gültig ist. Schauen Sie sich
        für Einzelheiten darüber, warum das so ist, obige Beispiele
        und den Abschnitt über <link
        linkend="language.types.string.parsing">Variablen-Analyse in
        Strings</link> an.
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>

   <sect2 id="language.types.array.casting">
    <title>Umwandlung nach array</title>

    <para>
     Für die Typen <type>Integer</type>, <type>Float</type>,
     <type>String</type>, <type>Boolean</type> und
     <type>Resource</type> gilt: wenn Sie einen Wert in ein Array
     umwandeln, bekommen Sie ein Array mit einem Element (mit Index
     0), das der skalare Wert ist, den Sie anfangs hatten.
    </para>

    <para>
     Wenn Sie ein <type>Objekt</type> in ein Array umwandeln, bekommen
     Sie die Eigenschaften (Mitgliedsvariablen) des Objekts als
     Elemente des Arrays. Die Schlüssel sind die Namen der
     Mitgliedsvariablen.
    </para>

    <para>
     Wenn Sie einen &null;-Wert in ein Array umwandeln, bekommen Sie
     ein leeres Array.
    </para>
   </sect2>

   <sect2 id="language.types.array.comparing">
    <title>Vergleiche</title>
    <para>
     Arrays können Sie mit der Funktion <function>array_diff</function> und
     mit den <link linkend="language.operators.array">Array Operatoren
     </link> vergleichen.
    </para>
   </sect2>

   <sect2 id="language.types.array.examples">
    <title>Beispiele</title>
    <para>
     Der Array-Typ in PHP ist sehr vielseitig. Hier folgen einige
     Beispiele um Ihnen die Mächtigkeit von Arrays zu
     veranschaulichen.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// Das hier
$a = array('Farbe'     => 'rot',
           'Geschmack' => 'süß',
           'Form'      => 'rund',
           'Name'      => 'Apfel',
                          4          // Schlüssel ist 0
          );

// ist komplett gleichwertig mit
$a['Farbe']     = 'rot';
$a['Geschmack'] = 'süß';
$a['Form']      = 'rund';
$a['Name']      = 'Apfel';
$a[]            = 4;          // Schlüssel ist 0

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
/* ergibt das Array: array(0 => 'a', 1 => 'b', 2 => 'c'),
   oder einfacher: array('a', 'b', 'c')
*/
?>
]]>
      </programlisting>
     </informalexample>
    </para>

    <example>
     <title>Verwenden von <function>array</function></title>
     <programlisting role="php">
<![CDATA[
<?php
// Array als (Eigenschafts-)Abbildung
$map = array('version'    => 4,
             'OS'         => 'Linux',
             'Sprache'    => 'englisch',
             'short_tags' => true
            );

// strikt numerische Schlüssel
$array = array(7,
               8,
               0,
               156,
               -10,
              );
// Dies entspricht: array(0 => 7, 1 => 8, ...)

// wechselnde Schlüssel
$wechselnd = array(        10,  // Schlüssel: 0
                   5    =>  6,
                   3    =>  7,
                   'a'  =>  4,
                           11,  // Schlüssel: 6 (Maximum der Integer-Indices war 5)
                   '8'  =>  2,  // Schlüssel: 8 (integer!)
                   '02' => 77,  // Schlüssel: '02'
                   0    => 12   // 10 wird mit dem neuen Wert 12 überschrieben
                  );

// leeres Array
$leer = array();
?>
]]>
     </programlisting>
    </example>

    <example id="language.types.array.examples.loop">
     <title>Sammlung</title>
     <programlisting role="php">
<![CDATA[
<?php
$farben = array('rot', 'blau', 'grün', 'gelb');

foreach ($farben as $farbe) {
    echo "Gefällt Ihnen $farbe?\n";
}

/* Ausgabe:
Gefällt Ihnen rot?
Gefällt Ihnen blau?
Gefällt Ihnen grün?
Gefällt Ihnen gelb?
*/
?>
]]>
     </programlisting>
    </example>

    <para>
     Beachten Sie, dass es gegenwärtig nicht möglich ist die Werte
     eines Arrays direkt in einer solchen Schleife zu ändern. Eine
     Lösung ist folgendes:
     <example id="language.types.array.examples.changeloop">

      <title>Sammlung</title>
      <programlisting role="php">
<![CDATA[
<?php
foreach ($farben as $schluessel => $farbe) {
    // funktioniert nicht:
    //$farbe = strtoupper($farbe);

    // funktioniert:
    $farben[$schluessel] = strtoupper($farbe);
}
print_r($farben);

/* Ausgabe:
Array
(
    [0] => ROT
    [1] => BLAU
    [2] => GRÜN
    [3] => GELB
)
*/
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Dieses Beispiel erzeugt ein Array, dessen Schlüssel bei eins
     beginnt.
     <example>
      <title>1-basierter Index</title>
      <programlisting role="php">
<![CDATA[
<?php
$erstes_viertel  = array(1 => 'Januar', 'Februar', 'März');
print_r($erstes_viertel);

/* Ausgabe:
Array
(
    [1] => 'Januar'
    [2] => 'Februar'
    [3] => 'März'
)
*/
?>
]]>
      </programlisting>
     </example>
    </para>
    <example>
     <title>Füllen eines Arrays</title>
     <programlisting role="php">
<![CDATA[
<?php
// Füllen eines Arrays mit allen Inhalten eines Verzeichnisses
$handle = opendir('.');
while (false !== ($datei = readdir($handle))) {
    $dateien[] = $datei;
}
closedir($handle);
?>
]]>
     </programlisting>
    </example>
    <para>
     Arrays sind geordnet. Diese Ordnung können Sie mit Hilfe
     verschiedener Sortierfunktionen verändern. Für mehr Informationen
     schauen Sie unter dem Abschnitt zu den <link
     linkend="ref.array">Array Funktionen</link> nach. Die Anzahl der
     Elemente in einem Array können Sie mit der Funktion
     <function>count</function> zählen.
    </para>
    <example>
     <title>Sortieren eines Arrays</title>
     <programlisting role="php">
<![CDATA[
<?php
sort($dateien);
print_r($dateien);
?>
]]>
     </programlisting>
    </example>
    <para>
     Weil der Wert eines Arrays alles sein kann, kann dieser Wert
     wiederum ein Array sein. Somit können Sie rekursive und
     multidimensionale Arrays erzeugen.
    </para>
    <example>
     <title>Rekursive and multidimensionale Arrays</title>
     <programlisting role="php">
<![CDATA[
<?php
$fruits = array ("früchte" => array("a" => "Orange",
                                    "b" => "Banane",
                                    "c" => "Apfel"
                                   ),
                 "nummern" => array(1,
                                    2,
                                    3,
                                    4,
                                    5,
                                    6
                                   ),
                 "löcher"  => array(     "erstens",
                                    5 => "zweitens",
                                         "drittens"
                                   )
                );

// Ein paar Beispiele zum Ansprechen der Werte aus obigem Array
echo $fruits["löcher"][5];    // gibt "zweitens" aus
echo $fruits["früchte"]["a"]; // gibt "Orange" aus
unset($fruits["löcher"][0]);  // entfernt "erstens"

// Erzeugen eines neuen mehrdimensionalen Arrays
$saefte["Apfel"]["gruen"] = "gut";
?>
]]>
     </programlisting>
    </example>
    <para>
     Sie sollten wissen, dass beim Zuweisen eines Arrays die Werte
     immer kopiert werden. Um ein Array als Referenz zu kopieren,
     müssen Sie den Referenz-Operator verwenden.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 wird verändert,
             // $arr1 ist immer noch array(2, 3)

$arr3 = &$arr1;
$arr3[] = 4; // nun sind $arr1 und $arr3 gleich
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.object">
   <title>Objekte</title>

   <sect2 id="language.types.object.init">
    <title>Objekt-Initialisierung</title>

    <para>
     Um ein Objekt zu initialisieren benutzen sie die Angabe
     <literal>new</literal>, dadurch wird das Objekt einer
     Variablen-Instanz zugewiesen.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class foo {
    function tue_foo() {
        echo "Tue gerade foo.";
    }
}

$bar = new foo;
$bar->tue_foo();
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Für eine ausführliche Darstellung lesen Sie das Kapitel <link
     linkend="language.oop">Klassen und Objekte</link>
    </simpara>
   </sect2>

   <sect2 id="language.types.object.casting">
    <title>Umwandlung nach object</title>

    <para>
     Wenn ein Objekt in ein Objekt umgewandelt wird, wird es nicht
     verändert. Wenn ein Wert eines anderen Typs in ein Objekt
     umgewandelt wird, wird eine neue Instanz der eingebauten Klasse
     <literal>stdClass</literal> erzeugt. War der Wert Null, dann ist
     die neue Instanz leer. Bei jedem anderen Wert enthält eine
     Mitgliedsvariable namens <literal>scalar</literal> den Wert.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$obj = (object) 'ciao';
echo $obj->scalar;  // gibt 'ciao' aus
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>

  </sect1>

  <sect1 id="language.types.resource">
   <title>Resource</title>

   <para>
    Eine Resource ist eine spezielle Variable, die eine Referenz auf
    eine externe Ressource enthält. Ressourcen werden von bestimmten
    Funktionen erzeugt und benutzt. Eine Liste dieser Funktionen und
    der entsprechenden Resource-Typen finden Sie im <link
    linkend="resource">Anhang</link>.
   </para>

   <note>
    <simpara>
     Der Resource-Typ wurde in PHP 4 eingeführt.
    </simpara>
   </note>

   <sect2 id="language.types.resource.casting">
    <title>Umwandlung nach resource</title>

    <para>
     Da Resource-Typen spezielle Routinen zu geöffneten Dateien,
     Datenbankverbindungen, Bildinformationen und Ähnlichem
     enthalten, können Sie keinen Wert in eine Resource umwandeln.
    </para>
   </sect2>

   <sect2 id="language.types.resource.self-destruct">
    <title>Freigabe von Ressourcen</title>

    <para>
     Aufgrund des Reference-Counting Systems, das mit PHP 4's
     Zend Egine eingeführt wurde, wird automatisch entdeckt, wenn auf
     eine Ressource nicht mehr zugegriffen wird (wie in Java). Wenn
     dies der Fall ist werden alle Ressourcen, die für diese Ressource
     in Gebrauch waren, durch den "Müllsammler" (garbage collector)
     freigegeben. Aus diesem Grund ist es selten jemals notwendig,
     Speicher manuell durch Aufruf von free_result-Funktionen
     freizugeben.
     <note>
      <simpara>
       Persistente Datenbank-Links stellen einen Sonderfall dar, sie
       werden durch den garbage collector <emphasis>nicht</emphasis>
       zerstört.  Siehe auch den Abschnitt über <link
       linkend="features.persistent-connections">Persistente
       Datenbankverbindungen</link>.
      </simpara>
     </note>
    </para>

   </sect2>
  </sect1>

  <sect1 id="language.types.null">
   <title>NULL</title>

   <para>
    Der spezielle Wert &null; steht dafür, dass eine Varaiable keinen
    Wert hat. &null; ist der einzig mögliche Wert des Typs
    <type>NULL</type>.
   </para>
   <note>
    <simpara>
     Der Null-Typ wurde in PHP 4 eingeführt.
    </simpara>
   </note>
   <para>
    Eine Variable wird als &null; interpretiert, wenn
    <itemizedlist>
     <listitem>
      <para>
       ihr die Konstannte &null; als Wert zugewiesen wurde,
      </para>
     </listitem>
     <listitem>
      <para>
       ihr bis jetzt kein Wert zugewiesen wurde,
      </para>
     </listitem>
     <listitem>
      <para>
       sie mit <function>unset</function> gelöscht wurde.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <sect2 id="language.types.null.syntax">
    <title>Syntax</title>
    <para>
     Es gibt nur einen Wert des Typs &null;: das Schlüsselwort &null;.
     Groß-/Kleinschreibung spielt keine Rolle.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$var = NULL;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Siehe auch <function>is_null</function> und
     <function>unset</function>.
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.pseudo-types">
   <title>In dieser Dokumentation verwendete Pseudo-Typen</title>

   <sect2 id="language.types.mixed">
    <title>Mixed</title>
    <para>
     <literal>Mixed</literal> deutet darauf hin, dass ein Parameter
     mehrere (aber nicht notwendigerweise alle) Typen akzeptiert.
    </para>
    <para>
     <function>gettype</function> akzeptiert beispielsweise alle
     PHP-Typen, während <function>str_replace</function> Strings und
     Arrays akzeptiert.
    </para>
   </sect2>

   <sect2 id="language.types.number">
    <title>Number</title>
    <para>
     <literal>Number</literal> deutet darauf hin, dass ein Parameter
     entweder ein <type>Integer</type> oder ein <type>Float</type>
     sein kann.
    </para>
   </sect2>

   <sect2 id="language.types.callback">
    <title>Callback</title>
    <para>
     Einige Funktionen wie <function>call_user_func</function> oder
     <function>usort</function> akzeptieren benutzerdefinierte
     Callback-Funktionen als Parameter. Callback-Funktionen können
     nicht nur einfache Funktionen sein, sondern auch Objektmethoden
     einschließlich statischer Klassenmethoden.
    </para>
    <para>
     Eine PHP-Funktion wird einfach durch Ihren Namen als String
     übergeben. Sie können jede eingebaute oder benutzerdefinierte
     Funktion übergeben mit Ausnahme von <function>array</function>,
     <function>echo</function>, <function>empty</function>,
     <function>eval</function>, <function>exit</function>,
     <function>isset</function>, <function>list</function>,
     <function>print</function> und <function>unset</function>.
    </para>
    <para>
     Eine Methode eines instanzierten Objekts wird als Array
     übergeben, das ein Objekt als Element mit Index 0 und einen
     Methodennamen als Element mit Index 1 enthält.
    </para>
    <para>
     Statische Klassenmethoden können auch übergeben werden, ohne ein
     Objekt dieser Klasse zu instanzieren, indem statt des Objekts der
     Name der Klasse als Element mit Index 0 übergeben wird.
    </para>

    <para>
     <example>
      <title>Beispiele zur Callback-Funktion</title>
      <programlisting role="php">
<![CDATA[
<?php

// einfaches callback Beispiel
function meine_callback_funktion() {
    echo 'hallo welt!';
}
call_user_func('meine_callback_funktion');

// Beispiele für Callbackmethoden
class MeineKlasse {
    function meineCallbackMethode() {
        echo 'Hallo Welt!';
    }
}

// Aufruf einer statischen Klassenmethode ohne Instanzierung
// eines Objekts
call_user_func(array('MeineKlasse', 'meineCallbackMethode'));

// Aufruf einer Objektmethode
$obj = new MeineKlasse();
call_user_func(array(&$obj, 'meineCallbackMethode'));
?>
]]>
      </programlisting>
     </example>
    </para>

   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>Typen-Tricks</title>

   <simpara>
    PHP erfordert (bzw. unterstützt) keine expliziten Typ-Definitionen
    bei der Deklaration von Variablen; der Typ einer Variablen wird
    durch den Zusammenhang bestimmt in dem die Variable benutzt wird.
    Das bedeutet, dass bei der Zuweisung eines Strings zu einer
    Variablen <parameter>$var</parameter> diese Variable
    <parameter>$var</parameter> zum Typ String wird.  Sollten Sie
    dananch der Variablen <parameter>$var</parameter> einen
    Integer-Wert zuweisen, wird sie zu einem Integer-Typ.
   </simpara>
   <para>
    Ein Beispiel für die automatische Typ-Konvertierung von PHP ist
    der Plus-Operator '+'. Ist einer der zu addierenden Werte vom Typ
    <type>float</type>, werden alle Werte als float-Typ behandelt.
    Auch das Ergebnis der Addition wird vom Typ float sein.
    Andernfalls werden die Werte als <type>integer</type>-Typen
    angesehen und das Ergebnis wird ebenfalls vom Typ Integer sein.
    Beachten Sie, dass hierdurch NICHT der Typ der Operanden selbst
    beeinflusst wird; der Unterschied liegt einzig und allein in der
    Auswertung dieser Operanden.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = "0";                         // $foo ist vom Typ String (ASCII 48)
$foo += 2;                          // $foo ist jetzt vom Typ Integer (2)
$foo = $foo + 1.3;                  // $foo ist nun vom Typ float (3.3)
$foo = 5 + "10 Sehr kleine Ferkel"; // $foo ist vom Typ Integer (15)
$foo = 5 + "10 Kleine Schweine";    // $foo ist vom Typ Integer (15)
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Wenn Ihnen die beiden letzten Beispiele merkwürdig erscheinen,
    beachten Sie die <link
    linkend="language.types.string.conversion">Umwandlung von Strings
    in Zahlen</link>.
   </simpara>
   <simpara>
    Wenn Sie die Auswertung einer Variablen als einen speziellen Typ
    erzwingen wollen, beachten sie den Abschnitt in <link
    linkend="language.types.typecasting">Typ-Umwandlung</link>. Wollen
    Sie den Typ einer Variable ändern, schauen Sie bei
    <function>settype</function> nach.
   </simpara>
   <para>
    Um die Beispiele dieses Kapitels auszuprobieren, können Sie die
    Funktion <function>var_dump</function> verwenden.
   </para>
   <note>
    <para>
     Das Verhalten einer automatischen Umwandlung zum Typ Array ist
     zur Zeit nicht definiert.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a = "1";     // $a ist ein String
$a[0] = "f";  // Was ist mit den String offsets? Was passiert?
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Weil PHP (aus historischen Gründen) die Indizierung innerhalb von
     Strings mittels der gleichen Syntax wie bei der Array-Indizierung
     unterstützt, führt das o.a. Beispiel zu einem Problem: Soll $a zu
     einem Array werden, dessen erstes Element ein "f" ist oder soll
     "f" das erste Zeichen des Strings $a werden?
    </para>
    <para>
     Die aktuellen Versionen von PHP interpretieren die zweite
     Anweisung als Stringversatz-Kennung, weshalb $a zu "f" wird. Das
     Ergebnis dieser automatischen Umwandlung sollte jedoch als
     undefiniert betrachtet werden. Mit PHP 4 wurde die neue Syntax
     mit geschweiften Klammern eingeführt um auf Zeichen in einem
     String zuzugreifen. Verwenden Sie statt der oben vorgestellten
     Syntax folgende:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a    = "abc"; // $a ist ein String
$a{1} = "f";   // $a ist jetzt "afc"
?>
]]>
      </programlisting>
     </informalexample>
     Für weitere Informationen siehe Abschnitt <link
     linkend="language.types.string.substr">Zugriff auf Zeichen in
     Strings</link>.
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>Typ-Umwandlung</title>

    <para>
     Typ-Umwandlung in PHP funktioniert vielfach wie in C: Der Name
     des gewünschten Typs wird vor der umzuwandelnden Variablen in
     Klammern gesetzt.
     <informalexample>
      <programlisting>
<![CDATA[
<?php
$foo = 10;             // $foo ist ein Integer-Wert
$bar = (boolean) $foo; // $bar ist vom Typ boolean
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Folgende Umwandlungen sind möglich:
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - nach integer</simpara>
      </listitem>
      <listitem>
       <simpara>(bool), (boolean) - nach boolean</simpara>
      </listitem>
      <listitem>
       <simpara>(float), (double), (real) - nach float</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - nach string</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - nach array</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - Wandlung zum Objekt</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Beachten sie, dass Tabulatoren und Leerzeichen innerhalb der
     Klammern erlaubt sind. Deshalb sind die folgenden Beispiele
     identisch:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo = (int) $bar;
$foo = ( int ) $bar;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      Anstatt eine Variable in einen String umzuwandeln, können Sie
      die Variable auch in doppelte Anführungszeichen einschließen.
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$foo = 10;            // $foo ist ein Integer
$str = "$foo";        // $str ist ein String
$fst = (string) $foo; // $fst ist auch ein String

// Das gibt aus "sie sind gleich"
if ($fst === $str) {
    echo "sie sind gleich";
}
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </note>
    <para>
     Es ist nicht immer offenkundig, was bei der Typ-Umwandlung
     geschieht. Für weitere Informationen schauen Sie unter folgenden
     Abschnitten nach:
     <itemizedlist>
      <listitem>
       <simpara>
        <link linkend="language.types.boolean.casting">Umwandlung nach
        boolean</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.integer.casting">Umwandlung nach
        integer</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.float.casting">Umwandlung nach
        float</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.casting">Umwandlung nach
        string</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.array.casting">Umwandlung nach
        array</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.object.casting">Umwandlung nach
        object</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.resource.casting">Umwandlung
        nach resource</link>
       </simpara>
      </listitem>
      <!-- don't exist yet
      <listitem>
       <simpara>
        <link linkend="language.types.null.casting">Umwandlung nach
        &null;</link>
       </simpara>
      </listitem>
      -->
      <listitem>
       <simpara>
        <link linkend="types.comparisons">PHP type comparison
        tables</link>
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
