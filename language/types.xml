 <chapter id="language.types">
  <title>Typen</title>
  
  <para>
   PHP unterstützt die folgenden Typ-Deklarationen:
   <itemizedlist>
    <listitem>
     <simpara>
      <link linkend="language.types.array">Array</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.double">Fließkomma-Zahl</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.integer">Integer</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.object">Object</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.types.string">String / Zeichenkette</link>
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <simpara>
   Der Typ einer Variabalen wird normalerweise nicht vom Programmierer
   bestimmt; vielmehr wird dies zur Laufzeit von PHP entschieden,
   abhängig vom Zusammenhang in dem die Variable benutzt wird.
  </simpara>
  <simpara>
   Wenn sie die Umwandlung in einen bestimmten Variablen-Typ erzwingen
   wollen, können sie dies entweder per <link
   linkend="language.types.typecasting">cast</link> oder durch
   Gebrauch der Funktion <function>settype</function>.
  </simpara>
  <simpara>
   qBeachten Sie, dass eine Variable je nach Gebrauch und Situation auf
   unterschiedliche Art und Weise typisiert sein kann. Weitere
   Informationen sehen sie unter <link
   linkend="language.types.type-juggling">Typ-Veränderung</link>.
  </simpara>

  <sect1 id="language.types.integer">
   <title>Integer-Typen</title>
   <para>
    Integer-Typen können durch Gebrauch einer der folgenden
    Zuweisungsarten angegeben werden:
    <informalexample>
     <programlisting role="php">
$a = 1234; # Zahlenwert im dezimal-Format
$a = -123; # ein negativer Zahlenwert
$a = 0123; # Oktal-Zahl (83 im dezimal-Format) Achtung: 
           # Fehlerquelle bei Strings mit führenden Nullen!
$a = 0x12; # Zahlenwert im hexadezimal-Format
           # (entspricht 18 im dezimal-Format)
     </programlisting>
    </informalexample>
    Die Größe eines Integer-Wertes ist plattformabhängig, dennoch
    beträgt der Maximalwert über 2 Billionen (Vorzeichen-behafteter
    32-Bit-Wert).
   </para>
  </sect1>
   
  <sect1 id="language.types.double">
   <title>Fließkomma-Zahlenwerte</title>
   <para>
    Fließkomma-Zahlenwerte ("doubles") können durch eine der folgenden
    Anweisungen zugewiesen werden:
    <informalexample>
     <programlisting role="php">
$a = 1.234;
$a = 1.2e3;
     </programlisting>
    </informalexample>
    Die Größe einer Fließkomma-Zahl ist plattformabhängig, dennoch
    stellt ein Maximum von ~1.8e308 mit einer Genauigkeit von 14
    Nachkomma-Stellen einen üblichen Wert dar (das ist 64-Bit im
    IEEE-Format).
   </para>
   <warning id="warn.float.precision">
    <para>
     Es ist normal, dass einfache Dezimalzahlen wie
     <literal>0.1</literal> oder <literal>0.7</literal> nicht in ihre
     internen binären Entsprechungen konvertiert werden können, ohne
     einen Teil ihrer Genauigkeit zu verlieren. Das kann zu
     verwirrenden Ergebnissen führen. So wird <literal>floor ((0.1 +
     0.7) * 10)</literal> normalerweise <literal>7</literal> statt des
     erwarteten Wertes <literal>8</literal> zurück geben (als Ergebnis
     der internen Entsprechung von <literal>7.9999999999...</literal>.
    </para>
    <para>
     Da es unmöglich ist, manche Dezimal-Zahlen durch eine begrenzte
     Anzahl an Nachkomma-Stellen darzu stellen, ist dies ein Fakt.
     Dem Wert <literal>1/3</literal> entspricht z.B. der interne
     Wert von <literal>0.3333333. . .</literal>.
    </para>
    <para>
     Deshalb sollten sie nie den Ergebnissen von Fließkomma-Operationen
     bis auf die letzte Nachkomma-Stelle glauben oder solche auf
     Gleichjeit prüfen. Sollten sie einen größere Genauigkeit brauchen,
     sollten sie die <link linkend="ref.bc"> mathematischen Funktionen
     beliebiger Genauigkeit </link> benutzen.
    </para>
   </warning>
  </sect1>
   
  <sect1 id="language.types.string">
   <title>Strings / Zeichenketten</title>
   <para>
    Strings können durch eines von zwei der folgenden Sets von
    Begrenzungszeichen zugewiesen werden:
   </para>
   <para>
    Wenn der String eingeschlossen wird von doppelten
    Anführungszeichen ("), werden die Variablen innerhalb der
    Zeichenkette ausgewertet (begrenzt durch einige Einschränkungen
    beim "Parsen" (Ausführen) des PHP- Scripts). Wie in C und Perl
    kann das Backslash-Zeichen ("\") zur An- / Ausgabe spezieller
    Zeichen benutzt werden:
    <table>
     <title>Nicht ausgewertete / übergangene Zeichen:</title>
     <tgroup cols="2">
      <thead>
       <row>
	<entry>Zeichenfolge</entry>
	<entry>Bedeutung</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry><literal>\n</literal></entry>
	<entry>neue Zeile (LF oder 0x0A als ASCII-Code)</entry>
       </row>
       <row>
	<entry><literal>\r</literal></entry>
	<entry>Wagenrücklauf (CR oder 0x0D als ASCII-Code)</entry>
       </row>
       <row>
	<entry><literal>\t</literal></entry>
	<entry>horizontaler Tabulator (HT oder 0x09 als ASCII-Code</entry>
       </row>
       <row>
	<entry><literal>\\</literal></entry>
	<entry>Backslash / Rückstrich</entry>
       </row>
       <row>
	<entry><literal>\$</literal></entry>
	<entry>Dollar-Symbol</entry>
       </row>
       <row>
	<entry><literal>\"</literal></entry>
	<entry>doppelte Anführungszeichen</entry>
       </row>
       <row>
	<entry><literal>\[0-7]{1,3}</literal></entry>
	<entry>
	 die Zeichenfolge, die dem regulären Ausdruck entspricht, ist
	 in Oktal-Schreibweise
	</entry>
       </row>
       <row>
	<entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
	<entry>
	 die Zeichenfolge, die dem regulären Ausdruck entspricht ist,
	 in Hexadezimal-Schreibweise
	</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    Sie können ein beliebiges anderes Zeichen übergehen bzw.  von der
    Auswertung ausschliessen; in der höchsten Warn-Stufe wird aber
    eine Warnmeldung ausgegeben.
   </para>
   <para>
    Die zweite Möglichkeit eine(n) Zeichenkette / String zu begrenzen,
    ist der Gebrauch des einfachen Anführungszeichens ("'"), auch
    Single-Quote genannt. Hier werden einzig die "\\" und
    "\'"-Zeichenfolgen von der Auswertung ausgeschlossen.  Dies dient
    der Erleichterung, so dass sie Single-Quotes und Backslashes in
    einem durch einfache Anführungszeichen begrenzten String benutzen
    können. Variablen innerhalb von durch Single-Quotes begrenzten
    Strings werden <emphasis>nicht</emphasis> ausgewertet.
   </para>
   <simpara>
    Eine andere Möglichkeit Strings einzufassen, besteht im Gebrauch
    der "here doc"-Syntax ("&lt;&lt;&lt;"). Hierfür ist nach
    <literal>&lt;&lt;&lt;</literal> ein Merker zu setzen. Nun folgt
    der eigentliche String und dann der selbe Merker um den String
    abzuschliessen. Der schliessende Merker <emphasis>muss</emphasis>
    in der ersten Spalte der Zeile stehen.
   </simpara>
   <para>
    "Here doc"-Text funktioniert wie ein Text innnerhalb von '"', aber
    ohne '"'. Anführungszeichen innerhalb von "here doc"-Texten müssen
    also keiner Sonderbehandlung (escapen) unterzogen werden. Sie
    können aber die obigen Escape-Anweisungen verwenden. Variablen
    werden ausgewertet, aber besondere Aufmerksamkeit muss komplexen
    Variablen gewidmet werden, genau wie Strings.
    <example>
     <title>
      Beispiel zur String-Festlegung per "here doc"-Methode
     </title>
     <programlisting role="php">
&lt;?php
$str = &lt;&lt;&lt;EOD
Beispiel eines Strings
über mehrere Script-Zeilen
durch Gebrauch der here doc-Syntax.
EOD;

/* komplexeres Beispiel, mit Variablen */
class foo {
    var $foo;
    var $bar;

    function foo() {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'Mein Name';

echo &lt;&lt;&lt;EOT
Mein Name ist "$name". Ich schreibe einige $foo->foo.
Nun schreibe ich gerade einige {$foo->bar[1]}.
Dies sollte ein Kapitel 'A' schreiben: \x41
EOT;
?>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Die "here-doc"-Unterstützung wurde in PHP 4 eingeführt.
    </para>
   </note>
   <para>
    Zeichenketten / Strings können mittels des '.'-Operators
    miteinander verbunden werden. Beachten sie, dass hier der '+'
    (Additions)-Operator nicht funktioniert. Bitte beachten sie auch
    <link linkend="language.operators.string">String-Operatoren</link>
    für weitergehende Informationen.  Zeichen in einem String können
    wie ein numerisch-indiziertes Array von Zeichen benutzt
    werden. Die Syntax ist der von C ähnlich.  Sehen sie hierzu die
    folgenden Beispiele:
   </para>
   <para>
    <example>
     <title>Einige String-Beispiele</title>
     <programlisting role="php">
&lt;?php
/* Zuweisung eines Strings. */
$str = "Dies ist eine Zeichenkette";

/* Erweiterung dieses Strings. */
$str = $str . " mit etwas zusätzlichem Text";

/* andere Möglichkeit zum Erweitern incl. Anweisung für Neue-Zeile. */
$str .= " und einer neuen Zeile am Ende.\n";

/* Dieser String wird am Ende zu: '&lt;p&gt;Nummer: 9&lt;/p&gt;' */
$num = 9;
$str = "&lt;p&gt;Nummer: $num&lt;/p&gt;";

/* Dieser wird zu '&lt;p&gt;Nummer: $num&lt;/p&gt;' */
$num = 9;
$str = '&lt;p&gt;Nummer: $num&lt;/p&gt;';
?&gt;	  

/* Das erste Zeichen eines Strings */
$str = 'Das ist ein Test.'
$first = $str[0];

/* Das letzte Zeichen eines Strings */
$str = 'Das ist immer noch ein Test.'
$last = $str[strlen($str)-1];
?&gt;
     </programlisting>
    </example>
   </para>

   <sect2 id="language.types.string.conversion">
    <title>Umwandlung von Zeichenketten / Strings</title>
    <simpara>
     Sobald ein String als Zahlenwert angesehen wird, wird der
     resultierende Wert und Typ wie folgt festgelegt:
    </simpara>
    <simpara>
     Der String wird als double angesehen, wenn er eines der Zeichen
     '.', 'e', oder 'E' enthält. Ansonsten wird er als Integer-Wert
     interpretiert.
    </simpara>
    <para>
     Der Inhalt wird durch den Anfangsteil des Strings vorgegeben.
     Sofern der String mit numerischen Daten beginnt, wird ein
     Zahlen-Wert angenommen. Andererseits kann der Wert auch 0 (Null)
     sein. Gültig sind auch Werte mit einem optionalen Vorzeichen,
     gefolgt von einer oder mehreren Zahlen (optional mit einem
     Dezimalpunkt). Wahlweise kann auch ein Exponent angegeben
     werden. Dieser besteht aus einem 'e' oder 'E', gefolgt von einer
     oder meheren Zahlen.
    </para>
    <simpara>
     Sobald der erste Ausdruck ein String ist, hängt der Typ der
     Variablen vom zweiten Ausdruck ab.
    </simpara>
    <informalexample>
     <programlisting role="php">
$foo = 1 + "10.5";              // $foo ist double (11.5)
$foo = 1 + "-1.3e3";            // $foo ist double (-1299)
$foo = 1 + "bob-1.3e3";         // $foo ist ein Integer-Wert (1)
$foo = 1 + "bob3";              // $foo ist ein Integer-Wert (1)
$foo = 1 + "10 Small Pigs";     // $foo ist ein Integer-Wert (11)
$foo = 1 + "10 Little Piggies"; // $foo ist ein Integer-Wert (11)
$foo = "10.0 pigs " + 1;        // $foo ist ein Integer-Wert (11)
$foo = "10.0 pigs " + 1.0;      // $foo ist double (11)     
     </programlisting>
    </informalexample>
    <simpara>
     Mehr Informationen über solche Umwandlungen können sie im
     UNIX-Manual unter strtod(3) finden.
    </simpara>
    <para>
     Wenn sie alle Beispiele dieses Abschnitts testen wollen, können
     sie sie per Cut und Paste in ihr Script übertragen und mit der
     folgenden Zeile selbst sehen, was passiert:
     <informalexample>
      <programlisting role="php">
echo "\$foo==$foo; Typ ist " . gettype( $foo ) . "&lt;br&gt;\n";
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>
  
  <sect1 id="language.types.array">
   <title>Arrays</title>
   <para>
    Arrays reagieren wie Hash-Tabellen (assoziative Arrays) und
    indizierte Arrays (Vektoren).
   </para>

   <sect2 id="language.types.array.single-dim">
    <title>Eindimensionale Arrays</title>
    <para>
     PHP unterstützt sowohl skalare als auch assoziative Arrays.
     Letztendlich gibt es keinen Unterschied zwischen den beiden.  Sie
     können ein Array erzeugen, indem sie die
     <function>list</function> oder <function>array</function>
     Funktionen benutzen, oder sie können explizit den Wert eines
     jeden Array-Elements festlegen.
     <informalexample>
      <programlisting role="php"> 
$a[0] = "abc"; 
$a[1] = "def"; 
$b["foo"] = 13;
      </programlisting>
     </informalexample>
    </para>
    <para>
     Sie können ein Array auch erzeugen, indem sie einfach Werte einem
     Array hinzu fügen. Wenn sie einer Array-Variablen einen Wert
     weisen, indem sie leere Klammern benutzen, wird der Wert am Ende
     des Arrays hinzugefügt.
     <informalexample>
      <programlisting role="php"> 
$a[] = "hello"; // $a[2] == "hello"
$a[] = "world"; // $a[3] == "world" 
      </programlisting>
     </informalexample>
    </para>
    <para>
     Arrays können durch Gebrauch der <function>asort</function>,
     <function>arsort</function>, <function>ksort</function>,
     <function>rsort</function>, <function>sort</function>,
     <function>uasort</function>, <function>usort</function>, und
     <function>uksort</function>-Funktionen sortiert werden (in
     Abhängigkeit von der gewünschten Sortierung).
    </para>
    <para>
     Sie können die Anzahl der Elemente eines Arrays mittels der
     <function>count</function>-Funktion ermitteln.
    </para>
    <para>
     Durchlaufen können sie ein Array per <function>next</function>
     und <function>prev</function>-Funktion. Eine weiter Möglichkeit
     ist die Funktion <function>each</function>.
    </para>
   </sect2>

   <sect2 id="language.types.array.multi-dim">
    <title>Mehrdimensionale Arrays</title>
    <para>
     Mehrdimensionale Arrays sind einfach. Für jede Dimension des
     Arrays fügen sie einen anderen [key]-Wert ans Ende an:
     <informalexample>
      <programlisting role="php"> 
$a[1]      = $f;               # Ein-Dimensionales Beispiel
$a["foo"]  = $f;   

$a[1][0]     = $f;             # Zwei-Dimensional
$a["foo"][2] = $f;             # (sie können numerische und
                                  assoziative Indizes so mischen)
$a[3]["bar"] = $f;             # (oder so)

$a["foo"][4]["bar"][0] = $f;   # Vier-Dimensional!
      </programlisting>
     </informalexample>
    </para>
    <para>
     In PHP ist es nicht möglich, mehrdimensionale Arrays direkt in
     Strings zu referenzieren. Deshalb erzeugt auch das nachfolgende
     Beispiel nicht das gewünschte Ergebnis:
     <informalexample>
      <programlisting role="php"> 
$a[3]['bar'] = 'Bob';
echo "Dies funktioniert nicht: $a[3][bar]";
      </programlisting>
     </informalexample>
     In PHP wird das o.a. Beispiel folgendes ausgeben:
     <computeroutput>Dies funktioniert nicht: Array[bar]
     </computeroutput>. Jedoch kann der String-Verbindungs-Operator
     benutzt werden, dies zu umgehen:
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "Das funktioniert: " . $a[3][bar];
      </programlisting>
     </informalexample>
    </para>
    <para>
     In PHP4 kann das Problem umgangen werden, indem die
     Array-Referenz in geschweiften Klammern eingeschlossen wird:
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "Das funktioniert in PHP4: {$a[3][bar]}";
      </programlisting>
     </informalexample>
    </para>
    <para>
     Man kann multi-dimensionale Arrays auf viele Arten füllen, aber
     der trickreichste Weg geht über das Verständnis, wie der
     <function>array</function>-Befehl für assoziative Arrays zu
     benutzen ist.  Die folgenden Code-Schnippsel füllen das
     ein-dimensionale Array über den gleichen Weg:
     <informalexample>
      <programlisting role="php"> 
# Example 1:

$a["color"]	= "red";
$a["taste"]	= "sweet";
$a["shape"]	= "round";
$a["name"]  	= "apple";
$a[3]		= 4;


# Example 2:
$a = array(
"color" => "red",
"taste" => "sweet",
"shape" => "round",
"name"  => "apple",
3       => 4
);
      </programlisting>
     </informalexample>
    </para>
    <para>
     Die <function>array</function>-Funktion kann eingefügt
     werden für mehrdimensionale Arrays:
     <informalexample>
      <programlisting role="php"> 
&lt;?php
$a = array(
    "apple"  => array(
        "color"  => "red",
        "taste"  => "sweet",
        "shape"  => "round"
    ),
    "orange"  => array(
        "color"  => "orange",
        "taste"  => "tart",
        "shape"  => "round"
    ),
    "banana"  => array(
        "color"  => "yellow",
        "taste"  => "paste-y",
        "shape"  => "banana-shaped"
    )
);
  
echo $a["apple"]["taste"];    # dies wird "sweet" ausgegeben
?>
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1>

  <sect1 id="language.types.object">
   <title>Objects</title>

   <sect2 id="language.types.object.init">
    <title>Objekt-Initialisierung</title>

    <para>
     Um ein Objekt zu initialisieren benutzen sie die Angabe
     <literal>new</literal>, dadurch wird das Objekt einer
     Variablen-Instanz zugewiesen.
     <informalexample>
      <programlisting role="php">
&lt;?php
class foo {
    function do_foo () { 
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar->do_foo ();
?>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Für eine ausführliche Besprechung lesen Sie im Kapitel <link
     linkend="language.oop">Klassen und Objekte</link> nach.
    </simpara>
   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>Typen-Tricks</title>

   <simpara>
    PHP erfordert (bzw. unterstützt) keine explizite Typ-Definitionen
    bei der Deklaration von Variablen; der Typ einer Variablen wird
    bestimmt durch den Zusammenhang in dem die Variable benutzt wird.
    Das bedeutet, dass bei der Zuweisung einer Zeichenkette / eines
    Strings zu einer Variablen <parameter>var</parameter> diese
    Variable <parameter>var</parameter> den Typ String erhält.
    Sollten sie dananch der Variablen <parameter>var</parameter> einen
    Integer-Wert zuweisen, wird sie zu einem Integer-Typ.
   </simpara>
   <para>
    Ein Beispiel für die automatische Typ-Konvertierung von PHP ist
    der Plus-Operator '+'. Ist einer der zu addierenden Werte vom Typ
    double, werden alle Werte als double-Typ gehandhabt. Auch das
    Ergebnis der Addition wird vom Typ double sein.  Ist dies nicht
    der Fall, werden Werte als Integer-Typen angesehen und das
    Ergebnis wird ebenfalls vom Typ Integer sein. Beachten sie, dass
    hierdurch nicht der Typ der Additions-Elemente selbst beeinflusst
    wird; der Unterschied liegt einzig und allein in der Auswertung
    dieser Elemente.
    <informalexample>
     <programlisting role="php">
$foo = "0";  // $foo ist vom Typ String (ASCII 48)
$foo++;      // $foo ist immer noch vom Typ String,
                Inhalt "1" (ASCII 49)
$foo += 1;   // $foo ist jetzt vom Typ Integer (2)
$foo = $foo + 1.3;  // $foo ist nun vom Typ double (3.3)
$foo = 5 + "10 Little Piggies"; // $foo ist vom Typ Integer (15)
$foo = 5 + "10 Small Pigs";     // $foo ist vom Typ Integer (15)
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Wenn für sie die letzten beiden Beispiele gleich sind, beachten
    sie <link linkend="language.types.string.conversion">
    String-Umwandlung</link>.
   </simpara>
   <simpara>
    Wenn sie die Auswertung einer Variablen als ein spezieller Typ
    erzwingen wollen, beachten sie den Abschnitt in <link
    linkend="language.types.typecasting">Typ-Umwandlung</link>.  Wenn
    sie den Typ einer Variablen wechseln wollen, sehen sie bitte
    <function>settype</function> nach.
   </simpara>
   <para>
    Um die Beispiele dieses Kapitels auszuprobieren, können sie diese
    per "Copy und Paste" übertragen und die folgende Zeile einfügen,
    um zu sehen, was passiert:
    <informalexample>
     <programlisting role="php">
echo "\$foo==$foo; ist vom Typ " . gettype( $foo ) . "&lt;br&gt;\n";
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     Das Verhalten einer automatischen Umwandlung ist zur Zeit
     undefiniert.
     <informalexample>
      <programlisting role="php">
$a = 1;       // $a ist ein Integer-Wert
$a[0] = "f";  // $a wird zum Array, $a[0] enthält "f"
      </programlisting>
     </informalexample>
    </para>
    <para>
     Weil das o.a. Beispiel so aussieht, als ob $a ein Array wird,
     dessen erstes Element ein 'f' enthält, beachten sie folgendes:
     <informalexample>
      <programlisting role="php">
$a = "1";     // $a ist ein String
$a[0] = "f";  // Was ist mit den String-Offsets? Was passiert?
      </programlisting>
     </informalexample>
    </para>
    <para>
     Weil PHP die Indizierung innerhalb von Strings mittels der
     gleichen Syntax wie bei der Array-Indizierung unterstützt, führt
     das o.a. Beispiel zu einem Problem: Soll $a zu einem Array
     werden, dessen erstes Element ein "f" ist oder soll "f" das erste
     Zeichen des Strings $a werden?
    </para>
    <para>
     Aus diesem Grund ist das Ergebnis der automatischen Umwandlung
     seit PHP 3.0.12 und auch in PHP 4.0b3-RC4 undefiniert.  Lösungen
     werden noch dikutiert.
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>Typ-Umwandlung</title>

    <para>
     Typ-Umwandlung in PHP funktioniert vielfach wie in C: Der Name
     des geforderten Typs wird vor der umzuwandelnden Variablen in
     Klammern gesetzt.
     <informalexample>
      <programlisting>
$foo = 10;   // $foo ist ein Integer-Wert
$bar = (double) $foo;   // $bar ist vom Typ double
      </programlisting>
     </informalexample>
    </para>
    <para>
     Folgende Umwandlungen sind möglich:
     <itemizedlist>
      <listitem>
       <simpara>
	(int), (integer) - Umwandlung in Integer-Wert
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	(real), (double), (float) - hin zu double
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	(string) - hin zu String
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	(array) - hin zum Array
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	(object) - Wandlung zum Objekt
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Beachten sie, dass Tabulatoren und Leerzeichen innerhalb der
     Klammern erlaubt sind. Deshalb sind die folgenden Beispiel
     identisch:
     <informalexample>
      <programlisting role="php">
$foo = (int) $bar;
$foo = ( int ) $bar;
      </programlisting>
     </informalexample>
    </para>
    <para>
     Es ist nicht immer offenkundig, was bei der Typ-Umwandlung
     geschieht. Zum besseren Verständnis sollte das Folgende beachtet
     werden:
    </para>
    <para>
     Bei der Umwandlung einer skalaren oder String-Variablen wird die
     Variable das erste Element des Arrays:
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$arr = (array) $var;
echo $arr[0];  // gibt 'ciao' aus
      </programlisting>
     </informalexample>
    </para>
    <para>
     Sobald eine skalare oder String-Variable in ein Objekt gewandelt
     wird, wird die Variable zu einem Attribut des Objekts; der
     Eigenschafts-Name wird 'scalar':
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$obj = (object) $var;
echo $obj-&gt;scalar;  // gibt 'ciao' aus
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>
  
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
