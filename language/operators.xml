<?xml version="1.0" encoding="iso-8859-1"?>
  <chapter id="language.operators">
   <title>Operatoren</title>
   <simpara>
   </simpara>

   <sect1 id="language.operators.arithmetic">
    <title>Arithmetische Operatoren</title>
    <simpara>
     Erinnerst du dich noch an die Grundrechenarten aus der
     Schule? Die arithmetischen Operatoren funktionieren
     genauso:
    </simpara>

    <table>
     <title>Arithmetic Operators</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Beispiel</entry>
        <entry>Name</entry>
        <entry>Ergebnis</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a + $b</entry>
        <entry>Addition</entry>
        <entry>Summe von $a und $b.</entry>
       </row>
       <row>
        <entry>$a - $b</entry>
        <entry>Subtraktion</entry>
        <entry>Differenz von $a und $b.</entry>
       </row>
       <row>
        <entry>$a * $b</entry>
        <entry>Multiplikation</entry>
        <entry>Produkt von $a und $b.</entry>
       </row>
       <row>
        <entry>$a / $b</entry>
        <entry>Division</entry>
        <entry>Quotient von $a und  $b.</entry>
       </row>
       <row>
        <entry>$a % $b</entry>
        <entry>Modulus</entry>
        <entry>Rest von $a geteilt durch $b.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!-- This appears to be inaccurate. Division always returns a float.
    <simpara>
     The division operator ("/") returns an integer value (the result
     of an integer division) if the two operands are integers (or
     strings that get converted to integers). If either operand is a
     floating-point value, floating-point division is performed.
    </simpara>
--></sect1>

   <sect1 id="language.operators.assignment">
    <title>Zuweisungsoperatoren</title>
    <simpara>
     Der einfachste Zuweisungsoperator ist "=". Wahrscheinlich kommt
     man als erstes auf die Idee, ihn  mit "ist gleich" zu bezeichnen.
     Das ist falsch. In Wirklichkeit bedeutet er, dass dem linken Operanden
     der Wert des rechten Operanden zugewiesen wird (man müsste ihn also 
     mit "wird gesetzt auf den Wert von" übersetzen).
    </simpara>
    <para>
     Der Wert eines Zuweisungs-Ausdruckes ist der zugewiesene Wert.
     D. h. der Wert des Ausdruckes "$a = 3" ist 3. Das erlaubt es,
     einige raffinierte Dinge zu tun:
<informalexample>
<programlisting>
$a = ($b = 4) + 5 // $a ist nun gleich 9 und $b wurde auf den Wert 4 gesetzt.
</programlisting>
</informalexample>
    </para>
    <para>
     Zusätzlich zu dem oben vorgestellten Zuweisungsoperator "=" gibt
     es "kombinierte Operatoren" für alle binären, arithmetischen und
     String-Operatoren, die es erlauben, den Wert einer Variablen in einem Ausdruck
     zu benutzen, und dieser anschließend das Ergebnis des Ausdrucks
     als neuen Wert zuzuweisen. Beispiel: <informalexample><programlisting>
$a = 3;
$a += 5; // setzt $a auf den Wert 8, als ob wir geschrieben haetten: $a = $a + 5;
$b = "Hallo ";
$b .= "Du!"; // setzt $b auf den Wert "Hallo Du!", aequivalent zu $b = $b . "There!";
</programlisting></informalexample>
    </para>

   <para>
        Man beachte, dass die Zuweisung nur den Wert der Ursprungsvarialbe der
        neuen Variable zuweist (assignment by value)(sie "kopiert"), weshalb sich
        Änderungen an der einen Variablen nicht auf die andere auswirken
        werden. Das kann wichtig sein wenn man einen großen Array o. ä.  in
	einer Schleife kopieren muss. PHP4 unterstützt 'assignement by
	reference' (Zuweisung als Verweis), mithilfe der 
	<computeroutput>$var = &amp;$othervar;</computeroutput>-Syntax, dies
	funktioniert jedoch nicht in PHP3. 'Assignement by reference' bedeutet,
	dass beide Variablen nach der Zuweisung die selben Daten repräsentieren.
	Nach der Zuweisung verändert eine Änderung der Variable <computeroutput>$var</computeroutput>
	auch den Inhalt der Variable <computeroutput>&amp;$othervar;</computeroutput>, nichts
	wird kopiert, stattdessen wird ein "Verweis" auf die erste Variable angelegt.
   </para>

  </sect1>

   <sect1 id="language.operators.bitwise">
    <title>Bit-Operatoren</title>
    <simpara>
     Bit-Operatoren erlauben es, in einem Integer bestimmte Bits "ein- oder 
     auszuschalten" (auf 0 oder 1 zu setzen).
    </simpara>

    <table>
     <title>Bit-Operatoren</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Beispiel</entry>
        <entry>Name</entry>
        <entry>Ergebnis</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a & $b</entry>
        <entry>Und</entry>
        <entry>Die Bits sind in $a und in $b gesetzt.</entry>
       </row>
       <row>
        <entry>$a | $b</entry>
        <entry>Oder</entry>
        <entry>Die Bits sind entweder in $a oder in $b gesetzt.</entry>
       </row>
       <row>
        <entry>$a ^ $b</entry>
        <entry>Entweder oder (Xor)</entry>
        <entry>Die Bits sind in $a oder in $b gesetzt, aber nicht in beiden.
	</entry>
       </row>
       <row>
        <entry>~ $a</entry>
        <entry>Nicht</entry>
        <entry>Die Bits, die in $a nicht gesetzt sind, sind gesetzt, und
	umgekehrt.</entry>
       </row>
       <row>
        <entry>$a &lt;&lt; $b</entry>
        <entry>Nach links verschieben</entry>
        <entry>Verschiebung der Bits von $a um $b Stellen nach links (Jede
	       Stelle entspricht einer Mulitplikation mit zwei.</entry>
       </row>
       <row>
        <entry>$a &gt;&gt; $b</entry>
        <entry>Nach links verschieben</entry>
        <entry>Verschiebt die Bits von $a um $b Stellen nach rechts (jede Stelle
	entspricht einer Division durch zwei).</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
  </sect1>



   <sect1 id="language.operators.comparison">
    <title>Vergleichs-Operatoren</title>
    <simpara>
	Vergleichs-Operatoren erlauben es - wie der Name
	schon sagt - zwei Werte zu vergleichen.
    </simpara>

    <table>
     <title>Vergleichsoperatoren</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Beispiel</entry>
        <entry>Name</entry>
        <entry>Ergebnis</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a == $b</entry>
        <entry>Gleich</entry>
        <entry>Gibt "wahr" zurück, von $a gleich $b ist.</entry>
       </row>
       <row>
        <entry>$a === $b</entry>
        <entry>Identisch</entry>
        <entry>Gibt "wahr" zurück wen $a gleich $b ist und beide
	       vom gleichen Typ sind(funktioniert nur in PHP4)</entry>
       </row>
       <row>
        <entry>$a != $b</entry>
        <entry>Ungleich</entry>
        <entry>Gibt "wahr" zurück, wenn $a nicht gleich $b ist.</entry>
       </row>
       <row>
        <entry>$a &lt; $b</entry>
        <entry>Kleiner Als</entry>
        <entry>Gibt "wahr" zurück, wenn $a kleiner als $b ist.</entry>
       </row>
       <row>
        <entry>$a &gt; $b</entry>
        <entry>Größer Als</entry>
        <entry>Gibt "wahr" zurück, wenn $a größer als $b ist.</entry>
       </row>
       <row>
        <entry>$a &lt;= $b</entry>
        <entry>Kleiner Gleich </entry>
        <entry>Gibt "wahr" zurück", wenn $a kleiner oder gleich $b ist.</entry>
       </row>
       <row>
        <entry>$a &gt;= $b</entry>
        <entry>Größer Gleich</entry>
        <entry>Gibt "wahr" zurück, wenn $a größer oder gleich $b ist.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
     Ein weiter Vergleichs-Operator ist der "?:"- oder Trinitäts-Operator.
     Er arbeitet genauso wie in C und vielen anderen Programmier-Sprachen.
     	
	<informalexample>
	 <programlisting>
(ausdr1) ? (ausdr2) : (ausdr3);
	 </programlisting>
	</informalexample> 

	Dieser Ausdruch gibt
	<replaceable>ausdr2</replaceable> zurück, wenn
	<replaceable>ausdr1</replaceable> "wahr" zurückgibt, und
	<replaceable>ausdr3</replaceable>, wenn
	<replaceable>ausdr1</replaceable> "falsch" zurückgibt.
   </para>
  </sect1>


  <sect1 id="language.operators.errorcontrol">
   <title>Fehler-Kontroll-Operatoren</title>
   
   <simpara>
    PHP unterstützt einen Operator zur Fehlerkontrolle: Das @-Symbol.
    Stellt man das @ in PHP vor einen Ausdruck werden alle Fehlermeldungen,
    die von diesem Ausdruck erzeugt werden könnten, ignoriert.
   </simpara>

   <simpara>
    Ist das <link linkend="ini.track-errors">track_errors</link>-Feature 
    aktiviert, werden alle Fehlermeldungen, die von diesem Ausdruck erzeugt 
    werden, in der globalen Variablen $php_errormsg gespeichert. Da diese 
    Variable mit jedem neuen Auftreten eines Fehlers überschrieben wird, sollte
    man sie möglichst bald nach Verwendung des Ausdrucks überprüfen, wenn man
    mit ihr arbeiten will.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
&lt;?php
/* Beabsichtigter SQL-Fehler (zusätzliches Anfuehrungszeichen): */
$res = @mysql_query( "select name, code from 'namelist" ) or
   die( "SQL-Anfrage fehlgeschlagen: Fehlermeldung: '$php_errormsg'" );
?&gt;
     </programlisting>
    </informalexample>

   </para>

   <simpara>
    Siehe auch <function>error_reporting</function>.
   </simpara>

  </sect1>


  <sect1 id="language.operators.execution">
   <title>Operatoren zur Programmausführung</title>
   
   <para>
        PHP unterstützt einen Operator zur Ausführung externer Programme:
	Die sog. Backticks (``). Achtung: Die Backticks sind keine einfachen Anführungszeichen,
	sondern entsprechen auf den meisten Tastaturen den Tasten für die
	frz. Accents.
	PHP versucht, den Text zwischen den Backticks als Kommandozeilen-Befehl
	auszuführen. Zurückgegeben wird der die Ausgabe des aufgegebenen Programms (d. h. die
	Ausgabe wird nicht einfach gelöscht, sondern kann einer Variablen zugewiesen werden).

	<informalexample>
	 <programlisting role="php">
$output = `ls -al`;
echo "&lt;pre&gt;$output&lt;/pre&gt;";
	 </programlisting>
	</informalexample>

   </para>

   <para>
	Siehe auch <function>system</function>,
	<function>passthru</function>, <function>exec</function>,
	<function>popen</function>, und
	<function>escapeshellcmd</function>.
   </para>

  </sect1>

  
  <sect1 id="language.operators.increment">
   <title>Inkrementierungs- bzw. Dekrementierungsoperatoren</title>

   <para>
        PHP unterstützt Prä- und Post-Inkrementierungs- und Dekrementierungsoperatoren im
	Stil der Programmiersprache C.
   </para>

    <table>
     <title>Inkrement- und Dekrementoperatoren</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Beispiel</entry>
        <entry>Name</entry>
        <entry>Auswirkung</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>++$a</entry>
        <entry>Prä-Inkrement</entry>
        <entry>Erhöht den Wert von $a um eins (inkrementiert $a), und gibt anschließend den neuen Wert von $a
	zurück.</entry>
       </row>
       <row>
        <entry>$a++</entry>
        <entry>Post-Inkrement</entry>
        <entry>Gibt zuerst den aktuellen Wert von $a zurück und erhöht dann den Wert von $a um eins.</entry>
       </row>
       <row>
        <entry>--$a</entry>
        <entry>Prä-Dekrement</entry>
        <entry>Vermindert den Wert von $a um eins (dekrementiert $a), und gibt anschließend den neuen Wert
	von $a zurück.</entry>
       </row>
       <row>
        <entry>$a--</entry>
        <entry>Post-Dekrement</entry>
        <entry>Gibt zuerst den aktuellen Wert von $a zurück und erniedrigt dann den Wert von $a um eins.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
	Ein einfach Beispiel-Skript:
	<informalexample>
	 <programlisting>
&lt;?php
echo "&lt;h3&gt;Post-Inkrement&lt;/h3&gt;";
$a = 5;
echo "Sollte 5 sein: " . $a++ . "&lt;br&gt;\n";
echo "Sollte 6 sein: " . $a . "&lt;br&gt;\n";

echo "&lt;h3&gt;Prae-Inkrement&lt;/h3&gt;";
$a = 5;
echo "Sollte 6 sein: " . ++$a . "&lt;br&gt;\n";
echo "Sollte 6 sein: " . $a . "&lt;br&gt;\n";

echo "&lt;h3&gt;Post-Dekrement&lt;/h3&gt;";
$a = 5;
echo "Sollte 5 sein: " . $a-- . "&lt;br&gt;\n";
echo "Sollte 4 sein: " . $a . "&lt;br&gt;\n";

echo "&lt;h3&gt;Predecrement&lt;/h3&gt;";
$a = 5;
echo "Sollte 4 sein: " . --$a . "&lt;br&gt;\n";
echo "Sollte 4 sein: " . $a . "&lt;br&gt;\n";
?&gt;	  
	 </programlisting>
	</informalexample>
   </para>

  </sect1>


  <sect1 id="language.operators.logical">
    <title>Logische Operatoren</title>

    <table>
     <title>Logische Operatoren</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Beispiel</entry>
        <entry>Name</entry>
        <entry>Ergebnis</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a and $b</entry>
        <entry>Und</entry>
        <entry>Wahr sowohl $a als auch $b wahr ist.</entry>
       </row>
       <row>
        <entry>$a or $b</entry>
        <entry>Oder</entry>
        <entry>Wahr wenn $a oder $b wahr ist.</entry>
       </row>
       <row>
        <entry>$a xor $b</entry>
        <entry>Entweder Oder</entry>
        <entry>Wahr wenn entweder $a oder $b wahr ist, aber nicht beide.</entry>
       </row>
       <row>
        <entry>! $a</entry>
        <entry>Nicht</entry>
        <entry>Wahr wenn $a nicht wahr ist.</entry>
       </row>
       <row>
        <entry>$a &amp;&amp; $b</entry>
        <entry>Und</entry>
        <entry>Wahr sowohl $a als auch $b wahr ist.</entry>
       </row>
       <row>
        <entry>$a || $b</entry>
        <entry>Oder</entry>
        <entry>Wahr wenn $a oder $b wahr ist.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <simpara>
	Der Grund dafür, dass es je zwei unterschiedliche Operatoren für 
	die "Und"- und die "Oder"-Verknüpfung gibt ist, dass die beiden
	Operatoren jeweils einen unterschiedliche Plätze in der Operator-Rangfolge
	haben. (siehe auch <link linkend="language.operators.precedence">Operator-Rangfolge</link>.)
   </simpara>
  </sect1>

   <sect1 id="language.operators.precedence">
    <title>Operator-Rangfolge</title>
    <para>
     Die Operator-Rangfolge legt fest, wie "eng" ein Operator zwei
     Ausdrücke miteinander verbindet. Das Ergebnis des Ausdruckes
     <literal>1 + 5 * 3</literal> ist z. B. 16 und nicht 18, da der
     Mulitiplikations-Operator (*) in der Rangfolge höher steht als
     der Additions-Operator (+).</para>
    <para>
     Die folgende Tabelle zeigt die Rangfolge der Operatoren, oben steht
     der Operator mit dem niedrigsten Rang.

    <table>
     <title>Operator-Rangfolge</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Associativity</entry>
        <entry>Operator</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>links</entry>
        <entry>,</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>or</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>xor</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>and</entry>
       </row>
       <row>
        <entry>rechts</entry>
        <entry>print</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>= += -= *= /= .= %= &= |= ^= ~= &lt;&lt;= &gt;&gt;=</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>? :</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>||</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>&amp;&amp;</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>|</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>^</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>&amp;</entry>
       </row>
       <row>
        <entry>keine Richtung</entry>
        <entry>== != ===</entry>
       </row>
       <row>
        <entry>keine Richtung</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>+ - .</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>* / %</entry>
       </row>
       <row>
        <entry>rechts</entry>
        <entry>! ~ ++ -- (int) (double) (string) (array) (object) @</entry>
       </row>
       <row>
        <entry>rechts</entry>
        <entry>[</entry>
       </row>
       <row>
        <entry>keine Richtung</entry>
        <entry>new</entry>
       </row>
      </tbody>
     </tgroup>
    </table></para></sect1>

  <sect1 id="language.operators.string">
   <title>Zeichenketten-Operatoren</title>
   <simpara>
        Es gibt in PHP zwei Operatoren für Zeichenketten. Der erste ist
	Vereinigungs-Operator. ('.'), dessen Rückgabewert eine Zeichenkette,
	zusammengesetzt aus dem rechten und dem linken Argument, ist.
	Der zweite ist der Vereinigungs-Zuweisungsoperator ('.='). Siehe
	<link linkend="language.operators.assignment">Zuweisungs-Operatoren</link> für 
	weitere Informationen.
   </simpara>
   <para>
	<informalexample>
	 <programlisting>
$a = "Hallo ";
$b = $a . "Welt!"; // $b enthaelt jetzt den Text "Hallo Welt!"

$a = "Hallo ";
$a .= "Welt!"; // $a enthält jetzt den Text "Hallo Welt!"
     </programlisting>
	</informalexample>
   </para>
  </sect1>


  </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
