<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 87b582706267d69006a8aaaed3b5eda2ccf99c92 Maintainer: nobody Status: ready -->
<!-- Reviewed: yes -->
<!-- Rev-Revision: e4b889a3e8b9d87ab605aac9bbe85d2c16c69a1b Reviewer: samesch -->
<!-- CREDITS: tzwenny, betz -->
 <chapter xml:id="language.operators" xmlns="http://docbook.org/ns/docbook">
  <title>Operatoren</title>
  <simpara>
   Ein Operator ist etwas das Sie mit einem oder mehreren Werten (oder
   Ausdrücken, um im Programmierjargon zu sprechen) füttern und Sie erhalten
   als Ergebnis einen anderen Wert (damit wird diese Konstruktion selbst zu
   einem Ausdruck).
  </simpara>
  <para>
   Operatoren können gemäß der Anzahl der Operanden, die sie erwarten,
   gruppiert werden. Unäre Operatoren arbeiten mit nur einem Operanden, zum
   Beispiel <literal>!</literal> (der

   <link linkend="language.operators.logical">logische Negationsoperator</link>)
   oder <literal>++</literal> (der
   <link linkend="language.operators.increment">Inkrementoperator</link>).
   Binäre Operatoren arbeiten mit zwei Operanden, wie etwa die bekannten
   <link linkend="language.operators.arithmetic">arithmetischen Operatoren</link>
   <literal>+</literal> (Plus) und <literal>-</literal> (Minus), und die
   meisten PHP-Operatoren fallen in diese Kategorie. Schließlich gibt es einen
   einzigen
   <link linkend="language.operators.comparison.ternary">ternären Operator</link>,
   <literal>? :</literal>, der mit drei Operanden arbeitet; dieser wird meist
   einfach "der ternäre Operator" genannt (obwohl er wohl richtiger bedingter
   Operator genannt werden könnte).
  </para>
  <para>
   Eine vollständige Liste von PHP-Operatoren folgt im Abschnitt
   <link linkend="language.operators.precedence">Operator-Rangfolge</link>.
   Dieser Abschnitt erklärt weiterhin die Operator-Rangfolge und die
   Assoziativität (Ausführungspriorität), die regeln wie Ausdrücke, die
   mehrere unterschiedliche Operatoren enthalten, ausgewertet werden.
  </para>

  <sect1 xml:id="language.operators.precedence">
   <title>Operator-Rangfolge</title>
   <para>
    Die Operator-Rangfolge legt fest, wie "eng" ein Operator zwei Ausdrücke
    miteinander verbindet. Zum Beispiel ist das Ergebnis des Ausdruckes
    <literal>1 + 5 * 3</literal> <literal>16</literal> und nicht
    <literal>18</literal>, da der Multiplikations-Operator ("*") in der
    Rangfolge höher steht als der Additions-Operator ("+"). Wenn nötig, können
    Sie Klammern setzen, um die Rangfolge der Operatoren zu beeinflussen. Zum
    Beispiel ergibt: <literal>(1 + 5) * 3</literal> <literal>18</literal>.
   </para>
   <para>
    Haben Operatoren die gleiche Rangfolge, dann entscheidet ihre
    Assoziativität wie die Operatoren gruppiert werden. Zum Beispiel ist "-"
    links-assoziativ, sodass <literal>1 - 2 - 3</literal> als <literal>(1 - 2)
    - 3</literal> gruppiert und zu <literal>-4</literal> ausgewertet wird.
    Andererseits ist "=" rechts-assoziativ, sodass <literal>$a = $b =
    $c</literal> als <literal>$a = ($b = $c)</literal> gruppiert wird.
   </para>
   <para>
    Operatoren gleicher Rangfolge, die nicht-assoziativ sind, können nicht
    nebeneinander verwendet werden; beispielsweise ist <literal>1 &lt; 2 &gt;
    1</literal> in PHP nicht erlaubt. Der Ausdruck <literal>1 &lt;= 1 ==
    1</literal> ist allerdings erlaubt, weil der Operator
    <literal>==</literal> eine niedrigere Rangfolge als der Operator
    <literal>&lt;</literal> hat.
   </para>
   <para>
    Assoziativität ist nur für binäre (und ternäre) Operatoren sinnvoll. Unäre
    Operatoren sind entweder Präfix oder Postfix, sodass dieser Begriff nicht
    anwendbar ist. Zum Beispiel kann <literal>!!$a</literal> nur als
    <literal>!(!$a)</literal> gruppiert werden.
   </para>
   <para>
    Die Verwendung von Klammern, auch wenn sie nicht unbedingt erforderlich
    sind, kann oft die Lesbarkeit des Codes verbessern, indem explizit
    gruppiert wird, statt sich auf die implizite Operator-Rangfolge und
    -Assoziativität zu verlassen.
   </para>
   <para>
    Die folgende Tabelle zeigt die Rangfolge der Operatoren, oben steht der
    Operator mit dem höchsten Rang. Operatoren in derselben Zeile haben die
    gleiche Rangfolge, sodass ihre Assoziativität die Gruppierung entscheidet.
    <table>
     <title>Operator-Rangfolge</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Assoziativität</entry>
        <entry>Operatoren</entry>
        <entry>Additional Information</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>(n. z.)</entry>
        <entry>
         <literal>clone</literal>
         <literal>new</literal>
        </entry>
        <entry>
         <link linkend="language.oop5.cloning">clone</link> und
         <link linkend="language.oop5.basic.new">new</link>
        </entry>
       </row>
       <row>
        <entry>rechts</entry>
        <entry><literal>**</literal></entry>
        <entry><link linkend="language.operators.arithmetic">arithmetisch</link></entry>
       </row>
       <row>
        <entry>(n. z.)</entry>
        <entry>
         <literal>+</literal>
         <literal>-</literal>
         <literal>++</literal>
         <literal>--</literal>
         <literal>~</literal>
         <literal>(int)</literal>
         <literal>(float)</literal>
         <literal>(string)</literal>
         <literal>(array)</literal>
         <literal>(object)</literal>
         <literal>(bool)</literal>
         <literal>@</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">arithmetisch</link> (unär
         <literal>+</literal> und <literal>-</literal>),
         <link linkend="language.operators.increment">inkrementell/dekrementell</link>,
         <link linkend="language.operators.bitwise">bitweise</link>,
         <link linkend="language.types.typecasting">Typumwandlung</link>&listendand;
         <link linkend="language.operators.errorcontrol">Fehlerkontrolle</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry><literal>instanceof</literal></entry>
        <entry>
         <link linkend="language.operators.type">Typ</link>
        </entry>
       </row>
       <row>
        <entry>(n. z.)</entry>
        <entry><literal>!</literal></entry>
        <entry>
         <link linkend="language.operators.logical">logisch</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>
         <literal>*</literal>
         <literal>/</literal>
         <literal>%</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">arithmetisch</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>
         <literal>+</literal>
         <literal>-</literal>
         <literal>.</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">arithmetisch</link>
         (binär <literal>+</literal> und <literal>-</literal>),
         <link linkend="language.operators.array">Array</link>&listendand;
         <link linkend="language.operators.string">Zeichenkette</link>
         (<literal>.</literal> vor PHP 8.0.0)
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>
         <literal>&lt;&lt;</literal>
         <literal>&gt;&gt;</literal>
        </entry>
        <entry>
         <link linkend="language.operators.bitwise">bitweise</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry><literal>.</literal></entry>
        <entry>
         <link linkend="language.operators.string">Zeichenkette</link>
         (seit PHP 8.0.0)
        </entry>
       </row>
       <row>
        <entry>non-associative</entry>
        <entry>
         <literal>&lt;</literal>
         <literal>&lt;=</literal>
         <literal>&gt;</literal>
         <literal>&gt;=</literal>
        </entry>
        <entry>
         <link linkend="language.operators.comparison">Vergleiche</link>
        </entry>
       </row>
       <row>
        <entry>nicht-assoziativ</entry>
        <entry>
         <literal>==</literal>
         <literal>!=</literal>
         <literal>===</literal>
         <literal>!==</literal>
         <literal>&lt;&gt;</literal>
         <literal>&lt;=&gt;</literal>
        </entry>
        <entry>
         <link linkend="language.operators.comparison">Vergleiche</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry><literal>&amp;</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">bitweise</link>&listendand;
         <link linkend="language.references">Referenzen</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry><literal>^</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">bitweise</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry><literal>|</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">bitweise</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry><literal>&amp;&amp;</literal></entry>
        <entry>
         <link linkend="language.operators.logical">logisch</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry><literal>||</literal></entry>
        <entry>
         <link linkend="language.operators.logical">logisch</link>
        </entry>
       </row>
       <row>
        <entry>rechts</entry>
        <entry><literal>??</literal></entry>
        <entry>
         <link linkend="language.operators.comparison.coalesce">NULL-Zusammenfügungsoperator</link>
        </entry>
       </row>
       <row>
        <entry>nicht-assoziativ</entry>
        <entry><literal>? :</literal></entry>
        <entry>
         <link linkend="language.operators.comparison.ternary">ternärer Operator</link>
         (vor PHP 8.0.0 links-assoziativ)
        </entry>
       </row>
       <row>
        <entry>rechts</entry>
        <entry>
         <literal>=</literal>
         <literal>+=</literal>
         <literal>-=</literal>
         <literal>*=</literal>
         <literal>**=</literal>
         <literal>/=</literal>
         <literal>.=</literal>
         <literal>%=</literal>
         <literal>&amp;=</literal>
         <literal>|=</literal>
         <literal>^=</literal>
         <literal>&lt;&lt;=</literal>
         <literal>&gt;&gt;=</literal>
         <literal>??=</literal>
        </entry>
        <entry>
         <link linkend="language.operators.assignment">Zuweisung</link>
        </entry>
       </row>
       <row>
        <entry>(n. z.)</entry>
        <entry><literal>yield from</literal></entry>
        <entry>
         <link linkend="control-structures.yield.from">yield from</link>
        </entry>
       </row>
       <row>
        <entry>(n. z.)</entry>
        <entry><literal>yield</literal></entry>
        <entry>
         <link linkend="control-structures.yield">yield</link>
        </entry>
       </row>
       <row>
        <entry>(n. z.)</entry>
        <entry><literal>print</literal></entry>
        <entry><function>print</function></entry>
       </row>
       <row>
        <entry>links</entry>
        <entry><literal>and</literal></entry>
        <entry>
         <link linkend="language.operators.logical">logisch</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry><literal>xor</literal></entry>
        <entry>
         <link linkend="language.operators.logical">logisch</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry><literal>or</literal></entry>
        <entry>
         <link linkend="language.operators.logical">logisch</link>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    <example>
     <title>Assoziativität</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
// die Assoziativität des ternären Operators ist anders als bei C/C++
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2 (vor PHP 8.0.0)

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Operator-Rangfolge und -Assoziativität bestimmen nur wie Ausdrücke
    gruppiert werden, aber nicht die Auswertungsreihenfolge. PHP legt (im
    Allgemeinen) nicht fest, in welcher Reihenfolge ein Ausdruck ausgewertet
    wird. Code, der eine bestimmte Auswertungsreihenfolge erwartet, sollte
    vermieden werden, denn das Verhalten kann sich von Version zu Version
    ändern und auch vom umgebenden Code abhängen.
    <example>
     <title>Nicht definierte Auswertungsreihenfolge</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
echo $a + $a++; // gibt entweder 2 oder 3 aus

$i = 1;
$array[$i] = $i++; // der Index ist entweder 1 oder 2
?>
]]>
     </programlisting>
    </example>
    <example>
     <title><literal>+</literal>, <literal>-</literal> und <literal>.</literal> haben dieselbe Rangfolge (vor PHP 8.0.0)</title>
     <programlisting role="php">
<![CDATA[
<?php
$x = 4;
// diese Zeile könnte eine unerwartete Ausgabe produzieren:
echo "x minus 1 ist gleich " . $x-1 . ", hoffe ich jedenfalls\n";
// da es wie diese Zeile ausgewertet wird (vor PHP 8.0.0):
echo (("x minus 1 ist gleich " . $x) - 1) . ", hoffe ich jedenfalls\n";
// die gewünschte Rangfolge kann durch die Verwendung von Klammern erzwungen werden:
echo "x minus 1 ist gleich " . ($x-1) . ", hoffe ich jedenfalls\n";
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
-1, hoffe ich jedenfalls
-1, hoffe ich jedenfalls
x minus 1 ist gleich 3, hoffe ich jedenfalls
]]>
     </screen>
    </example>
   </para>
   <note>
    <para>
     Obwohl <literal>=</literal> einen niedrigeren Rang als die meisten
     anderen Operatoren hat, erlaubt PHP dennoch Ausdrücke wie den folgenden:
     <literal>if (!$a = foo())</literal>; in diesem Fall wird der Rückgabewert
     von <literal>foo()</literal> der Variablen <varname>$a</varname>
     zugewiesen.
    </para>
   </note>

   <sect2 role="changelog">
    &reftitle.changelog;
    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>&Version;</entry>
        <entry>&Description;</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>8.0.0</entry>
        <entry>
         Die Verkettung von Zeichenketten (<literal>.</literal>) hat jetzt
         eine niedrigere Rangfolge als die arithmetische Addition/Subtraktion
         (<literal>+</literal> und <literal>-</literal>) und bitweises
         Verschieben nach links/rechts (<literal>&lt;&lt;</literal> und
         <literal>&gt;&gt;</literal>); vorher hatte sie die gleiche Rangfolge
         wie <literal>+</literal> und <literal>-</literal> und eine höhere
         Rangfolge als <literal>&lt;&lt;</literal> und
         <literal>&gt;&gt;</literal>.
        </entry>
       </row>
       <row>
        <entry>8.0.0</entry>
        <entry>
         Der ternäre Operator (<literal>? :</literal>) ist jetzt
         nicht-assoziativ; vorher war er links-assoziativ.
        </entry>
       </row>
       <row>
        <entry>7.4.0</entry>
        <entry>
         Der Vorrang der String-Verkettung (<literal>.</literal>) gegenüber
         der arithmetischen Addition/Subtraktion (<literal>+</literal> oder
         <literal>-</literal>) oder bitweises Verschieben nach links/rechts
         (<literal>&lt;&lt;</literal> oder <literal>&gt;&gt;</literal>), d. h.
         die gemeinsame Verwendung in einem Ausdruck ohne Klammern, ist
         veraltet.
        </entry>
       </row>
       <row>
        <entry>7.4.0</entry>
        <entry>
         Die Links-Assoziativität des ternären Operators (<literal>?
         :</literal>), d. h. die Verschachtelung mehrerer ternärer Operatoren,
         die nicht-in Klammern eingeschlossen sind, ist veraltet.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.arithmetic">
   <title>Arithmetische Operatoren</title>
   <simpara>
    Erinnern Sie sich noch an die Grundrechenarten aus der Schule? Die
    arithmetischen Operatoren funktionieren genauso:
   </simpara>
   <table>
    <title>Arithmetische Operatoren</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Beispiel</entry>
       <entry>Name</entry>
       <entry>Ergebnis</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>+$a</entry>
       <entry>Identität</entry>
       <entry>
        Umwandlung von <varname>$a</varname> nach <type>int</type> oder
        <type>float</type> je nach Bedarf.
       </entry>
      </row>
      <row>
       <entry>-$a</entry>
       <entry>Negation</entry>
       <entry>Gegenzahl von <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a + $b</entry>
       <entry>Addition</entry>
       <entry>Summe von <varname>$a</varname> und <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>Subtraktion</entry>
       <entry>Differenz von <varname>$a</varname> und <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>Multiplikation</entry>
       <entry>Produkt von <varname>$a</varname> und <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>Division</entry>
       <entry>Quotient von <varname>$a</varname> und <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>Modulus</entry>
       <entry>Rest von <varname>$a</varname> geteilt durch <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a ** $b</entry>
       <entry>Potenz</entry>
       <entry><varname>$b</varname>-te Potenz von <varname>$a</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    Der Divisions-Operator ("/") gibt einen Gleitkommawert zurück, es sei denn
    beide Operanden sind Ganzzahlen (oder Zeichenketten, die in Ganzzahlen
    umgewandelt werden) und können glatt geteilt werden; in diesem Fall wird
    eine Ganzzahl zurückgegeben. Für Ganzzahldivision siehe
    <function>intdiv</function>.
   </simpara>
   <simpara>
    Operanden des Modulus-Operators werden vor der Verarbeitung in
    <type>int</type> umgewandelt. Für den Gleitkommazahlen-Modulus ist
    <function>fmod</function> verfügbar.
   </simpara>
   <para>
    Das Ergebnis des Modulus-Operators <literal>%</literal> hat dasselbe
    Vorzeichen wie der Dividend, d. h. das Ergebnis von <literal>$a %
    $b</literal> hat dasselbe Vorzeichen wie <varname>$a</varname>. Zum
    Beispiel:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

echo (5 % 3)."\n";           // gibt 2 aus
echo (5 % -3)."\n";          // gibt 2 aus
echo (-5 % 3)."\n";          // gibt -2 aus
echo (-5 % -3)."\n";         // gibt -2 aus

?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="ref.math">Mathematische Funktionen</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.assignment">
   <title>Zuweisungsoperatoren</title>
   <simpara>
    Der einfachste Zuweisungsoperator ist "=". Wahrscheinlich kommt man als
    erstes auf die Idee, ihn mit "ist gleich" zu bezeichnen. Das ist falsch.
    In Wirklichkeit bedeutet er, dass dem linken Operanden der Wert des
    Ausdrucks auf der rechten Seite zugewiesen wird (man müsste ihn also mit
    "wird gesetzt auf den Wert von" übersetzen).
   </simpara>
   <para>
    Der Wert eines Zuweisungs-Ausdruckes ist der zugewiesene Wert. D. h. der
    Wert des Ausdruckes "<literal>$a = 3</literal>" ist 3. Das erlaubt es,
    einige raffinierte Dinge anzustellen:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a ist nun gleich 9 und $b wurde auf den Wert 4 gesetzt.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Zusätzlich zu dem oben vorgestellten Zuweisungsoperator "=" gibt es
    "kombinierte Operatoren" für alle
    <link linkend="language.operators">binären, arithmetischen</link>,
    Array-Vereinigungs- und Zeichenketten-Operatoren, die es erlauben, den
    Wert einer Variablen in einem Ausdruck zu benutzen und dieser anschließend
    das Ergebnis des Ausdrucks als neuen Wert zuzuweisen. Zum Beispiel:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // setzt $a auf den Wert 8, als ob wir geschrieben hätten: $a = $a + 5;
$b = "Hallo ";
$b .= "Du!"; // setzt $b auf den Wert "Hallo Du!", äquivalent zu
             // $b = $b . "Du!";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Man beachte, dass die Zuweisung nur den Wert der Ursprungsvariable der
    neuen Variable zuweist (Zuweisung als Wert, sie "kopiert"), weshalb sich
    Änderungen an der einen Variable nicht auf die andere auswirken werden.
    Das kann wichtig sein, wenn man ein großes Array o. ä. in einer Schleife
    kopieren muss.
   </para>
   <para>
    Eine Ausnahme vom üblichen Wertzuweisungsverhalten in PHP stellen Objekte
    (<type>object</type>) dar, die per Referenz zugewiesen werden. Objekte
    können mit dem
    <link linkend="language.oop5.cloning">clone</link>-Schlüsselwort explizit
    kopiert werden.
   </para>

   <sect2 xml:id="language.operators.assignment.reference">
    <title>Referenzzuweisung</title>
    <para>
     Referenzzuweisung wird ebenfalls unterstützt, unter Verwendung der
     "<computeroutput>$var = &amp;$othervar;</computeroutput>" Syntax.
     Referenzzuweisung bedeutet, dass beide Variablen schließlich auf dieselben
     Daten zeigen, und nichts kopiert wurde.
    </para>
    <para>
     <example>
      <title>Referenzzuweisung</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 3;
$b = &$a; // $b ist eine Referenz auf $a

print "$a\n"; // gibt 3 aus
print "$b\n"; // gibt 3 aus

$a = 4; // ändere $a

print "$a\n"; // gibt 4 aus
print "$b\n"; // gibt ebenfalls 4 aus, da $b eine Referenz auf $a ist, das
              // geändert wurde
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Der <link linkend="language.oop5.basic.new">new</link>-Operator gibt
     automatisch eine Referenz zurück, sodass das Zuweisen des Ergebnisses von
     <link linkend="language.oop5.basic.new">new</link> per Referenz ein
     Fehler ist.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

$o = &new C;
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Parse error: syntax error, unexpected 'new' (T_NEW) in …
]]>
      </screen>
     </informalexample>
    </para>
    <para>
     Weitere Informationen zu Referenzen und ihren Anwendungsmöglichkeiten
     sind dem Handbuch-Abschnitt
     <link linkend="language.references">Referenzen erklärt</link> zu entnehmen.
    </para>
   </sect2>

   <sect2 xml:id="language.operators.assignment.arithmetic">
    <title>Arithmetische Zuweisungsoperatoren</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Beispiel</entry>
        <entry>Entsprechung</entry>
        <entry>Operation</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a += $b</entry>
        <entry>$a = $a + $b</entry>
        <entry>Addition</entry>
       </row>
       <row>
        <entry>$a -= $b</entry>
        <entry>$a = $a - $b</entry>
        <entry>Subtraktion</entry>
       </row>
       <row>
        <entry>$a *= $b</entry>
        <entry>$a = $a * $b</entry>
        <entry>Multiplikation</entry>
       </row>
       <row>
        <entry>$a /= $b</entry>
        <entry>$a = $a / $b</entry>
        <entry>Division</entry>
       </row>
       <row>
        <entry>$a %= $b</entry>
        <entry>$a = $a % $b</entry>
        <entry>Modulus</entry>
       </row>
       <row>
        <entry>$a **= $b</entry>
        <entry>$a = $a ** $b</entry>
        <entry>Potenzierung</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>

   <sect2 xml:id="language.operators.assignment.bitwise">
    <title>Bitweise Zuweisungsoperatoren</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Beispiel</entry>
        <entry>Entsprechung</entry>
        <entry>Operation</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a &amp;= $b</entry>
        <entry>$a = $a &amp; $b</entry>
        <entry>Und</entry>
       </row>
       <row>
        <entry>$a |= $b</entry>
        <entry>$a = $a | $b</entry>
        <entry>Oder</entry>
       </row>
       <row>
        <entry>$a ^= $b</entry>
        <entry>$a = $a ^ $b</entry>
        <entry>Xor</entry>
       </row>
       <row>
        <entry>$a &lt;&lt;= $b</entry>
        <entry>$a = $a &lt;&lt; $b</entry>
        <entry>Linksverschiebung</entry>
       </row>
       <row>
        <entry>$a &gt;&gt;= $b</entry>
        <entry>$a = $a &gt;&gt; $b</entry>
        <entry>Rechtsverschiebung</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>

   <sect2 xml:id="language.operators.assignment.other">
    <title>Andere Zuweisungspperatoren</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Beispiel</entry>
        <entry>Entsprechung</entry>
        <entry>Operation</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a .= $b</entry>
        <entry>$a = $a . $b</entry>
        <entry>Stringverknüpfung</entry>
       </row>
       <row>
        <entry>$a ??= $b</entry>
        <entry>$a = $a ?? $b</entry>
        <entry>Null-Zusammenführungsoperator</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>

   <sect2 role="seealso" xml:id="language.operators.assignment.see-also">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="language.operators.arithmetic">Arithmetische Operatoren</link></member>
      <member><link linkend="language.operators.bitwise">Bit-Operatoren</link></member>
      <member><link linkend="language.operators.comparison.coalesce">Null-Coalescing-Operator</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.bitwise">
   <title>Bit-Operatoren</title>
   <simpara>
    Bit-Operatoren erlauben es die Prüfung und Manipulation von bestimmten Bits
    in einem Integer.
   </simpara>
   <table>
    <title>Bit-Operatoren</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Beispiel</entry>
       <entry>Name</entry>
       <entry>Ergebnis</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><userinput>$a &amp; $b</userinput></entry>
       <entry>Und</entry>
       <entry>
        Bits, die in <varname>$a</varname> und <varname>$b</varname> gesetzt sind,
        werden gesetzt.
       </entry>
      </row>
      <row>
       <entry><userinput>$a | $b</userinput></entry>
       <entry>Oder</entry>
       <entry>
        Bits, die in <varname>$a</varname> oder <varname>$b</varname> gesetzt sind,
        werden gesetzt.
       </entry>
      </row>
      <row>
       <entry><userinput>$a ^ $b</userinput></entry>
       <entry>Entweder oder (Xor)</entry>
       <entry>
        Bits, die entweder in <varname>$a</varname> oder <varname>$b</varname>,
        jedoch nicht in beiden gesetzt sind, werden gesetzt.
       </entry>
      </row>
      <row>
       <entry><userinput>~ $a</userinput></entry>
       <entry>Nicht</entry>
       <entry>
        Bits, die in <varname>$a</varname> nicht gesetzt sind, werden gesetzt,
        und umgekehrt.
       </entry>
      </row>
      <row>
       <entry><userinput>$a &lt;&lt; $b</userinput></entry>
       <entry>Nach links verschieben</entry>
       <entry>
        Verschiebung der Bits von <varname>$a</varname> um <varname>$b</varname>
        Stellen nach links (jede Stelle entspricht einer Mulitplikation mit zwei).
       </entry>
      </row>
      <row>
       <entry><userinput>$a &gt;&gt; $b</userinput></entry>
       <entry>Nach rechts verschieben</entry>
       <entry>
        Verschiebung der Bits von <varname>$a</varname> um <varname>$b</varname>
        Stellen nach rechts (jede Stelle entspricht einer Division durch zwei).
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Bit-Verschiebungen in PHP sind arithmetisch. Bits, die an einem der Enden
    herausgeschoben werden, werden verworfen. Bei Links-Verschiebungen werden
    von rechts Nullen hereingeschoben, während das Vorzeichenbit links
    herausgeschoben wird, was bedeutet, dass das Vorzeichen des Operanden
    nicht erhalten bleibt. Bei Rechts-Verschiebungen werden Kopien des
    Vorzeichenbits von links hereingeschoben, sodass das Vorzeichen des
    Operanden erhalten bleibt.
   </para>
   <para>
    Klammern sind zu verwenden, um die gewünschte
    <link linkend="language.operators.precedence">Rangfolge</link>
    sicherzustellen. Beispielsweise wird bei <literal>$a &amp; $b ==
    true</literal> zunächst der Vergleich ausgewertet, und erst dann das
    Bit-Und, während bei <literal>($a &amp; $b) == true</literal> zunächst das
    Bit-Und, und erst dann der Vergleich ausgewertet wird.
   </para>
   <para>
    Sind beide Operanden der <literal>&amp;</literal>, <literal>|</literal>
    und <literal>^</literal> Operatoren Zeichenketten, dann wird die Operation
    auf den ASCII-Werten der Zeichen der Zeichenketten durchgeführt, und das
    Ergebnis ist wiederum eine Zeichenkette. In allen anderen Fällen werden
    beide Operanden
    <link linkend="language.types.integer.casting">nach Integer umgewandelt</link>
    und das Ergebnis ist eine Ganzzahl.
   </para>
   <para>
    Ist der Operand des <literal>~</literal> Operators eine Zeichenkette, dann
    wird die Operation auf den ASCII-Werten der Zeichen der Zeichenkette
    durchgeführt, Und das Ergebnis ist wiederum eine Zeichenkette. Andernfalls
    werden Operand und Ergebnis als Ganzzahl behandelt.
   </para>
   <para>
    Beide Operanden und das Ergebnis der <literal>&lt;&lt;</literal> und
    <literal>&gt;&gt;</literal> Operatoren werden immer als Ganzzahl behandelt.
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
Die error_reporting ini-Einstellung von PHP verwendet Bitwerte, was die
realitätsnahe Demonstration des Ausschaltens einzelner Bits bietet. Um alle
Fehler außer Hinweisen anzuzeigen, weist die php.ini Datei an folgendes zu tun:
<userinput>E_ALL &amp; ~E_NOTICE</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Dies funktioniert, indem mit E_ALL begonnen wird:
<computeroutput>00000000000000000111011111111111</computeroutput>
Dann wird der Wert von E_NOTICE genommen...
<computeroutput>00000000000000000000000000001000</computeroutput>
... und dieser per <literal>~</literal> invertiert:
<computeroutput>11111111111111111111111111110111</computeroutput>
Schließlich wird UND (&amp;) verwendet, um die Bits zu ermitteln, die in
beiden Werten gesetzt sind:
<computeroutput>00000000000000000111011111110111</computeroutput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Eine andere Möglichkeit dies zu bewerkstelligen, ist XOR (<literal>^</literal>)
zu verwenden, um diejenigen Bits zu finden, die nur in einem der beiden Werte
gesetzt sind:
<userinput>E_ALL ^ E_NOTICE</userinput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
error_reporting kann ebenfalls verwendet werden, um zu zeigen, wie Bits gesetzt
werden. Auf folgende Weise werden nur Fehler und behebbare Fehler angezeigt:
<userinput>E_ERROR | E_RECOVERABLE_ERROR</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Dieser Vorgang kombiniert E_ERROR
<computeroutput>00000000000000000000000000000001</computeroutput>
und
<computeroutput>00000000000000000001000000000000</computeroutput>
unter Verwendung des ODER (<literal>|</literal>) Operators
um die Bits zu ermitteln, die in einem oder beiden Werten gesetzt sind:
<computeroutput>00000000000000000001000000000001</computeroutput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <example>
     <title>Bitweise UND, ODER und XODER Operationen mit Ganzzahlen</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Der erste Abschnitt kann ignoriert werden;
 * er dient nur zu Formatierungszwecken, um die Ausgabe deutlicher zu machen.
 */

$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'
        . ' %3$s (%4$2d = %4$04b)' . "\n";

echo <<<EOH
 ---------     ---------  -- ---------
 Ergebnis      Wert 1     Op Wert 2
 ---------     ---------  -- ---------
EOH;


/*
 * Hier kommen die Beispiele.
 */

$values = array(0, 1, 2, 4, 8);
$test = 1 + 4;

echo "\n Bitweises UND \n";
foreach ($values as $value) {
    $result = $value & $test;
    printf($format, $result, $value, '&', $test);
}

echo "\n Bitweises einschließendes ODER \n";
foreach ($values as $value) {
    $result = $value | $test;
    printf($format, $result, $value, '|', $test);
}

echo "\n Bitweises ausschließendes ODER (XODER) \n";
foreach ($values as $value) {
    $result = $value ^ $test;
    printf($format, $result, $value, '^', $test);
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
 ---------     ---------  -- ---------
 Ergebnis      Wert 1     Op Wert 2
 ---------     ---------  -- ---------
 Bitweises UND
( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)
( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)
( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)
( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)
( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)

 Bitweises einschließendes ODER
( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)

 Bitweises ausschließendes ODER (XODER)
( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)
]]>
     </screen>
    </example>
   </para>
   <para>
    <example>
     <title>Bitweise XODER Operationen mit Zeichenketten</title>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // Gibt '5' aus

echo "12" ^ "9"; // Gibt das Backspace-Zeichen (ASCII 8) aus
                 // ('1' (ASCII 49)) ^ ('9' (ASCII 57)) = #8

echo "hallo" ^ "hello"; // Gibt die ASCII-Werte #0 #4 #0 #0 #0 aus
                        // 'a' ^ 'e' = #4

echo 2 ^ "3"; // Gibt 1 aus
              // 2 ^ ((int)"3") == 1

echo "2" ^ 3; // Gibt 1 aus
              // ((int)"2") ^ 3 == 1
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Bit-Verschiebung mit Ganzzahlen</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Hier kommen die Beispiele.
 */

echo "\n--- RECHTSVERSCHIEBUNG MIT POSITIVEN GANZZAHLEN ---\n";

$val = 4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'Kopie des Vorzeichenbits wird links hereingeschoben');

$val = 4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places);

$val = 4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'Bits werden rechts herausgeschoben');

$val = 4;
$places = 4;
$res = $val >> $places;
p($res, $val, '>>', $places, 'dasselbe Ergebnis wie oben; man kann nicht über 0 hinaus verschieben');


echo "\n--- RECHTSVERSCHIEBUNG MIT NEGATIVEN GANZZAHLEN ---\n";

$val = -4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'Kopie des Vorzeichenbits wird links hereingeschoben');

$val = -4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places, 'Bits werden rechts herausgeschoben');

$val = -4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'dasselbe Ergebnis wie oben; man kann nicht über -1 hinaus verschieben');


echo "\n--- LINKSSVERSCHIEBUNG MIT POSITIVEN GANZZAHLEN ---\n";

$val = 4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'Nullen werden rechts hereingeschoben');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 4;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = 4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places, 'Vorzeichenbits werden herausgeschoben');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'Bits werden links herausgeschoben');


echo "\n--- LINKSVERSCHIEBUNG MIT NEGATIVEN GANZZAHLEN ---\n";

$val = -4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'Nullen werden rechts hereingeschoben');

$val = -4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = -4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'Bits werden links herausgeschoben, einschließlich des Vorzeichenbits');


/*
 * Dieser Abschnitt kann ignoriert werden;
 * es handlet sich nur um Formatierung, um die Ausgabe deutlicher zu machen.
 */

function p($res, $val, $op, $places, $note = '') {
    $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";

    printf("Ausdruck: %d = %d %s %d\n", $res, $val, $op, $places);

    echo " Dezimal:\n";
    printf("  Wert=%d\n", $val);
    printf("  Erg.=%d\n", $res);

    echo " Binär:\n";
    printf('  Wert=' . $format, $val);
    printf('  Erg.=' . $format, $res);

    if ($note) {
        echo " ANMERKUNG: $note\n";
    }

    echo "\n";
}
?>
]]>
     </programlisting>
     &example.outputs.32bit;
     <screen>
<![CDATA[

--- RECHTSVERSCHIEBUNG MIT POSITIVEN GANZZAHLEN ---
Ausdruck: 2 = 4 >> 1
 Dezimal:
  Wert=4
  Erg.=2
 Binär:
  Wert=00000000000000000000000000000100
  Erg.=00000000000000000000000000000010
 ANMERKUNG: Kopie des Vorzeichenbits wird links hereingeschoben

Ausdruck: 1 = 4 >> 2
 Dezimal:
  Wert=4
  Erg.=1
 Binär:
  Wert=00000000000000000000000000000100
  Erg.=00000000000000000000000000000001

Ausdruck: 0 = 4 >> 3
 Dezimal:
  Wert=4
  Erg.=0
 Binär:
  Wert=00000000000000000000000000000100
  Erg.=00000000000000000000000000000000
 ANMERKUNG: Bits werden rechts herausgeschoben

Ausdruck: 0 = 4 >> 4
 Dezimal:
  Wert=4
  Erg.=0
 Binär:
  Wert=00000000000000000000000000000100
  Erg.=00000000000000000000000000000000
 ANMERKUNG: dasselbe Ergebnis wie oben; man kann nicht über 0 hinaus verschieben


--- RECHTSVERSCHIEBUNG MIT NEGATIVEN GANZZAHLEN ---
Ausdruck: -2 = -4 >> 1
 Dezimal:
  Wert=-4
  Erg.=-2
 Binär:
  Wert=11111111111111111111111111111100
  Erg.=11111111111111111111111111111110
 ANMERKUNG: Kopie des Vorzeichenbits wird links hereingeschoben

Ausdruck: -1 = -4 >> 2
 Dezimal:
  Wert=-4
  Erg.=-1
 Binär:
  Wert=11111111111111111111111111111100
  Erg.=11111111111111111111111111111111
 ANMERKUNG: Bits werden rechts herausgeschoben

Ausdruck: -1 = -4 >> 3
 Dezimal:
  Wert=-4
  Erg.=-1
 Binär:
  Wert=11111111111111111111111111111100
  Erg.=11111111111111111111111111111111
 ANMERKUNG: dasselbe Ergebnis wie oben; man kann nicht über -1 hinaus verschieben


--- LINKSSVERSCHIEBUNG MIT POSITIVEN GANZZAHLEN ---
Ausdruck: 8 = 4 << 1
 Dezimal:
  Wert=4
  Erg.=8
 Binär:
  Wert=00000000000000000000000000000100
  Erg.=00000000000000000000000000001000
 ANMERKUNG: Nullen werden rechts hereingeschoben

Ausdruck: 1073741824 = 4 << 28
 Dezimal:
  Wert=4
  Erg.=1073741824
 Binär:
  Wert=00000000000000000000000000000100
  Erg.=01000000000000000000000000000000

Ausdruck: -2147483648 = 4 << 29
 Dezimal:
  Wert=4
  Erg.=-2147483648
 Binär:
  Wert=00000000000000000000000000000100
  Erg.=10000000000000000000000000000000
 ANMERKUNG: Vorzeichenbits werden herausgeschoben

Ausdruck: 0 = 4 << 30
 Dezimal:
  Wert=4
  Erg.=0
 Binär:
  Wert=00000000000000000000000000000100
  Erg.=00000000000000000000000000000000
 ANMERKUNG: Bits werden links herausgeschoben


--- LINKSVERSCHIEBUNG MIT NEGATIVEN GANZZAHLEN ---
Ausdruck: -8 = -4 << 1
 Dezimal:
  Wert=-4
  Erg.=-8
 Binär:
  Wert=11111111111111111111111111111100
  Erg.=11111111111111111111111111111000
 ANMERKUNG: Nullen werden rechts hereingeschoben

Ausdruck: -2147483648 = -4 << 29
 Dezimal:
  Wert=-4
  Erg.=-2147483648
 Binär:
  Wert=11111111111111111111111111111100
  Erg.=10000000000000000000000000000000

Ausdruck: 0 = -4 << 30
 Dezimal:
  Wert=-4
  Erg.=0
 Binär:
  Wert=11111111111111111111111111111100
  Erg.=00000000000000000000000000000000
 ANMERKUNG: Bits werden links herausgeschoben, einschließlich des Vorzeichenbits
]]>
     </screen>
     &example.outputs.64bit;
     <screen>
<![CDATA[

--- RECHTSVERSCHIEBUNG MIT POSITIVEN GANZZAHLEN ---
Ausdruck: 2 = 4 >> 1
 Dezimal:
  Wert=4
  Erg.=2
 Binär:
  Wert=0000000000000000000000000000000000000000000000000000000000000100
  Erg.=0000000000000000000000000000000000000000000000000000000000000010
 ANMERKUNG: Kopie des Vorzeichenbits wird links hereingeschoben

Ausdruck: 1 = 4 >> 2
 Dezimal:
  Wert=4
  Erg.=1
 Binär:
  Wert=0000000000000000000000000000000000000000000000000000000000000100
  Erg.=0000000000000000000000000000000000000000000000000000000000000001

Ausdruck: 0 = 4 >> 3
 Dezimal:
  Wert=4
  Erg.=0
 Binär:
  Wert=0000000000000000000000000000000000000000000000000000000000000100
  Erg.=0000000000000000000000000000000000000000000000000000000000000000
 ANMERKUNG: Bits werden rechts herausgeschoben

Ausdruck: 0 = 4 >> 4
 Dezimal:
  Wert=4
  Erg.=0
 Binär:
  Wert=0000000000000000000000000000000000000000000000000000000000000100
  Erg.=0000000000000000000000000000000000000000000000000000000000000000
 ANMERKUNG: dasselbe Ergebnis wie oben; man kann nicht über 0 hinaus verschieben


--- RECHTSVERSCHIEBUNG MIT NEGATIVEN GANZZAHLEN ---
Ausdruck: -2 = -4 >> 1
 Dezimal:
  Wert=-4
  Erg.=-2
 Binär:
  Wert=1111111111111111111111111111111111111111111111111111111111111100
  Erg.=1111111111111111111111111111111111111111111111111111111111111110
 ANMERKUNG: Kopie des Vorzeichenbits wird links hereingeschoben

Ausdruck: -1 = -4 >> 2
 Dezimal:
  Wert=-4
  Erg.=-1
 Binär:
  Wert=1111111111111111111111111111111111111111111111111111111111111100
  Erg.=1111111111111111111111111111111111111111111111111111111111111111
 ANMERKUNG: Bits werden rechts herausgeschoben

Ausdruck: -1 = -4 >> 3
 Dezimal:
  Wert=-4
  Erg.=-1
 Binär:
  Wert=1111111111111111111111111111111111111111111111111111111111111100
  Erg.=1111111111111111111111111111111111111111111111111111111111111111
 ANMERKUNG: dasselbe Ergebnis wie oben; man kann nicht über -1 hinaus verschieben


--- LINKSSVERSCHIEBUNG MIT POSITIVEN GANZZAHLEN ---
Ausdruck: 8 = 4 << 1
 Dezimal:
  Wert=4
  Erg.=8
 Binär:
  Wert=0000000000000000000000000000000000000000000000000000000000000100
  Erg.=0000000000000000000000000000000000000000000000000000000000001000
 ANMERKUNG: Nullen werden rechts hereingeschoben

Ausdruck: 4611686018427387904 = 4 << 60
 Dezimal:
  Wert=4
  Erg.=4611686018427387904
 Binär:
  Wert=0000000000000000000000000000000000000000000000000000000000000100
  Erg.=0100000000000000000000000000000000000000000000000000000000000000

Ausdruck: -9223372036854775808 = 4 << 61
 Dezimal:
  Wert=4
  Erg.=-9223372036854775808
 Binär:
  Wert=0000000000000000000000000000000000000000000000000000000000000100
  Erg.=1000000000000000000000000000000000000000000000000000000000000000
 NANMERKUNGTE: Vorzeichenbits werden herausgeschoben

Ausdruck: 0 = 4 << 62
 Dezimal:
  Wert=4
  Erg.=0
 Binär:
  Wert=0000000000000000000000000000000000000000000000000000000000000100
  Erg.=0000000000000000000000000000000000000000000000000000000000000000
 ANMERKUNG: Bits werden links herausgeschoben


--- LINKSVERSCHIEBUNG MIT NEGATIVEN GANZZAHLEN ---
Ausdruck: -8 = -4 << 1
 Dezimal:
  Wert=-4
  Erg.=-8
 Binär:
  Wert=1111111111111111111111111111111111111111111111111111111111111100
  Erg.=1111111111111111111111111111111111111111111111111111111111111000
 ANMERKUNG: Nullen werden rechts hereingeschoben

Ausdruck: -9223372036854775808 = -4 << 61
 Dezimal:
  Wert=-4
  Erg.=-9223372036854775808
 Binär:
  Wert=1111111111111111111111111111111111111111111111111111111111111100
  Erg.=1000000000000000000000000000000000000000000000000000000000000000

Ausdruck: 0 = -4 << 62
 Dezimal:
  Wert=-4
  Erg.=0
 Binär:
  Wert=1111111111111111111111111111111111111111111111111111111111111100
  Erg.=0000000000000000000000000000000000000000000000000000000000000000
 ANMERKUNG: Bits werden links herausgeschoben, einschließlich des Vorzeichenbits
]]>
     </screen>
    </example>
   </para>
   <warning>
    <para>
     Für die bitweise Manipulation von Zahlen größer als
     <literal>PHP_INT_MAX</literal> sind die Funktion der
     <link linkend="book.gmp">GMP</link>-Erweiterung zu verwenden.
    </para>
   </warning>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
<!-- <link linkend="language.oop5.basic.class.class">::class</link> -->
      <member><function>pack</function></member>
      <member><function>unpack</function></member>
      <member><function>gmp_and</function></member>
      <member><function>gmp_or</function></member>
      <member><function>gmp_xor</function></member>
      <member><function>gmp_testbit</function></member>
      <member><function>gmp_clrbit</function></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.comparison">
   <title>Vergleichs-Operatoren</title>
   <simpara>
    Vergleichs-Operatoren erlauben es – wie der Name schon sagt – zwei Werte
    zu vergleichen. Wenn Sie an Beispielen verschiedener auf Typen bezogener
    Vergleiche interessiert sind, können Sie sich die
    <link linkend="types.comparisons">PHP Typvergleich-Tabellen</link>
    anschauen.
   </simpara>
   <table>
    <title>Vergleichsoperatoren</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Beispiel</entry>
       <entry>Name</entry>
       <entry>Ergebnis</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>Gleich</entry>
       <entry>
        Gibt &true; zurück, wenn nach der Typ-Jonglage <varname>$a</varname>
        gleich <varname>$b</varname> ist.
       </entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identisch</entry>
       <entry>
        Gibt &true; zurück, wenn <varname>$a</varname> gleich
        <varname>$b</varname> ist und beide denselben Typ haben.
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Ungleich</entry>
       <entry>
        Gibt &true; zurück, wenn nach der Typ-Jonglage <varname>$a</varname>
        nicht gleich <varname>$b</varname> ist.
       </entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Ungleich</entry>
       <entry>
        Gibt &true; zurück, wenn nach der Typ-Jonglage <varname>$a</varname>
        nicht gleich <varname>$b</varname> ist.
       </entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Nicht identisch</entry>
       <entry>
        Gibt &true; zurück, wenn <varname>$a</varname> nicht gleich
        <varname>$b</varname> ist, oder wenn beide nicht denselben Typ haben.
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>Kleiner als</entry>
       <entry>
        Gibt &true; zurück, wenn <varname>$a</varname> kleiner als
        <varname>$b</varname> ist.
       </entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>Größer als</entry>
       <entry>
        Gibt &true; zurück, wenn <varname>$a</varname> größer als
        <varname>$b</varname> ist.
       </entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>Kleiner oder gleich </entry>
       <entry>
        Gibt &true; zurück, wenn <varname>$a</varname> kleiner oder gleich
        <varname>$b</varname> ist.
       </entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>Größer oder gleich</entry>
       <entry>
        Gibt &true; zurück, wenn <varname>$a</varname> größer oder gleich
        <varname>$b</varname> ist.
       </entry>
      </row>
      <row>
       <entry>$a &lt;=&gt; $b</entry>
       <entry>Raumschiff</entry>
       <entry>
        Eine Ganzzahl (<type>int</type>), die kleiner als, gleich oder größer
        als 0 ist, wenn <varname>$a</varname> kleiner als, gleich oder größer
        als <varname>$b</varname> ist.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Falls beide Operanden
    <link linkend="language.types.numeric-strings">numerische Zeichenketten</link>
    sind oder ein Operand eine Zahl ist und der andere eine
    <link linkend="language.types.numeric-strings">numerische Zeichenkette</link>,
    dann wird der Vergleich numerisch durchgeführt. Diese Regel gilt ebenfalls
    für die <link linkend="control-structures.switch">switch</link>-Anweisung.
    Die Typumwandlung wird nicht durchgeführt, wenn der Vergleichsoperator
    <literal>===</literal> oder <literal>!==</literal> ist, da hier sowohl der
    Typ als auch der Wert verglichen werden.
   </para>
   <warning>
    <para>
     Vor PHP 8.0.0 wurde bei einem Vergleich einer Zeichenkette mit einer Zahl
     oder einer numerischen Zeichenkette die Zeichenkette vor dem Vergleich in
     eine Zahl umgewandelt und der Vergleich numerisch durchgeführt.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a");
var_dump("1" == "01");
var_dump("10" == "1e1");
var_dump(100 == "1e2");

switch ("a") {
case 0:
    echo "0";
    break;
case "a":
    echo "a";
    break;
}
?>
]]>
      </programlisting>
      &example.outputs.7;
      <screen>
<![CDATA[
bool(true)
bool(true)
bool(true)
bool(true)
0
]]>
      </screen>
      &example.outputs.8;
      <screen>
<![CDATA[
bool(false)
bool(true)
bool(true)
bool(true)
a
]]>
      </screen>
     </informalexample>
    </para>
   </warning>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Ganzzahlen
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1

// Gleitkommazahlen
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1

// Zeichenketten
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1

echo "a" <=> "aa"; // -1
echo "zz" <=> "aa"; // 1

// Arrays
echo [] <=> []; // 0
echo [1, 2, 3] <=> [1, 2, 3]; // 0
echo [1, 2, 3] <=> []; // 1
echo [1, 2, 3] <=> [1, 2, 1]; // 1
echo [1, 2, 3] <=> [1, 2, 4]; // -1

// Objekte
$a = (object) ["a" => "b"];
$b = (object) ["a" => "b"];
echo $a <=> $b; // 0

$a = (object) ["a" => "b"];
$b = (object) ["a" => "c"];
echo $a <=> $b; // -1

$a = (object) ["a" => "c"];
$b = (object) ["a" => "b"];
echo $a <=> $b; // 1

// nicht nur die Werte werden verglichen; die Schlüssel müssen übereinstimmen
$a = (object) ["a" => "b"];
$b = (object) ["b" => "b"];
echo $a <=> $b; // 1

?>
]]>

     </programlisting>
    </informalexample>
   </para>
   <para>
    Für die verschiedenen Typen wird der Vergleich gemäß der folgenden Tabelle
    durchgeführt (in der angegebenen Reihenfolge).
   </para>
   <table xml:id="language.operators.comparison.types">
    <title>Vergleich mit verschiedenen Typen</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Typ des 1. Operanden</entry>
       <entry>Typ des 2. Operanden</entry>
       <entry>Ergebnis</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>null</type> oder <type>string</type></entry>
       <entry><type>string</type></entry>
       <entry>
        Umwandlung von &null; nach "", dann numerischer oder lexikalischer Vergleich
       </entry>
      </row>
      <row>
       <entry><type>bool</type> oder <type>null</type></entry>
       <entry>anything</entry>
       <entry>
        Umwandlung beider Werte nach <type>bool</type>, dann &false; &lt; &true;
       </entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry><type>object</type></entry>
       <entry>
        Eingebaute Klassen können eigene Vergleichsregeln definieren;
        unterschiedliche Klassen können nicht verglichen werden; für dieselben
        Klassen siehe
        <link linkend="language.oop5.object-comparison">Objektvergleiche</link>
       </entry>
      </row>
      <row>
       <entry><type>string</type>, <type>resource</type>, <type>int</type> oder <type>float</type></entry>
       <entry><type>string</type>, <type>resource</type>, <type>int</type> oder <type>float</type></entry>
       <entry>
        Umwandlung von Zeichenketten und Ressourcen in Zahlen, dann
        numerischer Vergleich
       </entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry><type>array</type></entry>
       <entry>
        Das Array mit weniger Elementen ist kleiner; wird ein Schlüssel vom
        ersten Operanden nicht im zweiten gefunden, dann sind die Arrays nicht
        vergleichbar; andernfalls wird Element für Element verglichen (siehe
        folgendes Beispiel)
       </entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry>anything</entry>
       <entry><type>object</type> ist immer größer</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry>anything</entry>
       <entry><type>array</type> ist immer größer</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <example>
     <title>Boolesche und null-Vergleiche</title>
     <programlisting role="php">
<![CDATA[
<?php
// Boolesche Werte und null werden immer als Boolesche Werte verglichen
var_dump(1 == TRUE);  // TRUE - dasselbe wie (bool)1 == TRUE
var_dump(0 == FALSE); // TRUE - dasselbe wie (bool)0 == FALSE
var_dump(100 < TRUE); // FALSE - dasselbe wie (bool)100 < TRUE
var_dump(-10 < FALSE);// FALSE - dasselbe wie (bool)-10 < FALSE
var_dump(min(-100, -10, NULL, 10, 100)); // NULL - (bool)NULL < (bool)-100 ist FALSE < TRUE
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Umschreibung von Standard-Array-Vergleichen</title>
     <programlisting role="php">
<![CDATA[
<?php
// Arrays werden mit den normalen Vergleichsoperatoren wie folgt verglichen
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return null; // nicht vergleichbar
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <warning>
    <title>Vergleich von Gleitkommazahlen</title>

    <para>
     Aufgrund der Art wie Gleitkommazahlen (<type>float</type>) intern
     dargestellt werden, sollten zwei Gleitkommazahlen nicht auf Gleichheit
     getestet werden.
    </para>

    <para>
     Weitere Informationen sind der Dokumantation von <type>float</type> zu
     entnehmen.
    </para>
   </warning>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>strcasecmp</function></member>
      <member><function>strcmp</function></member>
      <member><link linkend="language.operators.array">Array-Operatoren</link></member>
      <member><link linkend="language.types">Typen</link></member>
     </simplelist>
    </para>
   </sect2>

   <sect2 xml:id="language.operators.comparison.ternary">
    <title>Ternärer Operator</title>
    <para>
     Ein weiterer Vergleichs-Operator ist der "?:" (oder ternäre) Operator.
     <example>
      <title>Zuweisen eines Standardwerts</title>
      <programlisting role="php">
<![CDATA[
<?php
// Beispielanwendung für den ternären Operator
$action = (empty($_POST['action'])) ? 'standard' : $_POST['action'];

// Obiges ist mit dieser if/else-Anweisung identisch
if (empty($_POST['action'])) {
    $action = 'standard';
} else {
    $action = $_POST['action'];
}

?>
]]>
      </programlisting>
     </example>
     Der Ausdruck <literal>(ausdr1) ? (ausdr2) : (ausdr3)</literal>
     wird zu <replaceable>ausdr2</replaceable> ausgewertet, wenn
     <replaceable>ausdr1</replaceable> als &true; ausgewertet wird, und zu
     <replaceable>ausdr3</replaceable>, wenn
     <replaceable>ausdr1</replaceable> zu &false; ausgewertet wird.
    </para>
    <para>
     Beim ternären Operator kann der mittlere Teil weggelassen werden. Der
     Ausdruck <literal>(ausdr1) ?: (ausdr3)</literal> gibt
     <replaceable>ausdr1</replaceable> zurück, wenn
     <replaceable>ausdr1</replaceable> zu &true; ausgewertet wird, und
     <replaceable>ausdr3</replaceable> andernfalls.
    </para>
    <note>
     <simpara>
      Es ist zu beachten, dass der ternäre Operator ein Ausdruck ist und nicht
      als Variable, sondern als Wert eines Ausdrucks ausgewertet wird. Dies
      ist unbedingt zu berücksichtigen, wenn eine Variable per Referenz
      zurückgegeben werden soll. Die Anweisung <literal>return $var == 42 ? $a
      : $b;</literal> in einer Funktion, die per Referenz zurückgibt, wird
      daher nicht funktionieren und eine Warnung erzeugen.
     </simpara>
    </note>
    <note>
     <para>
      Es wird empfohlen, die "Verschachtelung" von ternären Ausdrücken zu
      vermeiden. Das Verhalten von PHP bei der Verwendung von mehr als einem
      nicht einkgeklammerten ternären Operator innerhalb eines einzigen
      Ausdrucks ist im Vergleich zu anderen Sprachen nicht eindeutig. In der
      Tat wurden ternäre Ausdrücke vor PHP 8.0.0 links-assoziativ (von links
      nach rechts) ausgewertet, und nicht rechts-assoziativ wie in den meisten
      anderen Programmiersprachen. Die Links-Assoziativität ist seit PHP 7.4.0
      veraltet. Seit PHP 8.0.0 ist der ternäre Operator nicht-assoziativ.
      <example>
       <title>Ungewöhnliches Verhalten des ternären Operators</title>
       <programlisting role="php">
<![CDATA[
<?php
// auf den ersten Blick scheint das folgende 'true' auszugeben
echo (true ? 'true' : false ? 't' : 'f');

// allerdings wird vor PHP 8.0.0 tatsächlich 't' ausgegeben
// das kommt daher, dass ternäre Ausdrücke links-assoziativ ausgewertet werden

// das Folgende ist eine augenfälligere Variante desselben Codes wie oben
echo ((true ? 'true' : false) ? 't' : 'f');

// hier kann man sehen, dass der erste Ausdruck zu 'true' ausgewertet wird,
// was wiederum zu (bool)true ausgewertet wird, und daher wird der Wahr-Zweig
// des zweiten ternären Ausdrucks zurückgegeben.
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>

   <sect2 xml:id="language.operators.comparison.coalesce">
    <title>Null-Coalescing-Operator</title>
    <para>
     Weiterhin gibt es den "??" (oder null-Coalescing) Operator.
     <example>
      <title>Zuweisung eines Standardwerts</title>
      <programlisting role="php">
<![CDATA[
<?php
// Example usage for: Null Coalesce Operator
$action = $_POST['action'] ?? 'standard';

// Obiges ist mit dieser if/else-Anweisung identisch
if (isset($_POST['action'])) {
    $action = $_POST['action'];
} else {
    $action = 'standard';
}

?>
]]>
      </programlisting>
     </example>
     Der Ausdruck <literal>(ausdr1) ?? (ausdr2)</literal> wird zu
     <replaceable>ausdr2</replaceable> ausgewertet, wenn
     <replaceable>ausdr1</replaceable> &null; ist, und zu
     <replaceable>ausdr1</replaceable> andernfalls.
    </para>
    <para>
     Insbesondere gibt dieser Operator keinen Hinweis und keine Warnung aus,
     wenn der Wert auf der linken Seite nicht existiert, genau wie
     <function>isset</function>. Dies ist besonders für Array-Schlüssel
     nützlich.
    </para>
    <note>
     <simpara>
      Es ist zu beachten, dass der null-Coalescing-Operator ein Ausdruck ist
      und nicht als Variable, sondern als Wert eines Ausdrucks ausgewertet
      wird. Dies ist unbedingt zu berücksichtigen, wenn eine Variable per
      Referenz zurückgegeben werden soll. Die Anweisung <literal>return $foo
      ?? $bar;</literal> in einer Funktion, die per Referenz zurückgibt, wird
      daher nicht funktionieren, und eine Warnung erzeugen.
     </simpara>
    </note>
    <note>
     <para>
      Es ist zu beachten, dass der null-Coalescing-Operator einfach
      verschachtelt werden kann:
      <example>
       <title>Verschachtelung des null-Coalescing-Operators</title>
       <programlisting role="php">
<![CDATA[
<?php

$foo = null;
$bar = null;
$baz = 1;
$qux = 2;

echo $foo ?? $bar ?? $baz ?? $qux; // gibt 1 aus

?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.errorcontrol">
   <title>Operator zur Fehlerkontrolle</title>

   <simpara>
    PHP unterstützt einen Operator für die Fehlerkontrolle: Das
    <literal>@</literal>-Symbol. Stellt man das <literal>@</literal> in PHP
    vor einen Ausdruck werden alle Fehlermeldungen, die von diesem Ausdruck
    erzeugt werden könnten, unterdrückt.
   </simpara>
   <para>
    Wurde eine benutzerdefinierte Fehlerbehandlungsfunktion mit
    <function>set_error_handler</function> definiert, wird sie auch dann
    aufgerufen, wenn die Diagnose unterdrückt wurde.
   </para>

   <warning>
    <para>
     Vor PHP 8.0.0 gab die Funktion <function>error_reporting</function>
     bei einem Aufruf innerhalb einer benutzerdefinierten Fehlerbehandlung
     immer <literal>0</literal> zurück, wenn Fehler mit dem Operator
     <literal>@</literal> unterdückt wurden. Seit PHP 8.0.0 gibt sie den Wert
     <literal>E_ERROR | E_CORE_ERROR | E_COMPILE_ERROR | E_USER_ERROR
     | E_RECOVERABLE_ERROR | E_PARSE</literal> zurück.
    </para>
   </warning>
   <simpara>
    Alle Fehlermeldungen, die von diesem Ausdruck erzeugt werden, sind im
    <literal>"message"</literal>-Element des Arrays, das von
    <function>error_get_last</function> zurückgegeben wird, enthalten. Da sich
    das Ergebnis dieser Funktion bei jedem Fehlers ändert, sollte es möglichst
    früh geprüft werden.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Beabsichtigter Dateifehler */
$my_file = @file ('nicht_vorhandene_Datei') or
    die ("Datei konnte nicht geöffnet werden: Fehler war:'" . error_get_last()['message'] . "'");

// Das funktioniert bei jedem Ausdruck, nicht nur bei Funktionen:
$value = @$cache[$key];
// gibt keine Meldung aus, falls der Index $key nicht vorhanden ist.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     Der @-Operator funktioniert nur bei
     <link linkend="language.expressions">Ausdrücken</link>. Eine einfache
     Daumenregel: wenn der Wert von etwas bestimmt werden kann, dann kann der
     <literal>@</literal>-Operator davor geschrieben werden. Zum Beispiel kann
     er vor Variablen gesetzt werden, vor Funktionsaufrufen, vor Aufrufen
     bestimmter Sprachkonstrukte (z. B. <function>include</function>), und so
     weiter. Nicht verwendet werden kann er vor Funktions- oder
     Klassendefinitionen oder vor Kontrollstrukturen wie <literal>if</literal>
     und &foreach; und so weiter.
    </simpara>
   </note>
   <warning>
    <para>
     Vor PHP 8.0.0 war es möglich, kritische Fehler, die die Skriptausführung
     beenden, mit dem <literal>@</literal>-Operator zu deaktivieren.
     Wenn zum Beispiel <literal>@</literal> dem Aufruf einer Funktion
     vorangestellt wird, die nicht existiert, weil sie nicht verfügbar ist
     oder falsch eingegeben wurde, würde das Skript ohne Hinweis auf die
     Ursache abbrechen.
    </para>
   </warning>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>error_reporting</function></member>
      <member><link linkend="ref.errorfunc">Fehlerbehandlungs- und Protokollierfunktionen</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.execution">
   <title>Operator zur Programmausführung</title>
   <para>
    PHP unterstützt einen Operator für die Ausführung externer Programme: Die
    sog. Backticks (``). Achtung: Die Backticks sind keine einfachen
    Anführungszeichen! PHP versucht, den Text zwischen den Backticks als
    Kommandozeilen-Befehl auszuführen. Die Ausgabe des aufgerufenen Programms
    wird zurückgegeben (d. h. wird nicht einfach ausgegeben, sondern kann
    einer Variablen zugewiesen werden). Die Verwendung des Backtick-Operators
    ist mit <function>shell_exec</function> identisch.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     Der Backtick-Operator steht nicht zur Verfügung, wenn die Funktion
     <function>shell_exec</function> deaktiviert wurde.
    </para>
   </note>
   <note>
    <para>
     Anders als bei einigen anderen Sprachen haben Backticks keine besondere
     Bedeutung, wenn sie in Zeichenketten, die in doppelten Anführungszeichen
     eingeschlossen sind, verwendet werden.
    </para>
   </note>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="ref.exec">Funktionen zur Programmausführung</link></member>
      <member><function>popen</function></member>
      <member><function>proc_open</function></member>
      <member><link linkend="features.commandline">Nutzung von PHP auf der Kommandozeile</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.increment">
   <title>Inkrement- bzw. Dekrementoperatoren</title>
   <para>
    PHP unterstützt Prä- und Post-Inkrement- und Dekrementoperatoren im Stil
    der Programmiersprache C.
   </para>
   <note>
    <simpara>
     Die Inkrement-/Dekrement-Operatoren wirken nur auf Zahlen und
     Zeichenketten. Bei Arrays, Objekten, Booleans und Ressourcen wirken sie
     nicht. Das Dekrementieren von &null; Werten hat ebenfalls keine Wirkung,
     aber sie zu Inkrementieren ergibt <literal>1</literal>.
    </simpara>
   </note>
   <table>
    <title>Inkrement- und Dekrementoperatoren</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Beispiel</entry>
       <entry>Name</entry>
       <entry>Auswirkung</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>Prä-Inkrement</entry>
       <entry>
        Erhöht <varname>$a</varname> um eins und gibt dann
        <varname>$a</varname> zurück.
       </entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>Post-Inkrement</entry>
       <entry>
        Gibt <varname>$a</varname> zurück und erhöht <varname>$a</varname>
        dann um eins.
       </entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>Prä-Dekrement</entry>
       <entry>
        Vermindert <varname>$a</varname> um eins, und gibt dann
        <varname>$a</varname> zurück.
       </entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>Post-Dekrement</entry>
       <entry>
        Gibt <varname>$a</varname> zurück, und vermindert
        <varname>$a</varname> dann um eins.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Ein einfaches Beispiel-Skript:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Post-Inkrement</h3>";
$a = 5;
echo "Sollte 5 sein: " . $a++ . "<br />\n";
echo "Sollte 6 sein: " . $a . "<br />\n";

echo "<h3>Pre-Inkrement</h3>";
$a = 5;
echo "Sollte 6 sein: " . ++$a . "<br />\n";
echo "Sollte 6 sein: " . $a . "<br />\n";

echo "<h3>Post-Dekrement</h3>";
$a = 5;
echo "Sollte 5 sein: " . $a-- . "<br />\n";
echo "Sollte 4 sein: " . $a . "<br />\n";

echo "<h3>Pre-Dekrement</h3>";
$a = 5;
echo "Sollte 4 sein: " . --$a . "<br />\n";
echo "Sollte 4 sein: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    PHP folgt bei der Behandlung arithmetischer Operationen auf
    Zeichenvariablen der Perl-Konvention und nicht der von C. Zum Beispiel
    ändert in PHP und Perl <literal>$a = 'Z'; $a++;</literal>
    <literal>$a</literal> zu <literal>'AA'</literal>, während <literal>a =
    'Z'; a++;</literal> in C <literal>a</literal> zu <literal>'['</literal>
    ändert. (Der ASCII-Wert von <literal>'Z'</literal> ist 90, der ASCII-Wert
    von <literal>'['</literal> ist 91). Es ist zu beachten, dass
    Zeichenvariablen inkrementiert, aber nicht dekrementiert werden können,
    und dass nur einfache ASCII-Buchstaben und Ziffern (a-z, A-Z, 0-9)
    unterstützt werden. Das Inkrementieren oder Dekrementieren anderer
    Zeichenvariablen hat keine Auswirkung; die ursprüngliche Zeichenkette wird
    nicht verändert.
    <example>
     <title>Arithmetrische Operationen an Zeichenvariablen</title>
     <programlisting role="php">
<![CDATA[
<?php
echo '== Buchstaben ==' . PHP_EOL;
$s = 'W';
for ($n=0; $n<6; $n++) {
    echo ++$s . PHP_EOL;
}
// Ziffernzeichen verhalten sich anders
echo '== Ziffern ==' . PHP_EOL;
$d = 'A8';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
$d = 'A08';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
== Buchstaben ==
X
Y
Z
AA
AB
AC
== Ziffern ==
A9
B0
B1
B2
B3
B4
A09
A10
A11
A12
A13
A14
]]>
     </screen>
    </example>
   </para>
   <para>
    Das Inkrementieren oder Dekrementieren Boolescher Variablen hat keine
    Auswirkung.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.logical">
   <title>Logische Operatoren</title>
   <table>
    <title>Logische Operatoren</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Beispiel</entry>
       <entry>Name</entry>
       <entry>Ergebnis</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>Und</entry>
       <entry>&true; wenn sowohl <varname>$a</varname> als auch <varname>$b</varname> &true; ist.</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>Oder</entry>
       <entry>&true; wenn <varname>$a</varname> oder <varname>$b</varname> &true; ist.</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>Entweder Oder</entry>
       <entry>
        &true; wenn entweder <varname>$a</varname> oder <varname>$b</varname>
        &true; ist, aber nicht beide.
       </entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>Nicht</entry>
       <entry>&true; wenn <varname>$a</varname> nicht &true; ist.</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>Und</entry>
       <entry>
        &true; wenn sowohl <varname>$a</varname> als auch
        <varname>$b</varname> &true; ist.
       </entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>Oder</entry>
       <entry>
        &true; wenn <varname>$a</varname> oder <varname>$b</varname> &true;
        ist.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    Der Grund dafür, dass es je zwei unterschiedliche Operatoren für die
    "Und"- und die "Oder"-Verknüpfung gibt, ist der, dass die beiden
    Operatoren unterschiedliche Rangfolgen haben. (siehe auch
    <link linkend="language.operators.precedence">Operator-Rangfolge</link>.)
   </simpara>
   <example>
    <title>Logische Operatoren erklärt</title>
    <programlisting role="php">
<![CDATA[
<?php

// --------------------
// foo() wird nie aufgerufen werden, da die Operatoren Kurzschlussauswertung verwenden

$a = (false && foo());
$b = (true  || foo());
$c = (false and foo());
$d = (true  or  foo());

// --------------------
// "||" hat eine höhere Rangfolge als "or"

// Das Ergebnis des Ausdrucks (false || true) wird $e zugewiesen
// Funktioniert wie: ($e = (false || true))
$e = false || true;

// Die Konstante "false" wird $f zugewiesen bevor die "or" Operation
// durchgeführt wird
// Funktioniert wie: (($e = false) or true)
$f = false or true;

var_dump($e, $f);

// --------------------
// "&&" hat eine höhere Rangfolge als "and"

// Das Ergebnis des Ausdrucks (true && false) wird $g zugewiesen
// Funktioniert wie: ($g = (true && false))
$g = true && false;

// Die Konstante "true" wird $h zugewiesen bevor die "and" Operation
// durchgeführt wird
// Funktioniert wie: (($h = true) and false)
$h = true and false;

var_dump($g, $h);
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
bool(true)
bool(false)
bool(false)
bool(true)
]]>
    </screen>
   </example>
  </sect1>

  <sect1 xml:id="language.operators.string">
   <title>Zeichenketten-Operatoren</title>
   <simpara>
    Es gibt in PHP zwei Operatoren für Zeichenketten (<type>string</type>).
    Der erste ist der Verknüpfungsoperator ('.'), dessen Rückgabewert eine
    zusammengesetzte Zeichenkette aus dem rechten und dem linken Argument ist.
    Der zweite ist der verknüpfende Zuweisungsoperator
    ('<literal>.=</literal>'), der das Argument auf der rechten Seite an das
    Argument der linken Seite anhängt. Siehe
    <link linkend="language.operators.assignment">Zuweisungs-Operatoren</link>
    für weitere Informationen.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "Hallo ";
$b = $a . "Welt!"; // $b enthält jetzt den Text "Hallo Welt!"

$a = "Hallo ";
$a .= "Welt!";    // $a enthält jetzt den Text "Hallo Welt!"
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="language.types.string">Strings</link></member>
      <member><link linkend="ref.strings">String-Funktionen</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.array">
   <title>Array-Operatoren</title>
   <table>
    <title>Array-Operatoren</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Beispiel</entry>
       <entry>Name</entry>
       <entry>Ergebnis</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>Vereinigung</entry>
       <entry>Vereinigung von <varname>$a</varname> und <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>Gleichwertigkeit</entry>
       <entry>
        &true; wenn <varname>$a</varname> und <varname>$b</varname> dieselben
        Schlüssel-/Wert-Paare enthalten.
       </entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identität</entry>
       <entry>
        &true; wenn <varname>$a</varname> und <varname>$b</varname> dieselben
        Schlüssel-/Wert-Paare in der gleichen Reihenfolge und vom selben Typ
        enthalten.
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Ungleichheit</entry>
       <entry>&true; wenn <varname>$a</varname> nicht gleich<varname>$b</varname> ist.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Ungleichheit</entry>
       <entry>&true; wenn <varname>$a</varname> nicht gleich<varname>$b</varname> ist.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>nicht identisch</entry>
       <entry>&true; wenn <varname>$a</varname> nicht identisch zu <varname>$b</varname> ist.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Der Operator <literal>+</literal> hängt das rechsstehende Array an das
    linksstehende Array an; kommen Schlüssel in beiden Arrays vor, dann werden
    die Elemente des linksstehenden Arrays verwendet, und die entsprechenden
    Elemente des rechtstehenden Arrays werden ignoriert.
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "Apfel", "b" => "Banane");
$b = array("a" =>"Birne", "b" => "Erdbeere", "c" => "Kirsche");

$c = $a + $b; // Vereinigung von $a mit $b;
echo "Vereinigung von \$a mit \$b: \n";
var_dump($c);

$c = $b + $a; // Vereinigung von $b mit $a;
echo "Vereinigung von \$b mit \$a: \n";
var_dump($c);

$a += $b; // Vereinigung von $a += $b ist $a + $b
echo "Vereinigung von \$a += \$b: \n";
var_dump($a);
?>
]]>
     </programlisting>
    </informalexample>
    Dieses Skript gibt folgendes aus:
    <screen role="php">
<![CDATA[
Vereinigung von $a mit $b:
array(3) {
  ["a"]=>
  string(5) "Apfel"
  ["b"]=>
  string(6) "Banane"
  ["c"]=>
  string(7) "Kirsche"
}
Vereinigung von $b mit $a:
array(3) {
  ["a"]=>
  string(4) "Birne"
  ["b"]=>
  string(8) "Erdbeere"
  ["c"]=>
  string(7) "Kirsche"
}
Vereinigung von $a += $b:
array(3) {
  ["a"] =>
  string(5) "Apfel"
  ["b"] =>
  string(6) "Banane"
  ["c"] =>
  string(6) "Kirsche"
}
]]>
    </screen>
   </para>
   <para>
    Beim Vergleich werden Arrayelemente als gleich angesehen, wenn diese
    dieselben Schlüssel und Werte beinhalten.
   </para>
   <para>
    <example>
     <title>Array-Vergleiche</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("Apfel", "Banane");
$b = array(1 => "Banane", "0" => "Apfel");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="language.types.array">Arrays</link></member>
      <member><link linkend="ref.array">Array-Funktionen</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.type">
   <title>Typ-Operatoren</title>
   <para>
    <literal>instanceof</literal> wird dazu verwendet um festzustellen, ob ein
    gegebenes Objekt ein Objekt ist, das zu einer bestimmten
    <link linkend="language.oop5.basic.class">Klasse</link> gehört.
    <example>
     <title>Die Verwendung von <literal>instanceof</literal> mit Klassen</title>
    <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

class NotMyClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof NotMyClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    <literal>instanceof</literal> kann auch verwendet werden, um zu bestimmen,
    ob ein Variable ein Exemplar einer Klasse ist, die von einer Elternklasse
    erbt:
    <example>
     <title>Verwendung von <literal>instanceof</literal> mit ererbten Klassen</title>
     <programlisting role="php">
<![CDATA[
<?php
class ParentClass
{
}

class MyClass extends ParentClass
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof ParentClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Um zu prüfen, ob ein Objekt <emphasis>nicht</emphasis> eine Instanz einer
    Klasse ist, kann der
    <link linkend="language.operators.logical">logische <literal>nicht</literal>-Operator</link>
    verwendet werden.
    <example>
     <title>
      Verwendung von <literal>instanceof</literal>, um zu prüfen, ob ein
      Objekt <emphasis>nicht</emphasis> eine Instanz einer Klasse ist
     </title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

$a = new MyClass;
var_dump(!($a instanceof stdClass));
?>
]]>
     </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Schließlich kann <literal>instanceof</literal> auch dazu verwendet werden,
    um zu bestimmen, ob eine Variable ein instanziiertes Objekt einer Klasse
    ist, die ein <link linkend="language.oop5.interfaces">Interface</link>
    implementiert:
    <example>
     <title>Verwendung von <literal>instanceof</literal> mit Interfaces</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof MyInterface);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Obwohl <literal>instanceof</literal> üblicherweise mit einem
    Klassennamensbezeichner verwendet wird, kann es auch mit einem anderen
    Objekt oder einer Zeichenkettenvariablen verwendet werden:
    <example>
     <title>Verwendung von <literal>instanceof</literal> mit anderen Variablen</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;
$b = new MyClass;
$c = 'MyClass';
$d = 'NotMyClass';

var_dump($a instanceof $b); // $b ist ein Exemplar der Klasse MyClass
var_dump($a instanceof $c); // $c ist die Zeichenkette 'MyClass'
var_dump($a instanceof $d); // $d ist die Zeichenkette 'NotMyClass'
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    instanceof löst keinen Fehler aus, wenn die getestete Variable kein Objekt
    ist; es gibt dann einfach &false; zurück. Konstanten waren allerdings vor
    PHP 7.3.0 nicht erlaubt.
    <example>
     <title>Verwendung von <literal>instanceof</literal> um andere Variablen zu prüfen</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = NULL;
$c = imagecreate(5, 5);
var_dump($a instanceof stdClass); // $a ist eine Ganzzahl
var_dump($b instanceof stdClass); // $b ist NULL
var_dump($c instanceof stdClass); // $c ist ein Ressource
var_dump(FALSE instanceof stdClass);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
bool(false)
bool(false)
PHP Fatal error:  instanceof expects an object instance, constant given
]]>
     </screen>
    </example>
   </para>
   <para>
    Von PHP 7.3.0 an sind Konstanten auf der linken Seite des
    <literal>instanceof</literal>-Operators erlaubt.
    <example>
     <title>Verwendung von <literal>instanceof</literal> um Konstanten zu prüfen</title>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(FALSE instanceof stdClass);
?>
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    Seit PHP 8.0.0 kann <literal>instanceof</literal> mit beliebigen
    Ausdrücken verwendet werden. Der Ausdruck muss in Klammern eingeschlossen
    sein und einen <type>&string;</type> erzeugen.
    <!-- RFC: https://wiki.php.net/rfc/variable_syntax_tweaks -->
    <example>
     <title>Verwendung von <literal>instanceof</literal> mit einem beliebigen Ausdruck</title>
     <programlisting role="php">
      <![CDATA[
<?php

class ClassA extends \stdClass {}
class ClassB extends \stdClass {}
class ClassC extends ClassB {}
class ClassD extends ClassA {}

function getSomeClass(): string
{
    return ClassA::class;
}

var_dump(new ClassA instanceof ('std' . 'Class'));
var_dump(new ClassB instanceof ('Class' . 'B'));
var_dump(new ClassC instanceof ('Class' . 'A'));
var_dump(new ClassD instanceof (getSomeClass()));
?>
]]>
     </programlisting>
     &example.outputs.8;
     <screen>
      <![CDATA[
bool(true)
bool(true)
bool(false)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <simpara>
    Der <literal>instanceof</literal>-Operator hat mit der Funktion
    <function>is_a</function> eine funktionale Variante.
   </simpara>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>get_class</function></member>
      <member><function>is_a</function></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
