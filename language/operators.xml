<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 345447 Maintainer: nobody Status: ready -->
<!-- CREDITS: tzwenny, betz -->

 <chapter xml:id="language.operators" xmlns="http://docbook.org/ns/docbook">
  <title>Operatoren</title>
  <simpara>
   Ein Operator ist etwas das Sie mit einem oder mehreren Werten füttern (oder
   Ausdrücken, um im Programmierjargon zu sprechen) und Sie erhalten als
   Ergebnis einen anderen Wert (damit wird diese Konstruktion selbst zu einem
   Ausdruck).
  </simpara>
  <para>
   Operatoren können gemäß der Anzahl der Operanden, die sie erwarten, gruppiert
   werden. Unäre Operatoren arbeiten mit nur einem Operanden, zum Beispiel
   <literal>!</literal> (der
   <link linkend="language.operators.logical">logische Negationsoperator</link>)
   oder <literal>++</literal> (der 
   <link linkend="language.operators.increment">Inkrementoperator</link>).
   Binare Operatoren arbeiten mit zwei Operanden, wie etwa die bekannten
   <link linkend="language.operators.arithmetic">arithemetischen Operatoren</link>
   <literal>+</literal> (Plus) und <literal>-</literal> (Minus), und die meisten
   PHP-Operatoren fallen in diese Kategorie. Schließlich gibt es einen einzigen
   <link linkend="language.operators.comparison.ternary">ternären Operator</link>,
   <literal>? :</literal>, der mit drei Operanden arbeitet; dieser wird meist einfach
   "der ternäre Operator" genannt (obwohl er wohl richtiger bedingter Operator
   genannt werden könnte).
  </para>
  <para>
   Eine vollständige Liste von PHP-Operatoren folgt im Abschnitt
   <link linkend="language.operators.precedence">Operator-Rangfolge</link>. Dieser
   Abschnitt erklärt weiterhin die Operator-Rangfolge und -	Assoziativität, die
   regeln wie Ausdrücke, die mehrere unterschiedliche Operatoren enthalten,
   ausgewertet werden.
  </para>

  <sect1 xml:id="language.operators.precedence">
   <title>Operator-Rangfolge</title>
   <para>
    Die Operator-Rangfolge legt fest, wie "eng" ein Operator zwei
    Ausdrücke miteinander verbindet. Zum Beispiel ist das Ergebnis des
    Ausdruckes <literal>1 + 5 * 3</literal> <literal>16</literal>
    und nicht <literal>18</literal>, da der Multiplikations-Operator
    ("*") in der Rangfolge höher steht als der Additions-Operator
    ("+"). Wenn nötig, können Sie Klammern setzen, um die Rangfolge
    der Operatoren zu beeinflussen. Zum Beispiel ergibt: <literal>(1 + 5) *
    3</literal> <literal>18</literal>.
   </para>
   <para>
    Haben Operatoren die gleiche Rangfolge, dann entscheidet ihre Assoziativität
    wie die Operatoren gruppiert werden. Zum Beispiel ist "-" links-assoziativ, so
    dass <literal>1 - 2 - 3</literal> als <literal>(1 - 2) - 3</literal> gruppiert
    und zu <literal>-4</literal> ausgewertet wird. Andererseits ist "=" rechts-assoziativ,
    so dass <literal>$a = $b = $c</literal> als <literal>$a = ($b = $c)</literal>
    gruppiert wird.
   </para>
   <para>
    Operatoren gleicher Rangfolge, die nicht-assoziativ sind, können nicht nebeneinander
    verwendet werden; beispielsweise ist <literal>1 &lt; 2 &gt; 1</literal> in PHP
    nicht erlaubt. Der Ausdruck <literal>1 &lt;= 1 == 1</literal> ist allerdings
    erlaubt, weil der <literal>==</literal> Operator eine kleinere Rangfolge als der
    <literal>&lt;</literal> Operator hat.
   </para>
   <para>
    Die Verwendung von Klammern, auch wenn sie nicht unbedingt erforderlich sind,
    kann oft die Lesbarkeit des Codes verbessern, indem explizit gruppiert wird,
    statt sich auf die implizite Operator-Rangfolge und -Assoziativität zu verlassen.
   </para>
   <para>
    Die folgende Tabelle zeigt die Rangfolge der Operatoren, oben
    steht der Operator mit dem höchsten Rang. Operatoren in derselben Zeile haben
    die gleiche Rangfolge, so dass ihre Assoziativität die Gruppierung entscheidet.
    <table>
     <title>Operator-Rangfolge</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Assoziativität</entry>
        <entry>Operator</entry>
        <entry>Additional Information</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>nicht-assoziativ</entry>
        <entry>
         <literal>clone</literal>
         <literal>new</literal>
        </entry> 
        <entry>
         <link linkend="language.oop5.cloning">clone</link> und
         <link linkend="language.oop5.basic.new">new</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry><literal>[</literal></entry>
        <entry><function>array</function></entry>
       </row>
       <row>
        <entry>rechts</entry>
        <entry><literal>**</literal></entry>
        <entry><link linkend="language.operators.arithmetic">Arithmetik</link></entry>
       </row>
       <row>
        <entry>rechts</entry>
        <entry>
         <literal>++</literal> 
         <literal>--</literal> 
         <literal>~</literal> 
         <literal>(int)</literal> 
         <literal>(float)</literal> 
         <literal>(string)</literal> 
         <literal>(array)</literal>
         <literal>(object)</literal> 
         <literal>(bool)</literal> 
         <literal>@</literal>
        </entry>
        <entry>
         <link linkend="language.types">Typen</link> und
         <link linkend="language.operators.increment">Inkrement/Dekrement</link>
        </entry>
       </row>
       <row>
        <entry>nicht-assoziativ</entry>
        <entry><literal>instanceof</literal></entry>
        <entry>
         <link linkend="language.types">Typen</link>
        </entry>
       </row>
       <row>
        <entry>rechts</entry>
        <entry><literal>!</literal></entry>
        <entry>
         <link linkend="language.operators.logical">Logik</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>
         <literal>*</literal>
         <literal>/</literal>
         <literal>%</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">Arithmetik</link>
        </entry>
       </row>
       <row>
        <entry>
         <literal>+</literal> 
         <literal>-</literal> 
         <literal>.</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">Arithmetik</link>&listendand;
         <link linkend="language.operators.string">Zeichenketten</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>
         <literal>&lt;&lt;</literal> 
         <literal>&gt;&gt;</literal>
        </entry>
        <entry>
         <link linkend="language.operators.bitwise">Bitoperatoren</link>
        </entry>
       </row>
       <row>
        <entry>nicht-assoziativ</entry>
        <entry>
         <literal>&lt;</literal> 
         <literal>&lt;=</literal> 
         <literal>&gt;</literal> 
         <literal>&gt;=</literal>
        </entry>
        <entry>
         <link linkend="language.operators.comparison">Vergleiche</link>
        </entry>
       </row>
       <row>
        <entry>nicht-assoziativ</entry>
        <entry>
         <literal>==</literal>
         <literal>!=</literal> 
         <literal>===</literal> 
         <literal>!==</literal> 
         <literal>&lt;&gt;</literal>
         <literal>&lt;=&gt;</literal>
        </entry>
        <entry>
         <link linkend="language.operators.comparison">Vergleiche</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry><literal>&amp;</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">Bitoperatoren</link>&listendand;
         <link linkend="language.references">Referenzen</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry><literal>^</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">Bitoperatoren</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry><literal>|</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">Bitoperatoren</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry><literal>&amp;&amp;</literal></entry>
        <entry>
         <link linkend="language.operators.logical">Logik</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry><literal>||</literal></entry>
        <entry>
         <link linkend="language.operators.logical">Logik</link>
        </entry>
       </row>
       <row>
        <entry>rechts</entry>
        <entry><literal>??</literal></entry>
        <entry>
         <link linkend="language.operators.comparison">Vergleiche</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry><literal>? :</literal></entry>
        <entry>
         <link linkend="language.operators.comparison.ternary">ternärer Operator</link>
        </entry>
       </row>
       <row>
        <entry>rechts</entry>
        <entry>
         <literal>=</literal> 
         <literal>+=</literal> 
         <literal>-=</literal> 
         <literal>*=</literal> 
         <literal>**=</literal> 
         <literal>/=</literal> 
         <literal>.=</literal> 
         <literal>%=</literal> 
         <literal>&amp;=</literal> 
         <literal>|=</literal> 
         <literal>^=</literal> 
         <literal>&lt;&lt;=</literal> 
         <literal>&gt;&gt;=</literal>
        </entry>
        <entry>
         <link linkend="language.operators.assignment">Zuweisung</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry><literal>and</literal></entry>
        <entry>
         <link linkend="language.operators.logical">Logik</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry><literal>xor</literal></entry>
        <entry>
         <link linkend="language.operators.logical">Logik</link>
        </entry>
       </row>
       <row>
        <entry>links</entry>
        <entry><literal>or</literal></entry>
        <entry>
         <link linkend="language.operators.logical">Logik</link>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    <example>
     <title>Assoziativität</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
// die Assoziativität des ternären Operators ist anders als bei C/C++
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Operator-Rangfolge und -Assoziativität bestimmen nur wie Ausdrücke gruppiert
    werden, aber nicht die Auswertungsreihenfolge. PHP legt (im Allgemeinen) nicht
    fest, in welcher Reihenfolge ein Ausdruck ausgewertet wird, und Code, der eine
    bestimmte Auswertungsreihenfolge erwartet, sollte vermieden werden, denn das
    Verhalten kann sich von Version zu Version ändern, und auch vom umgebenden Code
    abhängen.
    <example>
     <title>Nicht definierte Auswertungsreihenfolge</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
echo $a + $a++; // gibt entweder 2 oder 3 aus

$i = 1;
$array[$i] = $i++; // der Index ist entweder 1 oder 2
?>
]]>
     </programlisting>
    </example>
    <example>
     <title><literal>+</literal>, <literal>-</literal> und <literal>.</literal> haben dieselbe Rangfolge</title>
     <programlisting role="php">
<![CDATA[
<?php
$x = 4;
// diese Zeile könnte eine unerwartete Ausgabe produzieren:
echo "x minus 1 ist gleich " . $x-1 . ", hoffe ich jedenfalls\n";
// da es wie diese Zeile ausgewertet wird:
echo (("x minus 1 ist gleich " . $x) - 1) . ", hoffe ich jedenfalls\n";
// die gewünschte Rangfolge kann durch die Verwendung von Klammern erzwungen werden:
echo "x minus 1 ist gleich " . ($x-1) . ", hoffe ich jedenfalls\n";
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
-1, hoffe ich jedenfalls
-1, hoffe ich jedenfalls
x minus 1 ist gleich 3, hoffe ich jedenfalls
]]>
     </screen>
    </example>
   </para>
   <note>
    <para>
     Obwohl <literal>=</literal> einen niedrigeren Rang als die meisten anderen
     Operatoren hat, erlaubt PHP dennoch Ausdrücke wie den folgenden:
     <literal>if (!$a = foo())</literal>; in diesem Fall wird der Rückgabewert von
     <literal>foo()</literal> der Variablen <varname>$a</varname> zugewiesen.
    </para>
   </note>
  </sect1>

  <sect1 xml:id="language.operators.arithmetic">
   <title>Arithmetische Operatoren</title>
   <simpara>
    Erinnern Sie sich noch an die Grundrechenarten aus der Schule? Die
    arithmetischen Operatoren funktionieren genauso:
   </simpara>
   <table>
    <title>Arithmetische Operatoren</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Beispiel</entry>
       <entry>Name</entry>
       <entry>Ergebnis</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>+$a</entry>
       <entry>Identität</entry>
       <entry>
        Umwandlung von <varname>$a</varname> nach <type>int</type> oder
        <type>float</type> wie angebracht.
       </entry>
      </row>
      <row>
       <entry>-$a</entry>
       <entry>Negation</entry>
       <entry>Gegenzahl von <varname>$a</varname>.</entry>
      </row>
      <row>
       <entry>$a + $b</entry>
       <entry>Addition</entry>
       <entry>Summe von <varname>$a</varname>a und <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>Subtraktion</entry>
       <entry>Differenz von <varname>$a</varname> und <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>Multiplikation</entry>
       <entry>Produkt von <varname>$a</varname> und <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>Division</entry>
       <entry>Quotient von <varname>$a</varname> und <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>Modulus</entry>
       <entry>Rest von <varname>$a</varname> geteilt durch <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a ** $b</entry>
       <entry>Potenz</entry>
       <entry><varname>$b</varname>-te Potenz von <varname>$a</varname>. (von PHP 5.6 an)</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    Der Divisionsoperator ("/") gibt einen Fließkommawert zurück, es sei denn beide
    Operanden sind Ganzzahlen (oder Zeichenketten, die in Ganzzahlen umgewandelt werden),
    und die Zahlen können glatt geteilt werden; in diesem Fall wird eine Ganzzahl
    zurückgegeben. Für Ganzzahldivision siehe <function>intdiv</function>.
   </simpara>
   <simpara>
    Operanden des Modulusoperators werden vor der Verarbeitung in Ganzzahlen umgewandelt
    (indem die Nachkommastellen entfernt werden). Für den Fließkommazahlen-Modulus
    ist <function>fmod</function> verfügbar.
   </simpara>
   <para>
    Das Ergebnis des Modulusoperators <literal>%</literal> hat dasselbe Vorzeichen
    wie der Dividend, d.h. das Ergebnis von <literal>$a % $b</literal> hat dasselbe
    Vorzeichen wie <varname>$a</varname>. Zum Beispiel:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

echo (5 % 3)."\n";           // gibt 2 aus
echo (5 % -3)."\n";          // gibt 2 aus
echo (-5 % 3)."\n";          // gibt -2 aus
echo (-5 % -3)."\n";         // gibt -2 aus

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Siehe auch im Handbuch das Kapitel über <link
    linkend="ref.math">Mathematische Funktionen</link>.
   </simpara>
  </sect1>

  <sect1 xml:id="language.operators.assignment">
   <title>Zuweisungsoperatoren</title>
   <simpara>
    Der einfachste Zuweisungsoperator ist "=". Wahrscheinlich kommt
    man als erstes auf die Idee, ihn mit "ist gleich" zu bezeichnen.
    Das ist falsch. In Wirklichkeit bedeutet er, dass dem linken
    Operanden der Wert des Ausdrucks auf der rechten Seite zugewiesen
    wird (man müsste ihn also mit "wird gesetzt auf den Wert von"
    übersetzen).
   </simpara>
   <para>
    Der Wert eines Zuweisungs-Ausdruckes ist der zugewiesene Wert.
    D.h. der Wert des Ausdruckes "<literal>$a = 3</literal>" ist 3. Das erlaubt es,
    einige raffinierte Dinge anzustellen:
    <informalexample>
     <programlisting role="php"> 
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a ist nun gleich 9 und $b wurde auf den Wert 4 gesetzt.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Zusätzlich zu dem oben vorgestellten Zuweisungsoperator "=" gibt
    es "kombinierte Operatoren" für alle
    <link linkend="language.operators">binären, arithmetischen</link>, Array-Vereinigung- und
    String-Operatoren, die es erlauben, den Wert einer Variablen in
    einem Ausdruck zu benutzen, und dieser anschließend das Ergebnis
    des Ausdrucks als neuen Wert zuzuweisen. Zum Beispiel: 
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // setzt $a auf den Wert 8, als ob wir geschrieben haetten: $a = $a + 5;
$b = "Hallo ";
$b .= "Du!"; // setzt $b auf den Wert "Hallo Du!", aequivalent zu 
             // $b = $b . "Du!";
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    Man beachte, dass die Zuweisung nur den Wert der Ursprungsvariable
    der neuen Variable zuweist (Zuweisung als Wert, sie "kopiert"),
    weshalb sich Änderungen an der einen Variable nicht auf die
    andere auswirken werden. Das kann wichtig sein, wenn man ein
    großes Array o. ä. in einer Schleife kopieren muss.
   </para>
   <para>
    Eine Ausnahme vom üblichen Wertzuweisungsverhalten in PHP stellen Objekte
    (<type>object</type>) dar, die per Referenz zugewiesen werden. Objekte können
    mit dem <link linkend="language.oop5.cloning">clone</link> Schlüsselwort explizit
    kopiert werden.
   </para>

   <sect2 xml:id="language.operators.assignment.reference">
    <title>Referenzzuweisung</title>
    <para>
     Referenzzuweisung wird ebenfalls unterstützt, unter Verwendung der
     "<computeroutput>$var = &amp;$othervar;</computeroutput>" Syntax.
     Referenzzuweisung bedeutet, dass beide Variablen schließlich auf dieselben
     Daten zeigen, und nichts kopiert wurde.
    </para>
    <para>
     <example>
      <title>Referenzzuweisung</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 3;
$b = &$a; // $b ist eine Referenz auf $a

print "$a\n"; // gibt 3 aus
print "$b\n"; // gibt 3 aus

$a = 4; // ändere $a

print "$a\n"; // gibt 4 aus
print "$b\n"; // gibt ebenfalls 4 aus, da $b eine Referenz auf $a ist, das
              // geändert wurde
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Der <link linkend="language.oop5.basic.new">new</link>-Operator gibt automatisch
     eine Referenz zurück, so dass das Zuweisen des Ergbnisses von
     <link linkend="language.oop5.basic.new">new</link> per Referenz einen Fehler
     der Stufe <constant>E_DEPRECATED</constant> von PHP 5.3 an, und der Stufe
     <constant>E_STRICT</constant> zuvor, auslöst.
    </para>
    <para>
     Beispielsweise wird folgender Code eine Warnung auslösen:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

/* Folgende Zeile erzeugt die folgende Fehlermeldung:
 * Deprecated: Assigning the return value of new by reference is deprecated in...
 */
$o = &new C;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Weitere Informationen zu Referenzen und ihren Anwendungsmöglichkeiten sind dem
     Handbuch-Abschnitt <link linkend="language.references">Referenzen erklärt</link> 
     zu entnehmen.
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.bitwise">
   <title>Bit-Operatoren</title>
   <simpara>
    Bit-Operatoren erlauben es die Prüfung und Manipulation von bestimmten Bits
    in einem Integer.
   </simpara>
   <table>
    <title>Bit-Operatoren</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Beispiel</entry>
       <entry>Name</entry>
       <entry>Ergebnis</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><userinput>$a &amp; $b</userinput></entry>
       <entry>Und</entry>
       <entry>
        Bits, die in <varname>$a</varname> und <varname>$b</varname> gesetzt sind,
        werden gesetzt.
       </entry>
      </row>
      <row>
       <entry><userinput>$a | $b</userinput></entry>
       <entry>Oder</entry>
       <entry>
        Bits, die in <varname>$a</varname> oder <varname>$b</varname> gesetzt sind,
        werden gesetzt.
       </entry>
      </row>
      <row>
       <entry><userinput>$a ^ $b</userinput></entry>
       <entry>Entweder oder (Xor)</entry>
       <entry>
        Bits, die entweder in <varname>$a</varname> oder <varname>$b</varname>,
        jedoch nicht in beiden gesetzt sind, werden gesetzt.
       </entry>
      </row>
      <row>
       <entry><userinput>~ $a</userinput></entry>
       <entry>Nicht</entry>
       <entry>
        Bits, die in <varname>$a</varname> nicht gesetzt sind, werden gesetzt,
        und umgekehrt.
       </entry>
      </row>
      <row>
       <entry><userinput>$a &lt;&lt; $b</userinput></entry>
       <entry>Nach links verschieben</entry>
       <entry>
        Verschiebung der Bits von <varname>$a</varname> um <varname>$b</varname>
        Stellen nach links (jede Stelle entspricht einer Mulitplikation mit zwei).
       </entry>
      </row>
      <row>
       <entry><userinput>$a &gt;&gt; $b</userinput></entry>
       <entry>Nach rechts verschieben</entry>
       <entry>
        Verschiebung der Bits von <varname>$a</varname> um <varname>$b</varname>
        Stellen nach rechts (jede Stelle entspricht einer Division durch zwei).
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Bit-Verschiebungen in PHP sind arithmetisch. Bits, die an einem der Enden
    herausgeschoben werden, werden verworfen. Bei Links-Verschiebungen werden von
    rechts Nullen hereingeschoben, während das Vorzeichenbit links herausgeschoben wird,
    was bedeutet, dass das Vorzeichen des Operanden nicht erhalten bleibt.
    Bei Rechts-Verschiebungen werden Kopien des Vorzeichenbits von links
    hereingeschoben, so dass das Vorzeichen des Operand erhalten bleibt.
   </para>
   <para>
    Klammern sind zu verwenden, um die gewünschte
    <link linkend="language.operators.precedence">Rangfolge</link> sicherzustellen.
    Beispielsweise wird bei <literal>$a &amp; $b == true</literal> zunächst der
    Vergleich ausgewertet, und erst dann das Bit-Und, während bei
    <literal>($a &amp; $b) == true</literal> zunächst das Bit-Und, und erst dann
    der Vergleich ausgewertet wird.
   </para>
   <para>
    Sind beide Operanden der <literal>&amp;</literal>, <literal>|</literal> und
    <literal>^</literal> Operatoren Zeichenketten, dann wird die Operation auf den
    ASCII-Werten der Zeichen der Zeichenketten durchgeführt, und das Ergebnis ist
    wiederum eine Zeichenkette. In allen anderen Fällen werden beide Operanden
    <link linkend="language.types.integer.casting">nach Integer umgewandelt</link>,
    und das Ergebnis ist eine Ganzzahl.
   </para>
   <para>
    Ist der Operand des <literal>~</literal> Operators eine Zeichenkette, dann wird
    die Operation auf den ASCII-Werten der Zeichen der Zeichenkette durchgeführt, Und
    das Ergebnis ist wiederum eine Zeichenkette. Andernfalls werden Operand und Ergebnis
    als Ganzzahl behandelt.
   </para>
   <para>
    Beide Operanden und das Ergebnis der <literal>&lt;&lt;</literal> und
    <literal>&gt;&gt;</literal> Operatoren werden immer als Ganzzahl behandelt.
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
Die error_reporting ini-Einstellung von PHP verwendet Bitwerte, was die
realitätsnahe Demonstration des Ausschaltens einzelner Bits bietet. Um alle
Fehler außer Hinweisen anzuzeigen, weist die php.ini Datei an folgendes zu tun:
<userinput>E_ALL &amp; ~E_NOTICE</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Dies funktioniert, indem mit E_ALL begonnen wird:
<computeroutput>00000000000000000111011111111111</computeroutput>
Dann wird der Wert von E_NOTICE genommen...
<computeroutput>00000000000000000000000000001000</computeroutput>
... und dieser per <literal>~</literal> invertiert:
<computeroutput>11111111111111111111111111110111</computeroutput>
Schließlich wird UND (&amp;) verwendet, um die Bits zu ermitteln, die in
beiden Werten gesetzt sind:
<computeroutput>00000000000000000111011111110111</computeroutput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Eine andere Möglichkeit dies zu bewerkstelligen, ist XOR (<literal>^</literal>)
zu verwenden, um diejenigen Bits zu finden, die nur in einem der beiden Werte
gesetzt sind:
<userinput>E_ALL ^ E_NOTICE</userinput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
error_reporting kann ebenfalls verwendet werden, um zu zeigen, wie Bits gesetzt
werden. Auf folgende Weise werden nur Fehler und behebbare Fehler angezeigt:
<userinput>E_ERROR | E_RECOVERABLE_ERROR</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Dieser Vorgang kombiniert E_ERROR
<computeroutput>00000000000000000000000000000001</computeroutput>
und
<computeroutput>00000000000000000001000000000000</computeroutput>
unter Verwendung des ODER (<literal>|</literal>) Operators
um die Bits zu ermitteln, die in einem oder beiden Werten gesetzt sind:
<computeroutput>00000000000000000001000000000001</computeroutput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <example>
     <title>Bitweise UND, ODER und XODER Operationen mit Ganzzahlen</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Der erste Abschnitt kann ignoriert werden;
 * er dient nur zu Formatierungszwecken, um die Ausgabe deutlicher zu machen.
 */

$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'
        . ' %3$s (%4$2d = %4$04b)' . "\n";

echo <<<EOH
 ---------     ---------  -- ---------
 Ergebnis      Wert 1     Op Wert 2
 ---------     ---------  -- ---------
EOH;


/*
 * Hier kommen die Beispiele.
 */

$values = array(0, 1, 2, 4, 8);
$test = 1 + 4;

echo "\n Bitweises UND \n";
foreach ($values as $value) {
    $result = $value & $test;
    printf($format, $result, $value, '&', $test);
}

echo "\n Bitweises einschließendes ODER \n";
foreach ($values as $value) {
    $result = $value | $test;
    printf($format, $result, $value, '|', $test);
}

echo "\n Bitweises ausschließendes ODER (XODER) \n";
foreach ($values as $value) {
    $result = $value ^ $test;
    printf($format, $result, $value, '^', $test);
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
 ---------     ---------  -- ---------
 Ergebnis      Wert 1     Op Wert 2
 ---------     ---------  -- ---------
 Bitweises UND
( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)
( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)
( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)
( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)
( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)

 Bitweises einschließendes ODER
( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)

 Bitweises ausschließendes ODER (XODER)
( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)
]]>
     </screen>
    </example>
   </para>
   <para>
    <example>
     <title>Bitweise XODER Operationen mit Zeichenketten</title>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // Gibt '5' aus

echo "12" ^ "9"; // Gibt das Backspace-Zeichen (ASCII 8) aus
                 // ('1' (ASCII 49)) ^ ('9' (ASCII 57)) = #8

echo "hallo" ^ "hello"; // Gibt die ASCII-Werte #0 #4 #0 #0 #0 aus
                        // 'a' ^ 'e' = #4

echo 2 ^ "3"; // Gibt 1 aus
              // 2 ^ ((int)"3") == 1

echo "2" ^ 3; // Gibt 1 aus
              // ((int)"2") ^ 3 == 1
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Bit-Verschiebung mit Ganzzahlen</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Hier kommen die Beispiele.
 */

echo "\n--- RECHTSVERSCHIEBUNG MIT POSITIVEN GANZZAHLEN ---\n";

$val = 4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'Kopie des Vorzeichenbits wird links hereingeschoben');

$val = 4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places);

$val = 4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'Bits werden rechts herausgeschoben');

$val = 4;
$places = 4;
$res = $val >> $places;
p($res, $val, '>>', $places, 'dasselbe Ergebnis wie oben; man kann nicht über 0 hinaus verschieben');


echo "\n--- RECHTSVERSCHIEBUNG MIT NEGATIVEN GANZZAHLEN ---\n";

$val = -4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'Kopie des Vorzeichenbits wird links hereingeschoben');

$val = -4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places, 'Bits werden rechts herausgeschoben');

$val = -4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'dasselbe Ergebnis wie oben; man kann nicht über -1 hinaus verschieben');


echo "\n--- LINKSSVERSCHIEBUNG MIT POSITIVEN GANZZAHLEN ---\n";

$val = 4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'Nullen werden rechts hereingeschoben');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 4;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = 4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places, 'Vorzeichenbits werden herausgeschoben');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'Bits werden links herausgeschoben');


echo "\n--- LINKSVERSCHIEBUNG MIT NEGATIVEN GANZZAHLEN ---\n";

$val = -4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'Nullen werden rechts hereingeschoben');

$val = -4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = -4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'Bits werden links herausgeschoben, einschließlich des Vorzeichenbits');


/*
 * Dieser Abschnitt kann ignoriert werden;
 * es handlet sich nur um Formatierung, um die Ausgabe deutlicher zu machen.
 */

function p($res, $val, $op, $places, $note = '') {
    $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";

    printf("Ausdruck: %d = %d %s %d\n", $res, $val, $op, $places);

    echo " Dezimal:\n";
    printf("  Wert=%d\n", $val);
    printf("  Erg.=%d\n", $res);

    echo " Binär:\n";
    printf('  Wert=' . $format, $val);
    printf('  Erg.=' . $format, $res);

    if ($note) {
        echo " ANMERKUNG: $note\n";
    }

    echo "\n";
}
?>
]]>
     </programlisting>
     &example.outputs.32bit;
     <screen>
<![CDATA[

--- RECHTSVERSCHIEBUNG MIT POSITIVEN GANZZAHLEN ---
Ausdruck: 2 = 4 >> 1
 Dezimal:
  Wert=4
  Erg.=2
 Binär:
  Wert=00000000000000000000000000000100
  Erg.=00000000000000000000000000000010
 ANMERKUNG: Kopie des Vorzeichenbits wird links hereingeschoben

Ausdruck: 1 = 4 >> 2
 Dezimal:
  Wert=4
  Erg.=1
 Binär:
  Wert=00000000000000000000000000000100
  Erg.=00000000000000000000000000000001

Ausdruck: 0 = 4 >> 3
 Dezimal:
  Wert=4
  Erg.=0
 Binär:
  Wert=00000000000000000000000000000100
  Erg.=00000000000000000000000000000000
 ANMERKUNG: Bits werden rechts herausgeschoben

Ausdruck: 0 = 4 >> 4
 Dezimal:
  Wert=4
  Erg.=0
 Binär:
  Wert=00000000000000000000000000000100
  Erg.=00000000000000000000000000000000
 ANMERKUNG: dasselbe Ergebnis wie oben; man kann nicht über 0 hinaus verschieben


--- RECHTSVERSCHIEBUNG MIT NEGATIVEN GANZZAHLEN ---
Ausdruck: -2 = -4 >> 1
 Dezimal:
  Wert=-4
  Erg.=-2
 Binär:
  Wert=11111111111111111111111111111100
  Erg.=11111111111111111111111111111110
 ANMERKUNG: Kopie des Vorzeichenbits wird links hereingeschoben

Ausdruck: -1 = -4 >> 2
 Dezimal:
  Wert=-4
  Erg.=-1
 Binär:
  Wert=11111111111111111111111111111100
  Erg.=11111111111111111111111111111111
 ANMERKUNG: Bits werden rechts herausgeschoben

Ausdruck: -1 = -4 >> 3
 Dezimal:
  Wert=-4
  Erg.=-1
 Binär:
  Wert=11111111111111111111111111111100
  Erg.=11111111111111111111111111111111
 ANMERKUNG: dasselbe Ergebnis wie oben; man kann nicht über -1 hinaus verschieben


--- LINKSSVERSCHIEBUNG MIT POSITIVEN GANZZAHLEN ---
Ausdruck: 8 = 4 << 1
 Dezimal:
  Wert=4
  Erg.=8
 Binär:
  Wert=00000000000000000000000000000100
  Erg.=00000000000000000000000000001000
 ANMERKUNG: Nullen werden rechts hereingeschoben

Ausdruck: 1073741824 = 4 << 28
 Dezimal:
  Wert=4
  Erg.=1073741824
 Binär:
  Wert=00000000000000000000000000000100
  Erg.=01000000000000000000000000000000

Ausdruck: -2147483648 = 4 << 29
 Dezimal:
  Wert=4
  Erg.=-2147483648
 Binär:
  Wert=00000000000000000000000000000100
  Erg.=10000000000000000000000000000000
 ANMERKUNG: Vorzeichenbits werden herausgeschoben

Ausdruck: 0 = 4 << 30
 Dezimal:
  Wert=4
  Erg.=0
 Binär:
  Wert=00000000000000000000000000000100
  Erg.=00000000000000000000000000000000
 ANMERKUNG: Bits werden links herausgeschoben


--- LINKSVERSCHIEBUNG MIT NEGATIVEN GANZZAHLEN ---
Ausdruck: -8 = -4 << 1
 Dezimal:
  Wert=-4
  Erg.=-8
 Binär:
  Wert=11111111111111111111111111111100
  Erg.=11111111111111111111111111111000
 ANMERKUNG: Nullen werden rechts hereingeschoben

Ausdruck: -2147483648 = -4 << 29
 Dezimal:
  Wert=-4
  Erg.=-2147483648
 Binär:
  Wert=11111111111111111111111111111100
  Erg.=10000000000000000000000000000000

Ausdruck: 0 = -4 << 30
 Dezimal:
  Wert=-4
  Erg.=0
 Binär:
  Wert=11111111111111111111111111111100
  Erg.=00000000000000000000000000000000
 ANMERKUNG: Bits werden links herausgeschoben, einschließlich des Vorzeichenbits
]]>
     </screen>
     &example.outputs.64bit;
     <screen>
<![CDATA[

--- RECHTSVERSCHIEBUNG MIT POSITIVEN GANZZAHLEN ---
Ausdruck: 2 = 4 >> 1
 Dezimal:
  Wert=4
  Erg.=2
 Binär:
  Wert=0000000000000000000000000000000000000000000000000000000000000100
  Erg.=0000000000000000000000000000000000000000000000000000000000000010
 ANMERKUNG: Kopie des Vorzeichenbits wird links hereingeschoben

Ausdruck: 1 = 4 >> 2
 Dezimal:
  Wert=4
  Erg.=1
 Binär:
  Wert=0000000000000000000000000000000000000000000000000000000000000100
  Erg.=0000000000000000000000000000000000000000000000000000000000000001

Ausdruck: 0 = 4 >> 3
 Dezimal:
  Wert=4
  Erg.=0
 Binär:
  Wert=0000000000000000000000000000000000000000000000000000000000000100
  Erg.=0000000000000000000000000000000000000000000000000000000000000000
 ANMERKUNG: Bits werden rechts herausgeschoben

Ausdruck: 0 = 4 >> 4
 Dezimal:
  Wert=4
  Erg.=0
 Binär:
  Wert=0000000000000000000000000000000000000000000000000000000000000100
  Erg.=0000000000000000000000000000000000000000000000000000000000000000
 ANMERKUNG: dasselbe Ergebnis wie oben; man kann nicht über 0 hinaus verschieben


--- RECHTSVERSCHIEBUNG MIT NEGATIVEN GANZZAHLEN ---
Ausdruck: -2 = -4 >> 1
 Dezimal:
  Wert=-4
  Erg.=-2
 Binär:
  Wert=1111111111111111111111111111111111111111111111111111111111111100
  Erg.=1111111111111111111111111111111111111111111111111111111111111110
 ANMERKUNG: Kopie des Vorzeichenbits wird links hereingeschoben

Ausdruck: -1 = -4 >> 2
 Dezimal:
  Wert=-4
  Erg.=-1
 Binär:
  Wert=1111111111111111111111111111111111111111111111111111111111111100
  Erg.=1111111111111111111111111111111111111111111111111111111111111111
 ANMERKUNG: Bits werden rechts herausgeschoben

Ausdruck: -1 = -4 >> 3
 Dezimal:
  Wert=-4
  Erg.=-1
 Binär:
  Wert=1111111111111111111111111111111111111111111111111111111111111100
  Erg.=1111111111111111111111111111111111111111111111111111111111111111
 ANMERKUNG: dasselbe Ergebnis wie oben; man kann nicht über -1 hinaus verschieben


--- LINKSSVERSCHIEBUNG MIT POSITIVEN GANZZAHLEN ---
Ausdruck: 8 = 4 << 1
 Dezimal:
  Wert=4
  Erg.=8
 Binär:
  Wert=0000000000000000000000000000000000000000000000000000000000000100
  Erg.=0000000000000000000000000000000000000000000000000000000000001000
 ANMERKUNG: Nullen werden rechts hereingeschoben

Ausdruck: 4611686018427387904 = 4 << 60
 Dezimal:
  Wert=4
  Erg.=4611686018427387904
 Binär:
  Wert=0000000000000000000000000000000000000000000000000000000000000100
  Erg.=0100000000000000000000000000000000000000000000000000000000000000

Ausdruck: -9223372036854775808 = 4 << 61
 Dezimal:
  Wert=4
  Erg.=-9223372036854775808
 Binär:
  Wert=0000000000000000000000000000000000000000000000000000000000000100
  Erg.=1000000000000000000000000000000000000000000000000000000000000000
 NANMERKUNGTE: Vorzeichenbits werden herausgeschoben

Ausdruck: 0 = 4 << 62
 Dezimal:
  Wert=4
  Erg.=0
 Binär:
  Wert=0000000000000000000000000000000000000000000000000000000000000100
  Erg.=0000000000000000000000000000000000000000000000000000000000000000
 ANMERKUNG: Bits werden links herausgeschoben


--- LINKSVERSCHIEBUNG MIT NEGATIVEN GANZZAHLEN ---
Ausdruck: -8 = -4 << 1
 Dezimal:
  Wert=-4
  Erg.=-8
 Binär:
  Wert=1111111111111111111111111111111111111111111111111111111111111100
  Erg.=1111111111111111111111111111111111111111111111111111111111111000
 ANMERKUNG: Nullen werden rechts hereingeschoben

Ausdruck: -9223372036854775808 = -4 << 61
 Dezimal:
  Wert=-4
  Erg.=-9223372036854775808
 Binär:
  Wert=1111111111111111111111111111111111111111111111111111111111111100
  Erg.=1000000000000000000000000000000000000000000000000000000000000000

Ausdruck: 0 = -4 << 62
 Dezimal:
  Wert=-4
  Erg.=0
 Binär:
  Wert=1111111111111111111111111111111111111111111111111111111111111100
  Erg.=0000000000000000000000000000000000000000000000000000000000000000
 ANMERKUNG: Bits werden links herausgeschoben, einschließlich des Vorzeichenbits
]]>
     </screen>
    </example>
   </para>
   <warning>
    <para>
     Vor PHP 7.0.0 war das Verhalten von Bitverschiebungen um Werte größer oder gleich
     der Breite eines long integer oder um negative Zahlen nicht definiert. Anders
     ausgedrückt: wenn PHP 5.x verwendet wird, dürfen nicht mehr als um 31 Bits auf
     einem 32-bit System, und nicht mehr als um 63 Bits auf einem 64-bit System
     verschoben werden.
    </para>
    <para>
     Für die bitweise Manipulation von Zahlen größer als <literal>PHP_INT_MAX</literal>,
     sind die Funktion der <link linkend="book.gmp">GMP</link> Extension zu verwenden.
    </para>
   </warning>
   <para>
    Siehe auch
    <function>pack</function>,
    <function>unpack</function>,
    <function>gmp_and</function>,
    <function>gmp_or</function>,
    <function>gmp_xor</function>,
    <function>gmp_testbit</function>,
    <function>gmp_clrbit</function>
   </para>
  </sect1>

  <sect1 xml:id="language.operators.comparison">
   <title>Vergleichs-Operatoren</title>
   <simpara>
    Vergleichs-Operatoren erlauben es – wie der Name schon sagt –
    zwei Werte zu vergleichen. Wenn Sie an Beispielen verschiedener
    auf Typen bezogener Vergleiche interessiert sind, können Sie sich
    die <link linkend="types.comparisons">PHP Typvergleich-Tabellen</link>
    anschauen.
   </simpara>
   <table>
    <title>Vergleichsoperatoren</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Beispiel</entry>
       <entry>Name</entry>
       <entry>Ergebnis</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>Gleich</entry>
       <entry>
        Gibt &true; zurück, wenn nach der Typ-Jonglage <varname>$a</varname>
        gleich <varname>$b</varname> ist.
       </entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identisch</entry>
       <entry>
        Gibt &true; zurück, wenn <varname>$a</varname> gleich <varname>$b</varname>
        ist, und beide denselben Typ haben.
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Ungleich</entry>
       <entry>
        Gibt &true; zurück, wenn nach der Typ-Jonglage <varname>$a</varname>
        nicht gleich <varname>$b</varname> ist.
       </entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Ungleich</entry>
       <entry>
        Gibt &true; zurück, wenn nach der Typ-Jonglage <varname>$a</varname>
        nicht gleich <varname>$b</varname> ist.
       </entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Nicht identisch</entry>
       <entry>
        Gibt &true; zurück, wenn <varname>$a</varname> nicht gleich <varname>$b</varname>
        ist, oder wenn beide nicht denselben Typ haben.
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>Kleiner als</entry>
       <entry>
        Gibt &true; zurück, wenn <varname>$a</varname> kleiner als
        <varname>$b</varname> ist.
       </entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>Größer als</entry>
       <entry>
        Gibt &true; zurück, wenn <varname>$a</varname> größer als
        <varname>$b</varname> ist.
       </entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>Kleiner gleich </entry>
       <entry>
        Gibt &true; zurück, wenn <varname>$a</varname> kleiner oder gleich
        <varname>$b</varname> ist.
       </entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>Größer Gleich</entry>
       <entry>
        Gibt &true; zurück, wenn <varname>$a</varname> größer oder gleich
        <varname>$b</varname> ist.
       </entry>
      </row>
      <row>
       <entry>$a &lt;=&gt; $b</entry>
       <entry>Raumschiff</entry>
       <entry>
        Eine Ganzzahl (<type>integer</type>) kleiner als, gleich oder größer als 0,
        wenn <varname>$a</varname> entsprechend kleiner als, gleich oder größer als
        <varname>$b</varname> ist. Verfügbar von PHP 7 an.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Wenn eine Zahl mit einer Zeichenkette verglichen wird, oder der Vergleich numerische
    Zeichenketten einschließt, dann wird jede Zeichenkette
    <link linkend="language.types.string.conversion">in eine Zahl umgewandelt</link>,
    und der Vergleich wird numerisch durchgeführt. Diese Regeln gelten ebenfalls für
    die <link linkend="control-structures.switch">switch</link> Anweisung. Die
    Typumwandlung wird nicht durchgeführt, wenn der Vergleichsoperator === oder !==
    ist, da diese den Typ als auch den Wert vergleichen.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true
var_dump("10" == "1e1"); // 10 == 10 -> true
var_dump(100 == "1e2"); // 100 == 100 -> true

switch ("a") {
case 0:
    echo "0";
    break;
case "a": // wird niemals erreicht, weil "a" bereits mit 0 übereinstimmte
    echo "a";
    break;
}
?>
]]>
     </programlisting>
     <programlisting role="php">
<![CDATA[
<?php  
// Ganzzahlen
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1
 
// Fließkommazahlen
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1
 
// Zeichenketten
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1
 
echo "a" <=> "aa"; // -1
echo "zz" <=> "aa"; // 1
 
// Arrays
echo [] <=> []; // 0
echo [1, 2, 3] <=> [1, 2, 3]; // 0
echo [1, 2, 3] <=> []; // 1
echo [1, 2, 3] <=> [1, 2, 1]; // 1
echo [1, 2, 3] <=> [1, 2, 4]; // -1
 
// Objekte
$a = (object) ["a" => "b"]; 
$b = (object) ["a" => "b"]; 
echo $a <=> $b; // 0
 
$a = (object) ["a" => "b"]; 
$b = (object) ["a" => "c"]; 
echo $a <=> $b; // -1
 
$a = (object) ["a" => "c"]; 
$b = (object) ["a" => "b"]; 
echo $a <=> $b; // 1
 
// nicht nur die Werte werden verglichen; die Schlüssel müssen übereinstimmen
$a = (object) ["a" => "b"]; 
$b = (object) ["b" => "b"]; 
echo $a <=> $b; // 1

?>
]]>
      
     </programlisting>
    </informalexample>
   </para>

   <para>
    Für die verschiedenen Typen wird der Vergleich gemäß der folgenden Tabelle
    durchgeführt (in der angegebenen Reihenfolge).
   </para>
   <table xml:id="language.operators.comparison.types">
    <title>Vergleich mit verschiedenen Typen</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Typ des 1. Operanden</entry>
       <entry>Typ des 2. Operanden</entry>
       <entry>Ergebnis</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>null</type> oder <type>string</type></entry>
       <entry><type>string</type></entry>
       <entry>Umwandlung von &null; nach "", dann numerischer oder lexikalischer Vergleich</entry>
      </row>
      <row>
       <entry><type>bool</type> oder <type>null</type></entry>
       <entry>anything</entry>
       <entry>Umwandlung beider Werte nach <type>bool</type>, dann &false; &lt; &true;</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry><type>object</type></entry>
       <entry>
        Eingebaute Klassen können eigene Vergleichsregeln definieren; unterschiedliche
        Klassen können nicht verglichen werden; für dieselben Klassen siehe <link
        linkend="language.oop5.object-comparison">Objektvergleiche</link>
       </entry>
      </row>
      <row>
       <entry><type>string</type>, <type>resource</type> oder <type>number</type></entry>
       <entry><type>string</type>, <type>resource</type> oder <type>number</type></entry>
       <entry>
        Umwandlung von Zeichenketten und Ressourcen in Zahlen, dann
        numerischer Vergleich
       </entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry><type>array</type></entry>
       <entry>
        Ein Array mit weniger Elementen ist kleiner; wird ein Schlüssel vom ersten
        Operanden nicht im zweiten gefunden, dann sind die Arrays nicht vergleichbar;
        andernfalls wird Element für Element verglichen (siehe folgendes Beispiel)
       </entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry>anything</entry>
       <entry><type>object</type> ist immer größer</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry>anything</entry>
       <entry><type>array</type> ist immer größer</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    <example>
     <title>Boolesche und Null Vergleiche</title>
     <programlisting role="php">
<![CDATA[
<?php
// Boolesche Werte und NULL werden immer als Boolesche Werte verglichen
var_dump(1 == TRUE);  // TRUE - dasselbe wie (bool)1 == TRUE
var_dump(0 == FALSE); // TRUE - dasselbe wie (bool)0 == FALSE
var_dump(100 < TRUE); // FALSE - dasselbe wie (bool)100 < TRUE
var_dump(-10 < FALSE);// FALSE - dasselbe wie (bool)-10 < FALSE
var_dump(min(-100, -10, NULL, 10, 100)); // NULL - (bool)NULL < (bool)-100 ist FALSE < TRUE
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    <example>
     <title>Umschreibung von Standard-Array-Vergleichen</title>
     <programlisting role="php">
<![CDATA[
<?php
// Arrays werden mit den normalen Vergleichsoperatoren wie folgt verglichen
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return null; // nicht vergleichbar
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Siehe auch <function>strcasecmp</function>,
    <function>strcmp</function>,
    <link linkend="language.operators.array">Array-Operatoren</link>,
    und den Handbuchabschnitt über
    <link linkend="language.types">Typen</link>.
   </para>

   <warning>
    <title>Vergleich von Fließkommazahlen</title>

    <para>
     Aufgrund der Art wie Fließkommazahlen (<type>float</type>) intern dargestellt
     werden, sollten zwei Fließkommazahlen nicht auf Gleichheit getestet werden.
    </para>

    <para>
     Weitere Informationen sind der Dokumantation von <type>float</type> zu entnehmen.
    </para>
   </warning>


   <sect2 xml:id="language.operators.comparison.ternary">
    <title>Ternärer Operator</title>
    <para>
     Ein weiterer Vergleichs-Operator ist der "?:" (oder
     ternäre) Operator.
     <example>
      <title>Zuweisen eines Standardwerts</title>
      <programlisting role="php">
<![CDATA[
<?php
// Beispielanwendung für den ternären Operator
$action = (empty($_POST['action'])) ? 'standard' : $_POST['action'];

// Obiges ist mit dieser if/else-Anweisung identisch
if (empty($_POST['action'])) {
    $action = 'standard';
} else {
    $action = $_POST['action'];
}
?>
]]>
      </programlisting>
     </example>
     Der Ausdruck <literal>(ausdr1) ? (ausdr2) : (ausdr3)</literal>
     wird als <replaceable>ausdr2</replaceable> ausgewertet, wenn
     <replaceable>ausdr1</replaceable> als &true; ausgewertet wird, und als
     <replaceable>ausdr3</replaceable>, wenn
     <replaceable>ausdr1</replaceable> als &false; ausgewertet wird.
    </para>
    <para>
     Seit PHP 5.3 kann man beim ternären Operator den mittleren Teil
     weglassen. Der Ausdruck <literal>(ausdr1) ?: (ausdr3)</literal> 
     gibt <replaceable>ausdr1</replaceable> zurück, wenn 
     <replaceable>ausdr1</replaceable> als &true; ausgewertet wird, und
     andernfalls <replaceable>ausdr3</replaceable>.
    </para>
    <note>
     <simpara>
      Es ist zu beachten, das die ternäre Operation ein Ausdruck ist, und nicht als
      Variable, sondern als Wert eines Ausdrucks ausgewertet wird. Dies ist unbedingt
      zu berücksichtigen, wenn eine Variable per Referenz zurückgegeben werden soll.
      Die Anweisung <literal>return $var == 42 ? $a : $b;</literal> in einer Funktion,
      die per Referenz zurückgibt, wird daher nicht funktionieren, und eine Warnung
      erzeugen.
     </simpara>
    </note>
    <note>
     <para>
      Die Verschachtelung von ternären Ausdrücken wird nicht empfohlen. Das Verhalten
      von PHP, wenn mehrere ternäre Operatoren in einer einzelnen Anweisung verwendet
      werden, ist ungewöhnlich:
      <example>
       <title>Ungewöhnliches Verhalten des ternären Operators</title>
       <programlisting role="php">
<![CDATA[
<?php
// auf den ersten Blick scheint das folgende 'true' auszugeben
echo (true?'true':false?'t':'f');

// allerdings wird tatsächlich 't' ausgegeben
// das kommt daher, dass ternäre Ausdrücke von links nach rechts ausgewertet werden

// das Folgende ist eine augenfälligere Variante desselben Codes wie oben
echo ((true ? 'true' : false) ? 't' : 'f');

// hier kann man sehen, dass der erste Ausdruck zu 'true' ausgewertet wird,
// was wiederum zu (bool)true ausgewertet wird, und daher wird der Wahr-Zweig
// des zweiten ternären Ausdrucks zurückgegeben.
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>
   
   <sect2 xml:id="language.operators.comparison.coalesce">
    <title>Null-Coalescing-Operator</title>
    <para>
     Weiterhin gibt es den "??" (oder Null-Coalescing) Operator, verfügbar von PHP 7 an.
     <example>
      <title>Zuweisung eines Standardwerts</title>
      <programlisting role="php">
<![CDATA[
<?php
// Example usage for: Null Coalesce Operator
$action = $_POST['action'] ?? 'standard';

// Obiges ist mit dieser if/else-Anweisung identisch
if (isset($_POST['action'])) {
    $action = $_POST['action'];
} else {
    $action = 'standard';
}

?>
]]>
      </programlisting>
     </example>
     Der Ausdruck <literal>(ausdr1) ?? (ausdr2)</literal> wird zu
     <replaceable>ausdr2</replaceable> ausgewertet, wenn <replaceable>ausdr1</replaceable>
     &null; ist, und zu <replaceable>ausdr1</replaceable> andernfalls.
    </para>
    <para>
     Insbesondere gibt dieser Operator keinen Hinweis aus, wenn der Wert auf der linken
     Seite nicht existiert, genau wie <function>isset</function>. Dies ist besonders
     für Array-Schlüssel nützlich.
    </para>
    <note>
     <simpara>
      Es ist zu beachten, das die Null-Coalescing-Operation ein Ausdruck ist, und nicht als
      Variable, sondern als Wert eines Ausdrucks ausgewertet wird. Dies ist unbedingt
      zu berücksichtigen, wenn eine Variable per Referenz zurückgegeben werden soll.
      Die Anweisung <literal>return $foo ?? $bar;</literal> in einer Funktion,
      die per Referenz zurückgibt, wird daher nicht funktionieren, und eine Warnung
      erzeugen.
     </simpara>
    </note>
    <note>
     <para>
      Es ist zu beachten, dass der Null-Coalescing-Operator einfach verschachtelt
      werden kann:
      <example>
       <title>Verschachtelung des Null-Coalescing-Operator</title>
       <programlisting role="php">
<![CDATA[
<?php

$foo = null;
$bar = null;
$baz = 1;
$qux = 2;

echo $foo ?? $bar ?? $baz ?? $qux; // gibt 1 aus

?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2> 
  </sect1>

  <sect1 xml:id="language.operators.errorcontrol">
   <title>Fehler-Kontroll-Operatoren</title>
   
   <simpara>
    PHP unterstützt einen Operator zur Fehlerkontrolle: Das @-Symbol.
    Stellt man das @ in PHP vor einen Ausdruck werden alle
    Fehlermeldungen, die von diesem Ausdruck erzeugt werden könnten,
    ignoriert.
   </simpara>
   <simpara>
    Wurde ein benutzerdefinierte Fehlerbehandlungsfunktion mit
    <function>set_error_handler</function> registriert, dann wird diese immer noch
    aufgerufen, aber diese benutzerdefinierte Fehlerbehandlung kann (und sollte)
    <function>error_reporting</function> aufrufen, das 0 zurückgeben wird, wenn dem
    Aufruf, der den Fehler auslöste, ein @ vorangestellt war.
   </simpara>
   <simpara>
    Ist das <link
    linkend="ini.track-errors"><option>track_errors</option></link>-Feature
    aktiviert, werden alle Fehlermeldungen, die von diesem Ausdruck erzeugt
    werden, in der Variablen <link
    linkend="reserved.variables.phperrormsg">$php_errormsg</link>
    gespeichert. Da diese Variable mit jedem neuen Auftreten eines
    Fehlers überschrieben wird, sollte man sie möglichst bald nach
    Verwendung des Ausdrucks überprüfen, wenn man mit ihr arbeiten
    will.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Beabsichtigter Dateifehler */
$my_file = @file ('nicht_vorhandene_Datei') or
    die ("Datei konnte nicht geöffnet werden: Fehler war:'$php_errormsg'");

// Das funktioniert bei jedem Ausdruck, nicht nur bei Funktionen:
$value = @$cache[$key]; 
// erzeugt keine Notice, falls der Index $key nicht vorhanden ist.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     Der @-Operator funktioniert nur bei <link
     linkend="language.expressions">Ausdrücken</link>. Eine einfache
     Daumenregel: wenn Sie den Wert von etwas bestimmen können, dann
     können Sie den @-Operator davor schreiben. Zum Beispiel können
     Sie ihn vor Variablen, Funktionsaufrufe und vor
     <function>include</function> setzen, vor Konstanten und so
     weiter. Nicht verwenden können Sie diesen Operator vor Funktions-
     oder Klassendefinitionen oder vor Kontrollstrukturen wie zum
     Beispiel <literal>if</literal> und &foreach; und
     so weiter.
    </simpara>
   </note>
   <simpara>
    Siehe auch <function>error_reporting</function> und den Abschnitt
    über <link linkend="ref.errorfunc">Fehlerbehandlung- und Protokollierfunktionen</link>.
   </simpara>
   <warning>
    <para>
     Zum gegenwärtigen Zeitpunkt deaktiviert der "@"
     Fehler-Kontrolloperator die Fehlermeldungen selbst bei kritischen
     Fehlern, die die Ausführung eines Skripts beenden. Unter anderem
     bedeutet das, wenn Sie "@" einer bestimmten Funktion
     voranstellen, diese aber nicht zur Verfügung steht oder falsch
     geschrieben wurde, Ihr PHP-Skript einfach beendet wird, ohne
     Hinweis auf die Ursache.
    </para>
   </warning>
  </sect1>

  <sect1 xml:id="language.operators.execution">
   <title>Operatoren zur Programmausführung</title>
   <para>
    PHP unterstützt einen Operator zur Ausführung externer Programme:
    Die sog. Backticks (``). Achtung: Die Backticks sind keine
    einfachen Anführungszeichen! PHP versucht, den Text zwischen den
    Backticks als Kommandozeilen-Befehl auszuführen. Die Ausgabe des
    aufgerufenen Programms wird zurückgegeben (d.h. wird nicht einfach
    ausgegeben, sondern kann einer Variablen zugewiesen werden). Die
    Verwendung des Backtick-Operators ist mit
    <function>shell_exec</function> identisch.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     Der Backtick-Operator steht nicht zur Verfügung, wenn &safemode;
     aktiviert ist oder die Funktion <function>shell_exec</function>
     deaktiviert wurde.
    </para>
   </note>
   <note>
    <para>
     Anders als bei einigen anderen Sprachen haben Backticks keine besondere
     Bedeutung, wenn sie in Zeichenketten, die in doppelten Anführungszeichen
     eingeschlossen sind, verwendet werden.
    </para>
   </note>
   <para>
    Siehe auch den Abschnitt über <link linkend="ref.exec">Funktionen
    zur Programmausführung</link>, <function>popen</function>,
    <function>proc_open</function> und <link
    linkend="features.commandline">PHP auf der Kommandozeile verwenden</link>.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.increment">
   <title>Inkrement- bzw. Dekrementoperatoren</title>
   <para>
    PHP unterstützt Prä- und Post-Inkrement- und Dekrementoperatoren
    im Stil der Programmiersprache C.
   </para>
   <note>
    <simpara>
     Die Inkrement-/Dekrement-Operatoren wirken nur auf Zahlen und Zeichenketten.
     Bei Arrays, Objekten und Ressourcen wirken sie nicht. Das Dekrementieren von
     &null; Werten hat ebenfalls keine Wirkung, aber sie zu Inkrementieren ergibt
     <literal>1</literal>.
    </simpara>
   </note>
   <table>
    <title>Inkrement- und Dekrementoperatoren</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Beispiel</entry>
       <entry>Name</entry>
       <entry>Auswirkung</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>Prä-Inkrement</entry>
       <entry>
        Erhöht <varname>$a</varname> um eins, und gibt dann <varname>$a</varname> zurück.
       </entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>Post-Inkrement</entry>
       <entry>
        Gibt <varname>$a</varname> zurück, und erhöht dann <varname>$a</varname> um eins.
       </entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>Prä-Dekrement</entry>
       <entry>
        Vermindert <varname>$a</varname> um eins, und gibt dann <varname>$a</varname> zurück.
       </entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>Post-Dekrement</entry>
       <entry>
        Gibt <varname>$a</varname> zurück, und erniedrigt dann <varname>$a</varname> um eins.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Ein einfaches Beispiel-Skript:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Post-Inkrement</h3>";
$a = 5;
echo "Sollte 5 sein: " . $a++ . "<br />\n";
echo "Sollte 6 sein: " . $a . "<br />\n";

echo "<h3>Pre-Inkrement</h3>";
$a = 5;
echo "Sollte 6 sein: " . ++$a . "<br />\n";
echo "Sollte 6 sein: " . $a . "<br />\n";

echo "<h3>Post-Dekrement</h3>";
$a = 5;
echo "Sollte 5 sein: " . $a-- . "<br />\n";
echo "Sollte 4 sein: " . $a . "<br />\n";

echo "<h3>Pre-Dekrement</h3>";
$a = 5;
echo "Sollte 4 sein: " . --$a . "<br />\n";
echo "Sollte 4 sein: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    PHP folgt bei der Behandlung arithmetischer Operationen auf Zeichenvariablen der
    Perl-Konvention und nicht der von C. Zum Beispiel ändert in PHP und Perl
    <literal>$a = 'Z'; $a++;</literal> <literal>$a</literal> zu <literal>'AA'</literal>,
    während <literal>a = 'Z'; a++;</literal> in C <literal>a</literal> zu 
    <literal>'['</literal> ändert. (Der ASCII-Wert von <literal>'Z'</literal> ist 90,
    der ASCII-Wert von <literal>'['</literal> ist 91).
    Es ist zu beachten, dass Zeichenvariablen inkrementiert, aber nicht dekrementiert
    werden können, und dass nur einfache ASCII-Buchstaben und Ziffern (a-z, A-Z, 0-9)
    unterstützt werden. Das Inkrementieren oder Dekrementieren anderer Zeichenvariablen
    hat keine Auswirkung; die ursprüngliche Zeichenkette wird nicht verändert.
    <example>
     <title>Arithmetrische Operationen an Zeichenvariablen</title>
     <programlisting role="php">
<![CDATA[
<?php
echo '== Buchstaben ==' . PHP_EOL;
$s = 'W';
for ($n=0; $n<6; $n++) {
    echo ++$s . PHP_EOL;
}
// Ziffernzeichen verhalten sich anders
echo '== Ziffern ==' . PHP_EOL;
$d = 'A8';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
$d = 'A08';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
== Buchstaben ==
X
Y
Z
AA
AB
AC
== Ziffern ==
A9
B0
B1
B2
B3
B4
A09
A10
A11
A12
A13
A14
]]>
     </screen>
    </example>
   </para>
   <para>
    Das Inkrementieren oder Dekrementieren Boolescher Variablen hat keine Auswirkung.
   </para>
  </sect1>


  <sect1 xml:id="language.operators.logical">
   <title>Logische Operatoren</title>

   <table>
    <title>Logische Operatoren</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Beispiel</entry>
       <entry>Name</entry>
       <entry>Ergebnis</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>Und</entry>
       <entry>&true; wenn sowohl <varname>$a</varname> als auch <varname>$b</varname> &true; ist.</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>Oder</entry>
       <entry>&true; wenn <varname>$a</varname> oder <varname>$b</varname> &true; ist.</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>Entweder Oder</entry>
       <entry>
        &true; wenn entweder <varname>$a</varname> oder <varname>$b</varname> &true; ist, aber nicht beide.
       </entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>Nicht</entry>
       <entry>&true; wenn <varname>$a</varname> nicht &true; ist.</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>Und</entry>
       <entry>&true; wenn sowohl <varname>$a</varname> als auch <varname>$b</varname> &true; ist.</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>Oder</entry>
       <entry>&true; wenn <varname>$a</varname> oder <varname>$b</varname> &true; ist.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    Der Grund dafür, dass es je zwei unterschiedliche Operatoren für 
    die "Und"- und die "Oder"-Verknüpfung gibt ist der, dass die beiden
    Operatoren unterschiedliche Rangfolge haben. (siehe auch <link
    linkend="language.operators.precedence">Operator-Rangfolge</link>.)
   </simpara>

   <example>
    <title>Logische Operatoren erklärt</title>
    <programlisting role="php">
<![CDATA[
<?php

// --------------------
// foo() wird nie aufgerufen werden, da die Operatoren Kurzschlussauswertung verwenden

$a = (false && foo());
$b = (true  || foo());
$c = (false and foo());
$d = (true  or  foo());

// --------------------
// "||" hat eine höhere Rangfolge als "or"

// Das Ergebnis des Ausdrucks (false || true) wird $e zugewiesen
// Funktioniert wie: ($e = (false || true))
$e = false || true;

// Die Konstante "false" wird $f zugewiesen bevor die "or" Operation durchgeführt wird
// Funktioniert wie: (($e = false) or true)
$f = false or true;

var_dump($e, $f);

// --------------------
// "&&" hat eine höhere Rangfolge als "and"

// Das Ergebnis des Ausdrucks (true && false) wird $g zugewiesen
// Funktioniert wie: ($g = (true && false))
$g = true && false;

// Die Konstante "true" wird $h zugewiesen bevor die "and" Operation durchgeführt wird
// Funktioniert wie: (($h = true) and false)
$h = true and false;

var_dump($g, $h);
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
bool(true)
bool(false)
bool(false)
bool(true)
]]>
    </screen>
   </example>

  </sect1>

  <sect1 xml:id="language.operators.string">
   <title>Zeichenketten-Operatoren</title>
   <simpara>
    Es gibt in PHP zwei Operatoren für Zeichenketten (<type>string</type>).
    Der erste ist der Verknüpfungsoperator ('.'),
    dessen Rückgabewert eine zusammengesetzte Zeichenkette aus dem
    rechten und dem linken Argument ist. Der zweite ist der
    verknüpfende Zuweisungsoperator ('<literal>.=</literal>'), der das Argument auf der
    rechten Seite an das Argument der linken Seite anhängt. Siehe
    <link
    linkend="language.operators.assignment">Zuweisungs-Operatoren</link>
    für weitere Informationen.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "Hallo ";
$b = $a . "Welt!"; // $b enthält jetzt den Text "Hallo Welt!"

$a = "Hallo ";
$a .= "Welt!";    // $a enthält jetzt den Text "Hallo Welt!"
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Siehe auch die Abschnitte über <link
    linkend="language.types.string">Zeichenketten</link> und
    <link linkend="ref.strings">String-Funktionen</link>.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.array">
   <title>Array-Operatoren</title>
   <table>
    <title>Array-Operatoren</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Beispiel</entry>
       <entry>Name</entry>
       <entry>Ergebnis</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>Vereinigung</entry>
       <entry>Vereinigung von <varname>$a</varname> und <varname>$b</varname>.</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>Gleichwertigkeit</entry>
       <entry>
        &true; wenn <varname>$a</varname> und <varname>$b</varname> dieselben
        Schlüssel-/Wert-Paare enthalten.
       </entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identität</entry>
       <entry>
        &true; wenn <varname>$a</varname> und <varname>$b</varname> dieselben
        Schlüssel-/Wert-Paare in der gleichen Reihenfolge und vom selben Typ enthalten.
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Ungleichheit</entry>
       <entry>&true; wenn <varname>$a</varname> nicht gleich<varname>$b</varname> ist.</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>Ungleichheit</entry>
       <entry>&true; wenn <varname>$a</varname> nicht gleich<varname>$b</varname> ist.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>nicht identisch</entry>
       <entry>&true; wenn <varname>$a</varname> nicht identisch zu <varname>$b</varname> ist.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Der <literal>+</literal> Operator hängt das rechsstehende Array an das
    linksstehende Array an; kommen Schlüssel in beiden Arrays vor, dann werden die
    Elemente des linksstehenden Arrays verwendet, und die entsprechenden Elemente
    des rechtstehenden Arrays werden ignoriert.
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "Apfel", "b" => "Banane");
$b = array("a" =>"Birne", "b" => "Erdbeere", "c" => "Kirsche");

$c = $a + $b; // Vereinigung von $a mit $b;
echo "Vereinigung von \$a mit \$b: \n";
var_dump($c);

$c = $b + $a; // Vereinigung von $b mit $a;
echo "Vereinigung von \$b mit \$a: \n";
var_dump($c);

$a += $b; // Vereinigung von $a += $b ist $a + $b
echo "Vereinigung von \$a += \$b: \n";
var_dump($a);
?>
]]>
     </programlisting>
    </informalexample>
    Dieses Skript gibt folgendes aus:
    <screen role="php">
<![CDATA[
Vereinigung von $a mit $b:
array(3) {
  ["a"]=>
  string(5) "Apfel"
  ["b"]=>
  string(6) "Banane"
  ["c"]=>
  string(7) "Kirsche"
}
Vereinigung von $b mit $a:
array(3) {
  ["a"]=>
  string(4) "Birne"
  ["b"]=>
  string(8) "Erdbeere"
  ["c"]=>
  string(7) "Kirsche"
}
Vereinigung von $a += $b:
array(3) {
  'a' =>
  string(5) "Apfel"
  'b' =>
  string(6) "Banane"
  'c' =>
  string(6) "Kirsche"
}
]]>
    </screen>
   </para>
   <para>
    Beim Vergleich werden Arrayelemente als gleich angesehen, wenn diese
    dieselben Schlüssel und Werte beinhalten.
   </para>
   <para>
    <example>
     <title>Array-Vergleiche</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("Apfel", "Banane");
$b = array(1 => "Banane", "0" => "Apfel");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Siehe auch die Abschnitte über <link
    linkend="language.types.array">Arrays</link> und <link
    linkend="ref.array">Array-Funktionen</link>.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.type">
   <title>Typ-Operatoren</title>
   <para>
    <literal>instanceof</literal> wird dazu verwendet um festzustellen, ob ein
    gegebenes Objekt ein Objekt ist, das zu einer bestimmten
    <link linkend="language.oop5.basic.class">Klasse</link> gehört.
    <example>
     <title>Die Verwendung von <literal>instanceof</literal> mit Klassen</title>
    <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

class NotMyClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof NotMyClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    <literal>instanceof</literal> kann auch verwendet werden, um zu bestimmen, ob
    ein Variable ein Exemplar einer Klasse ist, die von einer Elternklasse erbt:
    <example>
     <title>Verwendung von <literal>instanceof</literal> mit ererbten Klassen</title>
     <programlisting role="php">
<![CDATA[
<?php
class ParentClass
{
}

class MyClass extends ParentClass
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof ParentClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Um zu prüfen, ob ein Objekt <emphasis>nicht</emphasis> ein Exemplar einer Klasse ist,
    kann der <link linkend="language.operators.logical">logische <literal>nicht</literal>
    Operator</link> verwendet werden.
    <example>
     <title>
      Verwendung von <literal>instanceof</literal>, um zu prüfen, ob ein Objekt 
      <emphasis>kein</emphasis> Exemplar einer Klasse ist</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

$a = new MyClass;
var_dump(!($a instanceof stdClass));
?>
]]>
     </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Schließlich kann <literal>instanceof</literal> auch dazu verwendet werden, um zu
    bestimmen, ob eine Variable ein Exemplar einer Klasse ist, die ein
    <link linkend="language.oop5.interfaces">Interface</link> implementiert:
    <example>
     <title>Verwendung von <literal>instanceof</literal> mit Interfaces</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof MyInterface);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Obwohl <literal>instanceof</literal> üblicherweise mit einem Klassennamensbezeichner
    verwendet wird, kann es ebenfalls mit einem anderen Objekt oder einer 
    Zeichenkettenvariablen verwendet werden:
    <example>
     <title>Verwendung von <literal>instanceof</literal> mit anderen Variablen</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;
$b = new MyClass;
$c = 'MyClass';
$d = 'NotMyClass';

var_dump($a instanceof $b); // $b ist ein Exemplar der Klasse MyClass
var_dump($a instanceof $c); // $c ist die Zeichenkette 'MyClass'
var_dump($a instanceof $d); // $d ist die Zeichenkette 'NotMyClass'
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    instanceof löst keinen Fehler aus, wenn die getestete Variable kein Objekt ist;
    es gibt dann einfach &false; zurück. Konstanten sind allerdings nicht erlaubt.
    <example>
     <title>Verwendung von <literal>instanceof</literal> um andere Variablen zu prüfen</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = NULL;
$c = imagecreate(5, 5);
var_dump($a instanceof stdClass); // $a ist eine Ganzzahl
var_dump($b instanceof stdClass); // $b ist NULL
var_dump($c instanceof stdClass); // $c ist ein Ressource
var_dump(FALSE instanceof stdClass);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
bool(false)
bool(false)
PHP Fatal error:  instanceof expects an object instance, constant given
]]>
     </screen>
    </example>
   </para>
   <para>
    Es gibt ein paar Fallstricke zu beachten. Vor PHP-Version 5.1.0 rief
    <literal>instanceof</literal> <function>__autoload</function> auf, wenn der Klassenname
    nicht existierte. Zusätzliche wurde, wenn die Klasse nicht geladen werden konnte,
    ein fataler Fehler ausgelöst. Es ist möglich dies zu umgehen, indem eine dynamische
    Klassenreferenz oder eine Zeichenkettenvariable, die den Klassennamen enthält,
    verwendet wird:
    <example>
     <title>Vermeidung von Klassennamenssuchen und fataler Fehler mit <literal>instanceof</literal> in PHP 5.0</title>
     <programlisting role="php">
<![CDATA[
<?php
$d = 'NotMyClass';
var_dump($a instanceof $d); // kein fataler Fehler
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
]]>
     </screen>
    </example>
   </para>
   <simpara>
    Der <literal>instanceof</literal> Operator wurde in PHP 5 eingeführt. Davor wurde
    <function>is_a</function> verwendet, aber <function>is_a</function> wurde seither
    zugunsten von <literal>instanceof</literal> missbilligt. Es ist zu beachten, dass
    <function>is_a</function> von PHP 5.3.0 nicht länger missbilligt ist.
   </simpara>
   <para>
    Siehe auch <function>get_class</function> und <function>is_a</function>.
   </para>
  </sect1>

 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"~/.phpdoc/manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
