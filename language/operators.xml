<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.16 $ -->
<!-- EN-Revision: 1.37 Maintainer: betz Status: ready -->
<!-- CREDITS: tzwenny -->
  <chapter id="language.operators">
   <title>Operatoren</title>
   <simpara>
   </simpara>

   <sect1 id="language.operators.precedence">
    <title>Operator-Rangfolge</title>
    <para>
     Die Operator-Rangfolge legt fest, wie "eng" ein Operator zwei
     Ausdrücke miteinander verbindet. Zum Beispiel ist das Ergebnis des
     Ausdruckes <literal>1 + 5 * 3</literal> <literal>16</literal>
     und nicht <literal>18</literal>, da der Mulitiplikations-Operator ("*")
     in der Rangfolge höher steht als der Additions-Operator ("+").
     Wenn nötig, können Sie Klammern setzen, um die Rangfolge der
     Operatoren zu beeinflussen. Zum Beispiel: <literal>(1 + 5) * 3</literal>
     ergibt <literal>18</literal>.
    </para>
    <para>
     Die folgende Tabelle zeigt die Rangfolge der Operatoren, oben steht
     der Operator mit dem niedrigsten Rang.

    <table>
     <title>Operator-Rangfolge</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Associativity</entry>
        <entry>Operator</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>links</entry>
        <entry>,</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>or</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>xor</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>and</entry>
       </row>
       <row>
        <entry>rechts</entry>
        <entry>print</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>= += -= *= /= .= %= &amp;= |= ^= ~= &lt;&lt;= &gt;&gt;=</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>? :</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>||</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>&amp;&amp;</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>|</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>^</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>&amp;</entry>
       </row>
       <row>
        <entry>keine Richtung</entry>
        <entry>== != ===</entry>
       </row>
       <row>
        <entry>keine Richtung</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>+ - .</entry>
       </row>
       <row>
        <entry>links</entry>
        <entry>* / %</entry>
       </row>
       <row>
        <entry>rechts</entry>
        <entry>! ~ ++ -- (int) (float) (string) (array) (object) @</entry>
       </row>
       <row>
        <entry>rechts</entry>
        <entry>[</entry>
       </row>
       <row>
        <entry>keine Richtung</entry>
        <entry>new</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
    </para>
   </sect1>

   <sect1 id="language.operators.arithmetic">
    <title>Arithmetische Operatoren</title>
    <simpara>
     Erinnern Sie sich noch an die Grundrechenarten aus der
     Schule? Die arithmetischen Operatoren funktionieren
     genauso:
    </simpara>

    <table>
     <title>Arithmetische Operatoren</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Beispiel</entry>
        <entry>Name</entry>
        <entry>Ergebnis</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a + $b</entry>
        <entry>Addition</entry>
        <entry>Summe von $a und $b.</entry>
       </row>
       <row>
        <entry>$a - $b</entry>
        <entry>Subtraktion</entry>
        <entry>Differenz von $a und $b.</entry>
       </row>
       <row>
        <entry>$a * $b</entry>
        <entry>Multiplikation</entry>
        <entry>Produkt von $a und $b.</entry>
       </row>
       <row>
        <entry>$a / $b</entry>
        <entry>Division</entry>
        <entry>Quotient von $a und  $b.</entry>
       </row>
       <row>
        <entry>$a % $b</entry>
        <entry>Modulus</entry>
        <entry>Rest von $a geteilt durch $b.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
    <simpara>
     Der Divisions-Operator ("/") gibt immer eine Fließkommazahl
     zurück, sogar wenn die zwei Operanden Ganzzahlen sind (oder
     Zeichenketten, die nach Ganzzahlen umgewandelt wurden).
    </simpara>
   </sect1>

   <sect1 id="language.operators.assignment">
    <title>Zuweisungsoperatoren</title>
    <simpara>
     Der einfachste Zuweisungsoperator ist "=". Wahrscheinlich kommt
     man als erstes auf die Idee, ihn mit "ist gleich" zu bezeichnen.
     Das ist falsch. In Wirklichkeit bedeutet er, dass dem linken Operanden
     der Wert des Ausdrucks auf der rechten Seite zugewiesen wird (man müsste
     ihn also mit "wird gesetzt auf den Wert von" übersetzen).
    </simpara>
    <para>
     Der Wert eines Zuweisungs-Ausdruckes ist der zugewiesene Wert.
     D.h. der Wert des Ausdruckes "$a = 3" ist 3. Das erlaubt es,
     einige raffinierte Dinge anzustellen:
     <informalexample>
      <programlisting role="php"> 
<![CDATA[
$a = ($b = 4) + 5 // $a ist nun gleich 9 und $b wurde auf den Wert 4 gesetzt.
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Zusätzlich zu dem oben vorgestellten Zuweisungsoperator "=" gibt
     es "kombinierte Operatoren" für alle binären, arithmetischen und
     String-Operatoren, die es erlauben, den Wert einer Variablen in einem Ausdruck
     zu benutzen, und dieser anschließend das Ergebnis des Ausdrucks
     als neuen Wert zuzuweisen. Zum Beispiel: 
     <informalexample>
      <programlisting role="php">
<![CDATA[
$a = 3;
$a += 5; // setzt $a auf den Wert 8, als ob wir geschrieben haetten: $a = $a + 5;
$b = "Hallo ";
$b .= "Du!"; // setzt $b auf den Wert "Hallo Du!", aequivalent zu $b = $b . "Du!";
]]>
      </programlisting>
     </informalexample>
    </para>

   <para>
    Man beachte, dass die Zuweisung nur den Wert der Ursprungsvarialbe der
    neuen Variable zuweist (Zuweisung als Wert, sie "kopiert"), weshalb sich
    Änderungen an der einen Variablen nicht auf die andere auswirken
    werden. Das kann wichtig sein,wenn man einen großen Array o. ä. in
    einer Schleife kopieren muss. PHP 4 unterstützt 'assignement by
    reference' (Zuweisung als Verweis), mit Hilfe der Schreibweise
    <computeroutput>$var = &amp;$othervar;</computeroutput>, das
    funktioniert jedoch nicht in PHP 3. 'Assignement by reference' bedeutet,
    dass beide Variablen nach der Zuweisung die selben Daten repräsentieren
    und nichts kopiert wird.
    Um mehr über Referenzen zu lernen, lesen Sie bitte den Abschnitt
    <link linkend="language.references">Referenzen erklärt</link>.
   </para>

  </sect1>

   <sect1 id="language.operators.bitwise">
    <title>Bit-Operatoren</title>
    <simpara>
     Bit-Operatoren erlauben es, in einem Integer bestimmte Bits "ein- oder 
     auszuschalten" (auf 0 oder 1 zu setzen). Wenn beide, der links- und
     rechsseitge Parameter, Zeichenketten sind, arbeiten die Bit-Operatoren
     mit den einzelnen Zeichen.
    </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
    echo 12 ^ 9; // Ausgabe '5'

    echo "12" ^ "9"; // Ausgabe:das Backspace-Zeichen (ascii 8)
                     // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

    echo "hallo" ^ "hello"; // Gibt die ASCII-Werte #0 #4 #0 #0 #0
                            // 'a' ^ 'e' = #4 aus
?>
]]>
     </programlisting>
    </informalexample> 
   </para>

   <table>
    <title>Bit-Operatoren</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Beispiel</entry>
       <entry>Name</entry>
       <entry>Ergebnis</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a &amp; $b</entry>
       <entry>Und</entry>
       <entry>Bits, die in $a und $b gesetzt sind werden gesetzt.</entry>
       </row>
       <row>
        <entry>$a | $b</entry>
        <entry>Oder</entry>
        <entry>Bits, die in $a oder $b gesetzt sind werden gesetzt.</entry>
       </row>
       <row>
        <entry>$a ^ $b</entry>
        <entry>Entweder oder (Xor)</entry>
        <entry>Bits, die entweder in $a oder $b gesetzt sind, werden gesetzt
         aber nicht in beiden.
        </entry>
       </row>
       <row>
        <entry>~ $a</entry>
        <entry>Nicht</entry>
        <entry>Die Bits, die in $a nicht gesetzt sind, werden gesetzt und
         umgekehrt.
        </entry>
       </row>
       <row>
        <entry>$a &lt;&lt; $b</entry>
        <entry>Nach links verschieben</entry>
        <entry>Verschiebung der Bits von $a um $b Stellen nach links (jede
         Stelle entspricht einer Mulitplikation mit zwei).
        </entry>
       </row>
       <row>
        <entry>$a &gt;&gt; $b</entry>
        <entry>Nach rechts verschieben</entry>
        <entry>Verschiebt die Bits von $a um $b Stellen nach rechts (jede Stelle
         entspricht einer Division durch zwei).
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
  </sect1>

   <sect1 id="language.operators.comparison">
    <title>Vergleichs-Operatoren</title>
    <simpara>
    Vergleichs-Operatoren erlauben es - wie der Name
    schon sagt - zwei Werte zu vergleichen.
    </simpara>

    <table>
     <title>Vergleichsoperatoren</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Beispiel</entry>
        <entry>Name</entry>
        <entry>Ergebnis</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a == $b</entry>
        <entry>Gleich</entry>
        <entry>Gibt &true; zurück, wenn $a gleich $b ist.</entry>
       </row>
       <row>
        <entry>$a === $b</entry>
        <entry>Identisch</entry>
        <entry>Gibt &true; zurück wenn $a gleich $b ist und beide
         vom gleichen Typ sind(nur PHP 4).
        </entry>
       </row>
       <row>
        <entry>$a != $b</entry>
        <entry>Ungleich</entry>
        <entry>Gibt &true; zurück, wenn $a nicht gleich $b ist.</entry>
       </row>
       <row>
        <entry>$a &lt;&gt; $b</entry>
        <entry>Ungleich</entry>
        <entry>Gibt &true; zurück, wenn $a nicht gleich $b ist.</entry>
       </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Nicht identisch</entry>
       <entry>
        Gibt &true; zurück, wenn $a nicht gleich $b ist, oder wenn beide
        nicht vom gleichen Typ sind (nur PHP 4).
       </entry>
      </row>
       <row>
        <entry>$a &lt; $b</entry>
        <entry>Kleiner Als</entry>
        <entry>Gibt &true; zurück, wenn $a kleiner als $b ist.</entry>
       </row>
       <row>
        <entry>$a &gt; $b</entry>
        <entry>Größer Als</entry>
        <entry>Gibt &true; zurück, wenn $a größer als $b ist.</entry>
       </row>
       <row>
        <entry>$a &lt;= $b</entry>
        <entry>Kleiner Gleich </entry>
        <entry>Gibt &true; zurück, wenn $a kleiner oder gleich $b ist.</entry>
       </row>
       <row>
        <entry>$a &gt;= $b</entry>
        <entry>Größer Gleich</entry>
        <entry>Gibt &true; zurück, wenn $a größer oder gleich $b ist.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>
     Ein weiter Vergleichs-Operator ist der "?:"- oder Trinitäts-Operator.
     Er arbeitet genauso wie in C und vielen anderen Programmier-Sprachen.
    <informalexample>
     <programlisting role="php">
<![CDATA[
(ausdr1) ? (ausdr2) : (ausdr3);
]]>
     </programlisting>
    </informalexample> 
     Dieser Ausdruck gibt
     <replaceable>ausdr2</replaceable> zurück, wenn
     <replaceable>ausdr1</replaceable> &true; zurückgibt und
     <replaceable>ausdr3</replaceable>, wenn
     <replaceable>ausdr1</replaceable> &false; zurückgibt.
    </para>
   </sect1>


  <sect1 id="language.operators.errorcontrol">
   <title>Fehler-Kontroll-Operatoren</title>
   
   <simpara>
    PHP unterstützt einen Operator zur Fehlerkontrolle: Das @-Symbol.
    Stellt man das @ in PHP vor einen Ausdruck werden alle Fehlermeldungen,
    die von diesem Ausdruck erzeugt werden könnten, ignoriert.
   </simpara>

   <simpara>
    Ist das <link linkend="ini.track-errors">track_errors</link>-Feature 
    aktiviert, werden alle Fehlermeldungen, die von diesem Ausdruck erzeugt 
    werden, in der globalen Variablen $php_errormsg gespeichert. Da diese 
    Variable mit jedem neuen Auftreten eines Fehlers überschrieben wird, sollte
    man sie möglichst bald nach Verwendung des Ausdrucks überprüfen, wenn man
    mit ihr arbeiten will.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Beabsichtigter Dateifehler */
$my_file = @file ('nicht_vorhandene_Datei') or
    die ("Datei konnte nicht geöffnetwerden: Fehler war:'$php_errormsg'");

// Das funktioniert bei jedem Ausdruck, nicht nur bei Funktionen:
$value = @$cache[$key]; 
// erzeugt keine Notice, falls der Index $key nicht vorhanden ist.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     Der @-Operator funktioniert nur bei Ausdrücken. Eine einfache
     Daumenregel: wenn Sie den Wert von etwas bestimmen können, dann
     können Sie den @-Operator davor schreiben. Zum Beispiel können Sie
     ihn vor Variablen, Funktionsaufrufe und vor
     <function>include</function> setzen, vor Konstanten und so weiter.
     Nicht verwenden können Sie diesen Operator vor Funktions- oder
     Klassendefinitionen oder vor Kontrollstrukturen wie zum Beispiel
     <literal>if</literal> und <literal>foreach</literal> und so weiter.
    </simpara>
   </note>
   <simpara>
    Siehe auch <function>error_reporting</function>.
   </simpara>
   <warning>
    <para>
     Zum gegenwärtigen Zeitpunkt deaktiviert der "@"
     Fehler-Kontrolloperator die Fehlermeldungen selbst bei kritischen
     Fehlern, die die Ausführung eines Skripts beenden. Unter anderem
     bedeutet das, wenn Sie "@" einer bestimmten Funktion voranstellen,
     diese aber nicht zur Verfügung steht oder falsch geschrieben wurde, Ihr
     PHP-Skript einfach beendet wird, ohne Hinweis auf die Ursache.
    </para>
   </warning>
  </sect1>

  <sect1 id="language.operators.execution">
   <title>Operatoren zur Programmausführung</title>
   <para>
    PHP unterstützt einen Operator zur Ausführung externer Programme:
    Die sog. Backticks (``). Achtung: Die Backticks sind keine einfachen
    Anführungszeichen! PHP versucht, den Text zwischen den Backticks als
    Kommandozeilen-Befehl auszuführen. Die Ausgabe des aufgerufenen Programms
    wird zurückgegeben (d.h. wird nicht einfach
    ausgegeben, sondern kann einer Variablen zugewiesen werden).

    <informalexample>
     <programlisting role="php">
<![CDATA[
$output = `ls -al`;
echo "<pre>$output</pre>";
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     Der Backtick-Operator steht nicht zur Verfügung, wenn der
     <link linkend="ini.safe-mode">Safe Mode</link> aktiviert
     ist oder die Funktion <function>shell_exec</function> deaktiviert wurde.
    </para>
   </note>
   <para>
    Siehe auch <function>escapeshellcmd</function>, <function>exec</function>,
    <function>passthru</function>, <function>popen</function>,
    <function>shell_exec</function> und <function>system</function>.
   </para>
  </sect1>

  <sect1 id="language.operators.increment">
   <title>Inkrementierungs- bzw. Dekrementierungsoperatoren</title>

   <para>
    PHP unterstützt Prä- und Post-Inkrementierungs- und Dekrementierungsoperatoren im
    Stil der Programmiersprache C.
   </para>

    <table>
     <title>Inkrement- und Dekrementoperatoren</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Beispiel</entry>
        <entry>Name</entry>
        <entry>Auswirkung</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>++$a</entry>
        <entry>Prä-Inkrement</entry>
        <entry>Erhöht den Wert von $a um eins (inkrementiert $a) und gibt
         anschließend den neuen Wert von $a zurück.
        </entry>
       </row>
       <row>
        <entry>$a++</entry>
        <entry>Post-Inkrement</entry>
        <entry>Gibt zuerst den aktuellen Wert von $a zurück und erhöht dann
         den Wert von $a um eins.
        </entry>
       </row>
       <row>
        <entry>--$a</entry>
        <entry>Prä-Dekrement</entry>
        <entry>Vermindert den Wert von $a um eins (dekrementiert $a) und gibt
         anschließend den neuen Wert von $a zurück.
        </entry>
       </row>
       <row>
        <entry>$a--</entry>
        <entry>Post-Dekrement</entry>
        <entry>Gibt zuerst den aktuellen Wert von $a zurück und erniedrigt
         dann den Wert von $a um eins.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Ein einfach Beispiel-Skript:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Post-Inkrement</h3>";
$a = 5;
echo "Sollte 5 sein: " . $a++ . "<br />\n";
echo "Sollte 6 sein: " . $a . "<br />\n";

echo "<h3>Pre-Inkrement</h3>";
$a = 5;
echo "Sollte 6 sein: " . ++$a . "<br />\n";
echo "Sollte 6 sein: " . $a . "<br />\n";

echo "<h3>Post-Dekrement</h3>";
$a = 5;
echo "Sollte 5 sein: " . $a-- . "<br />\n";
echo "Sollte 4 sein: " . $a . "<br />\n";

echo "<h3>Pre-Dekrement</h3>";
$a = 5;
echo "Sollte 4 sein: " . --$a . "<br />\n";
echo "Sollte 4 sein: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>


  <sect1 id="language.operators.logical">
    <title>Logische Operatoren</title>

    <table>
     <title>Logische Operatoren</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Beispiel</entry>
        <entry>Name</entry>
        <entry>Ergebnis</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a and $b</entry>
        <entry>Und</entry>
        <entry>&true; wenn sowohl $a als auch $b &true; ist.</entry>
       </row>
       <row>
        <entry>$a or $b</entry>
        <entry>Oder</entry>
        <entry>&true; wenn $a oder $b &true; ist.</entry>
       </row>
       <row>
        <entry>$a xor $b</entry>
        <entry>Entweder Oder</entry>
        <entry>&true; wenn entweder $a oder $b &true; ist, aber nicht beide.</entry>
       </row>
       <row>
        <entry>! $a</entry>
        <entry>Nicht</entry>
        <entry>&true; wenn $a nicht &true; ist.</entry>
       </row>
       <row>
        <entry>$a &amp;&amp; $b</entry>
        <entry>Und</entry>
        <entry>&true; wenn sowohl $a als auch $b &true; ist.</entry>
       </row>
       <row>
        <entry>$a || $b</entry>
        <entry>Oder</entry>
        <entry>&true; wenn $a oder $b &true; ist.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <simpara>
    Der Grund dafür, dass es je zwei unterschiedliche Operatoren für 
    die "Und"- und die "Oder"-Verknüpfung gibt ist der, dass die beiden
    Operatoren jeweils Rangfolgen haben. (siehe auch 
    <link linkend="language.operators.precedence">Operator-Rangfolge</link>.)
   </simpara>
  </sect1>

  <sect1 id="language.operators.string">
   <title>Zeichenketten-Operatoren</title>
   <simpara>
    Es gibt in PHP zwei Operatoren für Zeichenketten. Der erste ist der
    Vereinigungs-Operator ('.'), dessen Rückgabewert eine zusammengesetzte
    Zeichenkette aus dem rechten und dem linken Argument ist.
    Der zweite ist der Vereinigungs-Zuweisungsoperator ('.='), der das
    Argument auf der rechten Seite an das Argument der linken Seite anhängt.
    Siehe 
    <link linkend="language.operators.assignment">Zuweisungs-Operatoren</link>
    für weitere Informationen.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$a = "Hallo ";
$b = $a . "Welt!"; // $b enthält jetzt den Text "Hallo Welt!"

$a = "Hallo ";
$a .= "Welt!";    // $a enthält jetzt den Text "Hallo Welt!"
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>


  </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
