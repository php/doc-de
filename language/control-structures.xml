 <chapter id="control-structures">
  <title>Kontroll-Strukturen</title>
<!-- Anmerkung des Übersetzers:                      
     entspricht en/language/control-structures.xml 1.22 -->

  <simpara>
   Jedes PHP-Skript besteht aus einer Reihe von Anweisungen. Eine
   Anweisung kann aus einem Funktions-Aufruf, einer Schleife, einer
   bedingten Anweisung oder einem Befehl, der nichts macht (eine
   leere Anweisung), bestehen. Jeder Befehl endet gewöhnlich mit
   einem Semikolon. Darüber hinaus können Befehle zu einer
   Anweisungsgruppe zusammengefasst werden, welche durch geschweifte
   Klammern begrenzt wird. Eine Anweisungsgruppe ist auch eine
   Anweisung. Die unterschiedlichen Arten von Anweisungen werden in
   diesem Abschnitt erläutert.
  </simpara>

  <sect1 id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    Der <literal>if</literal>-Befehl ist eine der wichtigsten
    Möglichkeiten vieler Programmier-Sprachen, PHP eingeschlossen.
    Er erlaubt die bedingte Ausführung von Programmteilen. PHP
    beinhaltet eine <literal>if</literal>-Struktur, die ähnlich der
    C-Programmiersprache ist:
    <informalexample>
     <programlisting>
if (expr)
    Anweisung
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Wie im Abschnitt über Expressions / Ausdrücke beschrieben,
    wird expr auf seinen wirklichen Wertinhalt ausgewertet. Wenn
    <replaceable>expr</replaceable> &true;
    entspricht, wird PHP Anweisung ausführen, falls nicht - sie
    also &false; ist - wird Anweisung übergangen.
   </simpara>
   <para>
    Das folgende Beispiel wird <computeroutput>a ist grösser als b
    </computeroutput>anzeigen, wenn <replaceable>$a</replaceable> 
    grösser ist als <replaceable>$b</replaceable>:
    <informalexample>
     <programlisting role="php">
if ($a > $b)
    print "a ist grösser als b";
     </programlisting>
    </informalexample>
   </para>
   <para>
    Oft werden Sie die bedingte Ausführung von mehr als einer
    Anweisung wollen. Selbstverständlich ist es nicht erforderlich,
    jede Anweisung mit einer <literal>if</literal>-Bedingung zu
    versehen. Statt dessen können Sie mehrere Anweisungen in Gruppen
    zusammenfassen. Z.B. wird der folgende Programm-Code
    <computeroutput>a ist grösser als b</computeroutput> anzeigen,
    wenn <replaceable>$a</replaceable> grösser ist als
    <replaceable>$b</replaceable>. Danach wird der Wert von
    <replaceable>$a</replaceable> in <replaceable>$b</replaceable>
    gespeichert:
    <informalexample>
     <programlisting role="php">
if ($a > $b) {
    print "a ist grösser als b";
    $b = $a;
}
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    If-Anweisungen können ohne Einschränkung innerhalb anderer
    <literal>if</literal>-Anweisungen definiert werden. Das ermöglicht
    ihnen völlige Flexibilität bei der bedingten Ausführung verschiedenster
    Programmteile.
   </simpara>
  </sect1>
 
  <sect1 id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
    Häufig ist es erforderlich, eine Anweisung auszuführen, wenn eine
    bestimmte Bedingung erfüllt ist und eine andere Anweisung, falls
    sie nicht erfüllt ist. Dafür gibt es <literal>else</literal>.
    <literal>Else</literal> erweitert eine
    <literal>if</literal>-Anweisung um die Ausführung von Anweisungen,
    sobald der Ausdruck der <literal>if</literal>-Anweisung als
    &false; angesehen wird. Der folgende Code wird
    z.B. <computeroutput>a ist grösser als b</computeroutput> anzeigen,
    wenn <replaceable>$a</replaceable> grösser ist als
    <replaceable>$b</replaceable>, anderenfalls
    <computeroutput>a ist NICHT grösser als b</computeroutput>:
    <informalexample>
     <programlisting role="php">
if ($a > $b) {
    print "a ist grösser als b";
} else {
    print "a ist NICHT grösser als b";
}
     </programlisting>
    </informalexample>
    Die <literal>else</literal>-Anweisung wird nur ausgeführt, wenn
    der <literal>if</literal>-Ausdruck als &false;
    ausgewertet wurde und wenn bei vorhandenen
    <literal>elseif</literal>-Ausdrücken diese ebenfalls
    &false; sind (siehe <link
    linkend="control-structures.elseif">elseif</link>).
   </para>
  </sect1>
 
  <sect1 id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
    <literal>Elseif</literal> ist, wie der Name schon sagt, eine
    Verbindung von <literal>if</literal> und <literal>else</literal>.
    Wie <literal>else</literal> erweitert sie eine
    <literal>if</literal>-Anweisung um die Ausführung anderer
    Anweisungen, sobald die normale <literal>if</literal>-Bedingung
    als &false; angesehen wird. Anders als bei
    <literal>else</literal> wird die Ausführung dieser anderen
    Anweisungen nur durchgeführt, wenn die bei
    <literal>elseif</literal> angegebene alternative Bedingung als
    &true; angesehen wird. Der folgende Code wird
    z.B. <computeroutput>a ist grösser als b</computeroutput>,
    <computeroutput>a ist gleich b</computeroutput> oder
    <computeroutput>a ist kleiner als b</computeroutput> ausgeben:
    <informalexample>
     <programlisting role="php">
if ($a > $b) {
    print "a ist grösser als b";
} elseif ($a == $b) {
    print "a ist gleich b";
} else {
    print "a ist kleiner als b";
}
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Es kann mehrere <literal>elseif</literal>-Anweisungen innerhalb
    einer <literal>if</literal>-Anweisung geben. Die erste
    <literal>elseif</literal>-Bedingung (falls vorhanden), die
    &true; ist, wird ausgeführt. In PHP kann man
    auch 'else if' schreiben (zwei Wörter). Das Verhalten ist
    identisch zu 'elseif' (ein Wort), genau wie in C.
   </simpara>
   <simpara>
    Die <literal>elseif</literal>-Anweisung wird nur ausgeführt,
    wenn die vorausgehende <literal>if</literal>-Bedingung sowie 
    jede vorherige <literal>elseif</literal>-Bedingung
    &false; ist und die aktuelle
    <literal>elseif</literal>-Bedingung &true;
    ist.
   </simpara>
  </sect1>
 
  <sect1 id="control-structures.alternative-syntax">
   <title>Alternative Syntax für Kontroll-Strukturen</title>
   <para>
    PHP bietet eine alternative Syntax für einige seiner
    Kontroll-Strukturen, als da sind <literal>if</literal>, 
    <literal>while</literal>, <literal>for</literal>, 
    <literal>foreach</literal> und <literal>switch</literal>.
    Immer muss die öffnende Klammer durch einen Doppelpunkt
    &quot;:"quot; und die schließende Klammer durch ein
    <literal>endif;</literal>, <literal>endwhile;</literal>,
    <literal>endfor;</literal>, <literal>endforeach;</literal> 
    bzw. <literal>endswitch;</literal> ersetzt werden.
    <informalexample>
     <programlisting role="php">
&lt;?php if ($a == 5): ?&gt;
    A ist gleich 5
&lt;?php endif; ?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Im obigen Beispiel ist der HTML-Bereich eingebettet in eine
    <literal>if</literal>-Anweisung mit alternativer Syntax.
    Der HTML-Bereich wird nur ausgegeben, wenn $a gleich 5 ist.
   </simpara>
   <para>
    Die alternative Syntax kann auch auf <literal>else</literal>
    und <literal>elseif</literal> angewendet werden. Es folgt eine
    <literal>if</literal>-Struktur mit <literal>elseif</literal>
    und <literal>else</literal> im alternativen Format:
    <informalexample>
     <programlisting role="php">
if ($a == 5):
    print "a ist gleich 5";
    print "...";
elseif ($a == 6):
    print "a ist gleich 6";
    print "!!!";
else:
    print "a ist weder 5 noch 6";
endif;
     </programlisting>
    </informalexample>
   </para>
   <para>
    Siehe auch <link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link> und <link
    linkend="control-structures.if">if</link> für weitere Beispiele.
   </para>
  </sect1>

  <sect1 id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
    <literal>While</literal>-Schleifen sind die einfachste Form von
    Schleifen in PHP. Sie funktionieren genau wie in C. Die
    Grundform einer <literal>while</literal>-Anweisung lautet:
    <informalexample>
     <programlisting>
while (expr) Anweisung
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Die Bedeutung einer <literal>while</literal>-Anweisung ist einfach.
    Sie weist PHP an, einen in ihr eingebetteten Befehl so lange zu
    wiederholen, bis die <literal>while</literal>-Bedingung 
    &true; geworden ist. Der Wert der Bedingung wird
    immer am Anfang der Schleife geprüft. Wird der Wert während der 
    Ausführung der Befehle innerhalb der 
    <literal>while</literal>-Schleife geändert, endet die Ausführung
    dieses Befehls-Blocks nicht vor einem neuem Schleifen-Durchlauf
    (Iteration). Jeder Schleifendurchlauf ist eine Iteration. Falls
    die <literal>while</literal>-Bedingung bereits zu Beginn
    &false; ist, werden die Anweisungen der
    <literal>while</literal>-Schleife nicht ein einziges Mal durchlaufen.
   </simpara>
   <para>
    Wie bei der <literal>if</literal>-Anweisung kann man mehrere
    Befehle innerhalb einer Schleife angeben, indem man sie mit
    geschweiften Klammern umschliesst oder die alternative Syntax
    gebraucht:
    <informalexample>
     <programlisting>
while (expr): statement ... endwhile;
     </programlisting>
    </informalexample>
   </para>
   <para>
    Die folgenden Beispiele sind identisch; beide geben Zahlen von
    1 bis 10 aus:
    <informalexample>
     <programlisting>
/* Beispiel 1 */

$i = 1;
while ($i &lt;= 10) {
    print $i++;  /* es wird erst $i ausgegeben,
                    bevor der Wert erhöht wird
                    (post-increment) */
}
 
/* Beispiel 2 */
 
$i = 1;
while ($i &lt;= 10):
    print $i;
    $i++;
endwhile;
     </programlisting>
    </informalexample>
   </para>
  </sect1>
  <sect1 id="control-structures.do.while">
   <title><literal>do..while</literal></title>
   <simpara>
    <literal>Do..while</literal>-Schleifen sind den
    <literal>while</literal>-Schleifen sehr ähnlich, ausser dass die
    Erfüllung des Ausdrucks am Ende jedes Durchlaufs geprüft wird
    (statt am Anfang). Der Hauptunterschied zu gewöhnlichen
    <literal>while</literal>-Schleifen ist, dass der erste 
    Schleifen-Durchlauf bei <literal>do..while</literal> in jedem
    Fall statt findet, wogegen es bei <literal>while</literal>-Schleifen
    durchaus passieren kann, dass die Schleife nie durchlaufen wird,
    wenn die am Anfang zu prüfende Bedingung schon zu Beginn
    &false; ist.
   </simpara>
   <para>
    Es gibt nur eine Syntax für <literal>do..while</literal>-Schleifen:
    <informalexample>
     <programlisting role="php">
$i = 0;
do {
    print $i;
} while ($i>0);
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Die obige Schleife wird genau einmal durchlaufen, da nach der
    ersten Wiederholung die Erfüllung der Bedingung geprüft wird. Da
    diese aber nicht erfüllt, also &false; ist ($i
    ist nicht grösser als 0), wird die Schleifenausführung beendet.
   </simpara>
   <para>
    Erfahrene C-Anwender kennen auch die Möglichkeit, Programm-Blöcke
    mit <literal>do..while</literal>(0) einzuschliessen und dann die
    <link linkend="control-structures.break"><literal>break</literal></link>
    Anweisung zu benutzen. Der folgende Programm-Ausschnitt zeigt dies:
    <informalexample>
     <programlisting role="php">
do {
    if ($i &lt; 5) {
        print "i ist nicht gross genug";
        break;
    }
    $i *= $factor;
    if ($i &lt; $minimum_limit) {
        break;
    }
    print "i ist ok";

    ...process i...

} while(0);
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Es ist nicht weiter tragisch, wenn Sie dieses Beispiel nicht
    oder nur zum Teil verstehen. Sie können auch ohne dieses 
    Feature effektive PHP-Programme und Skripte schreiben.
   </simpara>
  </sect1>
 
  <sect1 id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
    <literal>For</literal>-Schleifen sind die komplexesten Schleifen
    in PHP. Sie funktionieren wie ihr Gegenstück in C. Die Syntax
    einer <literal>for</literal>-Schleife sieht so aus:
    <informalexample>
     <programlisting>
for (expr1; expr2; expr3) Anweisung
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Der erste Parameter (<replaceable>expr1</replaceable>) wird beim
    Schleifenbeginn geprüft bzw. ausgeführt (ohne jegliche Vorbedingung).
   </simpara>
   <simpara>
    Zu Beginn jedes Durchlaufs wird nun <replaceable>expr2</replaceable>
    geprüft. Wenn dieser &true; ist, fährt die Schleife
    weiter fort mit der Ausführung der nachfolgenden Befehle. Wenn das
    Ergebnis &false; lautet, wird die Schleife beendet.
   </simpara>
   <simpara>
    Am Ende jedes Durchlaufs wird nun auch noch 
    <replaceable>expr3</replaceable> geprüft / ausgeführt.
   </simpara>
   <simpara>
    Jeder der Parameter kann leer sein (optional).
    Ist <replaceable>expr2</replaceable> leer, wird die Schleife
    unbestimmt oft durchlaufen, da PHP ihn als &true;
    wertet (wie in C). Das ist nicht so sinnlos, wie Sie vielleicht glauben,
    weil man häufig eine Schleife erst durch eine bedingte
    <link linkend="control-structures.break"><literal>break</literal>
    </link>-Anweisung statt durch eine unwahr werdende
    <literal>for</literal>-Bedingung beenden möchte.
   </simpara>
   <para>
    Beachten Sie die folgenden Beispiele. Alle geben Zahlen von 1 bis
    10 aus:
    <informalexample>
     <programlisting role="php">
      /* Beispiel 1 */
 
for ($i = 1; $i &lt;= 10; $i++) {
    print $i;
}
 
      /* Beispiel 2 */
 
for ($i = 1;;$i++) {
    if ($i &gt; 10) {
        break;
    }
    print $i;
}
 
      /* Beispiel 3 */
 
$i = 1;
for (;;) {
    if ($i &gt; 10) {
        break;
    }
    print $i;
    $i++;
}
 
      /* Beispiel 4 */
 
for ($i = 1; $i &lt;= 10; print $i, $i++) ;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Selbstverständlich sieht das erste (oder das vierte) Beispiel am
    besten aus, aber Sie werden noch feststellen, dass es oftmals ganz
    nützlich sein kann, leere Parameter in 
    <literal>for</literal>-Schleifen zu verwenden.
   </simpara>
   <para>
    PHP unterstützt auch bei <literal>for</literal>-Schleifen die
    alternative "Doppelpunkt-Syntax".
    <informalexample>
     <programlisting>
for (expr1; expr2; expr3): Anweisung; ...; endfor;
     </programlisting>
     </informalexample>
   </para>
   <para>
    Andere Sprachen haben für das Durchlaufen eines Hash´s oder 
    Arrays eine <literal>foreach</literal>-Anweisung. PHP 3 hat dies
    nicht; im Gegensatz zu PHP 4 (vgl.
    <link linkend="control-structures.foreach">foreach</link>).
    In PHP 3 kann man dafür eine Kombination von
    <link linkend="control-structures.while">while</link> mit der
    <function>list</function>- und <function>each</function>-Funktion
    einsetzen. Beispiele finden Sie in der Dokumentation zu diesen
    Funktionen.
   </para>
  </sect1>

  <sect1 id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
    PHP 4 (nicht PHP 3) enthält eine <literal>foreach</literal>-Funktion,
    genau wie Perl und andere Sprachen. Diese ermöglicht es, auf
    einfache Weise ein Array zu durchlaufen. Es gibt zwei
    Syntax-Formen; die zweite ist eine unbedeutende aber sinnvolle
    Erweiterung der ersten Syntax:
    <informalexample>
     <programlisting>
foreach(array_expression as $value) Anweisung
foreach(array_expression as $key => $value) Anweisung
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Die erste Form durchläuft das
    <literal>array_expression</literal>-Array. Bei jedem Durchgang wird
    der Wert des aktuellen Elements <literal>$value</literal> zugewiesen
    und der interne Array-Zeiger um 1 erhöht. Dadurch wird beim nächsten
    Durchgang automatisch das nächste Element ausgewertet.
   </simpara>
   <simpara>
    Die zweite Form arbeitet genauso, ausser dass bei jedem Durchlauf
    auch der aktuelle Schlüssel der Variablen <literal>$key</literal>
    zugewiesen wird.
   </simpara>
   <para>
    <note>
     <para>
      Sobald <literal>foreach</literal> zum ersten Mal ausgeführt wird,
      wird der interne Array-Pointer automatisch auf das erste Element
      des Arrays zurück gesetzt. Das heisst, dass Sie nicht
      <function>reset</function> vor einem Durchlauf von
      <literal>foreach</literal> aufrufen müssen.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      Beachten Sie auch, dass <literal>foreach</literal> mit einer
      Kopie des angegebenen Arrays arbeitet. Deshalb wird auch der
      Array-Pointer nicht wie bei dem each-Konstrukt verändert.
     </para>
    </note>
   </para>
   <para>
    Beachten Sie, dass die folgenden Beispiele in ihrer Funktionalität
    identisch sind:
    <informalexample>
     <programlisting role="php">
      reset ($arr);
while (list(, $value) = each ($arr)) {
    echo "Wert: $value&lt;br&gt;\n";
}

foreach ($arr as $value) {
    echo "Wert: $value&lt;br&gt;\n";
}
     </programlisting>
    </informalexample>
    Auch hier funktioniert alles gleich:
    <informalexample>
     <programlisting role="php">
reset ($arr);
while (list($key, $value) = each ($arr)) {
    echo "Schlüssel: $key; Wert: $value&lt;br&gt;\n";
}

foreach ($arr as $key => $value) {
    echo "Schlüssel: $key; Wert: $value&lt;br&gt;\n";
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    Noch einige Beispiele, die die Anwendung verdeutlichen:
    <informalexample>
     <programlisting role="php">
/* foreach Beispiel 1: Nur der Wert */

$a = array (1, 2, 3, 17);

foreach ($a as $v) {
    print "Aktueller Wert von \$a: $v.\n";
}

/* foreach Beispiel 2: Wert (mit Ausgabe des Array-Schlüssels) */

$a = array (1, 2, 3, 17);

$i = 0; /* nur für Anschauungs-Zweck */

foreach($a as $v) {
    print "\$a[$i] => $k.\n";
}

/* foreach Beispiel 3: Schlüssel und Wert */

$a = array (
    "one" => 1,
    "two" => 2,
    "three" => 3,
    "seventeen" => 17
);

foreach($a as $k => $v) {
    print "\$a[$k] => $v.\n";
}
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
  <sect1 id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
    <literal>Break</literal> bricht die Ausführung der aktuellen
    <literal>for</literal>, <literal>while</literal> oder
    <literal>switch</literal>
    Anweisungs-Sequenz ab.
   </simpara>
   <simpara>
    Einem <literal>break</literal> kann optional ein numerisches
    Argument angehängt werden, das die Anzahl der abzubrechenden
    Befehls-Sequenzen enthält. 
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
$arr = array ('eins', 'zwei', 'drei', 'stop', 'vier');
while (list ( , $val) = each ($arr)) {
    if ($val == 'stop') {
        break;  /* Man kann hier auch 'break 1;' schreiben. */
    }
    echo "$val&lt;br&gt;\n";

/* Benutzung des optionalen Argumentes. */
$i = 0;
    while (++$i) {
        switch ($i) {
            case 5:
                echo "Bei 5&lt;br&gt;\n";
                break 1;  /* Beendet nur switch. */
            case 10:
                echo "Bei 10; quitting&lt;br&gt;\n";
                break 2;  /* Beendet switch und while. */
            default:
                break;
    }
}
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
  <sect1 id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
    <literal>Continue</literal> wird innerhalb von Schleifen
    gebraucht. Die Schleife wird an der aktuellen Stelle abgebrochen
    und es wird der nächste Durchlauf begonnen.
   </simpara>
   <simpara>
    <literal>Continue</literal> kann optional ein numerisches
    Argument erhalten, das die Anzahl der zu überspringenden
    Schleifendurchläufe beinhaltet.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
while (list ($key, $value) = each ($arr)) {
    if (!($key % 2)) { // überspringe ungerade Werte
        continue;
    }
    tue_was_mit_ungerade ($value);
}

$i = 0;
while ($i++ &lt; 5) {
    echo "Aussen&lt;br&gt;\n";
    while (1) {
        echo "&nbsp;&nbsp;Mitte&lt;br&gt;\n";
        while (1) {
            echo "&nbsp;&nbsp;Innen&lt;br&gt;\n";
            continue 3;
        }
        echo "Das wird nie ausgegeben.&lt;br&gt;\n";
    }
    echo "Dies auch nicht.&lt;br&gt;\n";
}
     </programlisting>
     </informalexample>
    </para>
  </sect1>
 
  <sect1 id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    Die <literal>switch</literal>-Anweisung ist gleichbedeutend einer
    Reihe von IF-Anweisungen mit dem gleichen Parameter. Häufig wollen
    Sie ein und die selbe Variable (bzw. den selben Ausdruck) mit 
    verschiedensten Werten vergleichen und in Abhängigkeit vom 
    Auswertungsergebnis verschiedene Programmteile ausführen. Genau
    das ermöglicht die <literal>switch</literal>-Anweisung.
   </simpara> 
   <para>
    Die folgenden 2 Beispiele zeigen 2 verschiedene Wege, das gleiche
    zu bewirken; eins gebraucht mehrere <literal>if</literal>-Befehle,
    das andere eine <literal>switch</literal>-Anweisung:
    <informalexample>
     <programlisting role="php">
if ($i == 0) {
    print "i ist gleich 0";
}
if ($i == 1) {
    print "i ist gleich 1";
}
if ($i == 2) {
    print "i ist gleich 2";
}
 
switch ($i) {
    case 0:
        print "i ist gleich 0";
        break;
    case 1:
        print "i ist gleich 1";
        break;
    case 2:
        print "i ist gleich 2";
        break;
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    Es ist wichtig, die Ausführung einer 
    <literal>switch</literal>-Anweisung zu verstehen, um Fehler zu
    vermeiden. Die <literal>switch</literal>-Anweisung wird Zeile für
    Zeile (also Anweisung für Anweisung) abgearbeitet. Zu Beginn wird
    nichts ausgeführt. Erst wenn bei einem <literal>case</literal>-Teil
    eine Entsprechung zum <literal>switch</literal>-Ausdruck vorliegt,
    werden die darin enthaltenen Befehle ausgeführt. PHP fährt dann
    mit der Abarbeitung des restlichen Codes innerhalb des
    <literal>switch</literal>-Blocks fort (oder bis zum ersten
    Auftreten einer <literal>break</literal>-Anweisung). Ohne
    <literal>break</literal> am Ende eines case-Teils werden also
    noch die folgenden case-Blöcke ausgeführt.
    Z.B.:
    <informalexample>
     <programlisting role="php">
switch ($i) {
    case 0:
        print "i ist gleich 0";
    case 1:
        print "i ist gleich 1";
    case 2:
        print "i ist gleich 2";
}
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Wenn hier $i gleich 0 ist, würde PHP alle print-Anweisungen
    ausführen. Ist $i gleich 1, würden die letzten beiden
    print-Befehle ausgeführt und wenn $i = 2 ist, würde nur der
    letzte print-Befehl ausgeführt. Deshalb ist es wichtig, bei
    der ersten gefundenen Übereinstimmung eine
    <literal>break</literal>-Anweisung zu setzen (abgesehen von
    bestimmten Fällen, wo genau dieses Verhalten gefordert wird).
   </simpara>
   <simpara>
    Bei einer <literal>switch</literal>-Anweisung wird die
    Bedingung also nur einmal überprüft und das Ergebnis mit jeder
    <literal>case</literal>-Anweisung verglichen. Bei einem
    <literal>elseif</literal>-Befehl wird die Bedingung neu geprüft.
    Eine <literal>switch</literal>-Anweisung kann schneller als
    mehrere <literal>if</literal>-Befehle sein, z.B. bei
    komplizierteren Bedingungen als einem einfachen Vergleich.
   </simpara>
   <para>
    Der Anweisungsteil von case kann auch leer sein. Dann wird
    die Kontrolle einfach an den nächsten case-Teil übergeben.
    <informalexample>
     <programlisting role="php">
switch ($i) {
    case 0:
    case 1:
    case 2:
        print "i ist kleiner als 3 aber nicht negativ";
        break;
    case 3:
        print "i ist gleich 3";
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    Ein Spezialfall ist die Anweisung default. Diese trifft
    auf alles zu, was nicht von den voranstehenden case-Ausdrücken
    erfasst wurde, wie z.B.:
    <informalexample>
     <programlisting role="php">
switch ($i) {
    case 0:
        print "i ist gleich 0";
        break;
    case 1:
        print "i ist gleich 1";
        break;
    case 2:
        print "i ist gleich 2";
        break;
    default:
        print "i ist weder 0, 1 noch 2";
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    Der <literal>case</literal>-Ausdruck kann eine Prüfung einfacher
    Typen sein, also von Integer- oder Fließkomma-Zahlen oder von
    Strings / Zeichenketten. Arrays oder Objekte können nicht benutzt
    werden, es sei denn, sie werden auf einfache Typen herunter
    gebrochen.
   </para>
   <para>
    Die alternative Syntax gilt auch für switch-Sequenzen. Mehr
    Informationen dazu unter <link
    linkend="control-structures.alternative-syntax">Alternative Syntax
    für Kontroll-Strukturen</link> .
    <informalexample>
     <programlisting role="php">
switch ($i):
    case 0:
        print "i ist gleich 0";
        break;
    case 1:
        print "i ist gleich 1";
        break;
    case 2:
        print "i ist gleich 2";
        break;
    default:
        print "i ist weder 0, 1 noch 2";
endswitch;
     </programlisting>
    </informalexample>
   </para>
  </sect1>
  
  <sect1 id="function.require">
   <title><function>require</function></title>
   <simpara>
    Der <function>require</function>-Befehl setzt an seine Stelle
    den Inhalt der angegebenen Datei (ähnlich dem #include von C).
   </simpara>
   <simpara>
    Wenn die PHP-Konfigurations-Option "URL fopen wrappers" auf enabled
    (per default) steht, können Sie für die mittels 
    <function>require</function> eingebundene Datei statt einer lokalen
    Pfadangabe auch eine URL angeben. Sehen Sie hierzu unter
    <link linkend="features.remote-files">Remote-Dateien</link> und 
    <function>fopen</function> für weitere Informationen nach.
   </simpara>
   <simpara>
    Wichtig: PHP kehrt zu Beginn der per <function>include</function>
    oder <function>require</function> eingebundenen Dateien vom
    PHP- in den HTML-Modus und am Schluß der Datei wieder vom 
    HTML- in den PHP-Modus zurück. Falls innerhalb dieser Dateien also
    PHP-Code ausgeführt werden soll, muss dieser eingeschlossen werden
    von gültigen PHP-Start- und PHP-Ende-Marken (siehe 
    <link linkend="language.basic-syntax.phpmode">gültige PHP-Start- und
    Ende-Tags</link>).
   </simpara>
   <simpara>
    <function>require</function> ist keine PHP-Anweisung, sondern
    eine spezielle Sprachanweisung. Sie ist anderen Regeln
    unterworfen als Funktionen. Einerseits unterliegt sie keinen
    Kontroll-Srukturen, andererseits gibt sie keinen Wert zurück.
    Der Versuch, von einem <function>require</function>-Aufruf einen
    Rückgabewert zu erhalten, führt zu einem Parse-Fehler.
   </simpara>
   <simpara>
    Anders als <function>include</function> wird
    <function>require</function> <emphasis>immer</emphasis> die
    angegebene Datei einlesen, <emphasis>auch dann, wenn die
    Programmzeile, in der sie steht, nicht ausgeführt wird.</emphasis>
    Wenn Sie eine Datei nur bedingt einlesen wollen, benutzen Sie
    <function>include</function>. Die bedingte Anweisung würde
    <function>require</function> nicht davon abhalten, die Datei zu
    laden.
   </simpara>
   <simpara>
    Innerhalb von Schleifen tritt der Effekt auf, dass, obwohl die den
    <function>require</function>-Befehl enthaltende Zeile mehrfach
    angesprungen wird, die entsprechende Datei trotzdem nur genau
    einmal eingelesen (ausgeführt) wird.
   </simpara>
   <para>
    Sie können also <function>require</function> nicht innerhalb von
    Programm-Schleifen einsetzen. Deshalb, und wenn Sie verschiedene
    Dateien einlesen wollen, müssen Sie in Schleifen den Befehl
    <function>include</function> benutzen.
    <informalexample>
     <programlisting role="php">
require ('header.inc');
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Wird eine Datei per <function>require</function> eingebunden, dann
    "erbt" der darin enthaltene Code die bis zur Skriptzeile mit der
    <function>require</function>-Anweisung definierten Variablen und
    deren Inhalt. Alle innerhalb der eingebundenen Datei Definitionen
    von Variablen stehen ab dieser Zeile zur Verfügung.
    Steht die <function>require</function>-Anweisung innerhalb einer
    Funktion, wird der darin stehende Code behandelt, als ob er
    innerhalb der Funktion stehen würde.
   </simpara>
   <para>
    Wird die mittels <function>require</function> einzubindende Datei
    über HTTP (fopen wrapper) aufgerufen und sieht der Ziel-Server die
    Ziel-Datei als PHP-Code ansieht, dann werden die Variablen an die
    einzubindende Datei wie bei einem HTTP GET übergeben. Das
    entspricht nicht genau der Einbindung einer lokalen Datei, da das
    Skript auf dem entfernten Server ausgeführt wird und nur die
    Ergebnisse in das lokale Skript eingebunden werden.
    <informalexample>
     <programlisting role="php">
/* Dieses Beispiel geht davon aus, dass ein beliebiger Server zum 
 * Parsen von *.php-Dateien konfiguriert ist. Also meint 'funkt' hier,
 * dass die Variablen $vareins und $varzwei innerhalb der angeforderten
 * Datei vorhanden sind. */

/* Funkt. nicht; file.txt wird vom besagten Server nicht geparst. */
require ("http://someserver/file.txt?vareins=1&amp;varzwei=2");

/* Funkt. nicht; schaut nach einer lokalen Datei namens 
/* 'file.php?varone=1&amp;vartwo=2' */
require ("file.php?vareins=1&amp;varzwei=2");               

/* Funkt. */
require ("http://someserver/file.php?vareins=1&amp;varzwei=2"); 

$vareins = 1;
$varzwei = 2;
require ("file.txt");    /* Funkt. */
require ("file.php");    /* Funkt. */
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    In PHP 3 ist es möglich, eine <literal>return</literal>-Anweisung
    innerhalb einer per <function>require</function> eingebundenen Datei
    auszuführen, solange diese Anweisung im Hauptteil dieser Datei steht.
    Die <literal>return</literal>-Anweisung darf nicht in Blöcken (also
    innerhalb von geschwungenen Klammern "{}" stehen. In PHP 4 existiert
    diese Möglichkeit nicht mehr. Wenn Sie diese dennoch benötigen, sehen
    Sie unter <function>include</function> nach.
   </simpara>
   <simpara>
    Siehe auch <function>include</function>, <function>require_once</function>,
    <function>include_once</function>, <function>readfile</function>
    und <function>virtual</function>.
   </simpara>
  </sect1>
 
  <sect1 id="function.include">
   <title><function>include</function></title>
   <simpara>
    Die <function>include</function>-Anweisung liest die angegebene Datei
    ein und wertet sie aus.
   </simpara>
   <simpara>
    Wenn die PHP-Konfigurations-Option "URL fopen wrappers" auf enabled
    (per default) steht, können Sie für die mittels 
    <function>include</function> eingebundene Datei statt einer lokalen
    Pfadangabe auch eine URL angeben. Sehen Sie hierzu unter
    <link linkend="features.remote-files">Remote-Dateien</link> und 
    <function>fopen</function> für weitere Informationen nach.
   </simpara>
   <simpara>
    Wichtig ist, dass beim <function>include</function>- oder
    <function>require</function>-Befehl vom PHP-Parsing-Modus in den
    HTML-Modus geschaltet wird und bei Rückkehr in das aufrufende Skript
    wieder zurück vom HTML- in den PHP-Modus. Deshalb muss jeder
    PHP-Code innerhalb der eingebundenen Dateien umschlossen werden von
    <link linkend="language.basic-syntax.phpmode">gültigen
    PHP-Start- und Ende-Tags</link>.
   </simpara>
   <para>
    Das passiert jedes Mal, sobald die 
    <function>include</function>-Anweisung auftritt. Deshalb können Sie
    <function>include</function> auch sehr gut innerhalb von Schleifen
    verwenden, um eine Anzahl unterschiedlicher Dateien einzubinden.
    <informalexample>
     <programlisting role="php">
$files = array ('first.inc', 'second.inc', 'third.inc');
for ($i = 0; $i &lt; count($files); $i++) {
    include $files[$i];
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    <function>include</function> unterscheidet sich von
    <function>require</function> dadurch, dass die include-Anweisung
    jedesmal neu ausgewertet wird, sobald sie auftritt (und nur zur
    Ausführungszeit). Dagegen wird die
    <function>require</function>-Anweisung beim ersten Auftreten mit
    der angegebenen Datei ersetzt, egal ob sie einzubinden ist oder
    nicht (innerhalb von bedingten Anweisungen, z.B. bei
    <link linkend="control-structures.if">if</link> auch dann, wenn
    das ausgewertete Argument &false; ergeben hat).
   </para>
   <para>
    Da <function>include</function> ein spezieller Sprach-Konstrukt
    ist, müssen Sie ihn innerhalb einer bedingten Anweisung in einen
    Anweisungsblock setzen.
    <informalexample>
     <programlisting role="php">
/* Das ist falsch und führt nicht zum gewünschten Ergebnis. */
 
if ($Bedingung)
    include($diesedatei);
else
    include($anderedatei);
 
/* Diese ist korrekt. */

if ($Bedingung) {
    include($diesedatei);
} else {
    include($anderedatei);
}
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Sowohl in PHP 3 als auch in PHP 4 ist es möglich, eine
    <literal>return</literal>-Anweisung innerhalb einer
    <function>include</function>eten Datei anzugeben, um die
    Ausführung dieser Datei abzubrechen und zum aufrufenden-Skript
    zurück zu kehren. Es gibt aber ein paar Unterschiede in der
    Arbeitsweise. Der erste ist, dass bei PHP 3 die
    <literal>return</literal>-Anweisung nicht innerhalb eines Blocks
    auftreten darf, es sei denn, es ist ein Funktions-Block. In
    diesem Fall gilt <literal>return</literal> für diese Funktion
    und nicht für die ganze Datei. In PHP 4 gibt es diese Beschränkung
    nicht. PHP 4 erlaubt ihnen auch die Rückgabe von Werten bei
    <function>include</function>eten Dateien. Sie können den Wert des
    <function>include</function>-Aufrufs nutzen, als wenn Sie eine 
    Funktion aufgerufen hätten. Das wird in PHP 3 einen Parse-Error
    ergeben.
   </simpara>
   <example>
    <title><function>include</function> in PHP 3 und PHP 4</title>
    <para>
     Beachten Sie, dass die folgende Datei, genannt
     <filename>test.inc</filename>) im gleichen Verzeichnis wie die
     Hauptdatei stehen muss:
     <programlisting role="php">
&lt;?php
echo "Vor dem Return &lt;br&gt;\n";
if (1) {
    return 27;
}
echo "Nach dem Return &lt;br&gt;\n";
?&gt;
     </programlisting>
    </para>
    <para>
     Die Datei <filename>main.html</filename> enthält folgendes:
     <programlisting role="php">
&lt;?php
$retval = include ('test.inc');
echo "Datei gibt zurück: '$retval'&lt;br&gt;\n";
?&gt;
     </programlisting>
    </para>
    <para>
     Sobald <filename>main.html</filename> in PHP 3 aufgerufen wird,
     wird ein Parse-Error in Zeile 2 angezeigt; Sie können in PHP 3
     also keinen Rückgabewert von <function>include</function>
     erhalten. In PHP 4 wird das Ergebnis sein:
     <screen>
Vor dem Return
Datei gibt zurück: '27'
     </screen>
    </para>
    <para>
     Die Datei <filename>main.html</filename> soll nun folgendes 
     enthalten:
     <programlisting role="php">
&lt;?php
include ('test.inc');
echo "Zurück in main.html&lt;br&gt;\n";
?&gt;
     </programlisting>
    </para>
    <para>
     In PHP 4 wird die Ausgabe sein:
     <screen>
Vor dem Return
Zurück in main.html
     </screen>
     PHP 3 wird dagegen folgendes ausgeben:
     <screen>
Vor dem Return
27Zurück in main.html

Parse error: parse error in /home/torben/public_html/phptest/main.html on line 5
     </screen>
    </para>
    <para>
     Der obige Parse-Error ist das Ergebnis der Tatsache, dass die
     <literal>return</literal>-Anweisung innerhalb eines
     Nicht-Funktions-Blocks von <filename>test.inc</filename> steht.
     Wenn das return ausserhalb diese Blocks zu stehen kommt, wird
     die Ausgabe wie folgt aussehen:
     <screen>
Before the return
27Back in main.html
     </screen>
    </para>
    <para>
     Die '27' entsteht aus der Tatsache, dass PHP 3 keine solchen
     Rückgabewerte unterstützt.
    </para>
   </example>
   <simpara>
    Wird eine Datei per <function>include</function> eingebunden, dann
    "erbt" der darin enthaltene Code die bis zur Skriptzeile mit der
    <function>include</function>-Anweisung definierten Variablen und
    deren Inhalt. Alle innerhalb der eingebundenen Datei Definitionen
    von Variablen stehen ab dieser Zeile zur Verfügung. Steht die
    <function>include</function>-Anweisung innerhalb einer Funktion,
    wird der darin stehende Code behandelt, als ob er innerhalb der
    Funktion stehen würde.
   </simpara>
   <para>
    Wird die mittels <function>include</function> einzubindende Datei
    über HTTP (fopen wrapper) aufgerufen und sieht der Ziel-Server die
    Ziel-Datei als PHP-Code ansieht, dann werden die Variablen an die
    einzubindende Datei wie bei einem HTTP GET übergeben. Das
    entspricht nicht genau der Einbindung einer lokalen Datei, da das
    Skript auf dem entfernten Server ausgeführt wird und nur die
    Ergebnisse in das lokale Skript eingebunden werden.
    <informalexample>
     <programlisting role="php">
/* Dieses Beispiel geht davon aus, dass ein beliebiger Server zum 
 * Parsen von *.php-Dateien konfiguriert ist. Also meint 'funkt' hier,
 * dass die Variablen $vareins und $varzwei innerhalb der angeforderten
 * Datei vorhanden sind. */

/* Funkt. nicht; file.txt wird vom besagten Server nicht geparst. */
include ("http://someserver/file.txt?vareins=1&amp;varzwei=2");

/* Funkt. nicht; schaut nach einer lokalen Datei namens 
/* 'file.php?varone=1&amp;vartwo=2' */
include ("file.php?vareins=1&amp;varzwei=2");               

/* Funkt. */
include ("http://someserver/file.php?vareins=1&amp;varzwei=2"); 

$vareins = 1;
$varzwei = 2;
include ("file.txt");    /* Funkt. */
include ("file.php");    /* Funkt. */
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Lassen Sie sich nicht durch die Tatsache irritieren, dass Sie
    Dateien auch über HTTP per require oder include einbinden können
    (vgl. <link linkend="features.remote-files">Remote files</link>).
    Das oben Gesagte behält seine Gültigkeit.
   </simpara>
   <simpara>
    Siehe auch <function>require</function>, 
    <function>require_once</function>,
    <function>include_once</function>,
    <function>readfile</function> und <function>virtual</function>.
   </simpara>
  </sect1>
 
  <sect1 id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    Die <function>require_once</function>-Anweisung ersetzt sich selbst
    durch die angegebene Datei (ähnlich der C-Preprozessor-Anweisung
    <literal>#include</literal>), funktioniert also ähnlich wie die
    <function>require</function>-Anweisung. Der Hauptunterschied dazu
    liegt in der Tatsache, dass bei <function>require_once</function>
    der einzubindende Code genau einmal in das Skript eingefügt wird.
   </para>
   <para>
    Sie erzeugen beispielsweise die folgenden zwei Include-Dateien
    <literal>utils.inc</literal> und <literal>foolib.inc</literal>:
    <example>
     <title>utils.inc</title>
     <programlisting role="php">
&lt;?php
define(PHPVERSION, floor(phpversion()));
echo "GLOBALE SIND GUT\n";
function guterTee() {
    return "Oolong-Tee schmeckt gut!";
}
?&gt;
     </programlisting>
    </example>
    <example>
     <title>foolib.inc</title>
     <programlisting role="php">
&lt;?php
require ("utils.inc");
function zeigeVar($var) {
    if (PHPVERSION == 4) {
        print_r($var);
    } else {
        var_dump($var);
    }
}

// es folgen weiter Funktionen ...
?&gt;
     </programlisting>
    </example>
    Nun schreiben Sie ein Skript
    <literal>cause_error_require.php</literal>:
    <example>
     <title>cause_error_require.php</title>
     <programlisting role="php">
&lt;?php
require("foolib.inc");
/* das Folgende erzeugt einen Fehler */
require("utils.inc");
$foo = array("1",array("complex","quaternion"));
echo "dies erfordert utils.inc, das auch\n";
echo "in foolib.inc erforderlich ist\n";
echo "Aufruf von guterTee: ".guterTee()."\n";
echo "Ausgabe foo: \n";
showVar($foo);
?&gt;
     </programlisting>
    </example>
    Wenn Sie letzteres starten, wird folgende Ausgabe erzeugt (gilt für
    PHP 4.01pl2):
    <informalexample>
     <programlisting>
GLOBALE SIND GUT
GLOBALE SIND GUT

Fatal error:  Cannot redeclare causeerror() in utils.inc on line 5
     </programlisting>
    </informalexample>
    Durch Umschreiben von <literal>foolib.inc</literal> und
    <literal>cause_errror_require.php</literal> (Gebrauch von
    <function>require_once</function> statt 
    <function>require</function>) und Umbenennung des letzten Skriptes
    zu <literal>avoid_error_require_once.php</literal> haben wir nun:
    <example>
     <title>foolib.inc (fixed)</title>
     <programlisting role="php">
...
require_once("utils.inc");
function showVar($var) {
...
     </programlisting>
    </example>
    <example>
     <title>avoid_error_require_once.php</title>
     <programlisting role="php">
...
require_once("foolib.inc");
require_once("utils.inc");
$foo = array("1",array("complex","quaternion"));
...
     </programlisting>
    </example>
    Beim nachfolgenden Aufruf wird folgende Ausgabe erzeugt (bei PHP 
    4.0.1pl2):
    <informalexample>
     <programlisting>
GLOBALE SIND GUT
dies erfordert utils.inc, das auch
in foolib.inc erforderlich ist
Aufruf von guterTee: Oolong-Tee schmeckt gut!.
Ausgabe foo:
Array
(
    [0] =&gt; 1
    [1] =&gt; Array
        (
            [0] =&gt; complex
            [1] =&gt; quaternion
        )

)
     </programlisting>
    </informalexample>
   </para>
   <para>
    Beachten Sie, dass analog zum Verhalten von 
    <literal>#include</literal> im C-Preprozessor diese Anweisung zur
    Zeit der Skript-"Compilierung" ausgewertet wird; sollten Sie also
    z.B. das Skript vor dessen Ausführung parsen und bei der Ausführung
    keinen Gebrauch machen wollen von dynamisch einzuschließenden 
    Teilen, sollten Sie <function>include_once</function> oder 
    <function>include</function> verwenden.
   </para>
   <para>
    Weiter Beispiele zu <function>require_once</function> und 
    <function>include_once</function> können Sie dem PEAR-Code 
    entnehmen, welcher im aktuellsten PHP-Source-Code enthalten ist.
   </para>
   <para>
    Siehe auch: <function>require</function>,
    <function>include</function>, <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, 
    <function>readfile</function>,
    und <function>virtual</function>.
   </para>
  </sect1>
  
  <sect1 id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    Die Anweisung <function>include_once</function> schließt zur 
    Ausführungszeit das angegebene Skript ein und führt es aus. Dies 
    ist ähnlich der <function>include</function>-Anweisung; mit dem
    Unterschied, dass einmal "includierter" Code nicht nochmals 
    eingebunden wird.
   </para>
   <para>
    Wie in der Beschreibung zu <function>require_once</function>
    bereits angemerkt, soll <function>include_once</function> in den
    Fällen verwendet werden, wo die selbe Datei mehr als einmal
    während der Ausführung eingebunden werden soll und Sie 
    Wiederholungen bei den Funktions-Definitionen und Wertzuweisungen
    zu Variablen usw. vermeiden müssen.
   </para>
   <para>
    Weiter Beispiele zu <function>require_once</function> und 
    <function>include_once</function> können Sie dem PEAR-Code 
    entnehmen, welcher im aktuellsten PHP-Source-Code enthalten ist.
   </para>
   <para>
    <function>include_once</function> steht ab PHP 4.01pl2 zur
    Verfügung.
   </para>
   <para>
    Siehe auch: <function>require</function>,
    <function>include</function>, <function>require_once</function>,
    <function>get_required_files</function>, 
    <function>get_included_files</function>, 
    <function>readfile</function> und <function>virtual</function>.
   </para>
  </sect1>
 
 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
