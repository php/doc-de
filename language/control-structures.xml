<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.34 $ -->
<!-- EN-Revision: 1.66 Maintainer: betz Status: ready -->
<!-- CREDITS: tzwenny -->

 <chapter id="control-structures">
  <title>Kontroll-Strukturen</title>
  <simpara>
   Jedes PHP-Skript besteht aus einer Reihe von Anweisungen. Eine
   Anweisung kann aus einem Funktionsaufruf, einer Schleife, einer
   bedingten Anweisung oder einem Befehl, der nichts macht (eine
   leere Anweisung), bestehen. Jede Anweisung endet gewöhnlich mit
   einem Semikolon. Darüber hinaus können Anweisungen zu einer
   Anweisungsgruppe zusammengefasst werden, welche durch geschweifte
   Klammern begrenzt wird. Eine Anweisungsgruppe ist auch eine
   Anweisung. Die unterschiedlichen Arten von Anweisungen werden in
   diesem Abschnitt erläutert.
  </simpara>

  <sect1 id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    Das <literal>if</literal>-Konstrukt ist eine der wichtigsten
    Möglichkeiten vieler Programmier-Sprachen, PHP eingeschlossen.
    Es erlaubt die bedingte Ausführung von Programmteilen. PHP
    kennt eine <literal>if</literal>-Struktur, die ähnlich der
    Programmiersprache C ist:
    <informalexample>
     <programlisting>
<![CDATA[
if (ausdr)
    Anweisung
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Wie im Abschnitt über
    <link linkend="language.expressions">Ausdrücke</link> beschrieben, wird
    <replaceable>ausdr</replaceable> auf seinen boolschen Wertinhalt
    ausgewertet. Wenn <replaceable>ausdr</replaceable> als &true; ausgewertet
    wird, führt PHP die <replaceable>Anweisung</replaceable> aus, falls die
    Auswertung &false; ergibt, wird sie übergangen. Mehr Informationen welche
    Werte als &false; ausgewertet werden finden Sie im Abschnitt 
    <link linkend="language.types.boolean.casting">'Umwandlung nach boolean'</link>.
   </simpara>
   <para>
    Das folgende Beispiel wird <computeroutput>a ist größer als b
    </computeroutput>anzeigen, wenn <replaceable>$a</replaceable>
    größer als <replaceable>$b</replaceable> ist:
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a > $b)
    print "a ist größer als b";
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Oft werden Sie die bedingte Ausführung von mehr als einer
    Anweisung wollen. Selbstverständlich ist es nicht erforderlich,
    jede Anweisung mit einer <literal>if</literal>-Bedingung zu
    versehen. Statt dessen können Sie mehrere Anweisungen in Gruppen
    zusammenfassen. Z.B. wird der folgende Programm-Code
    <computeroutput>a ist größer als b</computeroutput> anzeigen,
    wenn <replaceable>$a</replaceable> größer als
    <replaceable>$b</replaceable> ist. Danach wird der Wert von
    <replaceable>$a</replaceable> in <replaceable>$b</replaceable>
    gespeichert:
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a > $b) {
    print "a ist größer als b";
    $b = $a;
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <literal>If</literal>-Anweisungen können beliebig oft innerhalb anderer
    <literal>if</literal>-Anweisungen definiert werden. Das ermöglicht
    ihnen völlige Flexibilität bei der bedingten Ausführung verschiedenster
    Programmteile.
   </simpara>
  </sect1>
 
  <sect1 id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
    Häufig ist es erforderlich, eine Anweisung auszuführen, wenn eine
    bestimmte Bedingung erfüllt ist und eine andere Anweisung, falls
    sie nicht erfüllt ist. Dafür gibt es <literal>else</literal>.
    <literal>Else</literal> erweitert eine
    <literal>if</literal>-Anweisung um die Ausführung von Anweisungen,
    sobald der Ausdruck der <literal>if</literal>-Anweisung als
    &false; ausgewertet wird. Der folgende Code wird z.B. 
    <computeroutput>a ist größer als b</computeroutput> anzeigen,
    wenn <replaceable>$a</replaceable> größer ist als
    <replaceable>$b</replaceable>, anderenfalls
    <computeroutput>a ist NICHT größer als b</computeroutput>:
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a > $b) {
    print "a ist größer als b";
} else {
    print "a ist NICHT größer als b";
}
]]>
     </programlisting>
    </informalexample>
    Die <literal>else</literal>-Anweisung wird nur ausgeführt, wenn
    der <literal>if</literal>-Ausdruck als &false;
    ausgewertet wurde und wenn bei vorhandenen
    <literal>elseif</literal>-Ausdrücken diese ebenfalls
    &false; sind (siehe <link
    linkend="control-structures.elseif">elseif</link>).
   </para>
  </sect1>
 
  <sect1 id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
    <literal>Elseif</literal> ist, wie der Name schon sagt, eine
    Verbindung von <literal>if</literal> und <literal>else</literal>.
    Wie <literal>else</literal> erweitert sie eine
    <literal>if</literal>-Anweisung um die Ausführung anderer
    Anweisungen, sobald die normale <literal>if</literal>-Bedingung
    als &false; angesehen wird. Anders als bei
    <literal>else</literal> wird die Ausführung dieser alternativen
    Anweisungen nur durchgeführt, wenn die bei
    <literal>elseif</literal> angegebene alternative Bedingung als
    &true; angesehen wird. Der folgende Code wird
    z.B. <computeroutput>a ist größer als b</computeroutput>,
    <computeroutput>a ist gleich b</computeroutput> oder
    <computeroutput>a ist kleiner als b</computeroutput> ausgeben:
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a > $b) {
    print "a ist größer als b";
} elseif ($a == $b) {
    print "a ist gleich b";
} else {
    print "a ist kleiner als b";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Es kann mehrere <literal>elseif</literal>-Anweisungen innerhalb
    einer <literal>if</literal>-Anweisung geben. Die erste
    <literal>elseif</literal>-Bedingung (falls vorhanden), die
    &true; ist, wird ausgeführt. In PHP kann man
    auch 'else if' schreiben (zwei Wörter). Das Verhalten ist
    identisch zu 'elseif' (ein Wort). Die Bedeutung der Syntax ist leicht
    unterschiedlich (falls Sie mit C vertraut sind, das ist das gleiche
    Verhalten) aber der Grundtenor ist der, dass beide Schreibweisen, bezogen
    auf das Ergebnis, sich exakt gleich verhalten.
   </simpara>
   <simpara>
    Die <literal>elseif</literal>-Anweisung wird nur ausgeführt,
    wenn die vorausgehende <literal>if</literal>-Bedingung sowie
    jede vorherige <literal>elseif</literal>-Bedingung
    &false; ist und die aktuelle
    <literal>elseif</literal>-Bedingung &true; ist.
   </simpara>
  </sect1>
 
  <sect1 id="control-structures.alternative-syntax">
   <title>Alternative Syntax für Kontroll-Strukturen</title>
   <para>
    PHP bietet eine alternative Syntax für einige seiner
    Kontroll-Strukturen, als da sind <literal>if</literal>, 
    <literal>while</literal>, <literal>for</literal>, 
    <literal>foreach</literal> und <literal>switch</literal>.
    Immer muss die öffnende Klammer durch einen Doppelpunkt
    ":" und die schließende Klammer durch ein
    <literal>endif;</literal>, <literal>endwhile;</literal>,
    <literal>endfor;</literal>, <literal>endforeach;</literal>
    oder <literal>endswitch;</literal> ersetzt werden.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php if ($a == 5): ?>
    A ist gleich 5
<?php endif; ?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Im obigen Beispiel ist der HTML-Bereich "A ist gleich 5" in eine
    <literal>if</literal>-Anweisung mit alternativer Syntax eingebettet.
    Der HTML-Bereich wird nur ausgegeben, wenn $a gleich 5 ist.
   </simpara>
   <para>
    Die alternative Syntax kann auch auf <literal>else</literal>
    und <literal>elseif</literal> angewendet werden. Es folgt eine
    <literal>if</literal>-Struktur mit <literal>elseif</literal>
    und <literal>else</literal> im alternativen Format:
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a == 5):
    print "a ist gleich 5";
    print "...";
elseif ($a == 6):
    print "a ist gleich 6";
    print "!!!";
else:
    print "a ist weder 5 noch 6";
endif;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Siehe auch <link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link> und <link
    linkend="control-structures.if">if</link> für weitere Beispiele.
   </para>
  </sect1>

  <sect1 id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
    <literal>While</literal>-Schleifen sind die einfachste Form von
    Schleifen in PHP. Sie funktionieren genau wie in C. Die
    Grundform einer <literal>while</literal>-Anweisung lautet:
    <informalexample>
     <programlisting>
<![CDATA[
while (ausdr) Anweisung
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Die Bedeutung einer <literal>while</literal>-Anweisung ist einfach.
    Sie weist PHP an, einen in ihr eingebetteten Befehl so lange zu
    wiederholen, wie die <literal>while</literal>-Bedingung als &true;
    ausgewertet wird. Der Wert der Bedingung wird immer am Anfang der
    Schleife geprüft. Wird der Wert während der Ausführung der Anweisungen
    innerhalb der <literal>while</literal>-Schleife verändert, endet die
    Ausführung dieses Anweisungsblocks erst mit dem Ende der Iteration
    (Jeder Schleifendurchlauf ist eine Iteration). Falls die
    <literal>while</literal>-Bedingung bereits zu Beginn &false; ist, werden
    die Anweisungen der <literal>while</literal>-Schleife nicht ein einziges
    Mal durchlaufen.
   </simpara>
   <para>
    Wie bei der <literal>if</literal>-Anweisung kann man mehrere
    Anweisungen innerhalb der gleichen <literal>while</literal>-Schleife angeben,
    indem man sie mit geschweiften Klammern umschließt oder die alternative
    Syntax gebraucht:
    <informalexample>
     <programlisting>
<![CDATA[
while (ausdr): Anweisung ... endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Die folgenden Beispiele sind identisch; beide geben Zahlen von
    1 bis 10 aus:
    <informalexample>
     <programlisting>
<![CDATA[
/* Beispiel 1 */

$i = 1;
while ($i <= 10) {
    print $i++;  /* es wird erst $i ausgegeben,
                    bevor der Wert erhöht wird
                    (Post-Inkrement) */
}
 
/* Beispiel 2 */
 
$i = 1;
while ($i <= 10):
    print $i;
    $i++;
endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
  <sect1 id="control-structures.do.while">
   <title><literal>do..while</literal></title>
   <simpara>
    <literal>Do..while</literal>-Schleifen sind den <literal>while</literal>
    -Schleifen sehr ähnlich, außer dass der Wahrheitsgehalt des Ausdrucks erst am
    Ende jedes Durchlaufs geprüft wird, statt am Anfang. Der Hauptunterschied
    zu gewöhnlichen <literal>while</literal>-Schleifen ist der, dass die Schleife
    bei <literal>do..while</literal> in jeden Fall einmal durchlaufen wird
    (die Bedingung wird erst am Ende einer Iteration geprüft),
    wogegen es bei <literal>while</literal>-Schleifen
    durchaus passieren kann, dass die Schleife nie durchlaufen wird (die
    Bedingung wird immer am Anfang eines Durchlaufs überprüft. Wird diese
    Bedingung von Anfang an als &false; ausgewertet endet die Ausführung
    der Schleife sofort).
   </simpara>
   <para>
    Es gibt nur eine Syntax für <literal>do..while</literal>-Schleifen:
    <informalexample>
     <programlisting role="php">
<![CDATA[
$i = 0;
do {
    print $i;
} while ($i>0);
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Die obige Schleife wird genau einmal durchlaufen, da nach der
    ersten Wiederholung die Erfüllung der Bedingung geprüft wird. Da
    diese aber nicht erfüllt, also &false; ist ($i ist nicht größer als 0),
    wird die Schleifenausführung beendet.
   </simpara>
   <para>
    Erfahrene C-Anwender kennen auch die Möglichkeit, Programm-Blöcke
    mit <literal>do..while</literal>(0) einzuschliessen und dann die
    <link linkend="control-structures.break"><literal>break</literal></link>
    Anweisung zu benutzen. Der folgende Programm-Ausschnitt zeigt dies:
    <informalexample>
     <programlisting role="php">
<![CDATA[
do {
    if ($i < 5) {
        print "i ist nicht groß genug";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
    print "i ist ok";

    ...bearbeite i...

} while(0);
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Es ist nicht weiter tragisch, wenn Sie dieses Beispiel nicht
    oder nur zum Teil verstehen. Sie können auch ohne dieses
    'Feature' effektive PHP-Programme und Skripte schreiben.
   </simpara>
  </sect1>
 
  <sect1 id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
    <literal>For</literal>-Schleifen sind die komplexesten Schleifen
    in PHP. Sie funktionieren wie ihr Gegenstück in C. Die Syntax
    einer <literal>for</literal>-Schleife sieht so aus:
    <informalexample>
     <programlisting>
<![CDATA[
for (ausdr1; ausdr2; ausdr3) Anweisung
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Der erste Ausdruck (<replaceable>ausdr1</replaceable>) wird beim
    Schleifenbeginn (ohne jegliche Vorbedingung) geprüft bzw. ausgeführt.
   </simpara>
   <simpara>
    Zu Beginn jedes Durchlaufs wird nun <replaceable>ausdr2</replaceable>
    geprüft. Wenn dieser &true; ist, fährt die Schleife
    fort mit der Ausführung der nachfolgenden Anweisung. Ist das
    Ergebnis &false;, wird die Schleife beendet.
   </simpara>
   <simpara>
    Am Ende jedes Durchlaufs wird <replaceable>ausdr3</replaceable> geprüft
    (ausgeführt).
   </simpara>
   <simpara>
    Jeder Ausdruck kann leer sein.
    Ist <replaceable>ausdr2</replaceable> leer, wird die Schleife endlos oft
    durchlaufen (PHP wertet diesen, wie in C, implizit als &true;). Das ist
    nicht so sinnlos, wie Sie vielleicht glauben, weil man häufig eine
    Schleife erst durch eine bedingte
    <link linkend="control-structures.break"><literal>break</literal>
    </link>-Anweisung statt durch eine unwahr werdende
    <literal>for</literal>-Bedingung beenden möchte.
   </simpara>
   <para>
    Beachten Sie die folgenden Beispiele. Alle geben Zahlen von 1 bis
    10 aus:
    <informalexample>
     <programlisting role="php">
<![CDATA[
/* Beispiel 1 */
 
for ($i = 1; $i <= 10; $i++) {
    print $i;
}
 
/* Beispiel 2 */
 
for ($i = 1;;$i++) {
    if ($i > 10) {
        break;
    }
    print $i;
}
 
/* Beispiel 3 */
 
$i = 1;
for (;;) {
    if ($i > 10) {
        break;
    }
    print $i;
    $i++;
}

/* Beispiel 4 */
 
for ($i = 1; $i <= 10; print $i, $i++) ;
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Selbstverständlich sieht das erste (oder vielleicht das vierte) Beispiel am
    besten aus, aber Sie werden noch feststellen, dass es oftmals ganz
    nützlich sein kann, leere Parameter in 
    <literal>for</literal>-Schleifen zu verwenden.
   </simpara>
   <para>
    PHP unterstützt auch bei <literal>for</literal>-Schleifen die
    alternative "Doppelpunkt-Syntax".
    <informalexample>
     <programlisting>
<![CDATA[
for (ausdr1; ausdr2; ausdr3): Anweisung; ...; endfor;
]]>
     </programlisting>
     </informalexample>
   </para>
   <para>
    Andere Sprachen haben für das Durchlaufen eines Hash´s oder 
    Arrays eine <literal>foreach</literal>-Anweisung. PHP 3 hat dies
    nicht; im Gegensatz zu PHP 4 (vgl.
    <link linkend="control-structures.foreach">foreach</link>).
    In PHP 3 kann man dafür eine Kombination von
    <link linkend="control-structures.while">while</link> mit der
    <function>list</function>- und <function>each</function>-Funktion
    einsetzen. Beispiele finden Sie in der Dokumentation zu diesen
    Funktionen.
   </para>
  </sect1>

  <sect1 id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
    PHP 4 (nicht PHP 3) enthält ein <literal>foreach</literal> Konstrukt,
    genau wie Perl und einige andere Sprachen. Diese ermöglicht es, auf
    einfache Weise ein Array zu durchlaufen. <literal>foreach</literal>
    funktioniert nur in Verbindung mit Arrays. Wenn Sie versuchen
    <literal>foreach</literal> mit einer Variable eines anderen Datentyps oder
    einer nicht initialisierten Variable zu benutzen, gibt PHP einen Fehler
    aus. Es gibt zwei Syntax-Formen; die zweite ist eine unbedeutende, aber
    sinnvolle Erweiterung der ersten Syntax:
    <informalexample>
     <programlisting>
<![CDATA[
foreach(array_expression as $value) Anweisung
foreach(array_expression as $key => $value) Anweisung
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Die erste Form durchläuft das
    <literal>array_expression</literal>-Array. Bei jedem Durchgang wird
    der Wert des aktuellen Elements <literal>$value</literal> zugewiesen
    und der interne Array-Zeiger um eins erhöht. Dadurch wird beim nächsten
    Durchgang automatisch das nächste Element ausgewertet.
   </simpara>
   <simpara>
    Die zweite Form arbeitet genauso, außer dass bei jedem Durchlauf
    auch der aktuelle Schlüssel der Variablen <literal>$key</literal>
    zugewiesen wird.
   </simpara>
   <para>
    <note>
     <para>
      Sobald <literal>foreach</literal> zum ersten Mal ausgeführt wird,
      wird der interne Array-Pointer automatisch auf das erste Element
      des Arrays zurück gesetzt. Das bedeutet, dass Sie vor einem Durchlauf
      von <literal>foreach</literal> <function>reset</function> nicht
      aufrufen müssen.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      Beachten Sie auch, dass <literal>foreach</literal> mit einer
      Kopie des angegebenen Arrays arbeitet, nicht mit dem Array selbst.
      Deshalb wird auch der Array-Pointer nicht wie bei dem
      <function>each</function>-Konstrukt verändert und Veränderungen an
      ausgegebenen Arrayelementen haben keine Auswirkung auf das originale
      Array. Trotzdem <emphasis>wird</emphasis> der interne Arrayzeiger
      des originalen Arrays bei der Verarbeitung bewegt. Angenommen, die
      foreach-Schleife ist komplett abgearbeitet, wird der interne
      Arrayzeiger (des originalen Arrays) auf das letzte Element zeigen.
     </para>
    </note>
   </para>
   <note>
    <para>
     Fehlermeldungen durch den Gebrauch von '@' zu unterdrücken ist bei
     <literal>foreach</literal> nicht möglich.
    </para>
   </note>
   <para>
    Beachten Sie, dass die folgenden Beispiele in ihrer Funktionalität
    identisch sind:
    <informalexample>
     <programlisting role="php">
<![CDATA[
reset ($arr);
while (list(, $value) = each ($arr)) {
    echo "Wert: $value<br>\n";
}

foreach ($arr as $value) {
    echo "Wert: $value<br>\n";
}
]]>
     </programlisting>
    </informalexample>
    Auch hier funktioniert alles gleich:
    <informalexample>
     <programlisting role="php">
<![CDATA[
reset ($arr);
while (list($key, $value) = each ($arr)) {
    echo "Schlüssel: $key; Wert: $value<br>\n";
}

foreach ($arr as $key => $value) {
    echo "Schlüssel: $key; Wert: $value<br>\n";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Noch einige Beispiele, die die Anwendung verdeutlichen:
    <informalexample>
     <programlisting role="php">
<![CDATA[
/* foreach Beispiel 1: Nur der Wert */

$a = array (1, 2, 3, 17);

foreach ($a as $v) {
    print "Aktueller Wert von \$a: $v.\n";
}

/* foreach Beispiel 2:
Wert (mit Ausgabe des Array-Schlüssels zur Veranschaulichung) */

$a = array (1, 2, 3, 17);

$i = 0; /* nur zu Veranschaulichung */

foreach($a as $v) {
    print "\$a[$i] => $v.\n";
    $i++;
}

/* foreach Beispiel 3: Schlüssel und Wert */

$a = array (
    "eins" => 1,
    "zwei" => 2,
    "drei" => 3,
    "siebzehn" => 17
);

foreach($a as $k => $v) {
    print "\$a[$k] => $v.\n";
}

/* foreach Beispiel 4: multidimensionale Arrays */

$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach($a as $v1) {
    foreach ($v1 as $v2) {
        print "$v2\n";
    }
}

/* foreach Beispiel 5: dynamische Arrays */

foreach(array(1, 2, 3, 4, 5) as $v) {
    print "$v\n";
}
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
  <sect1 id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
    <literal>Break</literal> bricht die Ausführung der aktuellen
    <literal>for</literal>, <literal>foreach</literal>
    <literal>while</literal>, <literal>do..while</literal> or
    <literal>switch</literal>
    Anweisungs-Sequenz ab.
   </simpara>
   <simpara>
    Einem <literal>break</literal> kann optional ein nummerisches
    Argument angehängt werden, das die Anzahl der abzubrechenden
    Befehls-Sequenzen enthält.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$arr = array ('eins', 'zwei', 'drei', 'vier', 'stop', 'fünf');
while (list ( , $val) = each ($arr)) {
    if ($val == 'stop') {
        break;  /* Man kann hier auch 'break 1;' schreiben. */
    }
    echo "$val<br>\n";

/* Benutzung des optionalen Argumentes. */
$i = 0;
    while (++$i) {
        switch ($i) {
            case 5:
                echo "Bei 5<br>\n";
                break 1;  /* Beendet nur switch. */
            case 10:
                echo "Bei 10; quitting<br>\n";
                break 2;  /* Beendet switch und while. */
            default:
                break;
    }
}
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
  <sect1 id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
    <literal>Continue</literal> wird innerhalb von Schleifen
    gebraucht. Die Schleife wird an der aktuellen Stelle abgebrochen
    und es wird der nächste Durchlauf begonnen.
   </simpara>
   <simpara>
    <literal>Continue</literal> kann optional ein nummerisches
    Argument erhalten, das angibt, wie viele Ebenen von enhaltenen Schleifen
    übersprungen werden sollen.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
while (list ($key, $value) = each ($arr)) {
    if ($key % 2) { // überspringe ungerade Werte
        continue;
    }
    tue_was_mit_ungerade ($value);
}

$i = 0;
while ($i++ < 5) {
    echo "Außn<br>\n";
    while (1) {
        echo "&nbsp;&nbsp;Mitte<br>\n";
        while (1) {
            echo "&nbsp;&nbsp;Innen<br>\n";
            continue 3;
        }
        echo "Das wird nie ausgegeben.<br>\n";
    }
    echo "Dies auch nicht.<br>\n";
}
]]>
     </programlisting>
     </informalexample>
    </para>
  </sect1>
 
  <sect1 id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    Die <literal>switch</literal>-Anweisung ist gleichbedeutend einer
    Reihe von <literal>if</literal>-Anweisungen mit dem gleichen Parameter.
    Häufig wollen Sie ein und dieselbe Variable (bzw. den selben Ausdruck)
    mit verschiedensten Werten vergleichen und in Abhängigkeit vom 
    Auswertungsergebnis verschiedene Programmteile ausführen. Genau
    das ermöglicht die <literal>switch</literal>-Anweisung.
   </simpara> 
   <para>
    Die folgenden zwei Beispiele zeigen zwei verschiedene Wege, das Gleiche
    zu bewirken; eines gebraucht mehrere <literal>if</literal>-Anweisungen,
    das andere eine <literal>switch</literal>-Anweisung:
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($i == 0) {
    print "i ist gleich 0";
}
if ($i == 1) {
    print "i ist gleich 1";
}
if ($i == 2) {
    print "i ist gleich 2";
}
 
switch ($i) {
    case 0:
        print "i ist gleich 0";
        break;
    case 1:
        print "i ist gleich 1";
        break;
    case 2:
        print "i ist gleich 2";
        break;
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Es ist wichtig, die Ausführung einer 
    <literal>switch</literal>-Anweisung zu verstehen, um Fehler zu
    vermeiden. Die <literal>switch</literal>-Anweisung wird Zeile für
    Zeile (also Anweisung für Anweisung) abgearbeitet. Zu Beginn wird
    nichts ausgeführt. Erst wenn bei einem <literal>case</literal>-Teil
    eine Entsprechung zum <literal>switch</literal>-Ausdruck vorliegt,
    werden die darin enthaltenen Anweisungen von PHP ausgeführt. PHP fährt
    dann mit der Abarbeitung des restlichen Codes innerhalb des
    <literal>switch</literal>-Blocks fort oder bis zum ersten
    Auftreten einer <literal>break</literal>-Anweisung. Ohne
    <literal>break</literal> am Ende eines case-Teils werden also
    noch die folgenden case-Blöcke ausgeführt.
    Zum Beispiel:
    <informalexample>
     <programlisting role="php">
<![CDATA[
switch ($i) {
    case 0:
        print "i ist gleich 0";
    case 1:
        print "i ist gleich 1";
    case 2:
        print "i ist gleich 2";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Wenn hier $i gleich 0 ist, würde PHP alle print-Anweisungen
    ausführen! Ist $i gleich 1, werden die letzten beiden
    print-Befehle ausgeführt und wenn $i = 2 ist, wird nur der
    letzte print-Befehl ausgeführt. Deshalb ist es wichtig
    <literal>break</literal>-Anweisungen zu setzen (abgesehen von
    bestimmten Fällen, in denen Sie diese mit Absicht weglassen).
   </simpara>
   <simpara>
    Bei einer <literal>switch</literal>-Anweisung wird die
    Bedingung also nur einmal überprüft und das Ergebnis mit jeder
    <literal>case</literal>-Anweisung verglichen. Bei einem
    <literal>elseif</literal>-Befehl wird die Bedingung neu geprüft.
    Ist ihre Bedingung komplizierter als ein einfacher Vergleich
    und/oder in einer umfangreichen Schleife eingebettet, kann
    eine <literal>switch</literal>-Anweisung schneller als
    mehrere <literal>if</literal>-Befehle sein.
   </simpara>
   <para>
    Der Anweisungsteil von case kann auch leer sein. Dann wird
    die Kontrolle einfach an den nächsten case-Teil übergeben.
    <informalexample>
     <programlisting role="php">
<![CDATA[
switch ($i) {
    case 0:
    case 1:
    case 2:
        print "i ist kleiner als 3 aber nicht negativ";
        break;
    case 3:
        print "i ist gleich 3";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Ein Spezialfall ist default. Dieser Fall trifft
    auf alles zu, was nicht von den voranstehenden case-Ausdrücken
    erfasst wurde und sollte als letzte <literal>case</literal> Anweisung
    angegeben werden. Zum Beispiel:
    <informalexample>
     <programlisting role="php">
<![CDATA[
switch ($i) {
    case 0:
        print "i ist gleich 0";
        break;
    case 1:
        print "i ist gleich 1";
        break;
    case 2:
        print "i ist gleich 2";
        break;
    default:
        print "i ist weder 0, 1 noch 2";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Der <literal>case</literal>-Ausdruck kann eine Prüfung einfacher
    Typen sein, also von Integer- oder Fließkomma-Zahlen oder von
    Strings/Zeichenketten. Arrays oder Objekte können nicht benutzt
    werden, es sei denn, sie wurden in einfache Typen umgewandelt.
   </para>
   <para>
    Die alternative Syntax der Kontrollstrukturen gilt auch für
    switch-Sequenzen. Mehr Informationen dazu erhalten Sie unter <link
    linkend="control-structures.alternative-syntax">Alternative Syntax
    für Kontroll-Strukturen</link>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
switch ($i):
    case 0:
        print "i ist gleich 0";
        break;
    case 1:
        print "i ist gleich 1";
        break;
    case 2:
        print "i ist gleich 2";
        break;
    default:
        print "i ist weder 0, 1 noch 2";
endswitch;
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.declare">
   <title><literal>declare</literal></title>
   <para>
    Das Sprachkonstrukt <literal>declare</literal> wird dazu verwendet, um
    Ausführungsdirektiven für einen Codeblock anzugeben.
    Die Schreibweise von <literal>declare</literal> ist der anderer
    Kontrollstrukturen ähnlich:
    <informalexample>
     <programlisting>
<![CDATA[
declare (Direktive) Anweisung
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Die <literal>Directive</literal> gibt Ihnen die Möglichkeit, das
    Verhalten des <literal>declare</literal>-Blocks zu bestimmen.
    Zur Zeit wird nur eine Direktive erkannt: die <literal>ticks</literal>
    (Weiter unten finden Sie mehr Informationen zu den
    <link linkend="control-structures.declare.ticks">ticks</link>).
   </para>
   <para>
    Der <literal>Anweisung</literal>steil des <literal>declare</literal>-Blocks
    wird ausgeführt - wie genau diese Ausführung passiert und welche
    Nebeneffekte während der Ausführung auftreten, hängt von der Direktive ab,
    die Sie im <literal>directive</literal>-Block angegeben haben.
   </para>

   <sect2 id="control-structures.declare.ticks">
    <title>Ticks</title>
    <para>
     Ein tick ist ein Ereigniss, das bei jedem <replaceable>N</replaceable>-ten
     Autreten der low-level Anweisungen innerhalb des
     <literal>declare</literal> Blocks, die vom Parser ausgeführt werden,
     auftritt. Der Wert von <replaceable>N</replaceable> wird durch die
     Angabe von <literal>ticks=<replaceable>N</replaceable></literal>
     innerhalb des <literal>declare</literal>-Blocks in dem
     <literal>directive</literal> Abschnitt bestimmt.
    </para>
    <para>
     Das Ereignis/die Ereignisse, die bei jedem tick eintreten, legen Sie mit
     der Funktion <function>register_tick_function</function> fest.
     Weitere Einzelheiten können Sie dem Beispiel unten entnehmen. Beachten
     Sie, dass mehr als ein Ereigniss für jeden tick eintreten kann.
    </para>
    <para>
     <example>
     <title>Profil eines Bereichs von PHP Code</title>
      <programlisting role="php">
<![CDATA[
<?php
// Funktion, die bei Aufruf die Zeit aufzeichnet
function profile ($dump = FALSE)
{
    static $profile;

    // Rückgabe der gespeicherten Zeit aus profile, danach löschen
    if ($dump) {
        $temp = $profile;
        unset ($profile);
        return ($temp);
    }

    $profile[] = microtime ();
}

// Einen tick handler bestimmen
register_tick_function("profile");

// Funktion vor dem declare-Block initialisieren
profile ();

// Ausführen eines Code-Blocks, jede 2te Anweisung löst einen tick aus

declare (ticks=2) {
    for ($x = 1; $x < 50; ++$x) {
        echo similar_text (md5($x), md5($x*$x)), "<br />;";
    }
}

// Ausgabe der gespeicherten Daten aus dem Profiler
print_r (profile (TRUE));
?>
]]>
      </programlisting>
     </example>
    Dieses Beispiel 'profiliert' den PHP Code der im 'declare'-Block steht,
    indem die Zeit festgehalten wird, zu der jede zweite low-level Anweisung
    im Codeblock ausgeführt wird. Diese Information können Sie dazu benutzen,
    langsame Bereiche innerhalb bestimmter Codesegmente zu idebtifizieren.
    Das gleiche Ziel können Sie auch mit anderen Methoden erreichen: die
    Benutzung von ticks ist bequemer und einfacher zu implementieren.
   </para>
   <simpara>
    Ticks sind gut für Debugging, einfaches Multitasking,
    Hintergrund I/O und viele andere Aufgaben geeignet.
   </simpara>
   <simpara>
    Siehe auch <function>register_tick_function</function> und
    <function>unregister_tick_function</function>.
   </simpara>
   </sect2>
  </sect1>

  <sect1 id="function.return">
   <title>return</title>
   <simpara>
    Wird die <function>return</function> Anweisung innerhalb einer Funktion
    aufgerufen, wird die Ausführung der Funktion sofort beendet und das
    Argument als Wert des Funktionsaufrufs zurückgegeben.
    <function>return</function> beendet auch die Ausführung einer
    <function>eval</function> Anweisung oder einer Skriptdatei.
   </simpara>
   <simpara>
    Erfolgt der Aufruf innerhalb des globalen Bereichs, wird die Ausführung
    des aktuellen Skripts beendet. Wurde das aktuelle Skript
    <function>include</function>ed oder <function>require</function>ed, wird
    die Kontrolle an das aufrufende Skript zurückgegeben. Wurde das
    aktuelle Skript <function>include</function>ed, wird der Wert, der
    <function>return</function> zugewiesen wurde, als Wert des Aufrufs
    von <function>include</function> zurückgegeben.
    Wird <function>return</function> inerhalb des Hauptskripts aufgerufen,
    wird die Ausführung beendet. Handelt es sich bei dem Skript um eine
    Datei, die über die Einträge
    <link linkend="ini.auto-prepend-file">auto_prepend_file</link>
    oder <link linkend="ini.auto-append-file">auto_append_file</link>
    in der <link linkend="configuration.file">Konfigurationsdatei</link>
    aufgerufen wurde, wird die Ausführung dieses Skripts beendet.
   </simpara>
   <note>
    <simpara>
     Beachten Sie, dass <function>return</function> ein Sprachkonstrukt und
     keine Funktion ist. Deshalb brauchen Sie die Klammern um die Argumente
     <emphasis>nur</emphasis> dann zu setzen, wenn es sich um einen Ausdruck 
     handelt, dessen Ergebnis zurückgegeben werden soll.
     Es ist gebräuchlich, die Klammern wegzulassen, wenn eine Variable oder
     ein Wert dem return-Konstrukt folgt.
    </simpara>
   </note>
  </sect1>

  <sect1 id="function.require">
   <title><function>require</function></title>
   <simpara>
    Die <function>require</function> Anweisung bindet eine Datei ein und führt
    diese aus.
   </simpara>
   <simpara>
    <function>require</function> bindet eine Datei ein und führt
    diese aus. Genaue Informationen wie die Einbindung funktioniert ist in
    der Dokumentation für <function>include</function> beschrieben.
   </simpara>
   <simpara>
    <function>require</function> und <function>include</function> 
    sind in jeder Hinsicht gleichwertig mit der einen Ausnahme: der
    Umgang mit Fehlern. <function>include</function> erzeugt ein
    <link linkend="internal.e-warning">Warning</link> während
    <function>require</function> in einem <link linkend="internal.e-error">
    Fatal Error</link> endet. Mit anderen Worten: scheuen Sie sich nicht,
    <function>require</function> zu benutzen, wenn Sie möchten, dass eine
    fehlende Datei die Ausführung ihres Skripts beendet.
    <function>include</function> verhält sich anders, ihr Skript wird
    weiterhin ausgeführt. Stellen Sie außerdem sicher, dass Sie einen gültigen
    <link linkend="ini.include-path">include_path</link> gesetzt haben.
   </simpara>
   <para>
    <example>
     <title>Grundlegende <function>require</function> Beispiele</title>
     <programlisting role="php">
<![CDATA[
<?php

require 'prepend.php';

require $somefile;

require ('somefile.txt');

?>
]]>
     </programlisting>
   </example>
   </para>
   <simpara>
    Weitere Beispiele finden Sie in der Dokumentation zu
    <function>include</function>.
   </simpara>
   <note>
    <simpara>
     Für frühere Versionen als PHP 4.0.2 gilt folgendes:
     <function>require</function> wird immer versuchen die Zieldatei zu lesen,
     selbst wenn die Zeile in der die Anweisung steht, nie ausgeführt wird. Eine
     bedingte Anweisung hat keine Auswirkungen auf <function>require</function>.
     Wenn jedoch die Zeile in der <function>require</function> steht, nie
     ausgeführt wird, wird auch der Code der Zieldatei nie ausgeführt werden.
     Ähnliches gilt für Schleifenstrukturen, diese beeinflussen das Verhalten
     von <function>require</function> nicht. Obwohl der Code, der in der
     Zieldatei enthalten ist, zur Schleife gehört, wird
     <function>require</function> selbst nur einmal ausgeführt.
    </simpara>
   </note>
   &warn.no-win32-fopen-wrapper;
   <simpara>
    Siehe auch <function>include</function>, <function>require_once</function>,
    <function>include_once</function>, <function>eval</function>, 
    <function>file</function>, <function>readfile</function>, 
    <function>virtual</function> und <link linkend="ini.include-path">include_path</link>.
   </simpara>
  </sect1>

  <sect1 id="function.include">
   <title><function>include</function></title>
   <simpara>
    Die <function>include</function>-Anweisung bindet die angegebene Datei
    ein und wertet sie aus.
   </simpara>
   <simpara>
    Die untenstehende Dokumentation gilt ebenso für
    <function>require</function>. Diese beiden Konstrukte sind in jeder
    Hinsicht gleichwertig mit der einen Ausnahme: der Umgang mit Fehlern.
    <function>include</function> erzeugt ein
    <link linkend="internal.e-warning">Warning</link> während 
    <function>require</function> in einem <link linkend="internal.e-error">
    Fatal Error</link> endet. Mit anderen Worten, verwenden Sie
    <function>require</function>, wenn Sie möchten, dass eine
    fehlende Datei die Ausführung ihres Skripts beendet.
    <function>include</function> verhält sich anders, ihr Skript wird
    weiterhin ausgeführt. Stellen Sie außerdem sicher, dass Sie einen gültigen
    <link linkend="ini.include-path">include_path</link> gesetzt
    haben.
   </simpara>
   <simpara>
    Wenn eine Datei eingebunden wird, erbt der enthaltene Code den
    <link linkend="language.variables.scope">Geltungsbereich von Variablen</link>
    der Zeile in der die Anweisung steht. Ab dieser Zeile stehen alle verfügbaren
    Variablen in der aufgerufenen Datei im aufrufenden Skript zur Verfügung.
   </simpara>
   <para>
     <example>
      <title>Grundlegende <function>include</function> Beispiel</title>
      <programlisting role="php">
<![CDATA[
vars.php
<?php

$color = 'green';
$fruit = 'appel';

?>

test.php
<?php

echo "A $color $fruit"; // A

include 'vars.php';

echo "A $color $fruit"; // A green apple

?>
]]>
      </programlisting>
     </example>
   </para>
   <simpara>
    Steht include im aufrufenden Skript innerhalb einer Funktion,
    verhält sich der gesamte Code der aufgerufenen Datei genau so,
    als ob Sie diesen Code innerhalb dieser Funktion definiert hätten.
    Aus diesem Grund hat dieser Code den Geltungsbereich der Variablen
    dieser Funktion.
   </simpara>
   <para>
     <example>
     <title>Include innerhalb einer Funktion</title>
      <programlisting role="php">
<![CDATA[
<?php

function foo()
{
global $color;

    include 'vars.php';

    echo "A $color $fruit";
}

/* vars.php ist im Geltungsbereich von foo(),  *
 * d.h. $fruit steht außerhalb dieses Bereichs *
 * NICHT zur Verfügung. $color schon, da wir   *
 * diese Variable als global definiert haben  */

foo();                    // A green apple
echo "A $color $fruit";   // A green

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Beim Einbinden einer Datei wechselt der Parser vom PHP-Modus zu Beginn
    der Zieldatei in den HTML-Modus und kehrt am Ende der eingebunden
    Datei wieder in den PHP-Modus zurück. Deshalb muss jeglicher Code
    innerhalb der eingebundenen Datei, der als PHP-Code ausgeführt werden
    soll, von <link linkend="language.basic-syntax.phpmode">gültigen
    PHP-Start- und Ende-Tags</link> eingefaßt sein.
   </simpara>
   <simpara>
    Wenn "<link linkend="ini.allow-url-fopen">URL fopen wrappers</link>"
    in PHP aktiviert sind (in der Standardkonfiguration ist das der Fall)
    können Sie als Pfad der einzubindenden Datei auch eine URL (via HTTP oder
    anderen unterstützen Wrappern - eine Liste der unterstützen Protokolle
    finden Sie unter <xref linkend="wrappers"/>) statt einer lokalen
    Pfadangabe angeben. Falls der Zielserver die Zieldatei als PHP-Code
    interpretiert, können Sie an die einzubindende Datei Variablen in einem
    Request-String übergeben, genauso wie bei HTTP GET. Streng genommen ist
    das nicht das Gleiche, wie diese Datei einzubinden und diesem den
    Geltungsbereich des Vater-Skripts zu vererben; das Skript wird auf dem
    Remote-Server ausgeführt und danach wird das Ergebnis in das lokale Skript
    eingebunden.
   </simpara>
   &warn.no-win32-fopen-wrapper;
   <para>
    <example>
     <title><function>include</function> über HTTP</title>
     <programlisting role="php">
<![CDATA[
<?php

/* Dieses Beispiel geht davon aus, dass www.example.com so konfiguriert     *
 * ist, dass .php-Dateien geparst werden und keine .txt Dateien. Also meint *
 * 'Funkt' hier, dass die Variablen $foo und $bar innerhalb der             *
 * angeforderten Datei zur Verfügung stehen                                 */

// Funkt. nicht; file.txt wird von www.example.com nicht als PHP geparst

include 'http://www.example.com/file.txt?foo=1&bar=2';

// Funkt. nicht; schaut nach einer lokalen Datei namens
// 'file.php?foo=1&bar=2' im lokalen Dateisystem

include 'file.php?foo=1&bar=2';

// Funkt
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // Funkt.
include 'file.php';  // Funkt.

?>
]]>
     </programlisting>
    </example>
     Siehe auch <link linkend="features.remote-files">
     Zugriff auf entfernte Dateien</link>,
     <function>fopen</function> und <function>file</function> für verwandte
     Informationen 
   </para>
   <para>
    Da <function>include</function> und <function>require</function>
    spezielle Sprachkonstrukte sind, müssen Sie diese innerhalb einer
    bedingten Anweisung in einen Anweisungsblock setzen.
   </para>
   <para>
    <example>
     <title>include() und bedingte Blöcke</title>
     <programlisting role="php">
<![CDATA[
<?php

// Das ist FALSCH und führt nicht zum gewünschten Ergebnis.
 

if ($bedingung)
    include $datei;
else
    include $andere_datei;


// Das ist KORREKT.
if ($bedingung) {
    include $datei;
} else {
    include $andere_datei;
}

?>
]]>
     </programlisting>
    </example>
   </para>    
   <simpara>
    Der Umgang mit Returns: Es ist möglich eine <function>return</function>
    -Anweisung innerhalb einer eingebunden Datei anzugeben, um die 
    Ausführung innerhalb dieser Datei abzubrechen und zum aufrufenden Skript
    zurück zu kehren. Ebenso ist die Rückgabe von Werten aus einer
    eingebunden Datei möglich. Sie können den Wert eines include-Aufrufs auf
    die gleiche Art und Weise nutzen, wie Sie es bei einer Funktion machen
    würden.
   </simpara>
   <note>
    <simpara>
     In PHP 3 darf eine return-Anweisung nicht innerhalb eines Blocks
     auftreten, es sei denn, es ist ein Funktions-Block. In diesem Fall gilt
     <function>return</function> für diese Funktion und nicht für die ganze
     Datei.
    </simpara>
   </note>
   <para>
    <example>
     <title><function>include</function> und die <function>return</function> Anweisung</title>
      <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // gibt 'PHP' aus

$bar = include 'noreturn.php';

echo $bar; // gibt 1 aus

?>
]]>
      </programlisting>
    </example>
   </para>
   <simpara>
    <literal>$bar</literal> hat den Wert <literal>1</literal>, weil include
    erfolgreich war. Beachten Sie die Unterschiede in den obigen Beispielen.
    Das erste nutzt <function>return</function> innerhalb der eingebundenen
    Datei im Gensatzt zum zweiten Beispiel.
    Weitere Möglichkeiten Dateien in Variablen "einzubinden" bieten ihnen die
    Funktionen <function>fopen</function> und <function>file</function> oder
    <function>include</function> im Zusammenspiel mit den
    <link linkend="ref.outcontrol">Funktionen zur Ausgabesteuerung</link>.
   </simpara>

   <simpara>
    Siehe auch <function>require</function>, <function>require_once</function>,
    <function>include_once</function>, <function>readfile</function>,
    <function>virtual</function>und
    <link linkend="ini.include-path">include_path</link>.
   </simpara>
  </sect1>

  <sect1 id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    Die <function>require_once</function>-Anweisung bindet eine Datei ein
    und führt diese zur Laufzeit des Skripts aus.
    Das Verhalten ist ähnlich der <function>require</function>-Anweisung mit
    dem einzigen Unterschied, dass einmal eingebundener Code aus einer Datei
    nicht nocht einmal eingebunden wird. Lesen Sie die Dokumentation zu
    <function>require</function> um mehr Informationen über die Arbeitsweise
    dieser Anweisung zu erhalten.
   </para>
   <para>
    <function>require_once</function> sollten Sie in den Fällen benutzen,
    wenn die gleiche Datei in einem bestimmten Bereich mehrmals eingebunden
    und interpretiert werden soll und Sie sicher stellen wollen, dass diese
    Datei nur exakt einmal eingebunden wird, um Probleme mit Wiederholungen
    bei Funktions-Definitionen und Wertzuweisungen zu Variablen zu vermeiden,
    usw.
   </para>
   <para>
    Weitere Beispiele zu <function>require_once</function> und
    <function>include_once</function> können Sie dem
    <ulink url="&url.php.pear;">PEAR</ulink>-Code entnehmen, welcher
    im aktuellsten PHP-Source-Code enthalten ist.
   </para>
   <note>
   <para>
    <function>require_once</function> steht ab PHP 4.01pl2 zur
    Verfügung.
   </para>
   </note>
   <note>
    <para>
     Beachten Sie, dass auf auf einem Betriebssystem, das nicht zwischen
     Groß- und Kleinschreibung unterschiedet (wie z.B. Windows) das Verhalten
     von <function>require_once</function> und
     <function>include_once</function> nicht unbedingt ihren Erwartungen
     entspricht.
     <example>
      <title><function>require_once</function> und Groß-/Kleinschreibung</title>
      <programlisting role="php">
<![CDATA[
require_once("a.php"); // bindet a.php ein
require_once("A.php"); // bindet a.php auf Windows nochmal ein!
]]>
       </programlisting>
     </example>
    </para>
   </note>
   &warn.no-win32-fopen-wrapper;
   <para>
    Siehe auch: <function>require</function>,
    <function>include</function>, <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, 
    <function>readfile</function>
    und <function>virtual</function>.
   </para>
  </sect1>

  <sect1 id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    Die Anweisung <function>include_once</function> schließt zur
    Ausführungszeit die angegebene Datei ein und wertet diese aus. Dies
    ist ähnlich der <function>include</function>-Anweisung; mit dem
    Unterschied, dass einmal eingebundener Code nicht nochmals 
    eingebunden wird. Wie der Name vermuten lässt, wird ie Datei nur ein
    einziges Mal eingebunden.
   </para>
   <para>
    <function>include_once</function> sollten Sie in den Fällen benutzen,
    wenn die gleiche Datei in einem bestimmten Bereich mehrmals eingebunden
    und interpretiert werden soll und Sie sicher stellen wollen, dass diese
    Datei nur exakt einmal eingebunden wird, um Probleme mit Wiederholungen
    bei Funktions-Definitionen und Wertzuweisungen zu Variablen zu vermeiden,
    usw.
   </para>
   <para>
    Weitere Beispiele zu <function>require_once</function> und
    <function>include_once</function> können Sie dem
    <ulink url="&url.php.pear;">PEAR</ulink>-Code entnehmen, welcher
    im aktuellsten PHP-Source-Code enthalten ist.
   </para>
   <note>
   <para>
    <function>include_once</function> steht ab PHP 4.01pl2 zur
    Verfügung.
   </para>
   </note>
   <note>
    <para>
     Beachten Sie, dass auf auf einem Betriebssystem, das nicht zwischen
     Groß- und Kleinschreibung unterschiedet (wie z.B. Windows) das Verhalten
     von <function>include_once</function> und
     <function>require_once</function> nicht unbedingt ihren Erwartungen
     entspricht.
     <example>
      <title><function>include_once</function> und Groß-/Kleinschreibung</title>
      <programlisting role="php">
<![CDATA[
include_once("a.php"); // bindet a.php ein
include_once("A.php"); // bindet a.php auf Windows nochmal ein!
]]>
       </programlisting>
     </example>
    </para>
   </note>
   &warn.no-win32-fopen-wrapper;
   <para>
    Siehe auch <function>include</function>,
    <function>require</function>, <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>
    und <function>virtual</function>.
   </para>
  </sect1>
 
 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
