 <chapter id="control-structures">
  <title>Kontroll-Strukturen</title>

  <simpara>
   Jedes PHP-Skript besteht aus einer Reihe von Anweisungen. Eine
   Anweisung kann aus einem Funktions-Aufruf, einer Schleife, einer
   bedingten Anweisung oder einem Befehl, der nichts macht (eine
   leere Anweisung), bestehen. Jeder Befehl endet gewöhnlich mit
   einem Semikolon. Darüber hinaus können Befehle zu einer
   Anweisungsgruppe zusammengefasst werden, welche durch geschweifte
   Klammern begrenzt wird. Eine Anweisungsgruppe ist auch eine
   Anweisung. Die unterschiedlichen Arten von Anweisungen werden in
   diesem Abschnitt erläutert.
  </simpara>

  <sect1 id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    Der <literal>if</literal>-Befehl ist eine der wichtigsten
    Möglichkeiten vieler Programmier-Sprachen, PHP eingeschlossen.
    Er erlaubt die bedingte Ausführung von Programmteilen. PHP
    beinhaltet eine <literal>if</literal>-Struktur, die ähnlich der
    von C ist:
    <informalexample>
     <programlisting>
if (expr)
    Anweisung
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Wie im Abschnitt über Expressions / Ausdrücke beschrieben,
    wird expr auf seinen wirklichen Wertinhalt ausgewertet. Wenn
    <replaceable>expr</replaceable> <literal>TRUE</literal>
    entspricht, wird PHP Anweisung ausführen, falls nicht - sie
    also <literal>FALSE</literal> ist - wird Anweisung übergangen.
   </simpara>
   <para>
    Das folgende Beispiel wird <computeroutput>a ist grösser als b
    </computeroutput>anzeigen, wenn <replaceable>$a</replaceable> 
    grösser ist als <replaceable>$b</replaceable>:
    <informalexample>
     <programlisting role="php">
if ($a > $b)
    print "a ist grösser als b";
     </programlisting>
    </informalexample>
   </para>
   <para>
    Oft werden sie die bedingte Ausführung von mehr als einer
    Anweisung wollen. Selbstverständlich ist es nicht erforderlich,
    jede Anweisung mit einer <literal>if</literal>-Bedingung zu
    versehen. Statt dessen können sie mehrere Anweisungen in Gruppen
    zusammenfassen. Z.B. wird der folgende Programm-Code
    <computeroutput>a ist grösser als b</computeroutput> anzeigen,
    wenn <replaceable>$a</replaceable> grösser ist als
    <replaceable>$b</replaceable>. Danach wird der Wert von
    <replaceable>$a</replaceable> in <replaceable>$b</replaceable>
    gespeichert:
    <informalexample>
     <programlisting role="php">
if ($a > $b) {
    print "a ist grösser als b";
    $b = $a;
}
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    If-Anweisungen können ohne Einschränkung innerhalb anderer
    <literal>if</literal>-Anweisungen definiert werden. Das ermöglicht
    ihnen völlige Flexibilität bei der bedingten Ausführung verschiedenster
    Programmteile.
   </simpara>
  </sect1>
 
  <sect1 id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
    Häufig ist es erforderlich, eine Anweisung auszuführen, wenn eine
    bestimmte Bedingung erfüllt ist und eine andere Anweisung, falls
    sie nicht erfüllt ist. Dafür gibt es <literal>else</literal>.
    <literal>Else</literal> erweitert eine
    <literal>if</literal>-Anweisung um die Ausführung von Anweisungen,
    sobald der Ausdruck der <literal>if</literal>-Anweisung als
    <literal>FALSE</literal> angesehen wird. Der folgende Code wird
    z.B. <computeroutput>a ist grösser als b</computeroutput> anzeigen,
    wenn <replaceable>$a</replaceable> grösser ist als
    <replaceable>$b</replaceable>, anderenfalls
    <computeroutput>a ist NICHT grösser als b</computeroutput>:
    <informalexample>
     <programlisting role="php">
if ($a > $b) {
    print "a ist grösser als b";
} else {
    print "a ist NICHT grösser als b";
}
     </programlisting>
    </informalexample>

    Die <literal>else</literal>-Anweisung wird nur ausgeführt, wenn
    der <literal>if</literal>-Ausdruck als <literal>FALSE</literal>
    ausgewertet wurde und wenn bei vorhandenen
    <literal>elseif</literal>-Ausdrücken diese ebenfalls
    <literal>FALSE</literal> sind (siehe <link
    linkend="control-structures.elseif">elseif</link>).

   </para>
  </sect1>
 
  <sect1 id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
    <literal>Elseif</literal> ist, wie der Name schon sagt, eine
    Verbindung von <literal>if</literal> und <literal>else</literal>.
    Wie <literal>else</literal> erweitert sie eine
    <literal>if</literal>-Anweisung um die Ausführung anderer
    Anweisungen, sobald die normale <literal>if</literal>-Bedingung
    als <literal>FALSE</literal> angesehen wird. Anders als bei
    <literal>else</literal> wird die Ausführung dieser anderen
    Anweisungen nur durchgeführt, wenn die bei
    <literal>elseif</literal> angegebene alternative Bedingung als
    <literal>TRUE</literal> angesehen wird. Der folgende Code wird
    z.B. <computeroutput>a ist grösser als b</computeroutput>,
    <computeroutput>a ist gleich b</computeroutput> oder
    <computeroutput>a ist kleiner als b</computeroutput> ausgeben:
    <informalexample>
     <programlisting role="php">
if ($a > $b) {
    print "a ist grösser als b";
} elseif ($a == $b) {
    print "a ist gleich b";
} else {
    print "a ist kleiner als b";
}
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Es kann mehrere <literal>elseif</literal>-Anweisungen innerhalb
    einer <literal>if</literal>-Anweisung geben. Die erste
    <literal>elseif</literal>-Bedingung (falls vorhanden), die
    <literal>true</literal> ist, wird ausgeführt. In PHP kann man
    auch 'else if' schreiben (zwei Wörter). Das Verhalten ist
    identisch zu 'elseif' (ein Wort), genau wie in C.
   </simpara>
   <simpara>
    Die <literal>elseif</literal>-Anweisung wird nur ausgeführt,
    wenn die vorausgehende <literal>if</literal>-Bedingung sowie 
    jede vorherige <literal>elseif</literal>-Bedingung
    <literal>FALSE</literal> ist und die aktuelle
    <literal>elseif</literal>-Bedingung <literal>TRUE</literal>
    ist.
   </simpara>
  </sect1>
 
  <sect1 id="control-structures.alternative-syntax">
   <title>Alternative Syntax für Kontroll-Strukturen</title>
   <para>
    PHP bietet eine alternative Syntax für einige seiner
    Kontroll-Strukturen; als da sind <literal>if</literal>,
    <literal>while</literal>, <literal>for</literal> und
    <literal>switch</literal>. Die Grundform der alternativen Syntax
    besteht immer aus dem Wechsel der öffnenden Klammer gegen einen
    Doppelpunkt (:) und der schliessenden Klammer gegen ein
    <literal>endif;</literal>, <literal>endwhile;</literal>,
    <literal>endfor;</literal> bzw. <literal>endswitch;</literal>.
    <informalexample>
     <programlisting role="php">
&lt;?php if ($a == 5): ?&gt;
    A ist gleich 5
&lt;?php endif; ?&gt;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Im obigen Beispiel ist der HTML-Bereich eingebettet in eine
    <literal>if</literal>-Anweisung mit alternativer Syntax.
    Der HTML-Bereich wird nur ausgegeben, wenn $a gleich 5 ist.
   </simpara>
   <para>
    Die alternative Syntax kann auch auf <literal>else</literal>
    und <literal>elseif</literal> angewendet werden. Es folgt eine
    <literal>if</literal>-Struktur mit <literal>elseif</literal>
    und <literal>else</literal> im alternativen Format:
    <informalexample>
     <programlisting role="php">
if ($a == 5):
    print "a ist gleich 5";
    print "...";
elseif ($a == 6):
    print "a ist gleich 6";
    print "!!!";
else:
    print "a ist weder 5 noch 6";
endif;
     </programlisting>
    </informalexample>
   </para>
   <para>
    Siehe auch <link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link> und <link
    linkend="control-structures.if">if</link> für weitere Beispiele.
   </para>
  </sect1>

  <sect1 id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
    <literal>While</literal>-Schleifen sind die einfachste Form von
    Schleifen in PHP. Sie funktionieren genau wie in C. Die
    Grundform einer <literal>while</literal>-Anweisung lautet:
    <informalexample>
     <programlisting>
while (expr) Anweisung
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Die Bedeutung einer <literal>while</literal>-Anweisung ist einfach.
    Sie weist PHP an, einen in ihr eingebetteten Befehl so lange zu
    wiederholen, bis die <literal>while</literal>-Bedingung 
    <literal>TRUE</literal> geworden ist. Der Wert der Bedingung wird
    immer am Anfang der Schleife geprüft. Wird der Wert während der 
    Ausführung der Befehle innerhalb der 
    <literal>while</literal>-Schleife geändert, endet die Ausführung
    dieses Befehls-Blocks nicht vor einem neuem Schleifen-Durchlauf
    (Iteration). Jeder Schleifendurchlauf ist eine Iteration. Falls
    die <literal>while</literal>-Bedingung bereits zu Beginn
    <literal>FALSE</literal> ist, werden die Anweisungen der
    <literal>while</literal>-Schleife nicht ein einziges Mal durchlaufen.
   </simpara>
   <para>
    Wie bei der <literal>if</literal>-Anweisung kann man mehrere
    Befehle innerhalb einer Schleife angeben, indem man sie mit
    geschweiften Klammern umschliesst oder die alternative Syntax
    gebraucht:
    <informalexample>
     <programlisting>
while (expr): statement ... endwhile;
     </programlisting>
    </informalexample>
   </para>
   <para>
    Die folgenden Beispiele sind identisch; beide geben Zahlen von
    1 bis 10 aus:
    <informalexample>
     <programlisting>
/* Beispiel 1 */

$i = 1;
while ($i <= 10) {
    print $i++;  /* es wird erst $i ausgegeben,
                    bevor der Wert erhöht wird
                    (post-increment) */
}
 
/* Beispiel 2 */
 
$i = 1;
while ($i <= 10):
    print $i;
    $i++;
endwhile;
     </programlisting>
    </informalexample>
   </para>
  </sect1>
  <sect1 id="control-structures.do.while">
   <title><literal>do..while</literal></title>
   <simpara>
    <literal>Do..while</literal>-Schleifen sind den
    <literal>while</literal>-Schleifen sehr ähnlich, ausser dass die
    Erfüllung des Ausdrucks am Ende jedes Durchlaufs geprüft wird
    (statt am Anfang). Der Hauptunterschied zu gewöhnlichen
    <literal>while</literal>-Schleifen ist, dass der erste 
    Schleifen-Durchlauf bei <literal>do..while</literal> in jedem
    Fall statt findet, wogegen es bei <literal>while</literal>-Schleifen
    durchaus passieren kann, dass die Schleife nie durchlaufen wird,
    wenn die am Anfang zu prüfende Bedingung schon zu Beginn
    <literal>FALSE</literal> ist.
   </simpara>
   <para>
    Es gibt nur eine Syntax für <literal>do..while</literal>-Schleifen:
    <informalexample>
     <programlisting role="php">
$i = 0;
do {
    print $i;
} while ($i>0);
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Die obige Schleife wird genau einmal durchlaufen, da nach der
    ersten Wiederholung die Erfüllung der Bedingung geprüft wird. Da
    diese aber nicht erfüllt, also <literal>FALSE</literal> ist ($i
    ist nicht grösser als 0), wird die Schleifenausführung beendet.
   </simpara>
   <para>
    Erfahrene C-Anwender kennen auch die Möglichkeit, Programm-Blöcke
    mit <literal>do..while</literal>(0) einzuschliessen und dann die
    <link linkend="control-structures.break"><literal>break</literal></link>
    Anweisung zu benutzen. Der folgende Programm-Ausschnitt zeigt dies:
    <informalexample>
     <programlisting role="php">
do {
    if ($i < 5) {
        print "i ist nicht gross genug";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
    print "i ist ok";

    ...process i...

} while(0);
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Es ist nicht weiter tragisch, wenn sie dieses Beispiel nicht
    oder nur zum Teil verstehen. Sie können auch ohne dieses 
    Feature effektive PHP-Programme und Skripte schreiben.
   </simpara>
  </sect1>
 
  <sect1 id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
    <literal>For</literal>-Schleifen sind die komplexesten Schleifen
    in PHP. Sie funktionieren wie ihr Gegenstück in C. Die Syntax
    einer <literal>for</literal>-Schleife sieht so aus:
    <informalexample>
     <programlisting>
for (expr1; expr2; expr3) Anweisung
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Der erste Parameter (<replaceable>expr1</replaceable>) wird beim
    Schleifenbeginn geprüft bzw. ausgeführt (ohne jegliche Vorbedingung).
   </simpara>
   <simpara>
    Zu Beginn jedes Durchlaufs wird nun <replaceable>expr2</replaceable>
    geprüft. Wenn dieser <literal>TRUE</literal> ist, fährt die Schleife
    weiter fort mit der Ausführung der nachfolgenden Befehle. Wenn das
    Ergebnis <literal>FALSE</literal> lautet, wird die Schleife beendet.
   </simpara>
   <simpara>
    Am Ende jedes Durchlaufs wird nun auch noch 
    <replaceable>expr3</replaceable> geprüft / ausgeführt.
   </simpara>
   <simpara>
    Jeder der Parameter kann leer sein (optional).
    Ist <replaceable>expr2</replaceable> leer, wird die Schleife
    unbestimmt oft durchlaufen, da PHP ihn als <literal>TRUE</literal>
    wertet (wie in C). Das ist nicht so sinnlos, wie sie vielleicht glauben,
    weil man häufig eine Schleife erst durch eine bedingte
    <link linkend="control-structures.break"><literal>break</literal>
    </link>-Anweisung statt durch eine unwahr werdende
    <literal>for</literal>-Bedingung beenden möchte.
   </simpara>
   <para>
    Beachten sie die folgenden Beispiele. Alle geben Zahlen von 1 bis
    10 aus:
    <informalexample>
     <programlisting role="php">
      /* Beispiel 1 */
 
for ($i = 1; $i <= 10; $i++) {
    print $i;
}
 
      /* Beispiel 2 */
 
for ($i = 1;;$i++) {
    if ($i > 10) {
        break;
    }
    print $i;
}
 
      /* Beispiel 3 */
 
$i = 1;
for (;;) {
    if ($i > 10) {
        break;
    }
    print $i;
    $i++;
}
 
      /* Beispiel 4 */
 
for ($i = 1; $i <= 10; print $i, $i++) ;
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Selbstverständlich sieht das erste (oder das vierte) Beispiel am
    besten aus, aber sie werden noch feststellen, dass es oftmals
    ganz nützlich sein kann, leere Parameter in
    <literal>for</literal>-Schleifen zu verwenden.
   </simpara>
   <para>
    PHP unterstützt auch bei <literal>for</literal>-Schleifen die
    alternative "Doppelpunkt-Syntax".
    <informalexample>
     <programlisting>
for (expr1; expr2; expr3): Anweisung; ...; endfor;
     </programlisting>
     </informalexample>
   </para>
   <para>
    Andere Sprachen haben für das Durchlaufen eines Hash´s oder 
    Arrays eine <literal>foreach</literal>-Anweisung. PHP3 hat dies
    nicht; im Gegensatz zu PHP4 (vgl.
    <link linkend="control-structures.foreach">foreach</link>).
    In PHP3 kann man dafür eine Kombination von
    <link linkend="control-structures.while">while</link> mit der
    <function>list</function>- und <function>each</function>-Funktion
    einsetzen. Beispiele finden sie in der Dokumentation zu diesen
    Funktionen.
   </para>
  </sect1>

  <sect1 id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
    PHP4 (nicht PHP3) enthält eine <literal>foreach</literal>-Funktion,
    genau wie Perl und andere Sprachen. Diese ermöglicht es, auf
    einfache Weise ein Array zu durchlaufen. Es gibt zwei
    Syntax-Formen; die zweite ist eine unbedeutende aber sinnvolle
    Erweiterung der ersten Syntax:
    <informalexample>
     <programlisting>
foreach(array_expression as $value) Anweisung
foreach(array_expression as $key => $value) Anweisung
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Die erste Form durchläuft das
    <literal>array_expression</literal>-Array. Bei jedem Durchgang wird
    der Wert des aktuellen Elements <literal>$value</literal> zugewiesen
    und der interne Array-Zeiger um 1 erhöht. Dadurch wird beim nächsten
    Durchgang automatisch das nächste Element ausgewertet.
   </simpara>
   <simpara>
    Die zweite Form arbeitet genauso, ausser dass bei jedem Durchlauf
    auch der aktuelle Schlüssel der Variablen <literal>$key</literal>
    zugewiesen wird.
   </simpara>
   <para>
    <note>
     <para>
      Sobald <literal>foreach</literal> zum ersten Mal ausgeführt wird,
      wird der interne Array-Pointer automatisch auf das erste Element
      des Arrays zurück gesetzt. Das heisst, dass sie nicht
      <function>reset</function> vor einem Durchlauf von
      <literal>foreach</literal> aufrufen müssen.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      Beachten sie auch, dass <literal>foreach</literal> mit einer
      Kopie des angegebenen Arrays arbeitet. Deshalb wird auch der
      Array-Pointer nicht wie bei dem each-Konstrukt verändert.
     </para>
    </note>
   </para>
   <para>
    Beachten sie, dass die folgenden Beispiele in ihrer Funktionalität
    identisch sind:
    <informalexample>
     <programlisting role="php">
      reset ($arr);
while (list(, $value) = each ($arr)) {
    echo "Wert: $value&lt;br&gt;\n";
}

foreach ($arr as $value) {
    echo "Wert: $value&lt;br&gt;\n";
}
     </programlisting>
    </informalexample>
    Auch hier funktioniert alles gleich:
    <informalexample>
     <programlisting role="php">
reset ($arr);
while (list($key, $value) = each ($arr)) {
    echo "Schlüssel: $key; Wert: $value&lt;br&gt;\n";
}

foreach ($arr as $key => $value) {
    echo "Schlüssel: $key; Wert: $value&lt;br&gt;\n";
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    Noch einige Beispiele, die die Anwendung verdeutlichen:
    <informalexample>
     <programlisting role="php">
/* foreach Beispiel 1: Nur der Wert */

$a = array (1, 2, 3, 17);

foreach ($a as $v) {
    print "Aktueller Wert von \$a: $v.\n";
}

/* foreach Beispiel 2: Wert (mit Ausgabe des Array-Schlüssels) */

$a = array (1, 2, 3, 17);

$i = 0; /* nur für Anschauungs-Zweck */

foreach($a as $v) {
    print "\$a[$i] => $k.\n";
}

/* foreach Beispiel 3: Schlüssel und Wert */

$a = array (
    "one" => 1,
    "two" => 2,
    "three" => 3,
    "seventeen" => 17
);

foreach($a as $k => $v) {
    print "\$a[$k] => $v.\n";
}
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
  <sect1 id="control-structures.break">
   <title><literal>break</literal></title>
   
   <simpara>
    <literal>Break</literal> bricht die Ausführung der aktuellen
    <literal>for</literal>, <literal>while</literal> oder
    <literal>switch</literal>
    Anweisungs-Sequenz ab.
   </simpara>

   <simpara>
    Einem <literal>break</literal> kann optional ein numerisches
    Argument angehängt werden, das die Anzahl der abzubrechenden
    Befehls-Sequenzen enthält. 
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
$arr = array('eins', 'zwei', 'drei', 'stop', 'vier');
while (list( , $val) = each($arr)) {
    if ($val == 'stop') {
        break;  /* Man kann hier auch 'break 1;' schreiben. */
    }
    echo "$val&lt;br&gt;\n";

/* Benutzung des optionalen Argumentes. */
$i = 0;
    while ( ++$i ) {
        switch ( $i ) {
            case 5:
                echo "Bei 5&lt;br&gt;\n";
                break 1;  /* Beendet nur switch. */
            case 10:
                echo "Bei 10; quitting&lt;br&gt;\n";
                break 2;  /* Beendet switch und while. */
            default:
                break;
    }
}
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
  <sect1 id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
    <literal>Continue</literal> wird innerhalb von Schleifen
    gebraucht. Die Schleife wird an der aktuellen Stelle abgebrochen
    und es wird der nächste Durchlauf begonnen.
   </simpara>
   <simpara>
    <literal>Continue</literal> kann optional ein numerisches
    Argument erhalten, das die Anzahl der zu überspringenden
    Schleifendurchläufe beinhaltet.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
while (list ($key, $value) = each ($arr)) {
    if (!($key % 2)) { // überspringe ungerade Werte
        continue;
    }
    tue_was_mit_ungerade ($value);
}

$i = 0;
while ($i++ &lt; 5) {
    echo "Aussen&lt;br&gt;\n";
    while (1) {
        echo "&nbsp;&nbsp;Mitte&lt;br&gt;\n";
        while (1) {
            echo "&nbsp;&nbsp;Innen&lt;br&gt;\n";
            continue 3;
        }
        echo "Das wird nie ausgegeben.&lt;br&gt;\n";
    }
    echo "Dies auch nicht.&lt;br&gt;\n";
}
     </programlisting>
     </informalexample>
    </para>
  </sect1>
 
  <sect1 id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    Die <literal>switch</literal>-Anweisung ist gleichbedeutend einer
    Reihe von IF-Anweisungen mit dem gleichen Parameter. Häufig wollen
    sie ein und die selbe Variable (bzw. den selben Ausdruck) mit 
    verschiedensten Werten vergleichen und in Abhängigkeit vom 
    Auswertungsergebnis verschiedene Programmteile ausführen. Genau
    das ermöglicht die <literal>switch</literal>-Anweisung.
   </simpara> 
   <para>
    Die folgenden 2 Beispiele zeigen 2 verschiedene Wege, das gleiche
    zu bewirken; eins gebraucht mehrere <literal>if</literal>-Befehle,
    das andere eine <literal>switch</literal>-Anweisung:
    <informalexample>
     <programlisting role="php">
if ($i == 0) {
    print "i ist gleich 0";
}
if ($i == 1) {
    print "i ist gleich 1";
}
if ($i == 2) {
    print "i ist gleich 2";
}
 
switch ($i) {
    case 0:
        print "i ist gleich 0";
        break;
    case 1:
        print "i ist gleich 1";
        break;
    case 2:
        print "i ist gleich 2";
        break;
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    Es ist wichtig, die Ausführung einer 
    <literal>switch</literal>-Anweisung zu verstehen, um Fehler zu
    vermeiden. Die <literal>switch</literal>-Anweisung wird Zeile für
    Zeile (also Anweisung für Anweisung) abgearbeitet. Zu Beginn wird
    nichts ausgeführt. Erst wenn bei einem <literal>case</literal>-Teil
    eine Entsprechung zum <literal>switch</literal>-Ausdruck vorliegt,
    werden die darin enthaltenen Befehle ausgeführt. PHP fährt dann
    mit der Abarbeitung des restlichen Codes innerhalb des
    <literal>switch</literal>-Blocks fort (oder bis zum ersten
    Auftreten einer <literal>break</literal>-Anweisung). Ohne
    <literal>break</literal> am Ende eines case-Teils werden also
    noch die folgenden case-Blöcke ausgeführt.
    Z.B.:
    <informalexample>
     <programlisting role="php">
switch ($i) {
    case 0:
        print "i ist gleich 0";
    case 1:
        print "i ist gleich 1";
    case 2:
        print "i ist gleich 2";
}
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Wenn hier $i gleich 0 ist, würde PHP alle print-Anweisungen
    ausführen. Ist $i gleich 1, würden die letzten beiden
    print-Befehle ausgeführt und wenn $i = 2 ist, würde nur der
    letzte print-Befehl ausgeführt. Deshalb ist es wichtig, bei
    der ersten gefundenen Übereinstimmung eine
    <literal>break</literal>-Anweisung zu setzen (abgesehen von
    bestimmten Fällen, wo genau dieses Verhalten gefordert wird).
   </simpara>
   <simpara>
    Bei einer <literal>switch</literal>-Anweisung wird die
    Bedingung also nur einmal überprüft und das Ergebnis mit jeder
    <literal>case</literal>-Anweisung verglichen. Bei einem
    <literal>elseif</literal>-Befehl wird die Bedingung neu geprüft.
    Eine <literal>switch</literal>-Anweisung kann schneller als
    mehrere <literal>if</literal>-Befehle sein, z.B. bei
    komplizierteren Bedingungen als einem einfachen Vergleich.
   </simpara>
   <para>
    Der Anweisungsteil von case kann auch leer sein. Dann wird
    die Kontrolle einfach an den nächsten case-Teil übergeben.
    <informalexample>
     <programlisting role="php">
switch ($i) {
    case 0:
    case 1:
    case 2:
        print "i ist kleiner als 3 aber nicht negativ";
        break;
    case 3:
        print "i ist gleich 3";
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    Ein Spezialfall ist die Anweisung default. Diese trifft
    auf alles zu, was nicht von den voranstehenden case-Ausdrücken
    erfasst wurde, wie z.B.:
    <informalexample>
     <programlisting role="php">
switch ($i) {
    case 0:
        print "i ist gleich 0";
        break;
    case 1:
        print "i ist gleich 1";
        break;
    case 2:
        print "i ist gleich 2";
        break;
    default:
        print "i ist weder 0, 1 noch 2";
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    Der <literal>case</literal>-Ausdruck kann eine Prüfung einfacher
    Typen sein, also von Integer- oder Fließkomma-Zahlen oder von
    Strings / Zeichenketten. Arrays oder Objekte können nicht benutzt
    werden, es sei denn, sie werden auf einfache Typen herunter
    gebrochen.
   </para>
   <para>
    Die alternative Syntax gilt auch für switch-Sequenzen. Mehr
    Informationen dazu unter <link
    linkend="control-structures.alternative-syntax">Alternative Syntax
    für Kontroll-Strukturen</link> .
    <informalexample>
     <programlisting role="php">
switch ($i):
    case 0:
        print "i ist gleich 0";
        break;
    case 1:
        print "i ist gleich 1";
        break;
    case 2:
        print "i ist gleich 2";
        break;
    default:
        print "i ist weder 0, 1 noch 2";
endswitch;
     </programlisting>
    </informalexample>
   </para>
  </sect1>
  
  <sect1 id="function.require">
   <title><function>require</function></title>
   <simpara>
    Der <function>require</function>-Befehl setzt an seine Stelle
    den Inhalt der angegebenen Datei (ähnlich dem #include von C).
   </simpara>
   <simpara>
    Wichtig: PHP kehrt zu Beginn der per <function>include</function>
    oder <function>require</function> eingebundenen Dateien vom
    PHP- in den HTML-Modus und am Schluß der Datei wieder vom 
    HTML- in den PHP-Modus zurück. Falls innerhalb dieser Dateien also
    PHP-Code ausgeführt werden soll, muss dieser eingeschlossen werden
    von gültigen PHP-Start- und PHP-Ende-Marken (siehe 
    <link linkend="language.basic-syntax.phpmode">gültige PHP-Start- und
    Ende-Tags</link>).
   </simpara>
   <simpara>
    <function>Require</function> ist keine PHP-Anweisung, sondern
    eine spezielle Sprachanweisung. Sie ist anderen Regeln
    unterworfen als Funktionen. Einerseits unterliegt sie keinen
    Kontroll-Srukturen, andererseits gibt sie keinen Wert zurück.
    Der Versuch, von einem <function>require</function>-Aufruf einen
    Rückgabewert zu erhalten, führt zu einem Parse-Fehler.
   </simpara>
   <simpara>
    Anders als <function>include</function> wird
    <function>require</function> <emphasis>immer</emphasis> die
    angegebene Datei einlesen, <emphasis>auch dann, wenn die
    Programmzeile, in der sie steht, nicht ausgeführt wird.</emphasis>
    Wenn sie eine Datei nur bedingt einlesen wollen, benutzen sie
    <function>include</function>. Die bedingte Anweisung würde
    <function>require</function> nicht davon abhalten, die Datei zu
    laden.
   </simpara>
   <simpara>
    Innerhalb von Schleifen tritt der Effekt auf, dass, obwohl die den
    <function>require</function>-Befehl enthaltende Zeile mehrfach
    angesprungen wird, die entsprechende Datei trotzdem nur genau
    einmal eingelesen (ausgeführt) wird.
   </simpara>
   <para>
    Sie können also <function>require</function> nicht innerhalb von
    Programm-Schleifen einsetzen. Deshalb, und wenn sie verschiedene
    Dateien einlesen wollen, müssen sie in Schleifen den Befehl
    <function>include</function> benutzen.
    <informalexample>
     <programlisting role="php">
require ('header.inc');
     </programlisting>
    </informalexample>
   </para>
   <para>
    Beachten sie, dass sowohl <function>include</function> als auch
    <function>require</function> den Inhalt der angegebenen Datei in
    das Skript nur 1:1 einlesen. Sie kann weder über HTTP noch sonstwie
    eingelesen werden. Jede vor dem Einbinden der Datei definierte
    Variable ist innerhalb dieser Datei verfügbar, da sie Teil des
    umgebenden Skripts wird.
    <informalexample>
     <programlisting role="php">
require ("file.inc?vareins=1&amp;varzwei=2"); /* Funkt. nicht. */

$vareins = 1;
$varzwei = 2;
/* $vareins und $varzwei sind in file.inc verfügbar */ 
require ("file.inc");
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Lassen sie sich nicht durch die Tatsache irre führen, dass sie 
    Dateien über HTTP anfordern oder einbinden können (siehe <link
    linkend="features.remote-files">Remote files</link>-Funktionalität).
    Die obigen Angaben gelten dennoch.
   </simpara>
   <simpara>
    In PHP3 ist es möglich, eine <literal>return</literal>-Anweisung
    innerhalb einer per <function>require</function> eingebundenen Datei
    auszuführen, solange diese Anweisung im Hauptteil dieser Datei steht.
    Die <literal>return</literal>-Anweisung darf nicht in Blöcken (also
    innerhalb von geschwungenen Klammern "{}" stehen. In PHP4 existiert
    diese Möglichkeit nicht mehr. Wenn sie diese dennoch benötigen, sehen
    sie unter <function>include</function> nach.
   </simpara>
  </sect1>
 
  <sect1 id="function.include">
   <title><function>include</function></title>
   <simpara>
    Die <function>include</function>-Anweisung liest die angegebene Datei
    ein und wertet sie aus.
   </simpara>
   <simpara>
    Wichtig ist, dass beim <function>include</function>- oder
    <function>require</function>-Befehl vom PHP-Parsing-Modus in den
    HTML-Modus geschaltet wird und bei Rückkehr in das aufrufende Skript
    wieder zurück vom HTML- in den PHP-Modus. Deshalb muss jeder
    PHP-Code innerhalb der eingebundenen Dateien umschlossen werden von
    <link linkend="language.basic-syntax.phpmode">gültigen
    PHP-Start- und Ende-Tags</link>.
   </simpara>
   <para>
    Das passiert jedes Mal, sobald die 
    <function>include</function>-Anweisung auftritt. Deshalb können sie
    <function>include</function> auch sehr gut innerhalb von Schleifen
    verwenden, um eine Anzahl unterschiedlicher Dateien einzubinden.
    <informalexample>
     <programlisting role="php">
$files = array ('first.inc', 'second.inc', 'third.inc');
for ($i = 0; $i < count($files); $i++) {
    include $files[$i];
}
     </programlisting>
    </informalexample>
   </para>
   <para>
    <function>Include</function> unterscheidet sich von
    <function>require</function> dadurch, dass die include-Anweisung
    jedesmal neu ausgewertet wird, sobald sie auftritt (und nur zur
    Ausführungszeit). Dagegen wird die
    <function>require</function>-Anweisung beim ersten Auftreten mit
    der angegebenen Datei ersetzt, egal ob sie einzubinden ist oder
    nicht (innerhalb von bedingten Anweisungen, z.B. bei
    <link linkend="control-structures.if">if</link> auch dann, wenn
    das ausgewertete Argument false ergeben hat).
   </para>
   <para>
    Da <function>include</function> ein spezieller Sprach-Konstrukt
    ist, müssen sie ihn innerhalb einer bedingten Anweisung in einen
    Anweisungsblock setzen.
    <informalexample>
     <programlisting role="php">
/* Das ist falsch und führt nicht zum gewünschten Ergebnis. */
 
if ($Bedingung)
    include($diesedatei);
else
    include($anderedatei);
 
/* Diese ist korrekt. */

if ($Bedingung) {
    include($diesedatei);
} else {
    include($anderedatei);
}
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Sowohl in PHP3 als auch in PHP4 ist es möglich, eine
    <literal>return</literal>-Anweisung innerhalb einer
    <function>include</function>eten Datei anzugeben, um die
    Ausführung dieser Datei abzubrechen und zum aufrufenden-Skript
    zurück zu kehren. Es gibt aber ein paar Unterschiede in der
    Arbeitsweise. Der erste ist, dass bei PHP3 die
    <literal>return</literal>-Anweisung nicht innerhalb eines Blocks
    auftreten darf, es sei denn, es ist ein Funktions-Block. In
    diesem Fall gilt <literal>return</literal> für diese Funktion
    und nicht für die ganze Datei. In PHP4 gibt es diese Beschränkung
    nicht. PHP4 erlaubt ihnen auch die Rückgabe von Werten bei
    <function>include</function>eten Dateien. Sie können den Wert des
    <function>include</function>-Aufrufs nutzen, als wenn sie eine 
    Funktion aufgerufen hätten. Das wird in PHP3 eine Parse-Error
    ergeben.
   </simpara>
   <example>
    <title><function>Include</function> in PHP3 und PHP4</title>
    <para>
     Beachten sie, dass die folgende Datei, genannt
     <filename>test.inc</filename>) im gleichen Verzeichnis wie die
     Hauptdatei stehen muss:
     <programlisting role="php">
&lt?php
echo "Vor dem Return &lt;br&gt;\n";
if (1) {
    return 27;
}
echo "Nach dem Return &lt;br&gt;\n";
?&gt;
     </programlisting>
    </para>
    <para>
     Die Datei <filename>main.html</filename> enthält folgendes:
     <programlisting role="php">
&lt?php
$retval = include ('test.inc');
echo "Datei gibt zurück: '$retval'&lt;br&gt;\n";
?&gt;
     </programlisting>
    </para>
    <para>
     Sobald <filename>main.html</filename> in PHP3 aufgerufen wird,
     wird ein Parse-Error in Zeile 2 angezeigt; sie können in PHP3
     also keinen Rückgabewert von <function>include</function>
     erhalten. In PHP4 wird das Ergebnis sein:
     <screen>
Vor dem Return
Datei gibt zurück: '27'
     </screen>
    </para>
    <para>
     Die Datei <filename>main.html</filename> soll nun folgendes 
     enthalten:
     <programlisting role="php">
&lt?php
include ('test.inc');
echo "Zurück in main.html&lt;br&gt;\n";
?&gt;
     </programlisting>
    </para>
    <para>
     In PHP4 wird die Ausgabe sein:
     <screen>
Vor dem Return
Zurück in main.html
     </screen>
     PHP3 wird dagegen folgendes ausgeben:
     <screen>
Vor dem Return
27Zurück in main.html

Parse error: parse error in /home/torben/public_html/phptest/main.html on line 5
     </screen>
    </para>
    <para>
     Der obige Parse-Error ist das Ergebnis der Tatsache, dass die
     <literal>return</literal>-Anweisung innerhalb eines
     Nicht-Funktions-Blocks von <filename>test.inc</filename> steht.
     Wenn das return ausserhalb diese Blocks zu stehen kommt, wird
     die Ausgabe wie folgt aussehen:
     <screen>
Before the return
27Back in main.html
     </screen>
    </para>
    <para>
     Die '27' entsteht aus der Tatsache, dass PHP3 keine solchen
     Rückgabewerte unterstützt.
    </para>
   </example>
   <para>
    Beachten sie, dass sowohl <function>include</function> als auch
    <function>require</function> den Inhalt der einzufügenden Datei
    an ihre eigene Stelle des Skripts setzen. Sie lesen diese Datei
    nicht über HTTP oder sonstiges ein. Deshalb ist jede in der
    Hauptdatei gesetzte Variable auch innerhalb der eingebundenen
    Datei vorhanden; sie ist ja Bestandteil dieser Datei geworden.
    <informalexample>
     <programlisting role="php">
include ("file.inc?vareins=1&amp;varzwei=2"); /* Funkt. nicht. */

$vareins = 1;
$varzwei = 2;
/* $vareins und $varzwei sind in file.inc verfügbar */
include ("file.inc");
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Lassen sie sich nicht durch die Tatsache irritieren, dass sie
    Dateien auch über HTTP per require oder include einbinden können
    (vgl. <link linkend="features.remote-files">Remote files</link>).
    Das oben Gesagte behält seine Gültigkeit.
   </simpara>
   <simpara>
    Siehe auch <function>readfile</function>,
    <function>require</function> und <function>virtual</function>.
   </simpara>
  </sect1>
 
 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
