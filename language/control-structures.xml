<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.39 $ -->
<!-- EN-Revision: 1.91 Maintainer: betz Status: ready -->
<!-- CREDITS: tzwenny -->

 <chapter id="language.control-structures">
  <title>Kontroll-Strukturen</title>
  <simpara>
   Jedes PHP-Skript besteht aus einer Reihe von Anweisungen. Eine Anweisung
   kann eine Zuweisung, ein Funktionsaufruf, eine Schleife, eine bedingte
   Anweisung oder ein Befehl sein, der nichts macht (eine leere Anweisung). 
   Jede Anweisung endet gewöhnlich mit einem Semikolon. Darüber hinaus können Anweisungen zu einer
   Anweisungsgruppe zusammengefasst werden, welche durch geschweifte Klammern
   begrenzt wird. Eine Anweisungsgruppe selbst ist auch wieder eine Anweisung.
   Die unterschiedlichen Arten von Anweisungen werden in diesem Kapitel
   erläutert.
  </simpara>

  <sect1 id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    Das <literal>if</literal>-Konstrukt ist eine der wichtigsten Möglichkeiten
    vieler Programmier-Sprachen, PHP eingeschlossen. Es erlaubt die bedingte
    Ausführung von Programmteilen. PHP kennt eine <literal>if</literal>
    -Struktur, die ähnlich wie in der Programmiersprache C implementiert ist:
    <informalexample>
     <programlisting>
<![CDATA[
<?php
  if (ausdr)
    Anweisung
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Wie im Abschnitt über
    <link linkend="language.expressions">Ausdrücke</link> beschrieben,
    wird <replaceable>ausdr</replaceable> auf seinen boolschen Wertinhalt
    ausgewertet. Wenn <replaceable>ausdr</replaceable> als &true; ausgewertet
    wird, führt PHP die <replaceable>Anweisung</replaceable> aus. Falls die
    Auswertung &false; ergibt, wird die <replaceable>Anweisung</replaceable>
    übergangen. Mehr Informationen drüber welche Werte als &false; ausgewertet
    werden finden Sie im Abschnitt
    <link linkend="language.types.boolean.casting">'Umwandlung nach boolean'</link>.
   </simpara>
   <para>
    Das folgende Beispiel wird <computeroutput>a ist größer als b
    </computeroutput>anzeigen, wenn <varname>$a</varname> größer als
    <varname>$b</varname> ist:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b)
    echo "a ist größer als b";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Oft werden Sie die bedingte Ausführung von mehr als einer
    Anweisung wollen. Selbstverständlich ist es nicht erforderlich,
    jede Anweisung mit einer <literal>if</literal>-Bedingung zu
    versehen. Statt dessen können Sie mehrere Anweisungen in Gruppen
    zusammenfassen. Der folgende Programm-Code wird zum Beispiel
    <computeroutput>a ist größer als b</computeroutput> anzeigen,
    wenn <varname>$a</varname> größer als <varname>$b</varname> ist und
    danach wird der Wert von <varname>$a</varname> in <varname>$b</varname>
    gespeichert:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    print "a ist größer als b";
    $b = $a;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <literal>if</literal>-Anweisungen können beliebig oft innerhalb anderer
    <literal>if</literal>-Anweisungen definiert werden. Das ermöglicht
    ihnen völlige Flexibilität bei der bedingten Ausführung verschiedenster
    Programmteile.
   </simpara>
  </sect1>
 
  <sect1 id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
    Häufig möchten Sie eine Anweisung auszuführen, wenn eine
    bestimmte Bedingung erfüllt ist und eine andere Anweisung, falls
    sie nicht erfüllt ist. Dafür gibt es <literal>else</literal>.
    <literal>else</literal> erweitert eine <literal>if</literal>-Anweisung um
    die Ausführung von Anweisungen, sobald der Ausdruck der
    <literal>if</literal>-Anweisung als &false; ausgewertet wird. Der folgende
    Code wird z.B. <computeroutput>a ist größer als b</computeroutput>
    ausgeben, wenn <varname>$a</varname> größer als <varname>$b</varname> ist,
    anderenfalls <computeroutput>a ist NICHT größer als b</computeroutput>:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    print "a ist größer als b";
} else {
    print "a ist NICHT größer als b";
}
?>
]]>
     </programlisting>
    </informalexample>
    Die <literal>else</literal>-Anweisung wird nur ausgeführt, wenn
    der <literal>if</literal>-Ausdruck als &false;
    ausgewertet wurde und wenn bei vorhandenen
    <literal>elseif</literal>-Ausdrücken diese ebenfalls
    &false; sind (siehe <link
    linkend="control-structures.elseif">elseif</link>).
   </para>
  </sect1>
 
  <sect1 id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
    Wie der Name schon sagt ist <literal>elseif</literal> eine
    Verbindung von <literal>if</literal> und <literal>else</literal>.
    Wie <literal>else</literal> erweitert sie eine
    <literal>if</literal>-Anweisung um die Ausführung anderer Anweisungen,
    sobald die normale <literal>if</literal>-Bedingung als &false; ausgewertet
    wird. Anders als bei <literal>else</literal> wird die Ausführung dieser alternativen
    Anweisungen nur durchgeführt, wenn die bei <literal>elseif</literal>
    angegebene alternative Bedingung als &true; ausgewertet wird. Der folgende
    Code wird z.B. <computeroutput>a ist größer als b</computeroutput>,
    <computeroutput>a ist gleich b</computeroutput> oder
    <computeroutput>a ist kleiner als b</computeroutput> ausgeben:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a ist größer als b";
} elseif ($a == $b) {
    echo "a ist gleich b";
} else {
    echo "a ist kleiner als b";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Es kann mehrere <literal>elseif</literal>-Anweisungen innerhalb
    einer <literal>if</literal>-Anweisung geben. Die erste
    <literal>elseif</literal>-Bedingung (falls vorhanden), die &true; ist,
    wird ausgeführt. In PHP kann man auch 'else if' schreiben (zwei Wörter).
    Das Verhalten ist identisch zu 'elseif' (ein Wort). Die Bedeutung der
    Syntax ist leicht unterschiedlich (falls Sie mit C vertraut sind, das ist
    das gleiche Verhalten) aber der Grundtenor ist der, dass beide
    Schreibweisen, bezogen auf das Ergebnis, sich exakt gleich verhalten.
   </simpara>
   <simpara>
    Die <literal>elseif</literal>-Anweisung wird nur ausgeführt, wenn die
    vorausgehende <literal>if</literal>-Bedingung sowie jede vorherige
    <literal>elseif</literal>-Bedingung als &false; ausgewertet wird und die
    aktuelle <literal>elseif</literal>-Bedingung &true; ist.
   </simpara>
  </sect1>
 
  <sect1 id="control-structures.alternative-syntax">
   <title>Alternative Syntax für Kontroll-Strukturen</title>
   <para>
    PHP bietet eine alternative Syntax für einige seiner Kontroll-Strukturen,
    als da sind <literal>if</literal>, <literal>while</literal>,
    <literal>for</literal>, <literal>foreach</literal> und
    <literal>switch</literal>. Die öffnende Klammer muss immer durch einen
    Doppelpunkt ":" und die schließende Klammer entsprechend durch
    <literal>endif;</literal>, <literal>endwhile;</literal>,
    <literal>endfor;</literal>, <literal>endforeach;</literal>
    oder <literal>endswitch;</literal> ersetzt werden.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php if ($a == 5): ?>
A ist gleich 5
<?php endif; ?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Im obigen Beispiel ist der HTML-Bereich "A ist gleich 5" in eine
    <literal>if</literal>-Anweisung mit alternativer Syntax eingebettet. Der
    HTML-Bereich wird nur ausgegeben, wenn <varname>$a</varname> gleich 5 ist.
   </simpara>
   <para>
    Die alternative Syntax kann auch auf <literal>else</literal> und
    <literal>elseif</literal> angewendet werden. Es folgt eine
    <literal>if</literal>-Struktur mit <literal>elseif</literal>
    und <literal>else</literal> im alternativen Format:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a == 5):
    echo "a ist gleich 5";
    echo "...";
elseif ($a == 6):
    echo "a ist gleich 6";
    echo "!!!";
else:
    echo "a ist weder 5 noch 6";
endif;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Siehe auch <link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link> und <link
    linkend="control-structures.if">if</link> für weitere Beispiele.
   </para>
  </sect1>

  <sect1 id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
    Die <literal>while</literal>-Schleifen sind die einfachste Form von
    Schleifen in PHP. Sie funktionieren genau wie in C. Die Grundform einer
    <literal>while</literal>-Anweisung lautet:
    <informalexample>
     <programlisting>
<![CDATA[
while (ausdr) Anweisung
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Die Bedeutung einer <literal>while</literal>-Anweisung ist einfach.
    Sie weist PHP an, einen in ihr eingebetteten Befehl so lange zu
    wiederholen, wie die <literal>while</literal>-Bedingung als &true;
    ausgewertet wird. Der Wert der Bedingung wird immer am Anfang der
    Schleife geprüft. Wird der Wert während der Ausführung der Anweisungen
    innerhalb der <literal>while</literal>-Schleife verändert, endet die
    Ausführung dieses Anweisungsblocks erst mit dem Ende der Iteration
    (Jeder Schleifendurchlauf ist eine Iteration). Falls die
    <literal>while</literal>-Bedingung bereits beim ersten Mal &false; ist,
    werden die Anweisungen der <literal>while</literal>-Schleife nicht ein
    einziges Mal durchlaufen.
   </simpara>
   <para>
    Wie bei der <literal>if</literal>-Anweisung können Sie mehrere
    Anweisungen innerhalb der gleichen <literal>while</literal>-Schleife
    angeben, indem Sie dieses mit geschweiften Klammern umschließen oder die
    alternative Syntax verwenden:
    <informalexample>
     <programlisting>
<![CDATA[
while (ausdr): Anweisung ... endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Die folgenden Beispiele sind identisch; beide geben Zahlen von
    1 bis 10 aus:
    <informalexample>
     <programlisting>
<![CDATA[
/* Beispiel 1 */

$i = 1;
while ($i <= 10) {
    echo $i++;  /* es wird erst $i ausgegeben, bevor der Wert erhöht wird
                  (Post-Inkrement) */
}
 
/* Beispiel 2 */
 
$i = 1;
while ($i <= 10):
    echo $i;
    $i++;
endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
  <sect1 id="control-structures.do.while">
   <title><literal>do..while</literal></title>
   <simpara>
    <literal>do..while</literal>-Schleifen sind den <literal>while</literal>
    -Schleifen sehr ähnlich, außer dass der Wahrheitsgehalt des Ausdrucks erst
    am Ende jedes Durchlaufs geprüft wird, statt am Anfang. Der Hauptunterschied
    zu gewöhnlichen <literal>while</literal>-Schleifen ist der, dass die Schleife
    bei <literal>do..while</literal> in jeden Fall einmal durchlaufen wird
    (die Bedingung wird erst am Ende eines Durchlaufs geprüft).Bei
    <literal>while</literal>-Schleifen hingegen kann es durchaus passieren,
    dass die Schleife nie durchlaufen wird (die Bedingung wird immer am Anfang
    eines Durchlaufs überprüft. Wird diese Bedingung von Anfang an als &false;
    ausgewertet endet die Ausführung der Schleife sofort).
   </simpara>
   <para>
    Es gibt nur eine Syntax für <literal>do..while</literal>-Schleifen:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$i = 0;
do {
    echo $i;
} while ($i>0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Die obige Schleife wird genau einmal durchlaufen, da nach der
    ersten Wiederholung die Erfüllung der Bedingung geprüft wird. Diese
    Bedingung ist aber nicht erfüllt ($i ist nicht größer als 0), wird als
    &false; ausgewertet, und die Schleifenausführung beendet.
   </simpara>
   <para>
    Erfahrene C-Anwender kennen auch die Möglichkeit, Programm-Blöcke
    mit <literal>do..while</literal> (0) einzuschliessen und dann die
    <link linkend="control-structures.break"><literal>break</literal></link>
    Anweisung zu benutzen. Der folgende Programm-Ausschnitt zeigt diese
    Möglichkeit:
    <informalexample>
     <programlisting role="php">
<![CDATA[
do {
    if ($i < 5) {
        echo "i ist nicht groß genug";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
    echo "i ist ok";

    /* mach was mit i */

} while (0);
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Es ist nicht weiter tragisch, wenn Sie dieses Beispiel nicht
    oder nur zum Teil verstehen. Sie können auch ohne dieses
    'Feature' effektive PHP-Programme und Skripte schreiben.
   </simpara>
  </sect1>
 
  <sect1 id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
    Die <literal>for</literal>-Schleifen sind die komplexesten Schleifen in
    PHP. Sie funktionieren wie ihr Gegenstück in C. Die Syntax einer
    <literal>for</literal>-Schleife sieht wie folgt aus:
    <informalexample>
     <programlisting>
<![CDATA[
for (ausdr1; ausdr2; ausdr3) Anweisung
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Der erste Ausdruck (<varname>ausdr1</varname>) wird beim
    Schleifenbeginn (ohne jegliche Vorbedingung) geprüft bzw. ausgeführt.
   </simpara>
   <simpara>
    Zu Beginn jedes Durchlaufs wird nun <varname>ausdr2</varname>
    geprüft. Wenn dieser &true; ist, fährt die Schleife mit der Ausführung der
    nachfolgenden Anweisung(en) fort. Ist das Ergebnis &false;, wird die
    Schleife beendet.
   </simpara>
   <simpara>
    Am Ende jedes Durchlaufs wird <varname>ausdr3</varname> geprüft
    (ausgeführt).
   </simpara>
   <simpara>
    Jeder Ausdruck kann leer sein. Ist <varname>ausdr2</varname> leer,
    wird die Schleife endlos oft durchlaufen (PHP wertet diesen, wie in C,
    implizit als &true;). Das ist gar nicht so sinnlos, wie Sie vielleicht
    zunächst glauben, weil man häufig eine Schleife erst durch eine bedingte
    <link linkend="control-structures.break"><literal>break</literal>
    </link>-Anweisung statt durch eine unwahr werdende
    <literal>for</literal>-Bedingung beenden möchte.
   </simpara>
   <para>
    Beachten Sie die folgenden Beispiele. Alle geben Zahlen von 1 bis
    10 aus:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Beispiel 1 */

for ($i = 1; $i <= 10; $i++) {
    echo $i;
}

/* Beispiel 2 */
 
for ($i = 1; ; $i++) {
    if ($i > 10) {
        break;
    }
    echo $i;
}
 
/* Beispiel 3 */

$i = 1;
for (; ; ) {
    if ($i > 10) {
        break;
    }
    echo $i;
    $i++;
}

/* Beispiel 4 */

for ($i = 1; $i <= 10; echo $i, $i++);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Selbstverständlich sieht das erste (oder vielleicht das vierte) Beispiel
    am besten aus, aber Sie werden noch feststellen, dass es oftmals ganz
    nützlich sein kann, leere Parameter in <literal>for</literal>-Schleifen zu
    verwenden.
   </simpara>
   <para>
    PHP unterstützt auch bei <literal>for</literal>-Schleifen die
    alternative "Doppelpunkt-Syntax".
    <informalexample>
     <programlisting>
<![CDATA[
for (ausdr1; ausdr2; ausdr3): Anweisung; ...; endfor;
]]>
     </programlisting>
     </informalexample>
   </para>
   <para>
    Andere Sprachen haben für das Durchlaufen eines Hashs oder Arrays eine
    <literal>foreach</literal>-Anweisung. PHP 3 hat dies nicht; im Gegensatz
    zu PHP 4 (vgl.
    <link linkend="control-structures.foreach">foreach</link>).
    In PHP 3 können Sie für diesen Zweck
    <link linkend="control-structures.while">while</link> mit der
    <function>list</function>- und <function>each</function>-Funktion
    kombinieren. Beispiele finden Sie in der Dokumentation zu diesen
    Funktionen.
   </para>
  </sect1>

  <sect1 id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
    PHP 4 (nicht PHP 3) enthält ein <literal>foreach</literal> Konstrukt,
    genau wie Perl und einige andere Sprachen. Diese ermöglicht es, auf
    einfache Weise ein Array zu durchlaufen. <literal>foreach</literal>
    funktioniert nur in Verbindung mit Arrays. Wenn Sie versuchen
    <literal>foreach</literal> mit Variablen eines anderen Datentyps oder
    nicht initialisierten Variablen zu benutzen, gibt PHP einen Fehler aus. Es
    gibt zwei Syntaxformen; die zweite ist eine unbedeutende, aber sinnvolle
    Erweiterung der ersten Syntax:
    <informalexample>
     <programlisting>
<![CDATA[
foreach (array_expression as $value) Anweisung
foreach (array_expression as $key => $value) Anweisung
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Die erste Form durchläuft das <literal>array_expression</literal>-Array.
    Bei jedem Durchgang wird der Wert des aktuellen Elements
    <literal>$value</literal> zugewiesen und der interne Array-Zeiger um eins
    erhöht. Dadurch wird beim nächsten Durchgang automatisch das nächste
    Element ausgewertet.
   </simpara>
   <simpara>
    Die zweite Form arbeitet genauso, außer dass bei jedem Durchlauf
    auch der aktuelle Schlüssel der Variablen <literal>$key</literal>
    zugewiesen wird.
   </simpara>
   <para>
    <note>
     <para>
      Sobald <literal>foreach</literal> zum ersten Mal ausgeführt wird,
      wird der interne Arrayzeiger automatisch auf das erste Element
      des Arrays gesetzt. Das bedeutet, dass Sie vor einem Durchlauf
      von <literal>foreach</literal> <function>reset</function> nicht
      aufrufen müssen.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      Beachten Sie auch, dass <literal>foreach</literal> mit einer
      Kopie des angegebenen Arrays arbeitet, nicht mit dem Array selbst.
      Deshalb wird auch der Arrayzeiger nicht wie bei dem
      <function>each</function>-Konstrukt verändert und Veränderungen an
      ausgegebenen Arrayelementen haben keine Auswirkung auf das originale
      Array. Trotzdem <emphasis>wird</emphasis> der interne Arrayzeiger
      des originalen Arrays bei der Verarbeitung bewegt. Angenommen, die
      foreach-Schleife ist komplett abgearbeitet, wird der interne
      Arrayzeiger (des originalen Arrays) auf das letzte Element zeigen.
     </para>
    </note>
   </para>
   <note>
    <para>
     Bei <literal>foreach</literal> ist es nicht möglich Fehlermeldungen durch
     den Gebrauch von '@' zu unterdrücken ist 
    </para>
   </note>
   <para>
    Beachten Sie, dass die folgenden Beispiele in ihrer Funktionalität
    identisch sind:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("eins", "zwei", "drei");
reset ($arr);
while (list(, $value) = each ($arr)) {
    echo "Wert:  $value<br />\n";
}

foreach ($arr as $value) {
    echo "Wert:  $value<br />\n";
}
?>
]]>
     </programlisting>
    </informalexample>
    Auch hier funktioniert alles gleich:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("eins", "zwei", "drei");
reset ($arr);
while (list($key, $value) = each ($arr)) {
    echo "Schlüssel: $key; Wert: $value<br />\n";
}

foreach ($arr as $key => $value) {
    echo "Schlüssel: $key; Wert: $value<br />\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Noch einige Beispiele, die die Anwendung verdeutlichen:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* foreach Beispiel 1: Nur der Wert */

$a = array(1, 2, 3, 17);

foreach ($a as $v) {
   echo "Aktueller Wert von \$a: $v.\n";
}

/* foreach Beispiel 2:
Wert (mit Ausgabe des Arrayschlüssels zur Veranschaulichung) */

$a = array(1, 2, 3, 17);

$i = 0; /* nur zu Veranschaulichung */

foreach($a as $v) {
    echo "\$a[$i] => $v.\n";
    $i++;
}

/* foreach Beispiel 3: Schlüssel und Wert */

$a = array(
    "eins" => 1,
    "zwei" => 2,
    "drei" => 3,
    "siebzehn" => 17
);

foreach($a as $k => $v) {
    echo "\$a[$k] => $v.\n";
}

/* foreach Beispiel 4: multidimensionale Arrays */

$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach($a as $v1) {
    foreach ($v1 as $v2) {
        echo "$v2\n";
    }
}

/* foreach Beispiel 5: dynamische Arrays */

foreach (array(1, 2, 3, 4, 5) as $v) {
    echo "$v\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
  <sect1 id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
    <literal>Break</literal> bricht die Ausführung der aktuellen
    <literal>for</literal>, <literal>foreach</literal>
    <literal>while</literal>, <literal>do..while</literal> Schleife oder einer
    <literal>switch</literal> Anweisungssequenz ab.
   </simpara>
   <simpara>
    Einem <literal>break</literal> kann optional ein nummerisches
    Argument angehängt werden, das die Anzahl der abzubrechenden
    Befehlssequenzen enthält.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array('eins', 'zwei', 'drei', 'vier', 'stop', 'fünf');
while (list ( , $val) = each ($arr)) {
    if ($val == 'stop') {
        break;  /* Sie könnten hier auch 'break 1;' schreiben. */
    }
    echo "$val<br />\n";

/* Benutzung des optionalen Argumentes. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "Bei 5<br />\n";
        break 1;  /* Beendet nur switch. */
    case 10:
        echo "Bei 10; aussteigen<br />\n";
        break 2;  /* Beendet switch und while. */
    default:
        break;
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 
  <sect1 id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
    <literal>continue</literal> wird innerhalb von Schleifen verwendet. Die
    Schleife wird an der aktuellen Stelle abgebrochen und es wird der nächste
    Durchlauf begonnen.
   </simpara>
   <note>
    <simpara>
     Beachten Sie, dass in PHP die 
     <link linkend="control-structures.switch">switch</link> Anweisung
     als Schleifenstruktur zum Zweck von <literal>continue</literal> angesehen
     wird.
    </simpara>
   </note>
   <simpara>
    Bei <literal>continue</literal> können Sie ein optionales nummerisches
    Argument mitgeben, das angibt, wie viele Ebenen von enhaltenen Schleifen
    übersprungen werden sollen.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
while (list ($key, $value) = each ($arr)) {
    if (!($key % 2)) { // überspringe ungerade Werte
        continue;
    }
    tue_was_mit_ungerade ($value);
}

$i = 0;
while ($i++ < 5) {
    echo "Außen<br />\n";
    while (1) {
        echo "&nbsp;&nbsp;Mitte<br />\n";
        while (1) {
            echo "&nbsp;&nbsp;Innen<br />\n";
            continue 3;
        }
        echo "Das wird nie ausgegeben.<br />\n";
    }
    echo "Das hier auch nicht.<br />\n";
}
?>
]]>
     </programlisting>
     </informalexample>
    </para>
    <para>
     Lassen Sie das Semikolon nach <literal>continue</literal> weg, kann dies
     zu verwirrenden Ergebnissen führen. Es folgt ein Beispiel wie Sie es
     nicht machen sollten.
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
  for ($i = 0; $i < 5; ++$i) {
      if ($i == 2)
          continue
      print "$i\n";
  }
?>
]]>
      </programlisting>
      <para>
       Sie könnten erwarten, dass das Ergebnis wie folgt aussieht,
      </para>
      <screen>
<![CDATA[
0
1
3
4
]]>
      </screen>
      <para>
       aber tatsächlich sieht die Ausgabe so aus,
      </para>
      <screen>
<![CDATA[
2
]]>
      </screen>
      <para>
       weil der Rückgabewert von <function>print</function>
       <literal>int(1)</literal> ist und das wird als das oben angesprochene
       optinale Argument gewertet.
      </para>
     </informalexample>
    </para>
  </sect1>

  <sect1 id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    Die <literal>switch</literal>-Anweisung ist gleichbedeutend einer
    Reihe von <literal>if</literal>-Anweisungen mit dem gleichen Parameter.
    Häufig wollen Sie ein und dieselbe Variable (bzw. den selben Ausdruck)
    mit verschiedensten Werten vergleichen und in Abhängigkeit vom 
    Auswertungsergebnis verschiedene Programmteile ausführen. Genau
    das ermöglicht die <literal>switch</literal>-Anweisung.
   </simpara>
   <note>
    <simpara>
     Beachten Sie bitte, dass im Unterschied zu anderen Programmiersprachen
     die <link linkend="control-structures.continue">continue</link>
     Anweisung auch bei switch ihre Gültigkeit hat und ähnlich wie
     <literal>break</literal> funktioniert. Falls Sie switch innerhalb einer
     Schleife verwenden und mit dem nächsten Durchlauf der äußeren Schleife
     beginnen möchten, verwenden Sie <literal>continue 2</literal>.
    </simpara>
   </note>
   <para>
    Das folgende Beispiele zeigt Ihnen zwei verschiedene Möglichkeiten auf,
    das Gleiche zu erreichen. Einmal werden <literal>if</literal> und
    <literal>elseif</literal> Anweisungen benutzt, das andere Mal eine
    <literal>switch</literal>-Anweisung:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($i == 0) {
    echo "i ist gleich 0";
} elseif ($i == 1) {
    echo "i ist gleich 1";
} elseif ($i == 2) {
    echo "i ist gleich 2";
}

switch ($i) {
case 0:
    echo "i ist gleich 0";
    break;
case 1:
    echo "i ist gleich 1";
    break;
case 2:
    echo "i ist gleich 2";
    break;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Es ist wichtig, die Ausführung einer <literal>switch</literal>-Anweisung
    zu verstehen, um Fehler zu vermeiden. Die <literal>switch</literal>-Anweisung
    wird Zeile für Zeile (also Anweisung für Anweisung) abgearbeitet. Zu
    Beginn wird kein Code ausgeführt. Erst wenn bei einem
    <literal>case</literal>-Teil eine Entsprechung zum
    <literal>switch</literal>-Ausdruck vorliegt, werden die darin enthaltenen
    Anweisungen von PHP ausgeführt. PHP fährt dann mit der Abarbeitung des
    restlichen Codes innerhalb des <literal>switch</literal>-Blocks fort oder
    bis zum ersten Auftreten einer <literal>break</literal>-Anweisung. Ohne
    <literal>break</literal> am Ende eines case-Teils werden also
    noch die folgenden case-Blöcke ausgeführt. Zum Beispiel:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
    echo "i ist gleich 0";
case 1:
    echo "i ist gleich 1";
case 2:
    echo "i ist gleich 2";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Wenn hier <varname>$i</varname> gleich 0 ist, würde PHP alle echo
    Anweisungen ausführen! Ist <varname>$i</varname> gleich 1, werden die
    letzten beiden echo Anweisungen ausgeführt. Nur wenn <varname>$i</varname>
    gleich 2 ist, erhalten Sie das erwartete Ergebnis: die Ausgabe von
    "i ist gleich 2". Deshalb ist es wichtig <literal>break</literal>-Anweisungen
    zu setzen (abgesehen von bestimmten Fällen, in denen Sie diese mit Absicht
    weglassen).
   </simpara>
   <simpara>
    Bei einer <literal>switch</literal>-Anweisung wird die Bedingung also nur
    einmal überprüft und das Ergebnis mit jeder <literal>case</literal>-Anweisung
    verglichen. Bei einer <literal>elseif</literal>-Anweisung wird die
    Bedingung neu geprüft. Ist ihre Bedingung komplizierter als ein einfacher
    Vergleich und/oder in einer umfangreichen Schleife eingebettet, kann eine
    <literal>switch</literal>-Anweisung schneller sein.
   </simpara>
   <para>
    Der Anweisungsteil von case kann auch leer sein. Dann wird die Kontrolle
    einfach an den nächsten case-Teil übergeben.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
case 1:
case 2:
    echo "i ist kleiner als 3 aber nicht negativ";
    break;
case 3:
    echo "i ist gleich 3";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Ein Spezialfall ist <literal>default</literal>. Dieser Fall trifft
    auf alles zu, was nicht von den voranstehenden case-Ausdrücken
    erfasst wurde und sollte als letzte <literal>case</literal> Anweisung
    angegeben werden. Zum Beispiel:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
    echo "i ist gleich 0";
    break;
case 1:
    echo "i ist gleich 1";
    break;
case 2:
    echo "i ist gleich 2";
    break;
default:
    echo "i ist weder 0, 1 noch 2";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Der <literal>case</literal>-Ausdruck kann eine Prüfung einfacher Typen
    sein, also von Integer- oder Fließkomma-Zahlen oder von
    Strings/Zeichenketten. Arrays oder Objekte können nicht benutzt werden, es
    sei denn, sie wurden in einfache Typen umgewandelt.
   </para>
   <para>
    Die alternative Syntax der Kontrollstrukturen gilt auch für
    switch-Sequenzen. Mehr Informationen dazu erhalten Sie unter <link
    linkend="control-structures.alternative-syntax">Alternative Syntax
    für Kontroll-Strukturen</link>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i):
case 0:
    echo "i ist gleich 0";
    break;
case 1:
    echo "i ist gleich 1";
    break;
case 2:
    echo "i ist gleich 2";
    break;
default:
    echo "i ist weder 0, 1 noch 2";
endswitch;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.declare">
   <title><literal>declare</literal></title>
   <para>
    Das Sprachkonstrukt <literal>declare</literal> wird dazu verwendet, um
    Ausführungsdirektiven für einen Codeblock anzugeben.
    Die Schreibweise von <literal>declare</literal> ist der anderer
    Kontrollstrukturen ähnlich:
    <informalexample>
     <programlisting>
<![CDATA[
declare (Direktive) Anweisung
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Die <literal>Direktive</literal> gibt Ihnen die Möglichkeit, das
    Verhalten des <literal>declare</literal>-Blocks zu bestimmen.
    Zur Zeit wird nur eine Direktive unterstützt: die <literal>ticks</literal>
    (Weiter unten finden Sie mehr Informationen zu den
    <link linkend="control-structures.declare.ticks">ticks</link>).
   </para>
   <para>
    Der <literal>Anweisung</literal>steil des <literal>declare</literal>-Blocks
    wird ausgeführt - wie genau diese Ausführung passiert und welche
    Nebeneffekte während der Ausführung auftreten, hängt von der Direktive ab,
    die Sie im <literal>directive</literal>-Block angegeben haben.
   </para>
   <para>
    Das <literal>declare</literal> Konstrukt kann auch im globalen
    Geltungsbereich benutzt werden und gilt dann für den folgenden Code.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// bewirkt das Gleiche:

// sie können declare so benutzen:
declare(ticks=1) {
    // hier folgt Ihr ganzes Skript
}

// oder wie hier:
declare(ticks=1);
// hier folgt Ihr ganzes Skript
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <sect2 id="control-structures.declare.ticks">
    <title>Ticks</title>
    <para>
     Ein tick ist ein Ereigniss, das bei jedem <varname>N</varname>-ten
     Autreten der low-level Anweisungen innerhalb des
     <literal>declare</literal> Blocks, die vom Parser ausgeführt werden,
     auftritt. Der Wert von <varname>N</varname> wird durch die
     Angabe von <literal>ticks=<varname>N</varname></literal>
     innerhalb des <literal>declare</literal>-Blocks in dem
     <literal>directive</literal> Abschnitt bestimmt.
    </para>
    <para>
     Das Ereignis/die Ereignisse, die bei jedem tick eintreten, legen Sie mit
     der Funktion <function>register_tick_function</function> fest.
     Weitere Einzelheiten können Sie dem Beispiel unten entnehmen. Beachten
     Sie, dass mehr als ein Ereigniss für jeden tick eintreten kann.
    </para>
    <para>
     <example>
     <title>Profil eines Bereichs von PHP Code</title>
      <programlisting role="php">
<![CDATA[
<?php
// Funktion, die bei Aufruf die Zeit aufzeichnet
function profile($dump = FALSE)
{
    static $profile;

    // Rückgabe der gespeicherten Zeit aus profile, danach löschen
    if ($dump) {
        $temp = $profile;
        unset ($profile);
        return ($temp);
    }

    $profile[] = microtime ();
}

// Einen tick handler bestimmen
register_tick_function("profile");

// Funktion vor dem declare-Block initialisieren
profile();

// Ausführen eines Code-Blocks, jede 2te Anweisung löst einen tick aus

declare(ticks=2) {
    for ($x = 1; $x < 50; ++$x) {
        echo similar_text(md5($x), md5($x*$x)), "<br />;";
    }
}

// Ausgabe der gespeicherten Daten aus dem Profiler
print_r(profile (TRUE));
?>
]]>
      </programlisting>
     </example>
    Dieses Beispiel 'profiliert' den PHP Code der im 'declare'-Block steht,
    indem die Zeit festgehalten wird, zu der jede zweite low-level Anweisung
    im Codeblock ausgeführt wird. Diese Information können Sie dazu benutzen,
    langsame Bereiche innerhalb bestimmter Codesegmente zu identifizieren. Das
    gleiche Ziel können Sie auch mit anderen Methoden erreichen: die Benutzung
    von ticks ist bequemer und einfacher zu implementieren.
   </para>
   <simpara>
    Ticks sind gut für Debugging, einfaches Multitasking,
    Hintergrund I/O und viele andere Aufgaben geeignet.
   </simpara>
   <simpara>
    Siehe auch <function>register_tick_function</function> und
    <function>unregister_tick_function</function>.
   </simpara>
   </sect2>
  </sect1>

  <sect1 id="function.return">
   <title>return</title>
   <simpara>
    Wird die <function>return</function> Anweisung innerhalb einer Funktion
    aufgerufen, wird die Ausführung der Funktion sofort beendet und das
    Argument als Wert des Funktionsaufrufs zurückgegeben.
    <function>return</function> beendet auch die Ausführung einer
    <function>eval</function> Anweisung oder einer Skriptdatei.
   </simpara>
   <simpara>
    Erfolgt der Aufruf innerhalb des globalen Bereichs, wird die Ausführung
    des aktuellen Skripts beendet. Wurde das aktuelle Skript
    <function>include</function>ed oder <function>require</function>ed, wird
    die Kontrolle an das aufrufende Skript zurückgegeben. Wurde das
    aktuelle Skript <function>include</function>ed, wird der Wert, der
    <function>return</function> zugewiesen wurde, als Wert des Aufrufs
    von <function>include</function> zurückgegeben.
    Wird <function>return</function> innerhalb des Hauptskripts aufgerufen,
    wird die Ausführung beendet. Handelt es sich bei dem Skript um eine
    Datei, die über die Einträge
    <link linkend="ini.auto-prepend-file">auto_prepend_file</link>
    oder <link linkend="ini.auto-append-file">auto_append_file</link>
    in der &php.ini; aufgerufen wurde, wird die Ausführung dieses Skripts
    beendet.
   </simpara>
   <simpara>Weitere Informationen erhalten Sie im Abschnitt <link
   linkend="functions.returning-values">Rückgabewerte</link>.
   </simpara>
   <note>
    <simpara>
     Beachten Sie, dass <function>return</function> ein Sprachkonstrukt und
     keine Funktion ist. Die Klammern um ein Argument sind deshalb
     <emphasis>nur</emphasis> zwingend notwendig, wenn es sich um einen
     Ausdruck handelt, dessen Ergebnis zurückgegeben werden soll.
     Es ist gebräuchlich die Klammern wegzulassen, wenn eine Variable zurück
     gegeben soll.
    </simpara>
   </note>
  </sect1>

  <sect1 id="function.require">
   <title><function>require</function></title>
   <simpara>
    Die <function>require</function> Anweisung bindet die angegebene Datei ein
    und wertet diese aus.
   </simpara>
   <simpara>
    <function>require</function> bindet die angegebene Datei ein und führt
    diese aus. Genaue Informationen wie die Einbindung funktioniert ist in
    der Dokumentation für <function>include</function> beschrieben.
   </simpara>
   <simpara>
    <function>require</function> und <function>include</function> sind in
    jeder Hinsicht gleichwertig mit der einen Ausnahme: der Umgang mit
    Fehlern. <function>include</function> erzeugt ein
    <link linkend="internal.e-warning">Warning</link> während
    <function>require</function> in einem <link linkend="internal.e-error">
    Fatal Error</link> endet. Mit anderen Worten: scheuen Sie sich nicht,
    <function>require</function> zu benutzen, wenn Sie möchten, dass eine
    fehlende Datei die Ausführung ihres Skripts beendet.
    <function>include</function> verhält sich anders, ihr Skript wird
    weiterhin ausgeführt. Stellen Sie außerdem sicher, dass Sie einen gültigen
    <link linkend="ini.include-path">include_path</link> gesetzt haben.
   </simpara>
   <para>
    <example>
     <title>Grundlegende <function>require</function> Beispiele</title>
     <programlisting role="php">
<![CDATA[
<?php

require 'prepend.php';

require $somefile;

require ('somefile.txt');

?>
]]>
     </programlisting>
   </example>
   </para>
   <simpara>
    Weitere Beispiele finden Sie in der Dokumentation zu
    <function>include</function>.
   </simpara>
   <para>
    <note>
     <simpara>
      Für frühere Versionen als PHP 4.0.2 gilt folgendes:
      <function>require</function> wird immer versuchen die Zieldatei zu lesen,
      selbst wenn die Zeile in der die Anweisung steht, nie ausgeführt wird.
      Eine bedingte Anweisung hat keine Auswirkungen auf
      <function>require</function>. Wenn jedoch die Zeile in der
      <function>require</function> steht, nie ausgeführt wird, wird auch der
      Code der Zieldatei nie ausgeführt werden. Ähnliches gilt für
      Schleifenstrukturen, diese beeinflussen das Verhalten von
      <function>require</function> nicht. Obwohl der Code, der in der Zieldatei
      enthalten ist, zur Schleife gehört, wird <function>require</function>
      selbst nur einmal ausgeführt.
     </simpara>
    </note>
   </para>

   &note.language-construct;

   &warn.no-win32-fopen-wrapper;

<simpara>
    Siehe auch <function>include</function>, <function>require_once</function>,
    <function>include_once</function>, <function>eval</function>, 
    <function>file</function>, <function>readfile</function>, 
    <function>virtual</function> und <link linkend="ini.include-path">include_path</link>.
   </simpara>
  </sect1>

  <sect1 id="function.include">
   <title><function>include</function></title>
   <simpara>
    Die <function>include</function> Anweisung bindet die angegebene Datei ein
    und wertet diese aus.
   </simpara>
   <simpara>
    Die untenstehende Dokumentation gilt ebenso für
    <function>require</function>. Diese beiden Konstrukte sind in jeder
    Hinsicht gleichwertig mit der einen Ausnahme: der Umgang mit Fehlern.
    <function>include</function> erzeugt ein
    <link linkend="internal.e-warning">Warning</link> während 
    <function>require</function> in einem <link linkend="internal.e-error">
    Fatal Error</link> endet. Mit anderen Worten, verwenden Sie
    <function>require</function>, wenn Sie möchten, dass eine
    fehlende Datei die Ausführung ihres Skripts beendet.
    <function>include</function> verhält sich anders, ihr Skript wird
    weiterhin ausgeführt. Stellen Sie außerdem sicher, dass Sie einen gültigen
    <link linkend="ini.include-path">include_path</link> gesetzt
    haben. Beachten Sie, dass eine Parse Error in einer Datei, die mit require
    eingebunden wurde, die Ausführung ihre Skripts nicht unterbricht.
   </simpara>
   <simpara>
    Dateien die mit include eingebunden werden, werden zuerst im include_path
    relativ zum gegenwärtigen Arbeitsverzeichnis gesucht und danach im
    include_path relativ zum Verzeichnis des ausgeführten Skripts. Zur
    Veranschaulichung: Falls Ihr include_path <literal>.</literal> entspricht,
    ist das gegenwärtige Arbeitsverzeichnis
    <filename class="directory">/www/</filename>. Sie haben über include
    <filename>include/a.php</filename> eingebunden und in diesem Skript steht
    die Anweisung <literal>include "b.php"</literal>. In diesem Fall wird
    <filename>b.php</filename> zuerst im Verzeichnis
    <filename class="directory">/www/</filename> gesucht und danach im
    Verzeichnis <filename class="directory">/www/include/</filename>.
   </simpara>
   <simpara>
    Wenn eine Datei eingebunden wird, erbt der enthaltene Code den
    <link linkend="language.variables.scope">Geltungsbereich von Variablen</link>
    der Zeile in der die Anweisung steht. Ab dieser Zeile stehen alle verfügbaren
    Variablen in der aufgerufenen Datei im aufrufenden Skript zur Verfügung.
   </simpara>
   <para>
     <example>
      <title>Grundlegendes <function>include</function> Beispiel</title>
      <programlisting role="php">
<![CDATA[
vars.php
<?php

$color = 'grün';
$fruit = 'Apfel';

?>

test.php
<?php

echo "Ein $color $fruit"; // A

include 'vars.php';

echo "Ein $color $fruit"; // Ein grüner Apfel

?>
]]>
      </programlisting>
     </example>
   </para>
   <simpara>
    Steht include im aufrufenden Skript innerhalb einer Funktion, verhält sich
    der gesamte Code der aufgerufenen Datei genau so, als ob Sie diesen Code
    innerhalb dieser Funktion definiert hätten. Aus diesem Grund hat dieser
    Code den Geltungsbereich der Variablen dieser Funktion.
   </simpara>
   <para>
     <example>
     <title>Include innerhalb einer Funktion</title>
      <programlisting role="php">
<![CDATA[
<?php

function foo()
{
global $color;

    include 'vars.php';

    echo "Ein $color $fruit";
}

/* vars.php ist im Geltungsbereich von foo(),  *
 * d.h. $fruit steht außerhalb dieses Bereichs *
 * NICHT zur Verfügung. $color schon, da wir   *
 * diese Variable als global definiert haben  */

foo();                    // Ein grüner Apfel
echo "Ein $color $fruit";   // Ein grüner

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Beim Einbinden einer Datei wechselt der Parser vom PHP-Modus zu Beginn
    der Zieldatei in den HTML-Modus und kehrt am Ende der eingebunden
    Datei wieder in den PHP-Modus zurück. Deshalb muss jeglicher Code
    innerhalb der eingebundenen Datei, der als PHP-Code ausgeführt werden
    soll, von <link linkend="language.basic-syntax.phpmode">gültigen
    PHP-Start- und Ende-Tags</link> eingefaßt sein.
   </simpara>
   <simpara>
    Wenn "<link linkend="ini.allow-url-fopen">URL fopen wrappers</link>"
    in PHP aktiviert sind (in der Standardkonfiguration ist das der Fall)
    können Sie als Pfad der einzubindenden Datei auch eine URL (via HTTP oder
    anderen unterstützen Wrappern - eine Liste der unterstützen Protokolle
    finden Sie unter <xref linkend="wrappers"/>) statt einer lokalen
    Pfadangabe angeben. Falls der Zielserver die Zieldatei als PHP-Code
    interpretiert, können Sie an die einzubindende Datei Variablen in einem
    Request-String übergeben, genauso wie bei HTTP GET. Streng genommen ist
    das nicht das Gleiche, wie diese Datei einzubinden und diesem den
    Geltungsbereich des Vater-Skripts zu vererben; das Skript wird auf dem
    Remote-Server ausgeführt und danach wird das Ergebnis in das lokale Skript
    eingebunden.
   </simpara>
   &warn.no-win32-fopen-wrapper;
   <para>
    <example>
     <title><function>include</function> über HTTP</title>
     <programlisting role="php">
<![CDATA[
<?php

/* Dieses Beispiel geht davon aus, dass www.example.com so konfiguriert     *
 * ist, dass .php-Dateien geparst werden und keine .txt Dateien. Also meint *
 * 'Funkt' hier, dass die Variablen $foo und $bar innerhalb der             *
 * angeforderten Datei zur Verfügung stehen                                 */

// Funkt nicht; file.txt wird von www.example.com nicht als PHP geparst

include 'http://www.example.com/file.txt?foo=1&bar=2';

// Funkt nicht; schaut nach einer lokalen Datei namens
// 'file.php?foo=1&bar=2' im lokalen Dateisystem

include 'file.php?foo=1&bar=2';

// Funkt
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // Funkt
include 'file.php';  // Funkt

?>
]]>
     </programlisting>
    </example>
     Siehe auch <link linkend="features.remote-files">
     Zugriff auf entfernte Dateien</link>, <function>fopen</function> und
     <function>file</function> für verwandte Informationen.
   </para>
   <para>
    Da <function>include</function> und <function>require</function>
    spezielle Sprachkonstrukte sind, müssen Sie diese innerhalb einer
    bedingten Anweisung in einen Anweisungsblock setzen.
   </para>
   <para>
    <example>
     <title>include() und bedingte Blöcke</title>
     <programlisting role="php">
<![CDATA[
<?php

// Das ist FALSCH und führt nicht zum gewünschten Ergebnis.
 

if ($bedingung)
    include $datei;
else
    include $andere_datei;


// Das ist KORREKT.
if ($bedingung) {
    include $datei;
} else {
    include $andere_datei;
}

?>
]]>
     </programlisting>
    </example>
   </para>    
   <simpara>
    Der Umgang mit Returns: Es ist möglich eine <function>return</function>
    -Anweisung innerhalb einer eingebunden Datei anzugeben, um die 
    Ausführung innerhalb dieser Datei abzubrechen und zum aufrufenden Skript
    zurückzukehren. Ebenso ist die Rückgabe von Werten aus einer
    eingebunden Datei möglich. Sie können den Wert eines include-Aufrufs auf
    die gleiche Art und Weise nutzen, wie Sie es bei einer Funktion machen
    würden. Allerdings besteht diese Möglichkeit nicht, wenn Sie entfernte
    Dateien mittels include einbinden außer, wenn die Ausgabe der
    entfernten Datei <link linkend="language.basic-syntax.phpmode">
    gültige PHP Start- und Endetags</link> beeinhaltet (wie jede lokale Datei auch).
    Innerhalb dieser Tags können Sie die benötigten Variablen deklarieren und
    diese werden dann an dem Punkt Ihres Skripts eingeführt, von wo aus der
    Aufruf mit include erfolgt ist.
   </simpara>
   <note>
    <simpara>
     In PHP 3 darf eine return-Anweisung nicht innerhalb eines Blocks
     auftreten, es sei denn, es ist ein Funktionsblock. In diesem Fall gilt
     <function>return</function> für diese Funktion und nicht für die ganze
     Datei.
    </simpara>
   </note>
   <para>
    <example>
     <title><function>include</function> und die <function>return</function> Anweisung</title>
      <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // gibt 'PHP' aus

$bar = include 'noreturn.php';

echo $bar; // gibt 1 aus

?>
]]>
      </programlisting>
    </example>
   </para>
   <simpara>
    <literal>$bar</literal> hat den Wert <literal>1</literal>, weil include
    erfolgreich war. Beachten Sie die Unterschiede in den obigen Beispielen.
    Das erste nutzt <function>return</function> innerhalb der eingebundenen
    Datei im Gegensatz zum zweiten Beispiel. Weitere Möglichkeiten Dateien in
    Variablen "einzubinden" bieten ihnen die Funktionen
    <function>fopen</function> und <function>file</function> oder
    <function>include</function> im Zusammenspiel mit den
    <link linkend="ref.outcontrol">Funktionen zur Ausgabesteuerung</link>.
   </simpara>

   &note.language-construct;

   <simpara>
    Siehe auch <function>require</function>, <function>require_once</function>,
    <function>include_once</function>, <function>readfile</function>,
    <function>virtual</function>und
    <link linkend="ini.include-path">include_path</link>.
   </simpara>
  </sect1>

  <sect1 id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    Die <function>require_once</function> Anweisung bindet eine Datei ein
    und wertet diese zur Laufzeit des Skripts aus.
    Das Verhalten ist ähnlich der <function>require</function> Anweisung mit
    dem einzigen Unterschied, dass einmal eingebundener Code aus einer Datei
    nicht nocht einmal eingebunden wird. Lesen Sie die Dokumentation zu
    <function>require</function> um mehr Informationen über die Arbeitsweise
    dieser Anweisung zu erhalten.
   </para>
   <para>
    <function>require_once</function> sollten Sie in den Fällen benutzen,
    wenn die gleiche Datei in einem bestimmten Bereich mehrmals eingebunden
    und interpretiert werden soll und Sie sicher stellen wollen, dass diese
    Datei nur exakt einmal eingebunden wird, um Probleme mit Wiederholungen
    bei Funktions-Definitionen und Wertzuweisungen zu Variablen zu vermeiden,
    usw.
   </para>
   <para>
    Weitere Beispiele zu <function>require_once</function> und
    <function>include_once</function> können Sie dem
    <ulink url="&url.php.pear;">PEAR</ulink>-Code entnehmen, welcher
    im aktuellsten PHP-Sourcecode enthalten ist.
   </para>
   <note>
   <para>
    <function>require_once</function> steht ab PHP 4.01pl2 zur
    Verfügung.
   </para>
   </note>
   <note>
    <para>
     Beachten Sie, dass auf auf einem Betriebssystem, das nicht zwischen
     Groß- und Kleinschreibung unterschiedet (wie z.B. Windows) das Verhalten
     von <function>require_once</function> und
     <function>include_once</function> nicht unbedingt ihren Erwartungen
     entspricht.
     <example>
      <title>
       <function>require_once</function> unterscheidet nicht zwischen
       Groß-/Kleinschreibung unter Windows
      </title>
      <programlisting role="php">
<![CDATA[
<?php
require_once("a.php"); // bindet a.php ein
require_once("A.php"); // bindet a.php auf Windows nochmal ein!
?>
]]>
       </programlisting>
     </example>
    </para>
   </note>
   &warn.no-win32-fopen-wrapper;
   <para>
    Siehe auch: <function>require</function>,
    <function>include</function>, <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, 
    <function>readfile</function>
    und <function>virtual</function>.
   </para>
  </sect1>

  <sect1 id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    Die Anweisung <function>include_once</function> schließt zur
    Ausführungszeit die angegebene Datei ein und wertet diese aus. Dies
    ist ähnlich der <function>include</function>-Anweisung; mit dem
    Unterschied, dass einmal eingebundener Code nicht nochmals 
    eingebunden wird. Wie der Name vermuten lässt, wird die Datei nur ein
    einziges Mal eingebunden.
   </para>
   <para>
    <function>include_once</function> sollten Sie in den Fällen benutzen,
    wenn die gleiche Datei in einem bestimmten Bereich mehrmals eingebunden
    und interpretiert werden soll und Sie sicher stellen wollen, dass diese
    Datei nur exakt einmal eingebunden wird, um Probleme mit Wiederholungen
    von Funktionsdefinitionen und Wertzuweisungen an Variablen zu vermeiden,
    usw.
   </para>
   <para>
    Weitere Beispiele zu <function>require_once</function> und
    <function>include_once</function> können Sie dem
    <ulink url="&url.php.pear;">PEAR</ulink>-Code entnehmen, welcher
    im aktuellsten PHP-Source-Code enthalten ist.
   </para>
   <note>
   <para>
    <function>include_once</function> steht ab PHP 4.01pl2 zur
    Verfügung.
   </para>
   </note>
   <note>
    <para>
     Beachten Sie, dass auf auf einem Betriebssystem, das nicht zwischen
     Groß- und Kleinschreibung unterschiedet (wie z.B. Windows) das Verhalten
     von <function>include_once</function> und
     <function>require_once</function> nicht unbedingt ihren Erwartungen
     entspricht.
     <example>
      <title>
       <function>include_once</function> unterscheidet nicht zwischen
       Groß-/Kleinschreibung unter Windows
      </title>
      <programlisting role="php">
<![CDATA[
<?php
include_once("a.php"); // bindet a.php ein
include_once("A.php"); // bindet a.php auf Windows nochmal ein!
?>
]]>
       </programlisting>
     </example>
    </para>
   </note>
   &warn.no-win32-fopen-wrapper;
   <para>
    Siehe auch <function>include</function>,
    <function>require</function>, <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>
    und <function>virtual</function>.
   </para>
  </sect1>
 
 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
