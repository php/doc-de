<?xml version="1.0" encoding="utf-8" ?>
<!-- $Revision$ -->
<!-- EN-Revision: 329281 Maintainer: theseer Status: ready -->
<sect1 xml:id="language.types.float">
 <title>Fließkommazahlen</title>

 <para>
  Fließkommazahlen (auch bekannt als "floats", "doubles" oder
  "real numbers") können in jeder der folgenden Syntaxformen
  angegeben werden:
 </para>

 <informalexample>
  <programlisting role="php">
<![CDATA[
<?php
$a = 1.234;
$b = 1.2e3;
$c = 7E-10;
?>
]]>
  </programlisting>
 </informalexample>

 <para>
  Formell:
 </para>

 <informalexample>
  <programlisting>
<![CDATA[
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM [+-]?(({LNUM} | {DNUM}) [eE][+-]? {LNUM})
]]>
  </programlisting>
 </informalexample>

 <para>
  Der Wertebereich für Fließkommawertes ist platformabhängig,
  alderdings ist ein maximaler Wert von ca. 1.8e308 mit einer
  Genauigkeit von ca. 14 Nachkommastellen (entsprechend dem
  64bit IEEE-Format) üblich.
 </para>

 <warning xml:id="warn.float-precision">
  <title>Fließkommagenauigkeit</title>

  <para>
   Fließkommazahlen haben eine begrenzte Präzision. PHP nutzt normalerweise
   (dies hängt aber vom System ab) das IEEE 754 double precision Format,
   welches einen maximalen relativen Fehler von 1.11e-16 hat. Nicht elementare
   Rechenoperationen können einen größeren Fehler verursachen und bei Durchführung
   von mehreren Operationen können sich die Fehler addieren.
  </para>

  <para>
   Weiterhin können viele rationale Zahlen, die zwar eine genaue Darstellung
   zur Basis 10 besitzen, wie beispielsweilse <literal>0.1</literal> oder
   <literal>0.7</literal>, nicht genau als Gleitkommazahl zur intern genutzten
   Basis 2 dargestellt werden, unabhängig von der Größe der Mantisse. Daher
   können sie nicht ohne einen gewissen Präzisionsverlust in ihr internes
   binäres Gegenstück umgewandelt werden können. Dies kann zu verwirrenden
   Ergebnissen führen, so ergibt <literal>floor((0.1+0.7)*10)</literal> in der
   Regel <literal>7</literal> an Stelle der erwarteten <literal>8</literal>,
   da die interne Repräsentation etwa wie folgt aussieht:
   <literal role="infdec">7.9999999999999991118...</literal>
  </para>

  <para>
   Sie sollten daher Fließkommawerten nicht bis auf die letzte Nachkommastelle
   trauen und vor allem niemals Fließkommawerte auf exakte Gleichheit prüfen.
   Wenn Sie höhere Genauigkeit benötigen können Sie die
   <link linkend="ref.bc">Mathematikfunktionen für beliebige Genauigkeit</link>
   oder die <link linkend="ref.gmp">gmp</link>-Funktionen nutzen.
  </para>
 </warning>

 <sect2 xml:id="language.types.float.casting">
  <title>Umwandlung in Fließkommawerte</title>

  <para>
   Informationen zur Umwandlung von <type>String</type>s in
   <type>float</type> finden Sie im Abschnitt
   <link linkend="language.types.string.conversion">Umwandlung von
   Zeichenketten in Zahlen</link>.
   Andere Datentypen werden zunächst in einen <type>integer</type>-Wert
   umgewandelt und von da aus weiter in einen Fließkommawert.
   Mehr Informationen hierzu finden Sie im Abschnitt
   <link linkend="language.types.integer.casting">Umwandlung in Integerwerte</link>.
   Beginnend mit PHP 5 wird bei der Umwandlung eines
   <type>Object</type>s in <type>float</type> eine
   Hinweismeldung geworfen.
  </para>

 </sect2>

    <sect2 xml:id="language.types.float.comparison">
        <title>Comparing floats</title>

        <para>
            As noted in the warning above, testing floating point values for equality is
            problematic, due to the way that they are represented internally. However,
            there are ways to make comparisons of floating point values that work around
            these limitations.
        </para>

        <para>
            To test floating point values for equality, an upper bound on the relative
            error due to rounding is used. This value is known as the machine epsilon,
            or unit roundoff, and is the smallest acceptable difference in calculations.
        </para>

        <informalexample>
            <simpara>
                <varname>$a</varname> and <varname>$b</varname> are equal to 5 digits of
                precision.
            </simpara>
            <programlisting role="php">
                <![CDATA[
<?php
$a = 1.23456789;
$b = 1.23456780;
$epsilon = 0.00001;

if(abs($a-$b) < $epsilon) {
    echo "true";
}
?>
]]>
            </programlisting>
        </informalexample>
    </sect2>

    <sect2 xml:id="language.types.float.nan">
        <title>NaN</title>
        <para>
            Some numeric operations can result in a value represented by the constant
            <constant>NAN</constant>. This result represents an undefined or
            unrepresentable value in floating-point calculations. Any loose or strict
            comparisons of this value against any other value, including itself, will
            have a result of &false;.
        </para>
        <para>
            Because <constant>NAN</constant> represents any number of different values,
            <constant>NAN</constant> should not be compared to other values, including
            itself, and instead should be checked for using <function>is_nan</function>.
        </para>
    </sect2>

</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
