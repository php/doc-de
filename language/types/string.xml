<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: n/a Maintainer: hholzgra  Status: working -->
<sect1 xml:id="language.types.string">
 <title>Strings</title>

 <para>
  Ein <type>String</type> stellt eine Kette von Zeichen dar indem ein Zeichen gleichbedeutend mit einem Byte ist. Das bedeutet, es gibt exakt 256 mögliche Zeichen. Es impliziert zudem, dass PHP keine native Unterstützung von Unicode bietet. Siehe auch
  <function>utf8_encode</function> und <function>utf8_decode</function> zur Basis-Unicode Funktionalität.
 </para>

 <note>
  <simpara>
   Eine Zeichenkette (<type>String</type>) kann bis zu 2GB (maximal 2147483647 bytes) groß werden.
  </simpara>
 </note>

 <sect2 xml:id="language.types.string.syntax">
  <title>Syntax</title>

  <para>
   Ein <type>String</type>-Literal kann auf vier unterschiedliche Arten spezifiziert werden:
  </para>

  <itemizedlist>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.single">einfache Anführungszeichen</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.double">doppelte Anführungszeichen</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.heredoc">Heredoc Syntax</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.nowdoc">Nowdoc Syntax</link>
     (since PHP 5.3.0)
    </simpara>
   </listitem>
  </itemizedlist>

  <sect3 xml:id="language.types.string.syntax.single">
   <title>Einfache Anführungszeichen</title>

   <para>
    Der einfachste Weg einen <type>String</type> zu spezifizieren, ist ihn mit einfachen Anführungszeichen (das Zeichen <literal>'</literal>) zu umschließen.
   </para>

   <para>
    Um ein einfaches Anführungszeichen hierin anzugeben, fügen sie einen Backslash (<literal>\</literal>) vor dem Zeichen ein. Um einen Backslash vor einem einfachen Anführungszeichen im <type>String</type> oder am Ende des <type>Strings</type> zu verwenden, verdoppeln sie es (<literal>\\</literal>). Sollten vor ein beliebiges anderes Zeichen einen Backslash setzen, wird dieser mit ausgegeben.
   </para>

   <note>
    <simpara>
     Im Gegensatz zu den anderen Syntax werden
     <link linkend="language.variables">Variablen</link> und Escape-Sequenzen für Sonderzeichen <emphasis>nicht</emphasis> maskiert (ersetzt) wenn sie in einem mit einfachen Anführungszeichen umschlossenen <type>String</type> erscheinen.
    </simpara>
   </note>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo 'dies ist ein einfacher String';

echo 'Sie können auch Zeilenumbrüche
in dieser Art angeben,
dies ist okay so';

// Gibt aus: Arnold sagte einst: "I'll be back"
echo 'Arnold sagte einst: "I\'ll be back"';

// Ausgabe: Sie löschten C:\*.*?
echo 'Sie löschten C:\\*.*?';

// Ausgabe: Sie löschten C:\*.*?
echo 'Sie löschten C:\*.*?';

// Ausgabe: Dies erzeugt keinen: \n Zeilenumbruch
echo 'Dies erzeugt keinen: \n Zeilenumbruch';

// Ausgabe: Variablen werden $ebenfalls $nicht ersetzt
echo 'Variablen werden $ebenfalls $nicht ersetzt';
?>
]]>
    </programlisting>
   </informalexample>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.double">
   <title>Doppelte Anführungszeichen</title>

   <para>
    Wenn der <type>String</type> in doppelte Anführungszeichen (<literal>"</literal>) eingeschlossen wird, interpretiert PHP zusätzliche Escape-Sequenzen für Sonderzeichen:
   </para>

   <table>
    <title>Maskierte Zeichen</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Sequenz</entry>
       <entry>Bedeutung</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>Zeilenumbruch (LF or 0x0A (10) in ASCII)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>Wagenrücklauf (CR or 0x0D (13) in ASCII)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>horizontaler Tabulator (HT or 0x09 (9) in ASCII)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>vertikaler Tabulator (VT or 0x0B (11) in ASCII) (since PHP 5.2.5)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>Seitenvorschub (FF or 0x0C (12) in ASCII) (since PHP 5.2.5)</entry>
      </row>
      <row>
       <entry><literal>\\</literal></entry>
       <entry>Backslash (Rückstrich)</entry>
      </row>
      <row>
       <entry><literal>\$</literal></entry>
       <entry>Dollar-Zeichen</entry>
      </row>
      <row>
       <entry><literal>\"</literal></entry>
       <entry>doppelte Anführungszeichen</entry>
      </row>
      <row>
       <entry><literal>\[0-7]{1,3}</literal></entry>
       <entry>
        the sequence of characters matching the regular expression is a
        character in octal notation
       </entry>
      </row>
      <row>
       <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
       <entry>
        the sequence of characters matching the regular expression is a
        character in hexadecimal notation
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Wie bei <type>String</type>s in einfachen Anführungszeichen wird beim maskieren aller anderen Zeichen der Backslash mit ausgegeben. Vor PHP 5.1.1 wurde der Rückstrich vor <literal>\{$var}</literal> nicht ausgegeben.
   </para>

   <para>
    Das Expandieren von Varibalen-Namen ist eine der wichtigsten Besonderheiten von in doppelten Anführungszeichen angegebenen <type>String</type>s. Siehe hierzu
    <link linkend="language.types.string.parsing">string parsing</link> für weitere Details.
   </para>
  </sect3>
  
  <sect3 xml:id="language.types.string.syntax.heredoc">
   <title>Heredoc</title>

   <simpara>
    Ein dritter Weg <type>String</type>s zu begrenzen, stellt die Heredoc-Syntax dar: <literal>&lt;&lt;&lt;</literal>. Nach diesem Operator wird ein beliebiger Bezeichner angegeben, dann eine neue Zeile. Hiernach folgt der eigentliche <type>String</type> und abschließend erneut der Bezeichner um die Auszeichnung abzuschließen.
   </simpara>

   <simpara>
    Der schließende Bezeichner <emphasis>muss</emphasis> in der ersten Spalte der Zeile beginnen. Zudem muss dieser sich an die selben Namensregeln wie jede andere Kennung in PHP halten: es darf nur alhpanumerische Zeichen und den Unterstrich enthalten und muss mit einem Buchstaben oder dem Unterstrich beginngen.
   </simpara>
   
   <warning>
    <simpara>
     Es ist sehr wichtig, dass die Zeile mit dem schließenden Bezeichner keine anderen Zeichen, außer <emphasis>möglicherweise</emphasis> einem Semikolon (<literal>;</literal>), enthält.
     Das heißt insbesondere auch, dass der Bezeichner nicht eingerückt wird und auch keine Leerzeichen oder Tabulatoren vor oder nach dem Semikolon bestehen.
     Zudem muss das erste Zeichen vor dem schließenden Bezeichner eine neue Zeile sein, so wie sie vom Betriebssystem definiert wird.
     In UNIX Systemen, auch Mac OS X, ist dies <literal>\n</literal>.
     Auf den schließenden Bezeichner (möglicherweise gefolgt von einem Semikolon) muss zudem ebenfalls eine neue Zeile folgen.
    </simpara>

    <simpara>
     Wenn diese Regel gebrochen wird und der schließende Bezeichner nicht valide ist, wird er nicht als Bezeichner angenommen und PHP wird weiter nach einem solchen schließenden Bezeichner suchen. Wird kein gültiger schließender Bezeichner vor dem Dateiende gefunden, gibt PHP einen, auf die letzte Zeile der Datei zeigenden, Parser-Fehler aus.
    </simpara>

    <para>
     Heredocs können nicht zur Initialisierung von Klassen-<type>Eigenschaften</type> benutzt werden. Benutzen Sie stattdessen <link linkend="language.types.string.syntax.nowdoc">nowdocs</link>.
    </para>
    
    <example>
     <title>Ungültiges Beispiel</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>
   </warning>

   <para>
    Heredoc text behaves just like a double-quoted <type>string</type>, without
    the double quotes. This means that quotes in a heredoc do not need to be
    escaped, but the escape codes listed above can still be used. Variables are
    expanded, but the same care must be taken when expressing complex variables
    inside a heredoc as with <type>string</type>s.
   </para>

   <example> 
    <title>Heredoc string quoting example</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Example of string
spanning multiple lines
using heredoc syntax.
EOD;

/* More complex example, with variables. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<EOT
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should print a capital 'A': \x41
EOT;
?>
]]>
    </programlisting>
   </example>
   &example.outputs;
   <screen>
<![CDATA[
My name is "MyName". I am printing some Foo.
Now I am printing some Bar2.
This should print a capital 'A': \x41]]></screen>
   
   <note>
    <para>
     Heredoc support was added in PHP 4.
    </para>
   </note>

  </sect3>
  
  <sect3 xml:id="language.types.string.syntax.nowdoc">
   <title>Nowdoc</title>
   
   <para>
    Nowdocs are to single-quoted strings what heredocs are to double-quoted
    strings. A nowdoc is specified similarly to a heredoc, but <emphasis>no
    parsing is done</emphasis> inside a nowdoc. The construct is ideal for
    embedding PHP code or other large blocks of text without the need for
    escaping. It shares some features in common with the SGML
    <literal>&amp;lt;![CDATA[ ]]&amp;gt;</literal> construct, in that it declares a
    block of text which is not for parsing.
   </para>
   
   <para>
    A nowdoc is identified with the same <literal>&lt;&lt;&lt;</literal>
    seqeuence used for heredocs, but the identifier which follows is enclosed in
    single quotes, e.g. <literal>&lt;&lt;&lt;'EOT'</literal>. All the rules for
    heredoc identifiers also apply to nowdoc identifiers, especially those
    regarding the appearance of the closing identifier.
   </para>
   
   <example>
    <title>Nowdoc string quoting example</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<'EOD'
Example of string
spanning multiple lines
using nowdoc syntax.
EOD;

/* More complex example, with variables. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<'EOT'
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should not print a capital 'A': \x41
EOT;
?>
]]>
    </programlisting>
   </example>
   &example.outputs;
   <screen>
<![CDATA[
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should not print a capital 'A': \x41]]></screen>
   
   <note>
    <para>
     Unlike heredocs, nowdocs can be used in any static data context. The
     typical example is initializing class members or constants:
    </para>
    
    <example>
     <title>Static data example</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<'EOT'
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>
   </note>

   <note>
    <para>
     Nowdoc support was added in PHP 5.3.0.
    </para>
   </note>

  </sect3>

  <sect3 xml:id="language.types.string.parsing">
   <title>Variable parsing</title>

   <simpara>
    When a <type>string</type> is specified in double quotes or with heredoc,
    <link linkend="language.variables">variables</link> are parsed within it. 
   </simpara>

   <simpara>
    There are two types of syntax: a
    <link linkend="language.types.string.parsing.simple">simple</link> one and a
    <link linkend="language.types.string.parsing.complex">complex</link> one.
    The simple syntax is the most common and convenient. It provides a way to
    embed a variable, an <type>array</type> value, or an <type>object</type>
    property in a <type>string</type> with a minimum of effort.
   </simpara>

   <simpara>
    The complex syntax was introduced in PHP 4, and can be recognised by the
    curly braces surrounding the expression.
   </simpara>

   <sect4 xml:id="language.types.string.parsing.simple">
    <title>Simple syntax</title>

    <simpara>
     If a dollar sign (<literal>$</literal>) is encountered, the parser will
     greedily take as many tokens as possible to form a valid variable name.
     Enclose the variable name in curly braces to explicitly specify the end of
     the name.
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$beer = 'Heineken';
echo "$beer's taste is great"; // works; "'" is an invalid character for variable names
echo "He drank some $beers";   // won't work; 's' is a valid character for variable names
echo "He drank some ${beer}s"; // works
echo "He drank some {$beer}s"; // works
?>
]]>
     </programlisting>
    </informalexample>

    <simpara>
     Similarly, an <type>array</type> index or an <type>object</type> property
     can be parsed. With array indices, the closing square bracket
     (<literal>]</literal>) marks the end of the index. The same rules apply to
     object properties as to simple variables.
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// These examples are specific to using arrays inside of strings.
// When outside of a string, always quote array string keys and do not use
// {braces}.

// Show all errors
error_reporting(E_ALL);

$fruits = array('strawberry' => 'red', 'banana' => 'yellow');

// Works, but note that this works differently outside a string
echo "A banana is $fruits[banana].";

// Works
echo "A banana is {$fruits['banana']}.";

// Works, but PHP looks for a constant named banana first, as described below.
echo "A banana is {$fruits[banana]}.";

// Won't work, use braces.  This results in a parse error.
echo "A banana is $fruits['banana'].";

// Works
echo "A banana is " . $fruits['banana'] . ".";

// Works
echo "This square is $square->width meters broad.";

// Won't work. For a solution, see the complex syntax.
echo "This square is $square->width00 centimeters broad.";
?>
]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad."; 
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works, 
// XXX: analogously to the ${expr} syntax for variable var's.
-->
     </programlisting>
    </informalexample>

    <simpara>
     For anything more complex, you should use the complex syntax.
    </simpara>
   </sect4>

   <sect4 xml:id="language.types.string.parsing.complex">
    <title>Complex (curly) syntax</title>

    <simpara>
     This isn't called complex because the syntax is complex, but because it
     allows for the use of complex expressions.
    </simpara>

    <simpara>
     In fact, any value in the namespace can be included in a
     <type>string</type> with this syntax. Simply write the expression the same
     way as it would appeared outside the <type>string</type>, and then wrap it
     in <literal>{</literal> and <literal>}</literal>. Since
     <literal>{</literal> can not be escaped, this syntax will only be
     recognised when the <literal>$</literal> immediately follows the
     <literal>{</literal>. Use <literal>{\$</literal> to get a literal
     <literal>{$</literal>. Some examples to make it clear:
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Show all errors
error_reporting(E_ALL);

$great = 'fantastic';

// Won't work, outputs: This is { fantastic}
echo "This is { $great}";

// Works, outputs: This is fantastic
echo "This is {$great}";
echo "This is ${great}";

// Works
echo "This square is {$square->width}00 centimeters broad."; 

// Works
echo "This works: {$arr[4][3]}";

// This is wrong for the same reason as $foo[bar] is wrong  outside a string.
// In other words, it will still work, but only because PHP first looks for a
// constant named foo; an error of level E_NOTICE (undefined constant) will be
// thrown.
echo "This is wrong: {$arr[foo][3]}"; 

// Works. When using multi-dimensional arrays, always use braces around arrays
// when inside of strings
echo "This works: {$arr['foo'][3]}";

// Works.
echo "This works: " . $arr['foo'][3];

echo "This works too: {$obj->values[3]->name}";

echo "This is the value of the var named $name: {${$name}}";

echo "This is the value of the var named by the return value of getName(): {${getName()}}";

echo "This is the value of the var named by the return value of \$object->getName(): {${$object->getName()}}";
?>
]]>
<!-- maybe it's better to leave this out?? 
// this works, but i disencourage its use, since this is NOT 
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
     </programlisting>
    </informalexample>
    
    <note>
     <para>
      Functions and method calls inside <literal>{$}</literal> work since PHP 5.
     </para>
    </note>

   </sect4>
  </sect3>
  
  <sect3 xml:id="language.types.string.substr">
   <title>String access and modification by character</title>

   <para>
    Characters within <type>string</type>s may be accessed and modified by
    specifying the zero-based offset of the desired character after the
    <type>string</type> using square <type>array</type> brackets, as in
    <varname>$str[42]</varname>. Think of a <type>string</type> as an
    <type>array</type> of characters for this purpose.
   </para>

   <note>
    <simpara>
     <type>String</type>s may also be accessed using braces, as in
     <varname>$str{42}</varname>, for the same purpose. However, this syntax is
     deprecated as of PHP 6. Use square brackets instead.
    </simpara>
   </note>

   <example>
    <title>Some string examples</title>
    <programlisting role="php">
<![CDATA[
<?php
// Get the first character of a string
$str = 'This is a test.';
$first = $str[0];

// Get the third character of a string
$third = $str[2];

// Get the last character of a string.
$str = 'This is still a test.';
$last = $str[strlen($str)-1]; 

// Modify the last character of a string
$str = 'Look at the sea';
$str[strlen($str)-1] = 'e';

?>
]]>
    </programlisting>
   </example>

   <note>
    <para>
     Accessing variables of other types using <literal>[]</literal> or
     <literal>{}</literal> silently returns &null;.
    </para>
   </note>

  </sect3>
 </sect2><!-- end syntax -->

 <sect2 xml:id="language.types.string.useful-funcs">
  <title>Useful functions and operators</title>

  <para>
   <type>String</type>s may be concatenated using the '.' (dot) operator. Note
   that the '+' (addition) operator will <emphasis>not</emphasis> work for this.
   See <link linkend="language.operators.string">String operators</link> for
   more information.
  </para>

  <para>
   There are a number of useful functions for <type>string</type> manipulation.
  </para>

  <simpara>
   See the <link linkend="ref.strings">string functions section</link> for
   general functions, and the <link linkend="ref.regex">regular expression
   functions</link> or the <link linkend="ref.pcre">Perl-compatible regular
   expression functions</link> for advanced find &amp; replace functionality.
  </simpara>

  <simpara>
   There are also <link linkend="ref.url">functions for URL strings</link>, and
   functions to encrypt/decrypt strings
   (<link linkend="ref.mcrypt">mcrypt</link> and
   <link linkend="ref.mhash">mhash</link>).
  </simpara>

  <simpara>
   Finally, see also the <link linkend="ref.ctype">character type
   functions</link>.
  </simpara>
 </sect2>

 <sect2 xml:id="language.types.string.casting">
  <title>Converting to string</title>
  
  <para>
   A value can be converted to a <type>string</type> using the
   <literal>(string)</literal> cast or the <function>strval</function> function.
   <type>String</type> conversion is automatically done in the scope of an
   expression where a <type>string</type> is needed. This happens when using the
   <function>echo</function> or <function>print</function> functions, or when a
   variable is compared to a <type>string</type>. The sections on
   <link linkend="language.types">Types</link> and
   <link linkend="language.types.type-juggling">Type Juggling</link> will make
   the following clearer. See also the <function>settype</function> function.
  </para>
  
  <para>
   A <type>boolean</type> &true; value is converted to the <type>string</type>
   <literal>"1"</literal>. <type>Boolean</type> &false; is converted to
   <literal>""</literal> (the empty string). This allows conversion back and
   forth between <type>boolean</type> and <type>string</type> values.
  </para>

  <para> 
   An <type>integer</type> or <type>float</type> is converted to a
   <type>string</type> representing the number textually (including the
   exponent part for <type>float</type>s). Floating point numbers can be
   converted using exponential notation (<literal>4.1E+6</literal>).
  </para>

  <note>
   <para>
    The decimal point character is defined in the script's locale (category
    LC_NUMERIC). See the <function>setlocale</function> function.
   </para>
  </note>

  <para>
   <type>Array</type>s are always converted to the <type>string</type>
   <literal>"Array"</literal>; because of this, <function>echo</function> and
   <function>print</function> can not by themselves show the contents of an
   <type>array</type>. To view a single element, use a construction such as
   <literal>echo $arr['foo']</literal>. See below for tips on viewing the entire
   contents.
  </para>

  <para>
   <type>Object</type>s in PHP 4 are always converted to the <type>string</type>
   <literal>"Object"</literal>. To print the values of object members for
   debugging reasons, read the paragraphs below. To get an object's class name,
   use the <function>get_class</function> function. As of PHP 5, the
   <link linkend="language.oop5.magic">__toString</link> method is used when
   applicable.
  </para>

  <para>
   <type>Resource</type>s are always converted to <type>string</type>s with the
   structure <literal>"Resource id #1"</literal>, where <literal>1</literal> is
   the unique number assigned to the <type>resource</type> by PHP at runtime. Do
   not rely upon this structure; it is subject to change. To get a
   <type>resource</type>'s type, use the
   <function>get_resource_type</function> function.
  </para>

  <para>
   &null; is always converted to an empty string.
  </para>
  
  <para>
   As stated above, directly converting an <type>array</type>,
   <type>object</type>, or <type>resource</type> to a <type>string</type> does
   not provide any useful information about the value beyond its type. See the
   functions <function>print_r</function> and <function>var_dump</function> for
   more effective means of inspecting the contents of these types.
  </para>
  
  <para>
   Most PHP values can also be converted to <type>string</type>s for permanent
   storage. This method is called serialization, and is performed by the
   <function>serialize</function> function. If the PHP engine was built with
   <link linkend="ref.wddx">WDDX</link> support, PHP values can also be
   serialized as well-formed XML text.
  </para>

 </sect2>

 <sect2 xml:id="language.types.string.conversion">
  <title>String conversion to numbers</title>

  <simpara>
   When a <type>string</type> is evaluated in a numeric context, the resulting
   value and type are determined as follows.
  </simpara>

  <simpara>
   The <type>string</type> will be evaluated as a <type>float</type> if it
   contains any of the characters '.', 'e', or 'E'. Otherwise, it will be
   evaluated as an <type>integer</type>.
  </simpara>

  <para>
   The value is given by the initial portion of the <type>string</type>. If the
   <type>string</type> starts with valid numeric data, this will be the value
   used. Otherwise, the value will be 0 (zero). Valid numeric data is an
   optional sign, followed by one or more digits (optionally containing a
   decimal point), followed by an optional exponent. The exponent is an 'e' or
   'E' followed by one or more digits.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";                // $foo is float (11.5)
$foo = 1 + "-1.3e3";              // $foo is float (-1299)
$foo = 1 + "bob-1.3e3";           // $foo is integer (1)
$foo = 1 + "bob3";                // $foo is integer (1)
$foo = 1 + "10 Small Pigs";       // $foo is integer (11)
$foo = 4 + "10.2 Little Piggies"; // $foo is float (14.2)
$foo = "10.0 pigs " + 1;          // $foo is float (11)
$foo = "10.0 pigs " + 1.0;        // $foo is float (11)     
?>
]]>
   </programlisting>
  </informalexample>

  <simpara>
   For more information on this conversion, see the Unix manual page for
   strtod(3).
  </simpara>

  <para>
   To test any of the examples in this section, cut and paste the examples and
   insert the following line to see what's going on:
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; type is " . gettype ($foo) . "<br />\n";
?>
]]>
   </programlisting>
  </informalexample>

  <para>
   Do not expect to get the code of one character by converting it to integer,
   as is done in C. Use the <function>ord</function> and
   <function>chr</function> functions to convert between ASCII codes and
   characters.
  </para>

 </sect2>
</sect1><!-- end string -->
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
