<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 2e12177298dd66bb1de36576de23847c01bc1371 Maintainer: nobody Status: ready -->
<sect1 xml:id="language.types.string">
 <title>Strings (Zeichenketten)</title>

 <para>
  Ein <type>String</type> stellt eine Kette von Zeichen dar, in der ein
  Zeichen gleichbedeutend mit einem Byte ist. Das bedeutet, es gibt exakt 256
  mögliche Zeichen. Es impliziert zudem, dass PHP keine native Unterstützung
  von Unicode bietet. Siehe auch
  <link linkend="language.types.string.details">Details zum String-Typ</link>.
 </para>

 <note>
  <simpara>
   Unter 32-bit-Versionen kann ein <type>String</type> bis zu 2GB (maximal
   2147483647 Bytes) groß werden.
  </simpara>
 </note>

 <sect2 xml:id="language.types.string.syntax">
  <title>Syntax</title>

  <para>
   Ein <type>String</type>-Literal kann auf vier unterschiedliche Arten
   spezifiziert werden:
  </para>

  <itemizedlist>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.single">einfache Anführungszeichen</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.double">doppelte Anführungszeichen</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.heredoc">Heredoc-Syntax</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.nowdoc">Nowdoc-Syntax</link>
    </simpara>
   </listitem>
  </itemizedlist>

  <sect3 xml:id="language.types.string.syntax.single">
   <title>Einfache Anführungszeichen</title>

   <para>
    Der einfachste Weg einen <type>String</type> anzugeben, ist ihn mit
    einfachen Anführungszeichen (das Zeichen <literal>'</literal>) zu
    umschließen.
   </para>

   <para>
    Um ein einfaches Anführungszeichen hierin anzugeben, fügen sie einen
    Backslash (<literal>\</literal>) vor dem Zeichen ein. Um einen Backslash
    als Zeichen anzugeben, verdoppeln Sie ihn (<literal>\\</literal>).  Alle
    anderen Instanzen von Backslash werden als buchstäblicher Backslash
    behandelt: Das bedeutet, dass die anderen Escape-Sequenzen, die Sie
    vielleicht gewohnt sind, wie <literal>\r</literal> oder
    <literal>\n</literal>, buchstäblich wie angegeben ausgegeben werden und
    keine besondere Bedeutung haben.
   </para>

   <note>
    <simpara>
     Im Gegensatz zu den
     <link linkend="language.types.string.syntax.double">doppelten Anführungszeichen</link>- und
     <link linkend="language.types.string.syntax.heredoc">Heredoc</link>-Notationen
     werden <link linkend="language.variables">Variablen</link> und
     Escape-Sequenzen für Sonderzeichen <emphasis>nicht</emphasis> aufgelöst
     (ersetzt), wenn sie in einem mit einfachen Anführungszeichen
     umschlossenen <type>String</type> erscheinen.
    </simpara>
   </note>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo 'dies ist ein einfacher String';

echo 'Sie können auch Zeilenumbrüche
in dieser Art angeben,
dies ist okay so';

// Gibt aus: Arnold sagte einst: "I'll be back"
echo 'Arnold sagte einst: "I\'ll be back"';

// Ausgabe: Sie löschten C:\*.*?
echo 'Sie löschten C:\\*.*?';

// Ausgabe: Sie löschten C:\*.*?
echo 'Sie löschten C:\*.*?';

// Ausgabe: Dies erzeugt keinen: \n Zeilenumbruch
echo 'Dies erzeugt keinen: \n Zeilenumbruch';

// Ausgabe: Variablen werden $ebenfalls $nicht ersetzt
echo 'Variablen werden $ebenfalls $nicht ersetzt';
?>
]]>
    </programlisting>
   </informalexample>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.double">
   <title>Doppelte Anführungszeichen</title>

   <para>
    Wenn der <type>String</type> in doppelte Anführungszeichen (")
    eingeschlossen wird, interpretiert PHP zusätzliche Escape-Sequenzen für
    Sonderzeichen:
   </para>

   <table>
    <title>Maskierte Zeichen</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Sequenz</entry>
       <entry>Bedeutung</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>Zeilenumbruch (LF or 0x0A (10) in ASCII)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>Wagenrücklauf (CR or 0x0D (13) in ASCII)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>horizontaler Tabulator (HT or 0x09 (9) in ASCII)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>vertikaler Tabulator (VT or 0x0B (11) in ASCII)</entry>
      </row>
      <row>
       <entry><literal>\e</literal></entry>
       <entry>Escape-Zeichen (ESC or 0x1B (27) in ASCII)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>Seitenvorschub (FF or 0x0C (12) in ASCII)</entry>
      </row>
      <row>
       <entry><literal>\\</literal></entry>
       <entry>Backslash (Rückstrich)</entry>
      </row>
      <row>
       <entry><literal>\$</literal></entry>
       <entry>Dollar-Zeichen</entry>
      </row>
      <row>
       <entry><literal>\"</literal></entry>
       <entry>doppeltes Anführungszeichen</entry>
      </row>
      <row>
       <entry><literal>\[0-7]{1,3}</literal></entry>
       <entry>
        die Folge von Zeichen, die auf den regulären Ausdruck passt, ist ein
        Zeichen in oktaler Notation, die stillschweigend überläuft, um in ein
        Byte zu passen (&zb; "\400" === "\000")
       </entry>
      </row>
      <row>
       <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
       <entry>
        die Folge von Zeichen, die auf den regulären Ausdruck passt, ist ein
        Zeichen in hexadezimaler Schreibweise
       </entry>
      </row>
      <row>
       <entry><literal>\u{[0-9A-Fa-f]+}</literal></entry>
       <entry>
        die Folge von Zeichen, die auf den regulären Ausdruck passt, ist ein
        Unicode-Codepunkt, der in der Zeichenkette als UTF-8-Darstellung des
        Codepunkts ausgegeben wird
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Wie bei <type>String</type>s in einfachen Anführungszeichen wird beim
    Maskieren aller anderen Zeichen der Backslash mit ausgegeben.
   </para>

   <para>
    Das Auflösen von Variablen-Namen ist eine der wichtigsten Besonderheiten
    von in doppelten Anführungszeichen angegebenen <type>String</type>s. Siehe
    hierzu <link linkend="language.types.string.parsing">String-Parsing</link>
    für weitere Details.
   </para>
  </sect3>

  <sect3 xml:id="language.types.string.syntax.heredoc">
   <title>Heredoc</title>

   <simpara>
    Eine dritte Möglichkeit, <type>String</type>s zu begrenzen, stellt die
    Heredoc-Syntax dar: <literal>&lt;&lt;&lt;</literal>. Nach diesem Operator
    wird ein beliebiger Bezeichner angegeben, dann eine neue Zeile. Hiernach
    folgt der eigentliche <type>String</type> und abschließend erneut der
    Bezeichner, um die Auszeichnung abzuschließen.
   </simpara>

   <simpara>
    Der schließende Bezeichner darf durch Leerzeichen oder Tabulatoren
    eingerückt sein, wobei in diesem Fall die Einrückung aus allen Zeilen des
    Doc-Strings entfernt wird. Vor PHP 7.3.0 <emphasis>muss</emphasis> der
    schließende Bezeichner in der ersten Spalte der Zeile beginnen.
   </simpara>

   <simpara>
    Außerdem muss der schließende Bezeichner den gleichen Benennungsregeln
    folgen wie jeder andere Bezeichner in PHP: Er darf nur alphanumerische
    Zeichen sowie Unterstriche enthalten und muss mit einem nicht-numerischen
    Zeichen oder einem Unterstrich beginnen.
   </simpara>

   <example>
    <title>Grundlegendes Heredoc-Beispiel ab PHP 7.3.0</title>
    <programlisting role="php">
<![CDATA[
<?php
// keine Einrückung
echo <<<END
      a
     b
    c
\n
END;

// vier Leerzeichen Einrückung
echo <<<END
      a
     b
    c
    END;
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
      a
     b
    c

  a
 b
c
]]>
    </screen>
   </example>

   <simpara>
    Wenn der schließende Bezeichner weiter eingerückt ist als alle Zeilen des
    Textkörpers, wird ein <classname>ParseError</classname> ausgelöst:
   </simpara>

   <example>
    <title>Der schließende Bezeichner darf nicht weiter eingerückt sein, als die Zeilen des Textkörpers</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<END
  a
 b
c
   END;
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
PHP Parse error:  Invalid body indentation level (expecting an indentation level of at least 3) in example.php on line 4
]]>
    </screen>
   </example>

   <simpara>
    Wenn der schließende Bezeichner eingerückt ist, können auch Tabulatoren
    verwendet werden, allerdings dürfen Tabulatoren und Leerzeichen in Bezug
    auf die Einrückung des schließenden Bezeichners und die Einrückung des
    Textkörpers (bis zum schließenden Bezeichner) <emphasis>nicht</emphasis>
    miteinander vermischt werden. In jedem dieser Fälle wird ein
    <classname>ParseError</classname> ausgelöst. Diese
    Whitespace-Einschränkungen wurden aufgenommen, weil die Vermischung von
    Tabulatoren und Leerzeichen für die Einrückung die Lesbarkeit
    beeinträchtigt.
   </simpara>

   <example>
    <title>Unterschiedliche Einrückung für den Bezeichner, der den Textkörper (Leerzeichen) schließt</title>
    <programlisting role="php">
<![CDATA[
<?php
// Der gesamte folgende Code funktioniert nicht.

// Unterschiedliche Einrückung für den Bezeichner (Tabulatoren), der den
// Textkörper (Leerzeichen) schließt
{
	echo <<<END
	 a
		END;
}

// Vermischung von Leerzeichen und Tabulatoren im Textkörper
{
    echo <<<END
    	a
     END;
}

// Vermischung von Leerzeichen und Tabulatoren in der Endmarkierung
{
	echo <<<END
		  a
		 END;
}
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
PHP Parse error:  Invalid indentation - tabs and spaces cannot be mixed in example.php line 8
]]>
    </screen>
   </example>

   <simpara>
    Der schließende Bezeichner für den Textkörper muss nicht von einem
    Semikolon oder Zeilenumbruch gefolgt werden. Zum Beispiel ist der folgende
    Code ist ab PHP 7.3.0 erlaubt:
   </simpara>

   <example>
    <title>Fortsetzen eines Ausdrucks nach einem schließenden Bezeichner</title>
    <programlisting role="php">
<![CDATA[
<?php
$values = [<<<END
a
  b
    c
END, 'd e f'];
var_dump($values);
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
array(2) {
  [0] =>
  string(11) "a
  b
    c"
  [1] =>
  string(5) "d e f"
}
]]>
    </screen>
   </example>

   <warning>
    <simpara>
     Wenn der schließende Bezeichner am Anfang einer Zeile gefunden wurde,
     dann kann er unabhängig davon, ob er Teil eines anderen Wortes war, als
     schließender Bezeichner betrachtet werden und führt zu einem
     <classname>ParseError</classname>.
    </simpara>

    <example>
     <title>Ein schließender Bezeichner im Textkörper der Zeichenkette führt zu einem ParseError</title>
     <programlisting role="php">
<![CDATA[
<?php
$values = [<<<END
a
b
END ING
END, 'd e f'];
]]>
     </programlisting>
     &example.outputs.73;
    <screen>
<![CDATA[
PHP Parse error:  syntax error, unexpected identifier "ING", expecting "]" in example.php on line 6
]]>
     </screen>
    </example>

    <simpara>
     Um dieses Problem zu vermeiden, ist es ratsam, die einfache Regel zu
     befolgen: <emphasis>Wählen Sie nicht den schließenden Bezeichner, der im
     Textkörper erscheint</emphasis>.
    </simpara>

   </warning>

   <warning>
    <simpara>
     Vor PHP 7.3.0 ist es sehr wichtig, darauf zu achten, dass die Zeile mit
     dem schließenden Bezeichner keine anderen Zeichen außer einem Semikolon
     (<literal>;</literal>) enthalten darf. Das heißt insbesondere auch, dass
     der Bezeichner nicht <emphasis>eingerückt werden darf</emphasis> und dass
     es vor oder nach dem Semikolon auch keine Leerzeichen oder Tabulatoren
     geben darf. Zudem muss das erste Zeichen vor dem schließenden Bezeichner
     ein Zeilenumbruch sein, so wie er vom Betriebssystem definiert wird. In
     UNIX-Systemen, inlusive macOS, ist dies <literal>\n</literal>. Auf den
     schließenden Bezeichner muss ebenfalls ein Zeilenumbruch folgen.
    </simpara>

    <simpara>
     Wenn diese Regel gebrochen wird und der schließende Bezeichner nicht
     valide ist, wird er nicht als Bezeichner angenommen und PHP wird weiter
     nach einem solchen schließenden Bezeichner suchen. Wird kein gültiger
     schließender Bezeichner vor dem Dateiende gefunden, gibt PHP einen auf
     die letzte Zeile der Datei weisenden Parser-Fehler aus.
    </simpara>

    <example>
     <title>Ungültiges Beispiel vor PHP 7.3.0</title>
     <programlisting role="php">
      <!-- This is an INVALID example -->
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
    EOT;
}
// Identifier must not be indented
?>
]]>
     </programlisting>
    </example>
    <example>
     <title>Gültiges Beispiel, auch vor PHP 7.3.0</title>
     <programlisting role="php">
      <!-- This is a VALID example -->
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
EOT;
}
?>
]]>
     </programlisting>
    </example>

    <para>
     Heredocs, die Variablen enthalten, können nicht für die Initialisierung
     von Klasseneigenschaften verwendet werden.
    </para>

   </warning>

   <para>
    Heredoc-Text verhält sich genau wie ein <type>String</type> in doppelten
    Anführungsstrichen, ohne die doppelten Anführungszeichen. Das bedeutet,
    dass Anführungszeichen in einem Heredoc nicht maskiert werden müssen, aber
    die oben aufgeführten Maskierungscodes können trotzdem verwendet werden.
    Variablen werden aufgelöst, aber wenn komplexe Variablen innerhalb eines
    Heredocs verwendet werden, ist die gleiche Vorsicht geboten wie bei
    <type>String</type>s.
   </para>

   <example>
    <title>Beispiel für das Notieren von Heredoc-Strings</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Ein Beispiel für einen String, der sich
unter Verwendung der heredoc-Syntax
über mehrere Zeilen erstreckt.
EOD;

/* Ein komplexeres Beispiel mit Variablen. */
class foo
{
    var $foo;
    var $bar;

    function __construct()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MeinName';

echo <<<EOT
Mein Name ist "$name". Ich gebe etwas $foo->foo aus.
Jetzt gebe ich etwas {$foo->bar[1]} aus.
Dies sollte ein großes 'A' ausgeben: \x41
EOT;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Mein Name ist "MeinName". Ich gebe etwas Foo aus.
Jetzt gebe ich etwas Bar2 aus.
Dies sollte ein großes 'A' ausgeben: A]]>
    </screen>
   </example>

   <para>
    Es ist auch möglich, die Heredoc-Syntax zu verwenden, um Daten an
    Funktionsargumente zu übergeben:
   </para>

   <example>
    <title>Beispiel für Heredoc in Argumenten</title>
    <programlisting role="php">
<![CDATA[
<?php
var_dump(array(<<<EOD
foobar!
EOD
));
?>
]]>
    </programlisting>
   </example>

   <para>
    Es ist möglich, statische Variablen und Klasseneigenschaften/Konstanten
    mit Hilfe der Heredoc-Syntax zu initialisieren:
   </para>

   <example>
    <title>Verwendung von Heredoc zur Initialisierung von statischen Werten</title>
    <programlisting role="php">
<![CDATA[
<?php
// Statische Variablen
function foo()
{
    static $bar = <<<LABEL
Hier steht nichts drin...
LABEL;
}

// Klasseneigenschaften/Konstanten
class foo
{
    const BAR = <<<FOOBAR
Beispiel für eine Konstante
FOOBAR;

    public $baz = <<<FOOBAR
Beispiel für eine Eigenschaft
FOOBAR;
}
?>
]]>
    </programlisting>
   </example>

   <para>
    Der öffnende Heredoc-Bezeichner kann optional in doppelte
    Anführungszeichen gesetzt werden:
   </para>

   <example>
    <title>Verwendung von doppelten Anführungszeichen in Heredoc</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<"FOOBAR"
Hallo Welt!
FOOBAR;
?>
]]>
    </programlisting>
   </example>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.nowdoc">
   <title>Nowdoc</title>

   <para>
    Nowdocs sind für Strings in einfachen Anführungszeichen das, was Heredocs
    für Strings in doppelten Anführungszeichen sind. Ein Nowdoc wird ähnlich
    wie ein Heredoc angegeben, aber es wird <emphasis>kein Parsing</emphasis>
    innerhalb eines Nowdocs durchgeführt. Das Konstrukt ist ideal für die
    Einbettung von PHP-Code oder anderen großen Textblöcken ohne maskieren zu
    müssen. Es hat einige Eigenschaften mit dem
    <literal>&lt;![CDATA[ ]]&gt;</literal>-Konstrukt in SGML gemeinsam, indem
    es einen Textblock deklariert, der nicht geparst werden soll.
   </para>

   <para>
    Ein Nowdoc wird mit der gleichen <literal>&lt;&lt;&lt;</literal>-Sequenz
    identifiziert, die für Heredocs verwendet wird, aber der nachfolgende
    Bezeichner wird in einfachen Anführungszeichen eingeschlossen, &zb;
    <literal>&lt;&lt;&lt;'EOT'</literal>. Alle Regeln für Heredoc-Bezeichner
    gelten auch für Nowdoc-Bezeichner, insbesondere die hinsichtlich des
    Aussehens des schließenden Bezeichners.
   </para>

   <example>
    <title>Nowdoc-Beispiel für das Notieren von Strings</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<'EOD'
Ein Beispiel für einen String, der sich über mehrere Zeilen erstreckt
unter Verwendung der Nowdoc-Syntax. Backslashes werden immer als
Buchstaben behandelt,
z. B. \\ und \'.
EOD;
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Ein Beispiel für einen String, der sich über mehrere Zeilen erstreckt
unter Verwendung der Nowdoc-Syntax. Backslashes werden immer als
Buchstaben behandelt,
z. B. \\ und \'.
]]>
    </screen>
   </example>

   <example>
    <title>Nowdoc Beispiel für Strings mit Variablen</title>
    <programlisting role="php">
<![CDATA[
<?php
class foo
{
    public $foo;
    public $bar;

    function __construct()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MeinName';

echo <<<'EOT'
Mein Name ist "$name". Ich gebe etwas $foo->foo aus.
Jetzt gebe ich etwas {$foo->bar[1]} aus.
Dies sollte ein großes 'A' ausgeben: \x41
EOT;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Mein Name ist "$name". Ich gebe etwas $foo->foo aus.
Jetzt gebe ich etwas {$foo->bar[1]} aus.
Dies sollte ein großes 'A' ausgeben: \x41]]>
    </screen>
   </example>

   <example>
    <title>Beispiel für statische Daten</title>
    <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<'EOT'
bar
EOT;
}
?>
]]>
    </programlisting>
   </example>

  </sect3>

  <sect3 xml:id="language.types.string.parsing">
   <title>Parsing (Analyse) von Variablen</title>

   <simpara>
    Wenn ein <type>string</type> in doppelten Anführungszeichen oder mit
    Heredoc angegeben wird, werden darin
    <link linkend="language.variables">Variablen</link> geparst.
   </simpara>

   <simpara>
    Es gibt zwei Arten von Syntax: eine
    <link linkend="language.types.string.parsing.simple">einfache</link> und
    eine <link linkend="language.types.string.parsing.complex">komplexe</link>
    Syntax. Die einfache Syntax ist die gebräuchlichste und bequemste. Sie
    bietet eine Möglichkeit, eine Variable, einen <type>&array;</type>-Wert
    oder eine <type>&object;</type>-Eigenschaft mit minimalem Aufwand in einen
    <type>String</type> einzubetten.
   </simpara>

   <simpara>
    Die komplexe Syntax erkennt man an den geschweifte Klammern, die den
    Ausdruck umgeben.
   </simpara>

   <sect4 xml:id="language.types.string.parsing.simple">
    <title>Einfache Syntax</title>

    <simpara>
     Wenn ein Dollarzeichen (<literal>$</literal>) vorkommt, nimmt der Parser
     gierig so viele Token wie möglich, um einen gültigen Variablennamen zu
     bilden. Schließen Sie den Variablennamen in geschweifte Klammern ein, um
     das Ende des Namens explizit anzugeben.
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$juice = "apple";

echo "He drank some $juice juice.".PHP_EOL;
// Ungültig. "s" ist ein gültiges Zeichen für einen Variablennamen, aber die
// Variable ist $juice.
echo "He drank some juice made of $juices.";
// Gültig. Geben Sie das Ende des Variablennamens explizit an, indem Sie ihn
// in geschweifte Klammern einschließen:
echo "He drank some juice made of ${juice}s.";
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
He drank some apple juice.
He drank some juice made of .
He drank some juice made of apples.
]]>
     </screen>
    </informalexample>

    <simpara>
     In ähnlicher Weise kann ein <type>&array;</type>-Index oder eine
     <type>&object;</type>-Eigenschaft geparst werden. Bei Array-Indizes
     markiert die schließende eckige Klammer (<literal>]</literal>) das Ende
     des Indexes. Für Objekteigenschaften gelten die gleichen Regeln wie für
     einfache Variablen.
    </simpara>

    <example>
     <title>Beispiel für einfache Syntax</title>
     <programlisting role="php">
<![CDATA[
<?php
$juices = array("apple", "orange", "koolaid1" => "purple");

echo "He drank some $juices[0] juice.".PHP_EOL;
echo "He drank some $juices[1] juice.".PHP_EOL;
echo "He drank some $juices[koolaid1] juice.".PHP_EOL;

class people {
    public $john = "John Smith";
    public $jane = "Jane Smith";
    public $robert = "Robert Paulsen";

    public $smith = "Smith";
}

$people = new people();

echo "$people->john drank some $juices[0] juice.".PHP_EOL;
echo "$people->john then said hello to $people->jane.".PHP_EOL;
echo "$people->john's wife greeted $people->robert.".PHP_EOL;
echo "$people->robert greeted the two $people->smiths."; // Won't work
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
He drank some apple juice.
He drank some orange juice.
He drank some purple juice.
John Smith drank some apple juice.
John Smith then said hello to Jane Smith.
John Smith's wife greeted Robert Paulsen.
Robert Paulsen greeted the two .
]]>
     </screen>
    </example>

    <simpara>
     Seit PHP 7.1.0 werden auch <emphasis>negative</emphasis> numerische
     Indizes unterstützt.
    </simpara>

    <example>
     <title>Negative numerische Indizes</title>
     <programlisting role="php">
<![CDATA[
<?php
$string = 'string';
echo "Das Zeichen an Index -2 ist $string[-2].", PHP_EOL;
$string[-3] = 'o';
echo "Die Änderung des Zeichens an Index -3 auf o ergibt $string.", PHP_EOL;
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Das Zeichen an Index -2 ist n.
Die Änderung des Zeichens an Index -3 auf o ergibt strong.
]]>
     </screen>
    </example>

    <simpara>
     Für alles, das komplexer ist, sollten Sie die komplexe Syntax verwenden.
    </simpara>
   </sect4>

   <sect4 xml:id="language.types.string.parsing.complex">
    <title>Komplexe (geschweifte) Syntax</title>

    <simpara>
     Diese Syntax wird nicht komplex genannt, weil sie komplex ist, sondern
     weil sie die Verwendung komplexer Ausdrücke erlaubt.
    </simpara>

    <simpara>
     Jede skalare Variable, jedes Array-Element oder jede Objekteigenschaft
     mit einer <type>String</type>-Darstellung kann über diese Syntax
     eingebunden werden. Der Ausdruck wird so geschrieben, wie er auch
     außerhalb des <type>String</type>s erscheinen würde, und dann von
     <literal>{</literal> und <literal>}</literal> umschlossen. Da
     <literal>{</literal> nicht maskiert werden kann, wird diese Syntax nur
     erkannt werden, wenn das <literal>$</literal> unmittelbar auf das
     <literal>{</literal> folgt. Verwenden Sie <literal>{\$</literal>, um ein
     wörtliches <literal>{$</literal> zu erhalten. Einige Beispiele, um es zu
     verdeutlichen:
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Alle Fehler anzeigen
error_reporting(E_ALL);

$great = 'fantastisch';

// Wird nicht funktionieren, Ausgabe: Das ist { fantastisch}
echo "Das ist { $great}";

// Funktioniert, Ausgabe: Das ist fantastisch
echo "Das ist {$great}";

// Funktioniert
echo "Dieses Quadrat ist {$square->width}00 Zentimeter breit.";


// Funktioniert, Anführungszeichen funktionieren nur mit der geschweiften Klammer
echo "Das funktioniert: {$arr['key']}";


// Funktioniert
echo "Das funktioniert: {$arr[4][3]}";

// Dies ist aus demselben Grund falsch, aus dem $foo[bar] außerhalb eines
// Strings falsch ist. Mit anderen Worten, es wird trotzdem funktionieren,
// aber nur, weil PHP zuerst nach einer Konstante namens foo sucht; es wird
// ein Fehler der Stufe E_NOTICE (undefinierte Konstante) ausgelöst.
echo "Das ist falsch: {$arr[foo][3]}";

// Funktioniert. Verwenden Sie bei mehrdimensionalen Arrays immer geschweifte
// Klammern um die Arrays, wenn diese innerhalb von Strings stehen
echo "Das funktioniert: {$arr['foo'][3]}";

// Funktioniert.
echo "Das funktioniert: " . $arr['foo'][3];

echo "Das funktioniert auch: {$obj->values[3]->name}";

echo "Das ist der Wert der Variable namens $name: {${$name}}";

echo "Das ist der Wert der Variable, die durch den Rückgabewert von getName() benannt wurde: {${getName()}}";

echo "Das ist der Wert der Variable, die durch den Rückgabewert von \$object->getName() benannt wurde: {${$object->getName()}}";

// Wird nicht funktionieren, Ausgabe: Das ist der Rückgabewert von getName(): {getName()}
echo "Das ist der Rückgabewert von getName(): {getName()}";

// Wird nicht funktionieren, Ausgabe: C:\folder\{fantastic}.txt
echo "C:\folder\{$great}.txt"
// Funktioniert, Ausgabe: C:\folder\fantastic.txt
echo "C:\\folder\\{$great}.txt"
?>
]]>
<!-- maybe it's better to leave this out??
// das funktioniert, aber ich rate von seiner Verwendung ab, da es hier NICHT
// um Funktionen geht, sondern nur um Variablen, Arrays und Objekte.
$beer = 'Heineken';
echo "Ich hätte gerne ein weiteres {${ strrev('reeb') }}, hips";
 -->
     </programlisting>
    </informalexample>

    <para>
     Es ist mit dieser Syntax auch möglich, über Variablen innerhalb von
     Strings auf Klasseneigenschaften zuzugreifen.
    </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class foo {
    var $bar = 'I am bar.';
}

$foo = new foo();
$bar = 'bar';
$baz = array('foo', 'bar', 'baz', 'quux');
echo "{$foo->$bar}\n";
echo "{$foo->{$baz[1]}}\n";
?>
]]>
    </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
I am bar.
I am bar.
]]>
   </screen>
   </informalexample>

    <note>
     <para>
      Der Wert, auf den von Funktionen, Methodenaufrufen, statischen
      Klassenvariablen, und Klassenkonstanten innerhalb von
      <literal>{$}</literal> zugegriffen wird, wird als der Name einer
      Variablen in dem Bereich interpretiert, in dem der String definiert ist.
      Die Verwendung von einzelnen geschweiften Klammern
      (<literal>{}</literal>) funktioniert nicht für den Zugriff auf die
      Rückgabewerte von Funktionen oder Methoden oder die Werte von
      Klassenkonstanten oder statischen Klassenvariablen.
     </para>
    </note>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Alle Fehler anzeigen
error_reporting(E_ALL);

class beers {
    const softdrink = 'rootbeer';
    public static $ale = 'ipa';
}

$rootbeer = 'A & W';
$ipa = 'Alexander Keith\'s';

// Das funktioniert; Ausgabe: Ich hätte gerne ein A & W
echo "Ich hätte gerne ein {${beers::softdrink}}\n";

// Das funktioniert auch; Ausgabe: Ich hätte gerne ein Alexander Keith's
echo "Ich hätte gerne ein {${beers::$ale}}\n";
?>
]]>
     </programlisting>
    </informalexample>

   </sect4>
  </sect3>

  <sect3 xml:id="language.types.string.substr">
   <title>Zugriff auf Strings und Änderung von Zeichen</title>

   <para>
    Auf ein Zeichen in einem <type>String</type> kann zugegriffen und es kann
    geändert werden, indem seine Position (von 0 an) hinter dem
    <type>String</type> mit Hilfe von <type>&array;</type>-Klammern angegeben
    wird, &zb; <varname>$str[42]</varname>. In diesem Fall ist es hilfreich,
    sich einen <type>String</type> als ein <type>&array;</type> von Zeichen
    vorzustellen. Die Funktionen <function>substr</function> und
    <function>substr_replace</function> können verwendet werden, wenn mehr als
    ein Zeichen extrahiert oder ersetzt werden soll.
   </para>

   <note>
    <simpara>
     Seit PHP 7.1.0 werden auch negative String-Offsets unterstützt. Diese
     geben den Offset vom Ende des Strings an. Früher verursachten negative
     Offsets beim Lesen eine <constant>E_NOTICE</constant>-Meldung aus (was
     einen leeren String ergibt) und beim Schreiben eine
     <constant>E_WARNING</constant>-Meldung (was den String unangetastet
     lässt).
    </simpara>
   </note>

   <note>
    <simpara>
     Vor PHP 8.0.0 konnte für den gleichen Zweck auch mit Klammern auf
     <type>String</type>s zugegriffen werden, wie in
     <varname>$str{42}</varname>. Diese Syntax mit geschweiften Klammern ist
     seit PHP 7.4.0 veraltet und wird seit PHP 8.0.0 nicht mehr unterstützt.
    </simpara>
   </note>

   <warning>
    <simpara>
     Das Schreiben an einen Offset außerhalb des vorhandenen Bereichs bewirkt,
     dass der String bis zu dieser Position mit Leerzeichen aufgefüllt wird.
     Nicht-ganzzahlige Offsets werden in einen ganzzahligen Wert umgewandelt.
     Bei ungültigen Offset-Typen wird eine <constant>E_WARNING</constant>
     ausgegeben. Nur das erste Zeichen eines zugewiesenen Strings wird
     verwendet. Seit PHP 7.1.0 führt die Zuweisung eines leeren Strings zu
     einem schwerwiegenden Fehler. Vorher wurde ein NULL-Byte zugewiesen.
    </simpara>
   </warning>

   <warning>
    <simpara>
     Intern sind PHP-Strings Byte-Arrays. Folglich ist der Zugriff auf einen
     String oder dessen Änderung mit Array-Klammern nicht Multi-Byte-sicher
     und sollte nur mit Strings erfolgen, die in einer Ein-Byte-Kodierung wie
     ISO-8859-1 vorliegen.
    </simpara>
   </warning>

   <note>
    <simpara>
     Seit PHP 7.1.0 führt die Anwendung des leeren Indexoperators auf einen
     leeren String zu einem fatalen Fehler. Zuvor wurde der leere String
     stillschweigend in ein Array umgewandelt.
    </simpara>
   </note>

   <example>
    <title>Einige String-Beispiele</title>
    <programlisting role="php">
<![CDATA[
<?php
// Ermitteln des ersten Zeichens eines Strings.
$str = 'Das ist ein Test.';
$first = $str[0];

// Ermitteln des dritten Zeichens eines Strings.
$third = $str[2];

// Ermitteln das letzten Zeichens eines Strings.
$str = 'Das ist immer noch ein Test.';
$last = $str[strlen($str)-1];

// Ändern des letzten Zeichens eines Strings.
$str = 'Look at the sea';
$str[strlen($str)-1] = 'e';

?>
]]>
    </programlisting>
   </example>

   <para>
    String-Offsets müssen entweder Integer oder Integer-ähnliche Strings sein,
    andernfalls wird eine Warnung ausgelöst.
   </para>

   <example>
    <!-- TODO Update for PHP 8.0 -->
    <title>Beispiel für unzulässige String-Offsets</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = 'abc';

var_dump($str['1']);
var_dump(isset($str['1']));

var_dump($str['1.0']);
var_dump(isset($str['1.0']));

var_dump($str['x']);
var_dump(isset($str['x']));

var_dump($str['1x']);
var_dump(isset($str['1x']));
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
string(1) "b"
bool(true)

Warning: Illegal string offset '1.0' in /tmp/t.php on line 7
string(1) "b"
bool(false)

Warning: Illegal string offset 'x' in /tmp/t.php on line 9
string(1) "a"
bool(false)
string(1) "b"
bool(false)
]]>
    </screen>
   </example>

   <note>
    <para>
     Der Zugriff auf Variablen anderer Typen (ohne Arrays oder Objekte, die
     entsprechende Schnittstellen implementieren) mit <literal>[]</literal>
     oder <literal>{}</literal> gibt stillschweigend &null; zurück.
    </para>
   </note>

   <note>
    <para>
     Auf Zeichen innerhalb von String-Literalen kann mit <literal>[]</literal>
     oder <literal>{}</literal> zugegriffen werden.
    </para>
   </note>

   <note>
    <para>
     Der Zugriff auf Zeichen innerhalb von String-Literalen mit der
     <literal>{}</literal>-Syntax ist seit PHP 7.4 veraltet und wurde in PHP
     8.0 entfernt.
    </para>
   </note>
  </sect3>
 </sect2><!-- end syntax -->

 <sect2 xml:id="language.types.string.useful-funcs">
  <title>Nützliche Funktionen und Operatoren</title>

  <para>
   <type>String</type>s können mit dem Punkt-Operator '.' verkettet werden.
   Es ist zu beachten, dass der Additions-Operator '+' in diesem Fall
   <emphasis>nicht</emphasis> funktioniert. Siehe
   <link linkend="language.operators.string">String-Operatoren</link> für mehr
   Informationen.
  </para>

  <para>
   Es gibt eine Reihe nützlicher Funktionen für die
   <type>String</type>-Manipulation.
  </para>

  <simpara>
   Siehe den Abschnitt <link linkend="ref.strings" >String-Funktionen</link>
   für allgemeine Funktionen und die
   <link linkend="ref.pcre">Funktionen für Perl-kompatible reguläre Ausdrücke</link>
   für erweiterte Funktionen zum Suchen und Ersetzen.
  </simpara>

  <simpara>
   Außerdem gibt es <link linkend="ref.url">Funktionen für URL-Strings</link>
   und Funktionen zum Verschlüsseln/Entschlüsseln von Strings
   (<link linkend="ref.sodium">Sodium</link> und
   <link linkend="ref.hash">Hash</link>).
  </simpara>

  <simpara>
   Siehe zudem auch die
   <link linkend="ref.ctype">Zeichentyp-Funktionen</link>.
  </simpara>
 </sect2>

 <sect2 xml:id="language.types.string.casting">
  <title>Converting to string</title>

  <para>
   Ein Wert kann mit dem Schlüsselwort <literal>(string)</literal> oder der
   Funktion <function>strval</function> in einen <type>String</type>
   umgewandelt werden. Die Umwandlung in einen <type>String</type> erfolgt
   automatisch im Kontext eines Ausdrucks, in dem ein <type>String</type>
   erforderlich ist. Dies geschieht &zb; bei der Verwendung der Funktionen
   <function>echo</function> oder <function>print</function> oder wenn eine
   Variable mit einem <type>String</type> verglichen wird. In den Abschnitten
   über <link linkend="language.types">Typen</link> und
   <link linkend="language.types.type-juggling">Typ-Manipulationen</link>
   werden die folgenden Punkte näher erläutert. Siehe auch die Funktion
   <function>settype</function>.
  </para>

  <para>
   Ein <type>bool</type> &true; -Wert wird in den <type>String</type>
   <literal>"1"</literal> umgewandelt. <type>bool</type> &false; wird in
   <literal>""</literal> (den leeren String) umgewandelt. Dies ermöglicht es,
   zwischen <type>bool</type>- und <type>String</type>-Werten hin und her zu
   konvertieren.
  </para>

  <para>
   Ein <type>Int</type> oder <type>Float</type> wird in einen
   <type>String</type> umgewandelt, der die Zahl textuell darstellt
   (einschließlich des Exponententeil bei <type>Float</type>s).
   Gleitkommazahlen können mit der Exponentialschreibweise umgewandelt werden
   (<literal>4.1E+6</literal>).
  </para>

  <note>
   <para>
    Seit PHP 8.0.0 ist das Dezimalpunktzeichen immer ein Punkt
    ("<literal>.</literal>"). Vor PHP 8.0.0 wird das Dezimalpunktzeichen in
    der Locale des Skripts definiert (Kategorie LC_NUMERIC). Siehe die
    Funktion <function>setlocale</function>.
   </para>
  </note>

  <para>
   <type>&array;</type>s werden immer in
   <type>String</type>-<literal>"Arrays"</literal> umgewandelt; aus diesem
   Grund können <function>echo</function> und <function>print</function> nicht
   von sich aus den Inhalt eines <type>&array;</type>s anzeigen. Um ein
   einzelnes Element anzuzeigen, verwendet man eine Konstruktion wie
   <literal>echo $arr['foo']</literal>. Siehe unten für Tipps zur Anzeige
   des gesamten Inhalts.
  </para>

  <para>
   Um <type>&object;</type>e in <type>String</type>s umzuwandeln, muss die
   magische Methode <link linkend="language.oop5.magic">__toString</link>
   verwendet werden.
  </para>

  <para>
   <type>&resource;</type>n werden immer mit der Struktur
   <literal>"Resource id #1"</literal> in <type>String</type>s umgewandelt,
   wobei <literal>1</literal> die Ressourcennummer ist, die der
   <type>&resource;</type> von PHP zur Laufzeit zugewiesen wird. Obwohl man
   sich nicht auf die genaue Struktur dieses Strings verlassen sollte und sie
   sich ändern kann, wird sie für eine bestimmte Ressource innerhalb der
   Lebensdauer eines ausgeführten Skripts (&dh; einer Web-Anfrage oder eines
   CLI-Prozesses) immer eindeutig sein und wird nicht wiederverwendet. Um den
   Typ einer <type>&resource;</type> zu erhalten, kann die Funktion
   <function>get_resource_type</function> verwendet werden.
  </para>

  <para>
   &null; wird immer in einen leeren String umgewandelt.
  </para>

  <para>
   Wie oben erwähnt, liefert die direkte Umwandlung eines
   <type>&array;</type>s, <type>&object;</type>s oder einer
   <type>&resource;</type> in einen <type>String</type> keine nützlichen
   Informationen über den Wert, die über seinen Typ hinausgehen. Um den Inhalt
   dieser Typen zu ermitteln, siehe die Funktionen
   <function>print_r</function> und <function>var_dump</function>.
  </para>

  <para>
   Die meisten PHP-Werte können zur dauerhaften Speicherung auch in
   <type>String</type>s umgewandelt werden. Diese Methode wird Serialisierung
   genannt und wird von der Funktion <function>serialize</function>
   durchgeführt.
  </para>

 </sect2>

 <sect2 xml:id="language.types.string.details">

  <title>Details zum String-Typ</title>

  <para>
   Der Typ <type>string</type> ist in PHP als ein Array von Bytes und einem
   Integer, der die Länge des Puffers angibt, implementiert. Er hat keine
   Informationen darüber, wie diese Bytes in Zeichen umgewandelt werden; diese
   Aufgabe wird dem Programmierer überlassen. Es gibt keine Beschränkungen für
   die Werte, aus denen der String bestehen kann; insbesondere Insbesondere
   sind Bytes mit dem Wert <literal>0</literal> ("NUL-Bytes") in der
   Zeichenkette erlaubt (allerdings können einige Funktionen, die in diesem
   Handbuch als nicht "binärsicher" eingestuft werden, die Strings an
   Bibliotheken weitergeben, die Daten nach einem NUL-Byte ignorieren).
  </para>
  <para>
   Diese Eigenschaft des String-Typs erklärt, warum es in PHP keinen separaten
   "Byte"-Typ gibt - Strings übernehmen diese Rolle. Funktionen, die keine
   textuellen Daten zurückgeben - zum Beispiel beliebige Daten, die von einem
   Netzwerksocket gelesen werden - geben immer noch Strings zurück.
  </para>
  <para>
   Da PHP keine spezifische Kodierung für Strings vorschreibt, könnte man sich
   fragen, wie String-Literale kodiert werden. Ist zum Beispiel der String
   <literal>"á"</literal> äquivalent zu <literal>"\xE1"</literal>
   (ISO-8859-1), <literal>"\xC3\xA1"</literal> (UTF-8, C-Form),
   <literal>"\x61\xCC\x81"</literal> (UTF-8, D-Form) oder zu irgendeiner
   anderen möglichen Darstellung? Die Antwort lautet, dass der String auf die
   Art und Weise kodiert wird, wie er in der Skriptdatei kodiert ist. Wenn das
   Skript also in ISO-8859-1 geschrieben ist, wird die Zeichenkette in
   ISO-8859-1 kodiert und so weiter. Das gilt jedoch nicht, wenn
   Zend-Multibyte aktiviert ist; in diesem Fall kann das Skript in einer
   beliebigen Kodierung geschrieben werden (die explizit deklariert ist oder
   erkannt wird) und dann in eine bestimmte interne Kodierung konvertiert
   werden, welche dann die Kodierung ist, die für die String-Literale
   verwendet wird. Es ist zu beachten, dass es einige Beschränkungen für die
   Kodierung des Skripts gibt (oder für die interne Kodierung gibt, sollte
   Zend-Multibyte aktiviert sein) - das bedeutet fast immer, dass diese
   Kodierung eine kompatible Obermenge von ASCII sein sollte, wie &zb; UTF-8
   oder ISO-8859-1. Es ist jedoch zu beachten, dass zustandsabhängige
   Kodierungen, bei denen dieselben Byte-Werte sowohl im Anfangszustand als
   auch im Nicht-Anfangszustand verwendet werden können, problematisch sein
   können.
  </para>
  <para>
   Um nützlich zu sein, müssen Funktionen, die mit Text arbeiten, natürlich
   Annahmen darüber treffen, wie der String kodiert ist. Leider gibt es in
   diesem Punkt viele Unterschiede zwischen den PHP-Funktionen:
  </para>
  <itemizedlist>
   <listitem>
    <simpara>
     Einige Funktionen gehen davon aus, dass der String in einer (beliebigen)
     Ein-Byte-Kodierung kodiert ist, aber sie müssen diese Bytes nicht als
     bestimmte Zeichen interpretieren. Dies ist &zb; der Fall bei
     <function>substr</function>, <function>strpos</function>,
     <function>strlen</function> oder <function>strcmp</function>. Eine andere
     Möglichkeit, sich diese Funktionen vorzustellen, ist, dass sie mit
     Speicherpuffern arbeiten, &dh; sie arbeiten mit Bytes und Byte-Offsets.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Anderen Funktionen wird die Kodierung des Strings übergeben, eventuell
     nehmen sie auch einen Standardwert an, wenn keine solche Information
     angegeben wird. Dies ist der Fall bei <function>htmlentities</function>
     und den meisten der Funktionen in der
     <link linkend="book.mbstring">mbstring</link>-Erweiterung.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Andere verwenden die aktuelle Locale (siehe
     <function>setlocale</function>), arbeiten aber Byte für Byte.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Letztendlich können sie einfach davon ausgehen, dass der String eine
     bestimmte Kodierung verwendet, normalerweise UTF-8. Dies ist der Fall bei
     den meisten Funktionen in der
     <link linkend="book.intl">intl</link>-Erweiterung und in der
     <link linkend="book.pcre">PCRE</link>-Erweiterung (im letzteren Fall nur,
     wenn der Modifikator <literal>u</literal> verwendet wird).
    </simpara>
   </listitem>
  </itemizedlist>

  <para>
   Letztlich bedeutet dies, dass das Schreiben korrekter Programme mit Unicode
   davon abhängt, Funktionen, die nicht funktionieren und die Daten
   höchstwahrscheinlich beschädigen, sorgfältig zu vermeiden und stattdessen
   die Funktionen zu verwenden, die sich korrekt verhalten. Im Allgemeinen
   sind das die Funktionen der <link linkend="book.intl">intl</link>- und
   <link linkend="book.mbstring">mbstring</link>-Erweiterungen. Die Verwendung
   von Funktionen, die Unicode-Kodierungen verarbeiten können, ist jedoch nur
   der Anfang. Unabhängig von den Funktionen, die die Sprache zur Verfügung
   stellt, ist es wichtig, die Unicode-Spezifikation zu kennen. Ein Programm,
   das zum Beispiel davon ausgeht, dass es nur Groß- und Kleinbuchstaben gibt,
   geht von einer falschen Annahme aus.
  </para>
 </sect2>
</sect1><!-- end string -->

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
