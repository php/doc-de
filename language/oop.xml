<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.18 $ -->
<!-- EN-Revision: 1.37 Maintainer: nobody Status: working -->
 <chapter xml:id="language.oop" xmlns="http://docbook.org/ns/docbook">
  <title>Klassen und Objekte</title>

  <sect1 xml:id="keyword.class">
   <title><literal>Klassen</literal></title>
   <para>
    Eine Klasse ist eine Sammlung von Variablen und Funktionen, die
    mit diesen Variablen arbeiten. Eine Klasse wird folgendermaßen
    definiert:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Cart
{
    var $items;  // Artikel in unserem Einkaufswagen
   
    // Füge dem Einkaufswagen $num Artikel der Sorte $artnr zu
 
    function add_item ($artnr, $num)
    {
        $this->items[$artnr] += $num;
    }
   
    // Nimm $num Artikel von $artnr aus dem Einkaufswagen
 
    function remove_item ($artnr, $num)
    {
        if ($this->items[$artnr] > $num) {
            $this->items[$artnr] -= $num;
            return true;
        } else {
            return false;
        }   
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
 
   <para>
    In diesem Beispiel wird eine Klasse "Cart" definiert. Sie
    besteht aus einem assoziativen Array von Produkten im
    Einkaufswagen und zwei Funktionen zum Hinzufügen und Entfernen von
    Artikeln.
   </para>

   <caution>
    <simpara>
     Die folgenden warnenden Bemerkungen gelten für PHP 4.
    </simpara>

    <simpara>
     Der Name <literal>stdClass</literal> ist reserviert, da er intern
     von Zend benutzt wird. Sie können in PHP keine Klasse mit dem
     Namen <literal>stdClass</literal> haben.
    </simpara>

    <simpara>
      Die Funktionsnamen <literal>__sleep</literal> und
      <literal>__wakeup</literal> sind in PHP Klassen "magisch". Sie
      können in Ihren Klassen keine Funktionen mit diesen Namen haben,
      außer Sie wollen sie mit dieser "magischen" Funktionalität
      assoziieren. Mehr Informationen dazu finden Sie weiter unten.
    </simpara>

    <simpara>
      Sämtliche mit __ beginnende Funktionsnamen sind PHP als "magisch"
      vorbehalten. Es wird empfohlen, in PHP keine Funktionsnamen mit
      __ zu verwenden, außer Sie möchten dokumentierte "magische"
      Funktionalität.
    </simpara>
   </caution>

   <note>
    <simpara>
     In PHP 4 sind nur konstante Initialisierungen für
     <literal>var</literal> Variablen erlaubt. Um Variablen mit nicht
     konstanten Werten zu initialisieren, benötigen Sie eine Funktion
     zur Initialisierung, welche beim Erstellen eines Objektes
     automatisch von der Klasse aufgerufen wird. Eine solche Funktion
     wird Konstruktor genannt (siehe unten).
    </simpara>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Keine wird in PHP 4 funktionieren */
class Cart
{
    var $todays_date = date("Y-m-d");
    var $name = $firstname;
    var $owner = 'Fred ' . 'Jones';
    var $items = array("VCR", "TV");
}

/* So sollte es gemacht werden */
class Cart
{
    var $todays_date;
    var $name;
    var $owner;
    var $items;

    function Cart()
    {
        $this->todays_date = date("Y-m-d");
        $this->name = $GLOBALS['firstname'];
        /* etc. . . */
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </note>

   <para>
    Klassen sind Typen, das heißt sie sind die Blaupausen für reale
    Variablen. Um sie zu nutzen, muss zunächst eine Variable mit dem
    Operator <literal>new</literal> angelegt werden.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$cart = new Cart;
$cart->add_item("10", 1);

$another_cart = new Cart;
$another_cart->add_item("0815", 3);
]]>
    </programlisting>
   </informalexample>
 
   <para>
    Dies erstellt die Objekte $cart und $another_cart aus der Klasse
    Cart. Dann wird die Funktion add_item() des $cart Objektes
    aufgerufen, um $cart einen Artikel mit der Artikelnummer 10
    hinzuzufügen. 3 Artikel mit der Artikelnummer 0815 werden
    $another_cart hinzugefügt.
   </para>
   
   <para>
    Sowohl $cart als auch $another_cart haben die Funktionen
    add_item(), remove_item() und die Variable items. Dies sind
    verschiedene Funktionen und Variablen. Sie können sich Objekte
    ähnlich den Verzeichnissen in einem Dateisystem vorstellen. Sie
    können in einem Dateisystem zwei verschiedene Dateien README.TXT
    haben, solange sie sich in verschiedenen Verzeichnissen befinden.
    So wie Sie in Verzeichnissen den vollen Pfadnamen eingeben müssen,
    um jede Datei von dem obersten Verzeichnis aus zu erreichen, müssen
    Sie auch den vollen Namen der aufzurufenden Funktion angeben: Das
    heißt für PHP, dass das Hauptverzeichnis der globale Namensbereich,
    und der Separator des Pfadnamens -&gt; wäre. Deshalb benennen die
    Namen $cart-&gt;items und $another_cart-&gt;items auch zwei
    verschiedene Variablen. Beachten Sie, dass die Variable
    $cart-&gt;items, und nicht $cart-&gt;$items genannt wird, da
    ein Variablenname in PHP nur ein einziges Dollarzeichen hat.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
// korrekt, einfaches $
$cart->items = array("10" => 1); 

// falsch, denn $cart->$items wird zu $cart->""
$cart->$items = array("10" => 1);

// richtig aber fraglich, ob dies erwünscht war:
// $cart->$myvar wird zu $cart->items
$myvar = 'items';
$cart->$myvar = array("10" => 1);  
]]>
    </programlisting>
   </informalexample>

   <para>
    Innerhalb einer Klassendefinition ist nicht bekannt, unter welchem
    Namen das Objekt in Ihrem Programm erreichbar sein wird: Als die
    Klasse Cart geschrieben wurde war nicht bekannt, dass das Objekt
    später $cart oder $another_cart genannt wird. Deshalb können Sie
    innerhalb der Klasse Cart selbst auch nicht $cart-&gt;items schreiben.
    Um nun die eigenen Funktionen und Variablen innerhalb einer Klasse
    anzusprechen, können Sie die Pseudo-Variable $this verwenden, welche
    Sie auch als 'meine eigene' oder 'aktuelles Objekt' verstehen können.
    Deshalb kann '$this-&gt;items[$artnr] += $num' auch als 'addiere $num
    zu $artnr in meinem eigenen Array items', oder 'addiere $num zu
    $artnr im Array items innerhalb des aktuellen Objektes' lesen.
   </para>

   <note>
    <para>
    Es gibt ein paar angenehme Funktionen, um mit Klassen und Objekten umzugehen.
    Mehr darüber erfahren Sie im Kapitel <link linkend="ref.classobj">Klassen- 
    und Objekt-Funktionen</link>.
    </para>
   </note>
  </sect1>
  
  <sect1 xml:id="keyword.extends">
   <title><literal>extends</literal></title>

   <para>
    Oft braucht man Klassen mit in einer anderen Klasse ähnlichen Variablen
    und Funktionen. So ist es eine gute Vorgehensweise, eine in allen Ihren
    Projekten verwendbare Oberklasse zu definieren, und diese dann den
    Bedürfnissen Ihrer einzelnen Projekte anzupassen. Um dies zu erleichtern,
    können Klassen andere Klassen erweitern. Die erweiterte bzw. abgeleitete
    Klasse verfügt über alle Variablen und Funktionen der Basisklasse (dies
    wird 'Vererbung' genannt, obwohl niemand gestorben ist), und was Sie in
    der erweiterten Definition hinzufügen. Es ist nicht möglich, etwas von
    einer Klasse wegzunehmen, d.h. Sie können keine existierenden Variablen
    oder Funktionen 'wegdefinieren'. Eine Unterklasse ist immer von einer
    einzigen Oberklasse abhängig, d.h. Mehrfachvererbung wird nicht
    unterstützt. Klassen werden mittels dem Schlüsselwort 'extends' erweitert.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
class Named_Cart extends Cart
{
    var $owner;
  
    function set_owner ($name)
    {
        $this->owner = $name;
    }
}
]]>
    </programlisting>
   </informalexample>
 
   <para>
    Hier wird die Klasse Named_Cart definiert, die über alle Variablen
    und Funktionen von Cart, plus der Variable $owner und der Funktion
    set_owner() verfügt. Sie können einen bestimmten Einkaufswagen
    (Named_Cart) auf dem üblichen Weg erstellen, und nun auch den
    Besitzer (owner) bestimmen und erfragen. Sie können noch immer
    die normalen Cart Funktionen an Named_Cart anwenden:
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
$ncart = new Named_Cart;    // Erstellt einen bestimmten Einkaufwagen
$ncart->set_owner("kris");  // den Besitzer festlegen
print $ncart->owner;        // den Besitzer ausgeben
$ncart->add_item("10", 1);  // (vererbte Funktionalität von Cart)
]]>
    </programlisting>
   </informalexample>

   <para>
    Dies wird auch eine "Eltern-Kind" Beziehung genannt. Sie erstellen eine
    Klasse ("Eltern"), und erstellen mittels <literal>extends</literal> eine
    neue Klasse, die auf der "Eltern"-Klasse <emphasis>basiert</emphasis>:
    die "Kind"-Klasse. Sie können auch diese neue Unterklasse verwenden und
    eine neue, auf dieser Klasse basierenden Klasse erstellen.
   </para>
   <note>
    <para>
     Bevor Sie Klassen verwenden können, müssen Sie diese definieren. Wenn
     Sie wollen, dass <literal>Named_Cart</literal> die Klasse
     <literal>Cart</literal> erweitert, müssen Sie <literal>Cart</literal>
     erst definieren. Wenn Sie eine andere Klasse, z.B.
     <literal>Yellow_named_cart</literal> erstellen wollen, welche
     auf <literal>Named_Cart</literal> basiert, müssen Sie zuerst 
     <literal>Named_Cart</literal> definieren. Kurz gesagt ist die
     Reihenfolge, in der die Klassen definiert werden, sehr wichtig.
    </para>
   </note>
  </sect1>

  <sect1 xml:id="language.oop.constructor">
   <title><literal>Konstruktoren</literal></title>

   <caution>
    <simpara>
     In PHP 3 und PHP 4 verhalten sich die Konstruktoren
     unterschiedlich. Die PHP 4 Semantik wird dringend empfohlen.
    </simpara>
   </caution>

   <para>
    Konstruktoren sind Funktionen innerhalb einer Klasse, die
    automatisch aufgerufen wird, sobald Sie mittels
    <literal>new</literal> eine neue Instanz erstellen. In PHP 3
    wird eine Funktion zum Konstruktor, wenn sie den gleichen Namen
    wie die Klasse hat. In PHP 4 wird eine Funktion zum Konstruktor,
    wenn sie den gleichen Namen wie die Klasse hat, in der sie
    definiert ist. Der Unterschied ist subtil, aber entscheidend
    (siehe unten).
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
// Funktioniert sowohl in PHP 3, als auch in PHP 4.
class Auto_Cart extends Cart
{
    function Auto_Cart()
    {
        $this->add_item ("10", 1);
    }
}
]]>
    </programlisting>
   </informalexample>
 
   <para>
    Die Klasse Auto_Cart entspricht der Klasse Cart und hat einen
    Konstruktor, der Cart bereits mit einem Artikel der Nummer "10"
    initialisiert, sobald ein neuer Auto_Cart mittels "new" erstellt
    wird. Konstruktoren können Argumente übernehmen, die optional
    sein können, was sie sehr praktisch macht. Um eine Klasse auch
    ohne Parameter verwenden zu können, sollten alle Parameter für
    Konstruktoren optional sein, indem sie mit Standardwerten
    ausgestattet werden.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
// Funktioniert sowohl in PHP 3, als auch in PHP 4.
class Constructor_Cart extends Cart
{
    function Constructor_Cart($item = "10", $num = 1)
    {
        $this->add_item ($item, $num);
    }
}
 
// Kaufe das gleiche alte Zeug ein.
 
$default_cart = new Constructor_Cart;
 
// Kaufe etwas anderes...
 
$different_cart = new Constructor_Cart("20", 17);
]]>
    </programlisting>
   </informalexample>

   <para>
    Sie können auch den Operator <literal>@</literal> verwenden, um
    Fehlermeldungen innerhalb des Konstruktors zu unterdrücken, z.B.
    <literal>@new</literal>.
   </para>

   <caution>
    <simpara>
     In PHP 3 haben abgeleitete Klassen und Konstruktoren ein paar
     Einschränkungen. Sie sollten das folgende Beispiel sorgfältig
     lesen, um diese Einschränkungen zu verstehen.
    </simpara> 
   </caution>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
class A
{
    function A()
    {
      echo "I am the constructor of A.<br>\n";
    }
}

class B extends A
{
    function C()
    {
        echo "I am a regular function.<br>\n";
    }
}

// In PHP 3 wurde kein Konstruktor aufgerufen.
$b = new B;
]]>
    </programlisting>
   </informalexample>

   <para>
    In PHP 3 wird bei dem obigen Beispiel kein Konstruktor aufgerufen.
    Die Regel in PHP 3 besagt: 'Ein Konstruktor ist eine Funktion mit
    dem selben Namen wie die Klasse'. Der Name der Klasse ist B, und
    nachdem in Klasse B keine Funktion namens B() existiert, passiert
    nichts.
   </para>
   
   <para>
    Dies ist in PHP 4 mit der Einführung einer anderen Regel behoben:
    Wenn eine Klasse keinen Konstruktor hat, wird der Konstruktor der
    Basisklasse aufgerufen, so dieser existiert. Das obige Beispiel
    hätte in PHP 4 also 'I am the constructor of A.&lt;br>' ausgegeben.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
class A
{
    function A()
    {
        echo "I am the constructor of A.<br>\n";
    }

    function B()
    {
        echo "I am a regular function named B in class A.<br>\n";
        echo "I am not a constructor in A.<br>\n";
    }
}

class B extends A
{
    function C()
    {
        echo "I am a regular function.<br>\n";
    }
}

// Dies ruft B() als Konstruktor auf.
$b = new B;
]]>
    </programlisting>
   </informalexample>
   
   <para>
    In PHP 3 wird die Funktion B() in der Klasse A plötzlich zum
    Konstruktor in Klasse B, auch wenn dies nie beabsichtigt war.
    Die Regel in PHP 3 lautet: 'Ein Konstruktor ist eine Funktion
    mit dem gleichen Namen wie die Klasse'. PHP 3 kümmert sich nicht
    darum, ob die Funktion in Klasse B definiert, oder ob sie nur
    vererbt wurde.
   </para>
   
   <para>
    Dies ist in PHP 4 mit einer modifizierten Regel behoben: 'Ein
    Konstruktor ist eine Funktion mit dem selben Namen wie die Klasse,
    in der sie definiert wurde'. So hätte die Klasse B in dem obigen
    Beispiel keinen eigenen Konstruktor, und würde der Konstruktor
    der Basisklasse aufgerufen, welcher 'I am the constructor of
    A.&lt;br>' ausgeben würde.
   </para>
   
   <caution>
    <simpara>
     Weder PHP 3, noch PHP 4 rufen vom Konstruktor der abgeleiteten
     Klasse aus automatisch Konstruktoren der Basisklasse auf. Wenn
     angebracht, ist der Aufruf von Konstruktoren aufwärts Ihre
     Aufgabe.
    </simpara>
   </caution>
   
   <note>
    <simpara>
     In PHP 3 und PHP 4 gibt es keine Destruktoren. Stattdessen können
     Sie <function>register_shutdown_function</function> verwenden, um
     die meisten Effekte von Destruktoren zu simulieren.
    </simpara>
   </note>
   
   <para>
    Destruktoren sind Funktionen die automatisch aufgerufen werden, wenn
    ein Objekt entweder mittels <function>unset</function>, oder durch
    Verlassen des Gültigkeitsbereiches zerstört wird. Es gibt in PHP
    keine Destruktoren.
   </para>
  </sect1>

 <sect1 xml:id="keyword.paamayim-nekudotayim"><!-- :-) -->
   <title><literal>::</literal></title>

   <caution>
    <simpara>
     Die folgende Beschreibung ist nur für PHP 4 gültig.
    </simpara>
   </caution>

   <para>
    Manchmal ist es hilfreich, auf Funktionen in Basisklassen bzw.
    auf Funktionen in Klassen zuzugreifen, die noch keine Instanzen
    haben. Dafür wird der :: Operator verwendet. 
   </para>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
class A
{
    function example()
    {
        echo "I am the original function A::example().<br>\n";
    }
}

class B extends A
{
    function example()
    {
        echo "I am the redefined function B::example().<br>\n";
        A::example();
    }
}

// Es gibt kein Objekt der Klasse A.
// Dies wird folgendes ausgeben
//   I am the original function A::example().<br>
A::example();

// Erstellt ein Objekt der Klasse B.
$b = new B;

// Dies wird folgendes ausgeben
//   I am the redefined function B::example().<br>
//   I am the original function A::example().<br>
$b->example();
]]>
    </programlisting>
   </informalexample>

   <para>
    Das obige Beispiel ruft die Funktion example() der Klasse A auf.
    Nachdem noch kein Objekt der Klasse A existiert, können wir nicht
    $a->example() oder ähnliches schreiben. Stattdessen rufen wir
    example() als 'Klassenfunktion' auf, d.h. als Funktion der Klasse
    selbst, und nicht irgendein Objekt dieser Klasse.
   </para>
   
   <para>
    Es gibt Klassenfunktionen, aber keine Klassenvariablen. Tatsächlich
    gibt es zur Zeit des Aufrufs kein Objekt. Deshalb darf eine
    Klassenfunktion keine Objektvariablen benutzen (aber sie kann lokale
    und globale Variablen verwenden), und sie darf $this ebenfalls nicht
    benutzen.
   </para>

   <para>
    In dem obigen Beispiel definiert Klasse B die Funktion example() neu.
    Die ursprüngliche Definition in Klasse A ist überschattet und nicht
    länger verfügbar, außer Sie verweisen mittels des ::-Operators
    speziell auf example() in Klasse A. Schreiben Sie A::example(), um
    dies zu tun (Tatsächlich sollten Sie parent::example() schreiben,
    wie im nächsten Abschnitt beschrieben).
   </para>
   
   <para>
    In diesem Kontext besteht ein Objekt, das Objektvariablen haben
    kann. Deshalb können Sie auch $this und Objektvariablen verwenden,
    wenn sie von innerhalb einer Objektfunktion verwendet werden.
   </para>

 </sect1>

 <sect1 xml:id="keyword.parent">
   <title><literal>parent</literal></title>

  <para>
   Wahrscheinlich wollen Sie auch Code schreiben, der sich auch auf
   Variablen und Funktionen in Basisklassen bezieht. Dies gilt
   speziell dann, wenn Ihre abgeleitete Klasse eine Verfeinerung
   oder Spezialisierung von Code in Ihrer Basisklasse ist.
  </para>
  
  <para>
   Anstatt in Ihrem Code den wörtlichen Namen der Basisklasse zu
   verwenden, sollten Sie den speziellen Namen
   <literal>parent</literal> verwenden, welcher sich auf den in
   der Deklaration Ihrer Klasse mittels <literal>extends</literal>
   gegebenen Namen Ihrer Basisklasse bezieht. So vermeiden Sie
   die mehrfache Verwendung des Namens der Basisklasse. Sollte
   sich Ihr Vererbungsbaum während der Implementation ändern,
   brauchen Sie nur mehr die <literal>extends</literal> Deklaration
   Ihrer Klasse zu ändern.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
class A
{
    function example()
    {
        echo "I am A::example() and provide basic functionality.<br>\n";
    }
}

class B extends A
{
    function example()
    {
        echo "I am B::example() and provide additional functionality.<br>\n";
        parent::example();
    }
}

$b = new B;

// Dies ruft B::example() auf, welches wiederum A::example() aufruft.
$b->example();
]]>
   </programlisting>
  </informalexample>
 </sect1>

 <sect1 xml:id="language.oop.serialization">
  <title>Objekte serialisieren - Objekte in Sessions</title>

  <note>
   <simpara>
    In PHP 3 verlieren Objekte während des Prozesses der Serialisierung
    und Deserialisierung ihre Assoziation zur Klasse. Die resultierende
    Variable ist vom Typ Objekt, hat aber keine Klasse und keine Methoden,
    weshalb sie ziemlich unbrauchbar ist (Sie wurde wie ein Array, jedoch
    mit einer ziemlich komischen Syntax).
   </simpara>
  </note>

  <caution>
   <simpara>
    Die folgende Information ist nur für PHP 4 gültig.
   </simpara>
  </caution>

  <para>
   <function>serialize</function> gibt eine Zeichenkette zurück, die
   eine Byte-Strom-Repräsentation irgendeines in PHP speicherbaren
   Wertes enthält. <function>unserialize</function> kann diese
   Zeichenkette verwenden, um die ursprünglichen Variablenwerte
   wieder herzustellen. Die Verwendung von serialize zum Speichern
   eines Objektes wird alle Variablen innerhalb eines Objektes
   speichern. Die Funktionen in einem Objekt werden nicht gespeichert,
   sondern nur der Name der Klasse.
  </para>
  
  <para>
   Um ein Objekt wieder deserialisieren zu können, muss die Klasse
   dieses Objektes definiert werden. Das heißt, wenn Sie ein Objekt
   $a der Klasse A in page1.php haben und dieses serialisieren,
   erhalten Sie eine Zeichenkette, die sich auf die Klasse A bezieht,
   und alle Werte der in $a enthaltenen Variablen enthält. Wenn Sie
   $a der Klasse A in page2.php mittels unserialize wiederherstellen
   möchten, muss die Definition von Klasse A in page2.php vorhanden
   sein. Dies kann zum Beispiel durch das Speichern der
   Klassendefiniton von Klasse A in einer Include-Datei, und das
   Einbinden dieser Datei sowohl in page1.php und page2.php realisiert
   werden.
  </para>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
classa.inc:
  class A 
  {
      var $one = 1;
    
      function show_one()
      {
          echo $this->one;
      }
  }
  
page1.php:
  include("classa.inc");
  
  $a = new A;
  $s = serialize($a);
  // speichere $s irgendwo, wo sie page2.php finden kann.
  $fp = fopen("store", "w");
  fputs($fp, $s);
  fclose($fp);

page2.php:
  // Dies ist für das korrekte Arbeiten von unserialize nötig.
  include("classa.inc");

  $s = implode("", @file("store"));
  $a = unserialize($s);

  // Nun verwenden wir die Funktion show_one() des Objektes $a.  
  $a->show_one();
]]>
   </programlisting>
  </informalexample>
  
  <para>
   Wenn Sie mit Sessions arbeiten und <function>session_register</function>
   verwenden, um Objekte zu registrieren, so werden diese Objekte am Ende
   der PHP Seite serialisiert, und in jeder folgenden Seite automatisch
   via unserialize wiederhergestellt. Das heißt, dass diese Objekte auf
   jeder Ihrer Seite auftauchen können, sobald sie Teil Ihrer Session sind.
  </para>
  
  <para>
   Es wird ausdrücklich empfohlen, dass Sie die Klassendefinitionen der
   so registrierten Objekte in allen Ihren Seiten einbinden, auch wenn
   Sie diese Klassen eigentlich nicht auf allen Ihren Seiten benötigen.
   Tun Sie es nicht und wird ein Objekt ohne einer vorhandenen
   Klassendefinition deserialisiert, verliert es seine Assoziation zur
   Klasse, und wird zu einem Objekt der Klasse <literal>stdClass</literal>,
   ohne irgendwelchen Funktionen. Das bedeutet, dass es ziemlich nutzlos
   wird.
  </para>
  
  <para>
   Würde also $a in dem obigen Beispiel mittels 
   <literal>session_register("a")</literal> ein Teil einer Session,
   sollten Sie die Datei <literal>classa.inc</literal> nicht nur in
   page1.php und page2.php, sondern in all Ihre Seiten einbinden.
  </para>
 </sect1>

 <sect1 xml:id="language.oop.magic-functions">
  <title>Die "magischen" Funktionen <literal>__sleep</literal> und <literal>__wakeup</literal></title>

  <para>
   <function>serialize</function> prüft, ob Ihre Klasse eine Funktion mit
   dem magischen Namen <literal>__sleep</literal> enthält. Wenn dem so ist,
   wird diese Funktion vor einer Serialisierung ausgeführt. Sie kann das
   Objekt aufräumen und soll ein Array mit den Namen aller Variablen des
   zu serialisierenden Objektes zurückgeben.
  </para>
  
  <para>
   Die beabsichtigte Verwendung von <literal>__sleep</literal> ist,
   eventuelle Datenbankverbindungen des Objektes zu schließen, noch
   offene Daten zu committen, oder ähnliche Säuberungsaktionen
   durchzuführen. Weiters ist diese Funktion hilfreich, wenn Sie
   sehr große Objekte haben, die nicht komplett gespeichert werden 
   müssen.
  </para>
  
  <para>
   Umgekehrt prüft <function>unserialize</function> die Existenz einer
   Funktion mit dem magischen Namen <literal>__wakeup</literal>. Ist
   diese vorhanden, kann sie Ressourcen des Objektes rekonstruieren.
  </para>
  
  <para>
    Die vorgesehene Verwendung von <literal>__wakeup</literal> ist die
    Wiederherstellung von Datenbankverbindungen, welche während der
    Serialisierung verloren gegangen sein könnten, sowie andere
    Neuinitialisierungen.
  </para>
 </sect1>
  
 <sect1 xml:id="language.oop.newref">
   <title>Referenzen innerhalb des Konstruktors</title>
   <para>
    Referenzen innerhalb des Konstruktors können zu verwirrenden
    Resultaten führen. Dieser Abschnitt hilft, Probleme zu vermeiden.
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
class Foo
{
    function Foo($name)
    {
        // eine Referenz innerhalb des globalen Arrays  $globalref erstellen
        global $globalref;
        $globalref[] = &$this;
        // setze den Namen auf den übergebenen Wert
        $this->setName($name);
        // und gib' ihn aus
        $this->echoName();
    }

    function echoName()
    {
        echo "<br>",$this->name;
    }
    
    function setName($name)
    {
        $this->name = $name;
    }
}
]]>
    </programlisting>
   </informalexample>
  </para>
    
   <para>
    Prüfen wir, ob zwischen <varname>$bar1</varname>, die mittels
    dem Operator zum Kopieren  <literal>=</literal> erstellt wurde,
    und <varname>$bar2</varname>, die mittels dem Referenzoperator
    <literal>=&amp;</literal> erstellt wurde, ein Unterschied besteht...

    <informalexample>
     <programlisting role="php">
<![CDATA[
$bar1 = new Foo('set in constructor');
$bar1->echoName();
$globalref[0]->echoName();

/* Ausgabe:
set in constructor
set in constructor
set in constructor */

$bar2 =& new Foo('set in constructor');
$bar2->echoName();
$globalref[1]->echoName();

/* Ausgabe:
set in constructor
set in constructor
set in constructor */
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Scheinbar besteht kein Unterschied, aber tatsächlich existiert ein
    signifikanter: <varname>$bar1</varname> und
    <varname>$globalref[0]</varname> sind NICHT referenziert, d.h. sie
    sind NICHT die selbe Variable. Das kommt daher, dass "new" nicht
    automatisch eine Referenz, sondern eine Kopie zurückgibt.
    <note>
     <simpara>
      Das zurückgeben von Kopien anstatt von Referenzen stellt keinen
      Performanceverlust dar (da PHP 4 und höher Reference Counting
      verwendet). Andererseits ist es sehr oft besser, einfach mit Kopien
      anstatt mit Referenzen zu arbeiten, da die Erstellung von Referenzen
      etwas Zeit in Anspruch nimmt, während das Erstellen von Kopien so gut
      wie keine Zeit braucht (sofern keine von ihnen ein großes Array oder
      Objekt ist, und eines davon geändert wird und das/die andere/n
      nachträglich. In diesem Fall wäre es besser, Referenzen zu verwenden,
      um sie alle gleichzeitig zu ändern).
     </simpara>
    </note>
    Um das zuvor geschriebene zu beweisen, sehen wir uns den folgenden Code an.

    <informalexample>
     <programlisting role="php">
<![CDATA[
// nun werden wir den Namen ändern. Was erwarten Sie?
// ...dass sowohl $bar1, als auch $globalref[0] ihre Namen ändern...
$bar1->setName('set from outside');

// wie bereits zuvor erwähnt, ist dies nicht der Fall
$bar1->echoName();
$globalref[0]->echoName();

/* Ausgabe:
set from outside
set in constructor */

// lassen Sie uns den Unterschied zwischen $bar2 and $globalref[1] ansehen
$bar2->setName('set from outside');

// glücklicherweise sind sie nicht nur nicht gleich, sondern auch die selbe
// Variable; demnach sind $bar2->name und $globalref[1]->name ebenfalls gleich
$bar2->echoName();
$globalref[1]->echoName();

/* Ausgabe:
set from outside
set from outside */
]]>
     </programlisting>
    </informalexample>   
   </para>   
   <para>
   Ein anderes, letztes Beispiel zum Verständnis:
   
    <informalexample>
     <programlisting role="php">
<![CDATA[
class A
{
    function A($i)
    {
        $this->value = $i;
        // finden Sie heraus, warum wir hier keine Referenz benötigen
        $this->b = new B($this);
    }

    function createRef()
    {
        $this->c = new B($this);
    }

    function echoValue()
    {
        echo "<br>","class ",get_class($this),': ',$this->value;
    }
}


class B
{
    function B(&$a)
    {
        $this->a = &$a;
    }

    function echoValue()
    {
        echo "<br>","class ",get_class($this),': ',$this->a->value;
    }
}

// überlegen Sie, warum hier die Verwendung einer einfachen Kopie in der
// mit * markierten Zeile zu einem unerwünschten Ergebnis führen würde
$a =& new A(10);
$a->createRef();

$a->echoValue();
$a->b->echoValue();
$a->c->echoValue();

$a->value = 11;

$a->echoValue();
$a->b->echoValue(); // *
$a->c->echoValue();

/*
Ausgabe:
class A: 10
class B: 10
class B: 10
class A: 11
class B: 11
class B: 11
*/
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
