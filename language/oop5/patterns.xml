<?xml version="1.0" encoding="utf8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 297028 Maintainer: wiesemann Status: ready -->
<sect1 xml:id="language.oop5.patterns" xmlns="http://docbook.org/ns/docbook">
 <title>Pattern</title>
 <para>
  Pattern sind eine Möglichkeit, um optimale Verfahren und gute Entwürfe zu 
  beschreiben. Sie zeigen eine flexible Lösung für verbreitete Programierprobleme.
 </para>

 <sect2 xml:id="language.oop5.patterns.factory">
  <title>Factory</title>
  <para>
   Das Factory-Pattern erlaubt die Instanziierung von Objekten zur Laufzeit.
   Es wird Factory-Pattern genannt, weil es für die "Herstellung" eines Objektes
   zuständig ist. Eine parametrisierte Factory bekommt den Namen der zu
   instanziierenden Klasse als Parameter übergeben.
  </para>
  <example>
   <title>Parametrisierte Factory-Methode</title>
   <programlisting role="php">
<![CDATA[
<?php
class Example
{
    // Die parametrisierte Factory-Methode
    public static function factory($type)
    {
        if (include_once 'Drivers/' . $type . '.php') {
            $classname = 'Driver_' . $type;
            return new $classname;
        } else {
            throw new Exception('Treiber nicht gefunden');
        }
    }
}
?>
]]>
   </programlisting>
   <para>
    Wenn diese Methode in einer Klasse definiert wird, erlaubt sie dieser,
    Treiber bei Bedarf zu laden. Wenn die <literal>Example</literal>-Klasse
    eine Datenbankabstraktionsklasse wäre, könnte das Laden eines 
    <literal>MySQL</literal>- und <literal>SQLite</literal>-Treibers wie
    folgt aussehen:
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// Lade einen MySQL Treiber
$mysql = Example::factory('MySQL');

// Lade einen SQLite Treiber
$sqlite = Example::factory('SQLite');
?>
]]>
   </programlisting>
  </example>
 </sect2>

 <sect2 xml:id="language.oop5.patterns.singleton">
  <title>Singleton</title>
  <para>
   Das Singleton-Pattern greift in Situationen, in denen es nur eine Instanz
   einer Klasse geben darf. Das gebräuchlichste Beispiel ist eine
   Datenbankverbindung. Die Implementierung dieses Musters erlaubt dem Programmierer
   diese einzige Instanz leicht für viele andere Objekte zugänglich zu machen.
  </para>
  <example>
   <title>Singleton-Funktion</title>
   <programlisting role="php">
<![CDATA[
<?php
class Beispiel
{
    // Speichert die Instanz der Klasse
    private static $instance;
    
    // Ein private-Konstruktor; verhindert die direkte Erzeugung des Objektes
    private function __construct() 
    {
        echo 'Ich bin hergestellt';
    }

    // Die Singleton-Methode
    public static function singleton() 
    {
        if (!isset(self::$instance)) {
            $c = __CLASS__;
            self::$instance = new $c;
        }

        return self::$instance;
    }
    
    // Beispielmethode
    public function bellen()
    {
        echo 'Wuff!';
    }

    // Halte Benutzer vom Klonen der Instanz ab
    public function __clone()
    {
        trigger_error('Klonen ist nicht erlaubt.', E_USER_ERROR);
    }

}

?>
]]>
   </programlisting>
   <para>
    Dies erlaubt das Abrufen einer einzigen Instanz der
    <literal>Example</literal>-Klasse.
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// Dies wird fehlschlagen, weil der Konstruktor private ist
$test = new Example

// Dies wird immer eine einzige Instanz der Klasse abrufen
$test = Example::singleton();
$test->bellen();

// Dies wird einen E_USER_ERROR erzeugen
$test_clone = clone $test;

?>
]]>
   </programlisting>
  </example>
 </sect2>

</sect1>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
