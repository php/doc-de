<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 313136 Maintainer: wiesemann Status: ready -->
<sect1 xml:id="language.oop5.patterns" xmlns="http://docbook.org/ns/docbook">
 <title>Pattern</title>
 <para>
  Pattern sind eine Möglichkeit, um optimale Verfahren und gute Entwürfe zu 
  beschreiben. Sie zeigen eine flexible Lösung für verbreitete Programierprobleme.
 </para>

 <sect2 xml:id="language.oop5.patterns.factory">
  <title>Factory</title>
  <para>
   Das Factory-Pattern erlaubt die Instanziierung von Objekten zur Laufzeit.
   Es wird Factory-Pattern genannt, weil es für die "Herstellung" eines Objektes
   zuständig ist. Eine parametrisierte Factory bekommt den Namen der zu
   instanziierenden Klasse als Parameter übergeben.
  </para>
  <example>
   <title>Parametrisierte Factory-Methode</title>
   <programlisting role="php">
<![CDATA[
<?php
class Example
{
    // Die parametrisierte Factory-Methode
    public static function factory($type)
    {
        if (include_once 'Drivers/' . $type . '.php') {
            $classname = 'Driver_' . $type;
            return new $classname;
        } else {
            throw new Exception('Treiber nicht gefunden');
        }
    }
}
?>
]]>
   </programlisting>
   <para>
    Wenn diese Methode in einer Klasse definiert wird, erlaubt sie dieser,
    Treiber bei Bedarf zu laden. Wenn die <literal>Example</literal>-Klasse
    eine Datenbankabstraktionsklasse wäre, könnte das Laden eines 
    <literal>MySQL</literal>- und <literal>SQLite</literal>-Treibers wie
    folgt aussehen:
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// Lade einen MySQL Treiber
$mysql = Example::factory('MySQL');

// Lade einen SQLite Treiber
$sqlite = Example::factory('SQLite');
?>
]]>
   </programlisting>
  </example>
 </sect2>

 <sect2 xml:id="language.oop5.patterns.singleton">
  <title>Singleton</title>
  <para>
   Das Singleton stellt sicher, dass es nur eine Instanz einer Klasse geben kann;
   es stellt eine globale Zugriffsmöglichkeit zu dieser Instanz bereit. Singleton
   ist ein Pattern der "Gang of Four".
  </para>
  <para>Das Singleton-Pattern wird oft implementiert in Datenbankklassen,
  Loggern, Front-Controllern oder Request- und Response-Objekten.
  </para>
  
  <example>
   <title xml:id="language.oop5.patterns.singleton.examples.basic">Singleton-Funktion</title>
   <programlisting role="php"><![CDATA[
<?php
class Beispiel
{
    private static $instance;
    private $count = 0;

    private function __construct()
    {
    }

    public static function singleton()
    {
        if (!isset(self::$instance)) {
            echo 'Erstelle neue Instanz.';
            $className = __CLASS__;
            self::$instance = new $className;
        }
        return self::$instance;
    }

    public function increment()
    {
        return $this->count++;
    }

    public function __clone()
    {
        trigger_error('Clonen ist nicht erlaubt.', E_USER_ERROR);
    }

    public function __wakeup()
    {
        trigger_error('Deserialisierung ist nicht erlaubt.', E_USER_ERROR);
    }
}
?>
]]>
   </programlisting>
   <para>Illustrated below is how the Singleton behaves</para>
   <programlisting role="php"><![CDATA[
<?php
$singleton = Example::singleton(); // gibt "Erstelle neue Instanz." aus
echo $singleton->increment(); // 0
echo $singleton->increment(); // 1

$singleton = Example::singleton(); // verwendet die bereits existierende Instanz
echo $singleton->increment(); // 2
echo $singleton->increment(); // 3

// alle folgenden Zeilen führen zu einem Fatal Error
$singleton2 = new Example;
$singleton3 = clone $singleton;
$singleton4 = unserialize(serialize($singleton));
?>
   ]]>
   </programlisting>
  </example>
  <warning xml:id="warn.singleton.controversy">
   <para>
    Das Singleton-Pattern ist eines der kontrovers betrachteten Pattern. Kritiker
    argumentieren, dass Singletons zu globale Zuständen in Applikationen führen
    und dass sie das Singleton und die benutzenden Klassen eng koppeln. Somit
    entstehen versteckte Abhängigkeiten und unerwartete Seiteneffekte, woraus
    wiederum Code entsteht, der schwierig zu testen und zu warten ist.
   </para>
   <para>
    Die Kritiker argumentieren außerdem, dass es sinnlos ist, ein Singleton in einer
    Shared-Nothing-Architektur wie PHP einzusetzen, in der Objekte nur innerhalb eines
    Requests eindeutig sind. Es ist einfacher und sauberer, Kollaborations-Objektgraphen
    zu erstellen, indem die Builder- und Factory-Pattern am Anfang eines Requests benutzt
    werden.
   </para>
   <para>
    Singletons verstoßen außerdem gegen die "SOLID"-OOP-Design-Regeln und gegen das Gesetz von
    Demeter. Singletons können nicht serialisiert werden. Sie können nicht durch Subtypen
    ersetzt werden (vor PHP 5.3) und sie werden auch nicht bei der Garbage-Collection
    berücksichtigt, weil die Instanz als statisches Attribut des Singletons gespeichert
    wird.
   </para>   
  </warning>
 </sect2>
 
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
