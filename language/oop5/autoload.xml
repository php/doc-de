<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 327202 Maintainer: simp Status: ready -->
<!-- Credits: hholzgra -->
<sect1 xml:id="language.oop5.autoload" xmlns="http://docbook.org/ns/docbook">
  <title>Autoloading</title>
  <para>
   Viele Entwickler, die objektorientierte Anwendungen entwickeln, erzeugen
   eine eigene PHP Quelldatei für jede Klassendefinition. Eines der größten
   Ärgernisse ist die Notwendigkeit, eine lange Liste von benötigten 
   Include-Anweisungen am Anfang eines jeden Skripts (eine für jede Klasse).
  </para>
  <para>
   In PHP 5 ist das nicht länger notwendig. Man kann eine 
   <function>__autoload</function> Funktion
   definieren, die automatisch aufgerufen wird, falls man versucht eine noch
   nicht definierte Klasse oder ein nicht definiertes Interface zu benutzen.
   Durch den Aufruf dieser Funktion erhält die Scripting Engine einen letzten 
   Versuch, die Klasse zu laden, bevor PHP unter Ausgabe einer Fehlermeldung 
   scheitert.
  </para>
  <tip>
   <para>
    <function>spl_autoload_register</function> bietet eine flexiblere Alternative
    zum automatischen Laden von Klassen an. Aus diesem Grund wird von der Verwendung
    von <function>__autoload</function> abgeraten und diese Funktion könnte
    zukünftig als veraltet gekennzeichnet oder gar entfernt werden.
   </para>
  </tip>
  <note>
   <para>
    Vor der Version 5.3.0 waren Exceptions, die in einer __autoload-Funktion 
    geworfen wurden nicht in einem <link linkend="language.exceptions">Catch</link>-
    Block fangbar und führten zu einem fatalen Fehler. Seit 5.3.0+ können 
    Exceptions, die in einer __autoload-Funktion geworfen wurden, unter der folgenden
    Bedingung in einem <link linkend="language.exceptions">Catch</link>-Block
    gefangen werden. Wenn eine selbst definierte Exception geworfen wird, so
    muss die Klasse dieser Exception bereits verfügbar sein. Die __autoload-
    Funktion darf rekursiv verwendet werden, um diese Exceptionklasse zu laden.
   </para>
  </note>
  <note>
   <para>
    Autoloading ist nicht verfügbar, wenn man PHP im CLI <link
    linkend="features.commandline">interaktiven Modus</link> betreibt.
   </para>
  </note>
  <note>
   <para>
    Wird der Klassenname verwendet, z.B. in der Funktion <function>call_user_func</function>, 
    so ist zu beachten, dass er gefährliche Zeichen wie z.B. <literal>../</literal>
    enthalten kann. Es wird daher empfohlen keine Benutzereingaben an
    solche Funktionen weiterzugeben oder zumindest die Eingaben in
    <function>__autoload</function> zu prüfen. 
   </para>
  </note>
  <para>
   <example>
    <title>Autoload Beispiel</title>
    <para>
     Dieses Beispiel versucht die Klassen <literal>MyClass1</literal> und
     <literal>MyClass2</literal> aus den entsprechenden Dateien 
     <filename>MyClass1.php</filename> und <filename>MyClass2.php</filename>
     zu laden.
    </para>
    <programlisting role="php">
<![CDATA[
<?php
function __autoload($class_name) {
    include $class_name . '.php';
}

$obj  = new MyClass1();
$obj2 = new MyClass2(); 
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>Weiteres Autoload Beispiel</title>
    <para>
     Dieses Beispiel versucht das Interface <literal>ITest</literal> 
     zu laden.
    </para>
    <programlisting role="php">
<![CDATA[
<?php

function __autoload($name) {
    var_dump($name);
}

class Foo implements ITest {
}
 
/*
string(5) "ITest"
 
Fatal error: Interface 'ITest' not found in ...
*/
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>Autoloading mit Ausnahmebehandlung für 5.3.0+</title>
    <para>
     In diesem Beispiel wird eine Exception geworfen und ein try/catch-Block demonstriert.
    </para>
    <programlisting role="php">
<![CDATA[
<?php
function __autoload($name) {
    echo "Möchte $name laden.\n";
    throw new Exception("Kann $name nicht laden.");
}

try {
    $obj = new NonLoadableClass();
} catch (Exception $e) {
    echo $e->getMessage(), "\n";
}
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Möchte NonLoadableClass laden.
Kann NonLoadableClass nicht laden.
]]>
    </screen>
   </example>
   <example>
    <title>Autoloading mit Ausnahmebehandlung für 5.3.0+ mit fehlender eigener Exception</title>
    <para>
     In diesem Beispiel wird eine Exception geworfen für eine nicht ladbare eigene Exception.
    </para>
    <programlisting role="php">
<![CDATA[
<?php
function __autoload($name) {
    echo "Möchte $name laden.\n";
    throw new MissingException("Kann $name nicht laden.");
}

try {
    $obj = new NonLoadableClass();
} catch (Exception $e) {
    echo $e->getMessage(), "\n";
}
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Möchte NonLoadableClass laden.
Möchte MissingException laden.

Fatal error: Class 'MissingException' not found in testMissingException.php on line 4
]]>
    </screen>
   </example>
  </para>

  <simplesect role="seealso">
   &reftitle.seealso;
   <para>
    <simplelist>
     <member><function>unserialize</function></member>
     <member><link linkend="unserialize-callback-func">unserialize_callback_func</link></member>
     <member><function>spl_autoload</function></member>
     <member><function>spl_autoload_register</function></member>
    </simplelist>
   </para>
  </simplesect>
  
 </sect1>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
