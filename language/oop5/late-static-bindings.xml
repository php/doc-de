<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.1 $ -->
<!-- EN-Revision: 1.3  Maintainer: hholzgra  Status: ready -->
 <sect1 xml:id="language.oop5.late-static-bindings" xmlns="http://docbook.org/ns/docbook">
  <title>Späte statische Bindung</title>
  <para>
   Beginnend mit PHP 5.3.9 unterstützt PHP späte statische Bindung ("Late
   static bindind"). Hiermit kann die aufgerufene Klasse im Kontext statischer
   Vererbung referenziert werden.
  </para>

  <para>
   Diese Funktionalität wurde in Hinblick auf die interne Perspektive als 
   "späte statische Bindbung" benannt. "Späte Bindung" bezieht sich auf die
   Tatsache das <literal>static::</literal> nicht mehr über die Klasse in der
   die aufgerufene Methode definiert ist aufgelöst wird, statt dessen wird
   diese mit Hilfe von Laufzeitinformationen bestimmt.

   Die Benennung als "statische Bindung" beruht darauf das dieser Mechanismus
   unter anderem für statische Methodenaufrufe genutzt werden kann.
  </para>

  <sect2 xml:id="language.oop5.late-static-bindings.self">
   <title>Beschränkungen von <literal>self::</literal></title>
   <para>
    Statische Referenzen auf die aktuelle Klasse wie <literal>self::</literal>
    oder <literal>__CLASS__</literal> werden mit Hilte der Klasse zu der die
    Methode gehört, also in welcher sie definiert ist, aufgelöst. 
   </para>
   <example>
    <title>Nutzung von <literal>self::</literal></title>
    <programlisting role="php">
<![CDATA[
<?php
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        self::who();      
    }  
}  

class B extends A {      
    public static function who() {
         echo __CLASS__;
    }  
}   

B::test();
?>  
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
A
]]>
    </screen>
   </example>

  </sect2>
 
  <sect2 xml:id="language.oop5.late-static-bindings.usage">
   <title>Nutzung spöter statischer Bindung</title>

   <para>
    Späte statische Bindung versucht diese Beschränkung zu umgehen
    indem ein neues Schlüsselwort eingeführt wird das die Klasse
    referenziert die tatsächlich zur Laufzeit genutzt wurde,
    also im wesentlichen ein Schlüsselwort das es ihnen gestattet
    im vorangegangenen Beispiel aus der aufgerufenen Methode
    <literal>test()</literal> die Klasse <literal>B</literal>
    zu referenzieren.
   </para>

   <example>
    <title>Einfache Nutzung von <literal>static::</literal></title>
    <programlisting role="php">
<![CDATA[
<?php
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        static::who(); // statische Bindung 
    }  
}  

class B extends A {      
    public static function who() {
         echo __CLASS__;
    }  
}   

B::test();
?>  
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
B
]]>
    </screen>
   </example>
   <note>
    <para>
     In statischen Methoden verhält sich <literal>static::</literal> nicht
     wie <literal>$this</literal>! <literal>$this</literal> folgt den 
     Vererbungsregeln während <literal>static::</literal> dies nicht tut.
     Dieser Unterschied wird später in diesem Abschnitt noch genauer 
     beschrieben.
    </para>
   </note>
   <example>
    <title>Nutznug von <literal>static::</literal> außerhalb eines statischen Kontext</title>
    <programlisting role="php">
<![CDATA[
<?php
class TestChild extends TestParent {
    public function __construct() {
        static::who();
    }

    public function test() {
        $o = new TestParent();
    }

    public static function who() {
        echo __CLASS__."\n";
    }
}

class TestParent {
    public function __construct() {
        static::who();
    }

    public static function who() {
        echo __CLASS__."\n";
    }
}
$o = new TestChild;
$o->test();

?>  
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
TestChild
TestParent
]]>
    </screen>
   </example>
   <note>
    <para>
     Die Auflösung später statischer Bindungen endet mit einem vollständig 
     aufgelösten Statischen Aufruf ohne Alternative. Statische Aufrufe die
     Schlüsselworte wie <literal>parent::</literal> oder <literal>self::</literal>
     nutzen geben dagegen die Aufrufinformationen weiter.
    <example>
     <title>Weitergegebene und nicht weitergegebene Aufrufe</title>
     <programlisting role="php">
<![CDATA[
<?php
class A {
    public static function foo() {
        static::who();
    }
        
    public static function who() {
        echo __CLASS__."\n";
    }
}

class B extends A {
    public static function test() {
        A::foo();
        parent::foo();
        self::foo();
    }

    public static function who() {
        echo __CLASS__."\n";
    }
}
class C extends B {
    public static function who() {
        echo __CLASS__."\n";
    }
}

C::test();
?>  
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
A
C
C
]]>
     </screen>
    </example>
   </note>
  </sect2>
  <sect2 xml:id="language.oop5.late-static-bindings.edge-cases">
   <title>Sonderfälle</title>
   <para>
    Es gibt in PHP viele verschiedene Wege den Aufruf einer Methode
    auszulösen. Da bei später statische Bindung die Auflösung von 
    Aufrufen auf Laufzeitinformationen beruht kann sie in speziellen
    Fällen zu unerwarteten Ergebnissen führen.
   </para>
   <example>
    <title>Späte statische Bindung in 'magischen' Methoden</title>
    <programlisting role="php">
<![CDATA[
<?php
class A {

   protected static function who() {
        echo __CLASS__."\n";
   }

   public function __get($var) {
       return static::who();
   }
}

class B extends A {

   protected static function who() {
        echo __CLASS__."\n";
   }
}

$b = new B;
$b->foo;
?>  
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
B
]]>
    </screen>
   </example>
  </sect2>
 </sect1>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
