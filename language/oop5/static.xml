<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.1 $ -->
<!-- EN-Revision: 1.7 Maintainer: simp Status: ready -->
 <sect1 id="language.oop5.static">
  <title>Static Schlüsselwort</title>

  <para>
   Klassenmember oder -methoden als statisch zu deklarieren macht diese 
   zugänglich, ohne dass man die Klasse instantiieren muss. Auf ein als statisch
   deklariertes Member kann nicht mit einem instantiierten Klassenobjekt
   zugegriffen werden (obgleich einen statische Methode dies kann). Statische
   Member und Methoden können in Unterklassen nicht neu definiert werden.
  </para>

  <para>
   Die Deklaration static muss sich hinter der Sichtbarkeitsdeklaration befinden.
   Für die Abwärtskompatibilität zu PHP 4 werden Member oder Methode behandelt
   als ob diese als <literal>public static</literal> deklariert wären, wenn
   keine <link linkend="language.oop5.visibility">Sichtbarkeit</link> 
   deklariert wird.
  </para>

  <para>
   Weil statische Methoden ohne die Instanz eines erzeugten Objektes aufrufbar
   sind, ist die Pseudovariable <varname>$this</varname> nicht innerhalb von
   der als statisch deklarierten Methode verfügbar.
  </para>
  
  <para>
   Tatsächlich werden <literal>static</literal> Methodenaufrufe zum
   Kompilierungszeitpunkt aufgelöst. Bei der Nutzung des expliziten Klassennamens
   ist die Methode bereits gänzlich identifiziert und es kommen keine
   Vererbungsregeln zur Anwendung. Falls der Aufruf durch <literal>self</literal>
   erfolgt, wird <literal>self</literal> in den aktuellen Klassennamen übersetzt,
   d.h. die Klasse zu dem der Code gehört. Hier kommen ebenfalls keine
   Vererbungsregeln zur Anwendung.
  </para>
  
  <para>
   Auf statische Eigenschaften kann nicht durch das Objekt mittels des
   Pfeiloperators -&gt; zugegriffen werden.
  </para>

  <example>
   <title>Beispiel für statische Member</title>
   <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    public static $my_static = 'foo';

    public function staticValue() {
        return self::$my_static;
    }
}

class Bar extends Foo
{
    public function fooStatic() {
        return parent::$my_static;
    }
}


print Foo::$my_static . "\n";

$foo = new Foo();
print $foo->staticValue() . "\n";
print $foo->my_static . "\n";      // Undefinierte "Eigenschaft" my_static 

// $foo::my_static ist nicht möglich

print Bar::$my_static . "\n";
$bar = new Bar();
print $bar->fooStatic() . "\n";
?>
]]>
   </programlisting>
  </example>

  <example>
   <title>Beispiel für statische Methoden</title>
    <programlisting role="php">
<![CDATA[
<?php
class Foo {
    public static function aStaticMethod() {
        // ...
    }
}

Foo::aStaticMethod();
?> 
]]>
    </programlisting>
  </example>

 </sect1>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
