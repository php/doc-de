<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.11 $ -->
<!-- EN-Revision: 1.20 Maintainer: hholzgra Status: ready -->
<!-- Credits: simp -->
 <sect1 xml:id="language.oop5.magic" xmlns="http://docbook.org/ns/docbook">
  <title>Magische Methoden</title>
  <para>
   Die Funktionen
   <literal>__construct</literal>,
   <literal>__destruct</literal>
   (siehe auch <link linkend="language.oop5.decon">Konstruktoren und Destruktoren</link>),
   <literal>__call</literal>,
   <literal>__callStatic</literal>,
   <literal>__get</literal>,
   <literal>__set</literal>,
   <literal>__isset</literal>,
   <literal>__unset</literal>
   (siehe auch <link linkend="language.oop5.overloading">Überladung</link>),
   <literal>__sleep</literal>,
   <literal>__wakeup</literal>,
   <literal>__toString</literal>,
   <literal>__set_state</literal> und
   <link linkend="language.oop5.cloning">__clone</link> 
   sind in PHP Klassen magisch. Man kann keine Funktionen gleichen Namens in
   einer seiner Klassen haben, wenn man nicht die magische Funktionalität,
   die sie mit sich bringen, haben will.
  </para>

  <caution>
   <simpara>
    PHP reserviert alle Funktionsnamen die mit __ beginnen als magsich.
    Es ist empfohlen keine Funktionsnamen mit __ in PHP zu benutzen, es sei
    denn man möchte dokumentierte magische Funktionalität verwenden.
   </simpara>
  </caution>
 
  <sect2 xml:id="language.oop5.magic.sleep">
   <title><literal>__sleep</literal> und <literal>__wakeup</literal></title>
   <para>
    <function>serialize</function> prüft, ob Ihre Klasse eine Funktion mit dem
    magischen Namen <literal>__sleep</literal> besitzt.  Wenn dem so ist, wird
    die Funktion vor jeder Serialisierung ausgeführt. Sie kann das Objekt
    aufräumen und es wird von Ihr erwartet, dass Sie ein Array mit den Namen 
    aller Variablen zurückliefert, die serialisiert werden sollen. Wenn die
    Methode nichts zurückgibt, so wird &null; serialisiert und eine E_NOTICE
    ausgegeben.
   </para>
   <para>
    Die beabsichtigte Verwendung von <literal>__sleep</literal> ist es,
    nicht gespeicherte Daten zu sichern oder ähnliche Aufräumarbeiten zu
    erledigen. Die Funktion ist ebenfalls nützlich, wenn Sie sehr große Objekte
    haben, welche nicht komplett gespeichert werden müssen.
   </para>
   <para>
    Umgekehrt überprüft <function>unserialize</function> die Anwesenheit einer
    Funktion mit dem magsichen Namen <literal>__wakeup</literal>. Falls anwesend
    kann diese Funktion alle Resourcen die das Objekt haben könnte 
    wiederherstellen.
   </para>
   <para>
    Der beabsichtigte Zweck von <literal>__wakeup</literal> ist es, alle 
    Datenbankverbindungen wiederherzustellen die während der Serialisierung 
    verloren gegangen sein könnten oder auch andere Aufgaben zur
    erneuten Initialisierung.
   </para>
   <example>
    <title>Sleep und wakeup Beispiel</title>
    <programlisting role="php">
<![CDATA[
<?php
class Connection {
    protected $link;
    private $server, $username, $password, $db;

    public function __construct($server, $username, $password, $db)
    {
        $this->server = $server;
        $this->username = $username;
        $this->password = $password;
        $this->db = $db;
        $this->connect();
    }

    private function connect()
    {
        $this->link = mysql_connect($this->server, $this->username, $this->password);
        mysql_select_db($this->db, $this->link);
    }

    public function __sleep()
    {
        return array('server', 'username', 'password', 'db');
    }

    public function __wakeup()
    {
        $this->connect();
    }
}
?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.magic.tostring">
   <title><literal>__toString</literal></title>
   <para>
    Die <literal>__toString</literal> Methode erlaubt einer Klasse zu entscheiden
    wie sie reagieren will, wenn Sie in eine Zeichenkette umgewandelt wird.
   </para>
   <example>
    <title>Einfaches Beispiel</title>
    <programlisting role="php">
<![CDATA[
<?php
// Deklariere eine einfache Klasse
class TestClass
{
    public $foo;

    public function __construct($foo) {
        $this->foo = $foo;
    }

    public function __toString() {
        return $this->foo;
    }
}

$class = new TestClass('Hallo');
echo $class;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Hallo
]]>
    </screen>
   </example>
   <para>
    Es muss angemerkt werden, dass die <literal>__toString</literal> Methode
    in Versionen vor PHP 5.2.0 nur in direkter Kombination mit 
    <function>echo</function> oder <function>print</function> aufgerufen
    wurde.
    Beginnend mit PHP 5.2.0 erfolgt dieser Aufruf in jedem Stringkontext (z.B. in
    <function>printf</function> mit <literal>%s</literal> Platzhalter) aber in keinem
    der anderen Typenkontexte (z.B. mit dem <literal>%d</literal> Platzhalter).
    Ebenfalls beginnend mit PHP 5.2.0 bewirkt die Umwandlung eines Objekts ohne 
    <literal>__toString</literal> Metohde in einen String einen Fehler der Klasse
    <constant>E_RECOVERABLE_ERROR</constant>.
   </para>
  </sect2>

  <sect2 xml:id="language.oop5.magic.set-state">
   <title><literal>__set_state</literal></title>
   <para>
    Dieses <link linkend="language.oop5.static">statische</link> Methode wird
    seit PHP 5.1.0 für Klassen aufgerufen, die mittels <function>var_export</function>
    exportiert werden.
   </para>
   <para>
    Der einzige Parameter dieser Methode ist ein Array, welches aus exportierten
    Eigenschaften der Form <literal>array('Eigenschaft' => Wert, ...)</literal>
    besteht.
   </para>
    <example>
    <title>Using <literal>__set_state</literal> (since PHP 5.1.0)</title>
    <programlisting role="php">
<![CDATA[
<?php

class A
{
    public $var1;
    public $var2;

    public static function __set_state($an_array) // As of PHP 5.1.0
    {
        $obj = new A;
        $obj->var1 = $an_array['var1'];
        $obj->var2 = $an_array['var2'];
        return $obj;
    }
}

$a = new A;
$a->var1 = 5;
$a->var2 = 'foo';

eval('$b = ' . var_export($a, true) . ';'); // $b = A::__set_state(array(
                                            //    'var1' => 5,
                                            //    'var2' => 'foo',
                                            // ));
var_dump($b);

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
object(A)#2 (2) {
  ["var1"]=>
  int(5)
  ["var2"]=>
  string(3) "foo"
}
]]>
    </screen>
   </example>
  </sect2>
 </sect1>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
