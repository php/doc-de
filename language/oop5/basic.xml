<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 297028 Maintainer: wiesemann Status: ready -->

 <sect1 xml:id="language.oop5.basic" xmlns="http://docbook.org/ns/docbook">
  <title>Die Grundlagen</title>

  <sect2 xml:id="language.oop5.basic.class">
   <title>class</title>
   <para>
    Jede Klassendefinition beginnt mit dem Schlüsselwort
    <literal>class</literal>, gefolgt von einem Klassennamen, gefolgt von
    einem Paar geschweifter Klammern, die die Definitionen der
    Klasseneigenschaften und -methoden enthalten.
   </para>
   <para>
    Der Klassenname kann jeder gültige Bezeichner sein, der kein von PHP
    <link linkend="reserved">reserviertes Wort</link> ist. Ein gültiger
    Klassenname beginnt mit einem Buchstaben oder einem Unterstrich, gefolgt
    von einer beliebigen Anzahl von Buchstaben, Ziffern oder Unterstrichen;
    als regulärer Ausdruck formuliert:
    <literal>[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*</literal>.
   </para>
   <para>
    Eine Klasse darf aus ihren eigenen
    <link linkend="language.oop5.constants">Konstanten</link>,
    <link linkend="language.oop5.properties">Variablen</link>
    ("Eigenschaften" genannt) und Funktionen ("Methoden" genannt)
    bestehen.
   </para>
   <example>
    <title>Definition einer einfachen Klasse</title>
    <programlisting role="php">
<![CDATA[
<?php
class SimpleClass
{
    // Deklaration einer Eigenschaft
    public $var = 'ein Standardwert';

    // Deklaration einer Methode
    public function displayVar() {
        echo $this->var;
    }
}
?>
]]>
    </programlisting>
   </example>
   <para>
    Die Pseudovariable
    <varname>$this</varname> ist verfügbar, falls eine Methode aus einem 
    Objektkontext heraus aufgerufen wird. <varname>$this</varname> ist eine
    Referenz auf das aufrufende Objekt (üblicherweise das Objekt, zu dem die 
    Methode gehört, aber möglicherweise ein anderes Objekt, falls 
    die Methode <link linkend="language.oop5.static">statisch</link> aus dem
    Kontext eines zusätzlichen Objektes aufgerufen wird).
   </para>
   <para>
    <example>
     <title>Einige Beispiele für die <varname>$this</varname>-Pseudovariable</title>
     <programlisting role="php">
<![CDATA[
<?php
class A
{
    function foo()
    {
        if (isset($this)) {
            echo '$this ist definiert (';
            echo get_class($this);
            echo ")\n";
        } else {
            echo "\$this ist nicht definiert.\n";
        }
    }
}

class B
{
    function bar()
    {
        // Hinweis: die folgende Zeile führt zu einer Warnung, wenn
        // E_STRICT aktiviert ist
        A::foo();
    }
}

$a = new A();
$a->foo();

// Hinweis: die folgende Zeile führt zu einer Warnung, wenn E_STRICT aktiviert ist
A::foo();
$b = new B();
$b->bar();

// Hinweis: die folgende Zeile führt zu einer Warnung, wenn E_STRICT aktiviert ist
B::bar();
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
$this ist definiert (A)
$this ist nicht definiert.
$this ist definiert (B)
$this ist nicht definiert.
]]>
     </screen>
    </example>
   </para>
  </sect2>

  <sect2 xml:id="language.oop5.basic.new">
   <title>new</title>
   <para>
    Um eine Instanz einer Klasse zu erzeugen, muss ein neues Objekt erzeugt
    und einer Variablen zugewiesen werden. Bei der Erzeugung wird das Objekt 
    immer zugewiesen, außer wenn das Objekt einen definierten
    <link linkend="language.oop5.decon">Konstruktor</link> besitzt, der
    aufgrund eines Fehlers eine <link linkend="language.exceptions">Exception</link>
    wirft. Klassen sollten vor ihrer Instantiierung definiert werden (in manchen
    Fällen ist dies eine Notwendigkeit).
   </para>
   <example>
    <title>Eine Instanz erzeugen</title>
    <programlisting role="php">
<![CDATA[
<?php
$instanz = new SimpleClass();

// dies ist auch mit einer Variablen möglich:
$klassenname = 'Foo';
$instanz = new $klassenname(); // Foo()
?>
]]>
    </programlisting>
   </example>
   <para>
    Im Kontext einer Klasse ist es möglich, neue Objekte mit
    <literal>new self</literal> und <literal>new parent</literal>
    anzulegen.
   </para>
   <para>
    Wenn man eine bereits erzeugte Instanz einer Klasse einer neuen Variablen
    zuweist, wird die neue Variable auf die selbe Instanz zugreifen wie das
    Objekt, das zugewiesen wurde. Dieses Verhalten ist das selbe, wenn man
    Instanzen an Funktionen übergibt. Eine Kopie eines bereits erzeugten
    Objektes erhält man, indem man es
    <link linkend="language.oop5.cloning">klont</link>.
   </para>
   <example>
    <title>Objektzuweisung</title>
    <programlisting role="php">
<![CDATA[
<?php
$instanz = new SimpleClass();

$zugewiesen   =  $instanz;
$referenz     =& $instanz;

$instanz->var = '$zugewiesen wird diesen Wert haben';

$instanz = null; // $instanz und $referenz werden null

var_dump($instanz);
var_dump($referenz);
var_dump($zugewiesen);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
NULL
NULL
object(SimpleClass)#1 (1) {
   ["var"]=>
     string(30) "$zugewiesen wird diesen Wert haben"
}
]]>
    </screen>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.basic.extends">
   <title>extends</title>
   <para>
    Eine Klasse kann Methoden und Eigenschaften einer anderen Klasse erben, indem
    man das <literal>extends</literal>-Schlüsselwort in der Deklaration benutzt.
    Es ist nicht möglich, mehrere Klassen zu erweitern; eine Klasse kann nur eine
    einzige Basisklasse beerben.
   </para>
   <para>
    Die geerbten Methoden und Eigenschaften können durch eine Neudeklaration
    mit dem gleichen Namen wie in der Elternklasse überschrieben werden. Falls
    die Elternklasse eine Methode als <link linkend="language.oop5.final">final</link>
    definiert hat, kann diese Methode nicht überschrieben werden. Es ist möglich,
    auf die überschriebenen Methoden oder statischen Eigenschaften zuzugreifen,
    wenn diese mittels
    <link linkend="language.oop5.paamayim-nekudotayim">parent::</link>
    referenziert werden.
   </para>
   <para>
    Wenn Methoden überschrieben werden, sollte die Parametersignatur gleich
    bleiben; andernfalls wird PHP einen <constant>E_STRICT</constant>-Fehler
    generieren. Dies gilt nicht für den Konstruktor, der das Überschreiben
    mit unterschiedlichen Parameter erlaubt.
   </para>
   <example>
    <title>Einfache Vererbung</title>
    <programlisting role="php">
<![CDATA[
<?php
class ExtendClass extends SimpleClass
{
    // Die Vatermethode überschreiben
    function displayVar()
    {
        echo "Erweiternde Klasse\n";
        parent::displayVar();
    }
}

$extended = new ExtendClass();
$extended->displayVar();
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Erweiternde Klasse
ein Vorgabewert
]]>
    </screen>
   </example>
  </sect2>

 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
