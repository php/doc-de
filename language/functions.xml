<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.17 $ -->
<!-- EN-Revision: 1.33 Maintainer: tom Status: ready -->
 <chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook">
  <title>Funktionen</title>

  <sect1 xml:id="functions.user-defined">
   <title>Vom Nutzer definierte Funktionen</title>
 
   <para>
    Eine Funktion kann wie folgt definiert werden:
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
function foo ($arg_1, $arg_2, ..., $arg_n)
{
    echo "Beispielfunktion.\n";
    return $retval;
}
]]>
     </programlisting>
    </informalexample>
   </para>
     
   <simpara>
    Jeder beliebige korrekte PHP-Code kann in einer Funktion
    vorkommen, sogar andere Funktionen und <link
    linkend="keyword.class">Klassen-</link> Definitionen.
   </simpara>
   <simpara>
    In PHP 3 müssen Funktionen definiert sein, bevor man auf sie
    verweist. In PHP4 ist das nicht mehr erforderlich,
    <emphasis>außer</emphasis> wenn eine Funktion nur bedingt definiert
    wird, wie in den beiden untenstehenden Beispielen gezeigt.
   </simpara>
   <para>
    Wenn eine Funktion nur unter bestimmten Bedingungen definiert wird,
    muß die Definition dieser Funktion noch <emphasis>vor</emphasis>
    deren Aufruf abgearbeitet werden.
    <example>
     <title>Bedingte Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Wir können foo() von her aus nicht
   aufrufen, da sie noch nicht existiert,
   aber wir können bar() aufrufen */

bar();

if ($makefoo) {
  function foo ()
  {
    echo "Ich existiere nicht, bis mich die Programmausführung erreicht hat.\n";
  }
}

/* Nun können wir foo() sicher aufrufen,
   da $makefoo als true ausgewertet wurde */

if ($makefoo) foo();

function bar()
{
  echo "Ich existiere sofort nach Programmstart.\n";
}

?>
]]>
     </programlisting>
    </example>
    <example>
     <title>Funktionen innerhalb von Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() 
{
  function bar() 
  {
    echo "Ich existiere nicht, bis foo() aufgerufen wurde.\n";
  }
}

/* Wir können bar() noch nicht
   aufrufen, da es nicht existiert */

foo();

/* Nun können wir auch bar() aufrufen,
   da sie durch die Abarbeitung von
   foo() verfügbar gemacht wurde */

bar();

?>  
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    PHP unterstützt weder das Überladen von Funktionen, noch ist es
    möglich, zuvor deklarierte Funktionen neu zu definieren oder die
    Definition zu löschen.
   </simpara>
   <simpara>
    PHP 3 unterstützt keine variable Anzahl von Parametern,
    obwohl Vorgabewerte für Parameter unterstützt werden
    (weitere Informationen finden Sie unter
    <link linkend="functions.arguments.default">Vorgabewerte
    für Parameter</link>). PHP 4 unterstützt beides: siehe
    <link linkend="functions.variable-arg-list">Variable
    Parameteranzahl</link> und die Funktionsreferenzen für
    <function>func_num_args</function>,
    <function>func_get_arg</function> und
    <function>func_get_args</function> für weitere Informationen.
   </simpara>
  </sect1>
 
  <sect1 xml:id="functions.arguments">
   <title>Funktionsparameter</title>
 
   <simpara>
    Mit einer Parameterliste kann man Informationen an eine Funktion 
    übergeben. Die Parameterliste ist eine durch Kommas getrennte
    Liste von Variablen und/oder Konstanten.
   </simpara>
   <para>
    PHP unterstützt die Weitergabe von Parametern als Werte (das ist
    der Standard), als <link
    linkend="functions.arguments.by-reference">Verweise</link>, und
    als <link linkend="functions.arguments.default">Vorgabewerte</link>.
    Die Übergabe einer variablen Anzahl von Parametern wird nur von
    PHP 4 und höher unterstützt, siehe <link
    linkend="functions.variable-arg-list">Variable
    Parameteranzahl</link> und die Funktionsreferenzen für
    <function>func_num_args</function>,
    <function>func_get_arg</function> und
    <function>func_get_args</function> für weitere Informationen. 
    Durch die Übergabe eines Arrays mit Parametern kann man auch
    in PHP 3 einen ähnlichen Effekt erreichen:
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
function rechne_array($eingabe)
{
    echo "$eingabe[0] + $eingabe[1] = ", $eingabe[0]+$eingabe[1];
}
]]>
     </programlisting>
    </informalexample>
   </para>
 
   <sect2 xml:id="functions.arguments.by-reference">
    <title>Verweise als Parameter übergeben</title>
 
    <simpara>
     Normalerweise werden den Funktionen Werte als Parameter
     übermittelt. Wenn man den Wert dieses Parameters innerhalb der
     Funktion ändert, bleibt der Parameter außerhalb der Funktion
     unverändert. Wollen Sie aber genau das erreichen, dann müssen
     Sie die Parameter als Verweise (Referenzen) übergeben. 
    </simpara>
       
    <para>
     Wenn eine Funktion einen Parameter generell als Verweis behandeln
     soll, setzt man in der Funktionsdefinition ein kaufmännisches Und
     (&amp;) vor den Parameternamen:
 
     <informalexample>
      <programlisting role="php">
<![CDATA[
function fuege_etwas_anderes_an (&$string)
{
    $string .= 'und nun zu etwas anderem.';
}
$str = 'Dies ist ein String, ';
fuege_etwas_anderes_an ($str);
echo $str; // Ausgabe: 'Dies ist ein String, und nun zu etwas anderem.'
]]>
      </programlisting>
     </informalexample>
    </para>

   </sect2>
 
   <sect2 xml:id="functions.arguments.default">
    <title>Vorgabewerte für Parameter</title>
 
    <para>
     Eine Funktion kann C++-artige Vorgabewerte für skalare Parameter
     wie folgt definieren:
 
     <informalexample>
      <programlisting role="php">
<![CDATA[
function machkaffee ($typ = "Cappucino")
{
    return "Ich mache eine Tasse $typ.\n";
}
echo machkaffee ();
echo machkaffee ("Espresso");
]]>
      </programlisting>
     </informalexample>
    </para>
 
    <para>
     Die Ausgabe von diesem kleinen Skript ist:
 
     <screen>
Ich mache eine Tasse Cappucino.
Ich mache eine Tasse Espresso.
     </screen>
    </para>
 
    <simpara>
     Der Vorgabewert muss ein konstanter Ausdruck sein, darf also (zum
     Beispiel) keine Variable oder Element einer Klasse sein.
    </simpara>
    <para>
     Bitte beachten Sie, dass alle Vorgabewerte rechts von den 
     Nicht-Vorgabeparametern stehen sollten; - sonst wird es nicht 
     funktionieren. Betrachten Sie folgendes Beispiel:

     <informalexample>
      <programlisting role="php">
<![CDATA[
function mach_joghurt ($typ = "rechtsdrehendes", $geschmack)
{
    return "Mache einen Becher $typ $geschmack-joghurt.\n";
}
 
echo mach_joghurt ("Brombeer");   // arbeitet nicht wie erwartet
]]>
      </programlisting>
     </informalexample>
    </para>
 
    <para>
     Die Ausgabe dieses Beispiels ist::
 
     <screen>
Warning: Missing argument 2 in call to makeyogurt() in 
/usr/local/etc/httpd/htdocs/php3test/functest.html on line 41
Mache einen Becher Brombeer-joghurt.
     </screen></para>
 
    <para>
     Nun vergleichen Sie bitte oberes Beispiel mit folgendem:
 
     <informalexample>
      <programlisting role="php">
<![CDATA[
function mach_joghurt ($geschmack, $typ = "rechtsdrehendes")
{
    return "Mache einen Becher $typ $geschmack-joghurt.\n";
}
 
echo mach_joghurt ("Brombeer");   // arbeitet wie erwartet.
]]>
      </programlisting>
     </informalexample>
    </para>
 
    <para>
     ... und jetzt ist die Ausgabe:
 
     <screen>
Mache einen Becher rechtsdrehendes Brombeer-Joghurt.
     </screen>
    </para>

   </sect2>

   <sect2 xml:id="functions.variable-arg-list">
    <title>Variable Anzahl von Parametern</title>
	
    <simpara>
     PHP 4 unterstützt eine variable Anzahl von Parametern in
     benutzerdefinierten Funktionen. Das Handling dieser Parameter
     fällt mittels der Funktionen <function>func_num_args</function>,
     <function>func_get_arg</function> und
     <function>func_get_args</function> sehr leicht.
    </simpara>

    <simpara>
     Es ist keine spezielle Syntax erforderlich. Die Parameter können
     wie gehabt explizit in den Funktionsdeklarationen angegeben
     werden, und werden sich wie gewohnt verhalten.
    </simpara>

   </sect2>

  </sect1>
 
  <sect1 xml:id="functions.returning-values">
   <title>Rückgabewerte</title>
 
   <para>
    Sie können Werte mit dem optionalen Befehl "return" zurückgeben.
    Es können Variablen jedes Typs zurückgegeben werden, auch Listen
    oder Objekte. Die beendet sofort die Funktion, und die Kontrolle
    wird wieder an die aufrufende Zeile zurückgegeben. Weitere
    Informationen finden Sie unter <function>return</function>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
function quadrat ($zahl)
{
    return $zahl * $zahl;
}
echo quadrat (4);   // gibt '16' aus.
]]>
     </programlisting>
    </informalexample>
   </para>
      
   <para>
    Es ist nicht möglich, mehrere Werte von einer Funktion zurückzugeben.
    Ein ähnliches Resultat kann man aber durch die Rückgabe von Listen
    erreichen.
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
function kleine_zahlen()
{
   return array (0, 1, 2);
}
list ($null, $eins, $zwei) = kleine_zahlen();
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Um von einer Funktion eine Referenz zurückzugeben, müssen Sie
    den Referenz-Operator &amp; sowohl in der Funktionsdeklaration,
    als auch bei der Zuweisung des zurückgegebenen Wertes verwenden: 
    <informalexample>
     <programlisting role="php">
<![CDATA[
function &returniere_referenz()
{
    return $einereferenz;
}

$neuereferenz =& returniere_referenz();
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Weitere Informationen über Referenzen finden Sie im Kapitel
    <link linkend="language.references">Referenzen in PHP</link>.
   </simpara>
  </sect1>
 
  <sect1 xml:id="functions.old-syntax">
   <title><literal>old_function</literal></title>
 
   <simpara>
    Der Befehl <literal>old_function</literal> erlaubt es, eine
    Funktion genauso wie bei PHP/FI2 zu definieren (nur "function"
    wird durch "old_function" ersetzt.
   </simpara>
   <simpara>
    Dieser Befehl sollte nur vom PHP/FI2->PHP3-Konverter genutzt
    werden.
   </simpara>
   <warning>
    <para>
     Funktionen, die durch <literal>old_function</literal> definiert
     werden, können nicht von PHP selbst aufgerufen werden. Das heißt
     unter anderem, dass sie nicht in Funktionen wie <function>usort
     </function>, <function>array_walk</function> und <function>
     register_shutdown_function</function> benutzt werden können.
     Dieses Manko können Sie umgehen, indem Sie eine Adapterfunktion
     (in normalem PHP3) schreiben, welche die
     <literal>old_function</literal> aufruft.
    </para>
   </warning>

  </sect1>

  <sect1 xml:id="functions.variable-functions">
   <title>Variablenfunktionen</title>

   <para>
    PHP unterstützt das Konzept der Variablenfunktionen. Wenn Sie an
    das Ende einer Variablen Klammern hängen, versucht PHP eine
    Funktion aufzurufen, deren Name der aktuelle Wert der Variable
    ist. Dies kann unter anderem für Callbacks, Funktionstabellen,
    usw. genutzt werden.
   </para>
   <para>
    Variablenfunktionen funktionieren nicht mit Sprachkonstrukten
    wie <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function> und
    <function>require</function>. Sie müssen Ihre eigenen Wrapperfunktionen
    verwenden, um diese Konstrukte als variable Funktionen benutzen zu
    können.
   </para>
   <para>
    <example>
     <title>Beispiel für Variablenfunktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
    echo "In foo()<br>\n";
}

function bar($arg = '')
{
    echo "In bar(); der Parameter ist '$arg'.<br>\n";
}

// Dies ist eine Wrapperfunkiton für echo
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // Dies ruft foo() auf

$func = 'bar';
$func('test');  // Dies ruft bar() auf

$func = 'echoit';
$func('test');  // Dies ruft echoit() auf
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Sie können auch die Methode eines Objektes mittels der variablen
    Funktionen aufrufen.
    <example>
     <title>Variable Methode</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Var()
    {
        $name = 'Bar';
        $this->$name(); // Dies ruft die Bar() Methode auf
    }
    
    function Bar()
    {
        echo "Das ist Bar";
    }
}

$foo = new Foo();
$funcname = "Var";
$foo->$funcname();   // Dies ruft $foo->Var() auf

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Siehe auch <function>call_user_func</function>,
    <link linkend="language.variables.variable">
    Variable Variablen</link> und <function>function_exists</function>.
   </para>
  </sect1>
 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
