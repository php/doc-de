<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 340960 Maintainer: cmb Status: ready -->
<!-- Credits: hholzgra, tom, updated to fix build by theseer -->

 <chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook">
  <title>Funktionen</title>

  <sect1 xml:id="functions.user-defined">
   <title>Benutzerdefinierte Funktionen</title>

   <para>
    Eine Funktion kann wie folgt definiert werden:
   </para>

   <para>
    <example>
     <title>Pseudocode zur Demonstration der Nutzung von Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, ..., $arg_n)
{
    echo "Beispielfunktion.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <simpara>
    Jeder beliebige korrekte PHP-Code kann in einer Funktion
    vorkommen, sogar andere Funktionen und <link
    linkend="language.oop5.basic.class">Klassen</link>-Definitionen.
   </simpara>
   <para>
    Für Funktionsnamen gelten in PHP die gleichen Regeln wie für
    andere Bezeichner. Ein gültiger Funktionsname beginnt mit
    einem Buchstaben oder Unterstrich gefolgt von einer beliebigen
    Anzahl von Buchstaben, Ziffern und Unterstrichen. Als
    regulärer Ausdruck wird dies so ausgedrückt:
    <literal>[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*</literal>.
   </para>
   &tip.userlandnaming;
   <simpara>
    Es ist nicht erforderlich, dass Funktionen bereits definiert sein
    müssen, wenn auf sie verwiesen wird,
    <emphasis>außer</emphasis> wenn eine Funktion nur bedingt definiert
    wird, wie in den beiden untenstehenden Beispielen gezeigt.
   </simpara>
   <para>
    Wenn eine Funktion nur unter bestimmten Bedingungen definiert wird,
    wie in den beiden folgenden Beispielen,
    muss die Definition dieser Funktion noch <emphasis>vor</emphasis>
    deren Aufruf abgearbeitet werden.
   </para>
   <para>
    <example>
     <title>Bedingte Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Wir können foo() von hier aus nicht
   aufrufen, da sie noch nicht existiert,
   aber wir können bar() aufrufen */

bar();

if ($makefoo) {
  function foo ()
  {
    echo "Ich existiere nicht, bis mich die Programmausführung erreicht hat.\n";
  }
}

/* Nun können wir foo() sicher aufrufen,
   da $makefoo als true ausgewertet wurde */

if ($makefoo) foo();

function bar()
{
  echo "Ich existiere sofort nach Programmstart.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Funktionen innerhalb von Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
  function bar()
  {
    echo "Ich existiere nicht, bis foo() aufgerufen wurde.\n";
  }
}

/* Wir können bar() noch nicht
   aufrufen, da es nicht existiert */

foo();

/* Nun können wir auch bar() aufrufen,
   da sie durch die Abarbeitung von
   foo() verfügbar gemacht wurde */

bar();

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Alle Funktionen und Klassen in PHP existieren im globalen Namensraum -
    sie können außerhalb von Funktionen aufgerufen werden, selbst wenn sie
    innerhalb einer Funktion definiert wurden und umgekehrt.
   </para>
   <simpara>
    PHP unterstützt weder das Überladen von Funktionen, noch ist es
    möglich, zuvor deklarierte Funktionen neu zu definieren oder die
    Definition zu löschen.
   </simpara>
   <note>
    <simpara>
     Groß- und Kleinschreibung spielt zwar bei Funktionsnamen keine
     Rolle, es empfiehlt sich aber trotzdem bei Funktionsaufrufen
     die gleiche Schreibweise wie in der Deklaration zu benutzen.
    </simpara>
   </note>
   <simpara>
    Sowohl <link linkend="functions.variable-arg-list">eine
    variable Anzahl Parameter</link> als auch
    <link linkend="functions.arguments.default">Vorgabewerte
    für Parameter</link> werden in Funktionen unterstützt.
    Siehe auch die Funktionsreferenzen für
    <function>func_num_args</function>,
    <function>func_get_arg</function> und
    <function>func_get_args</function> für weitere Informationen.
   </simpara>

   <para>
    Es ist in PHP möglich, Funktionen rekursiv aufzurufen.
    <example>
     <title>Rekursive Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
     </programlisting>
    </example>
   <note>
    <simpara>
     Rekursive Funktions-/Methodenaufrufe mit einer Tiefe von über 100-200
     können zu einem Stacküberlauf und damit zum Programmabbruch führen.
     Besonders unbegrenzte Rekursion wird als Programmierfehler erachtet.
    </simpara>
   </note>
   </para>
  </sect1>

  <sect1 xml:id="functions.arguments">
   <title>Funktionsparameter</title>

   <simpara>
    Mit einer Parameterliste kann man Informationen an eine Funktion
    übergeben. Die Parameterliste ist eine durch Kommas getrennte
    Liste von Ausdrücken. 
    Die Parameter werden von links nach rechts ausgewertet.
   </simpara>
   <para>
    PHP unterstützt die Weitergabe von Parametern als Werte (das ist
    der Standard), als <link
    linkend="functions.arguments.by-reference">Verweise</link> und
    als <link linkend="functions.arguments.default">Vorgabewerte</link>.
    <link linkend="functions.variable-arg-list">Eine variable Anzahl
    von Parametern</link> wird ebenfalls unterstützt.
   </para>

   <para>
    <example>
     <title>Arrays an Funktionen übergeben</title>
     <programlisting role="php">
<![CDATA[
<?php
function nimm_array($eingabe)
{
    echo "$eingabe[0] + $eingabe[1] = ", $eingabe[0]+$eingabe[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 xml:id="functions.arguments.by-reference">
    <title>Parameter als Verweise übergeben</title>

    <simpara>
     Normalerweise werden den Funktionen Werte als Parameter
     übermittelt. Wenn man den Wert dieses Parameters innerhalb der
     Funktion ändert, bleibt der Parameter außerhalb der Funktion
     unverändert. Wollen Sie aber erreichen, dass die Änderung auch außerhalb
     der Funktion sichtbar wird, müssen Sie die Parameter als Verweise
     (Referenzen) übergeben.
    </simpara>

    <para>
     Wenn eine Funktion einen Parameter generell als Verweis behandeln
     soll, setzt man in der Funktionsdefinition ein kaufmännisches Und
     (&amp;) vor den Parameternamen:
    </para>

    <para>
     <example>
      <title>Übergeben von Funktionsparametern als Verweis</title>
      <programlisting role="php">
<![CDATA[
<?php
function fuege_etwas_an(&$string)
{
    $string .= 'und etwas mehr.';
}
$str = 'Dies ist ein String, ';
fuege_etwas_an($str);
echo $str; // Ausgabe: 'Dies ist ein String, und etwas mehr.'
?>
]]>
      </programlisting>
     </example>
    </para>

   </sect2>

   <sect2 xml:id="functions.arguments.default">
    <title>Vorgabewerte für Parameter</title>

    <para>
     Eine Funktion kann C++-artige Vorgabewerte für skalare Parameter
     wie folgt definieren:
    </para>

    <para>
     <example>
      <title>Einsatz von Vorgabeparametern in Funktionen</title>
      <programlisting role="php">
<![CDATA[
<?php
function machkaffee($typ = "Cappucino")
{
    return "Ich mache eine Tasse $typ.\n";
}
echo machkaffee();
echo machkaffee(null);
echo machkaffee("Espresso");
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Ich mache eine Tasse Cappucino.
Ich mache eine Tasse .
Ich mache eine Tasse Espresso.
]]>
      </screen>
     </example>
    </para>

    <para>
     PHP gestattet es, <type>Array</type>s und den speziellen Typ &null; als
     Vorgabewert zu nutzen, zum Beispiel:
    </para>
    <para>
     <example>
      <title>Nichtskalare Typen als Vorgabewert</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($types = array("cappuccino"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "hands" : $coffeeMaker;
    return "Ich mache eine Tasse ".join(", ", $types)." mit $device.\n";
}
echo makecoffee();
echo makecoffee(array("cappuccino", "lavazza"), "teapot");
?>
]]>
      </programlisting>
     </example>
    </para>

    <simpara>
     Der Vorgabewert muss ein konstanter Ausdruck sein, darf also zum
     Beispiel keine Variable, Eigenschaft einer Klasse oder ein
     Funktionsaufruf sein.
    </simpara>
    <para>
     Bitte beachten Sie, dass alle Parameter mit Vorgabewert rechts von den
     Parametern ohne Vorgabewert stehen müssen - sonst wird es nicht
     funktionieren. Betrachten Sie folgendes Beispiel:
    </para>

    <para>
     <example>
      <title>Ungültige Anwendung von Vorgabewerten</title>
      <programlisting role="php">
<![CDATA[
<?php
function mach_joghurt($typ = "rechtsdrehendes", $geschmack)
{
    return "Mache einen Becher $typ $geschmack-joghurt.\n";
}

echo mach_joghurt("Brombeer");   // arbeitet nicht wie erwartet
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Warning: Missing argument 2 in call to mach_joghurt() in
/usr/local/etc/httpd/htdocs/phptest/functest.html on line 41
Mache einen Becher Brombeer -joghurt.
]]>
      </screen>
     </example>
    </para>

    <para>
     Nun vergleichen Sie bitte obiges Beispiel mit folgendem:
    </para>

    <para>
     <example>
     <title>Richtiger Einsatz von Vorgabewerten</title>
      <programlisting role="php">
<![CDATA[
<?php
function mach_joghurt($geschmack, $typ = "rechtsdrehendes")
{
    return "Mache einen Becher $typ $geschmack-Joghurt.\n";
}

echo mach_joghurt("Brombeer");   // arbeitet wie erwartet.
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Mache einen Becher rechtsdrehendes Brombeer-Joghurt.
]]>
      </screen>
     </example>
    </para>

    <note>
     <simpara>
      Das Setzen von Standardwerten für Argumente, die als Referenz
      übergeben werden ("passed by reference") wird seit PHP 5
      unterstützt.
     </simpara>
    </note>

   </sect2>
   
   <sect2 xml:id="functions.arguments.type-declaration">
    <title>Typdeklarationen</title>

    <note>
     <para>
      Typdeklarationen waren unter PHP 5 ebenfalls unter dem Namen Type-Hints bekannt.
     </para>
    </note>

    <para>
     Typdeklarationen erlauben es, dass Funktionsparameter zur Aufrufzeit von einem bestimmten Typ sind.
     Ist der gegebene Wert von einem falschen Typ,
     dann wird ein Fehler generiert: in PHP 5 ist es ein recoverable fatal error,
     während PHP 7 eine <classname>TypeError</classname>-Exception auslöst.
    </para>

    <para>
     Um eine Typdeklaration zu spezifizieren, sollte der Typname vor dem Parameternamen hinzugefügt werden.
     Wird der Vorgabewert des Parameters als &null; definiert, akzeptiert die Funktion die Übergabe von &null;.
    </para>

    <sect3 xml:id="functions.arguments.type-declaration.types">
     <title>Gültige Typen</title>
     <informaltable>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Typ</entry>
         <entry>Beschreibung</entry>
         <entry>Minimale PHP-Version</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>Klassen/Interface-Name</entry>
         <entry>
          Der Parameter muss ein Exemplar (&instanceof;) der gegebenen Klasse oder des Interface sein.
         </entry>
         <entry>PHP 5.0.0</entry>
        </row>
        <row>
         <entry><literal>self</literal></entry>
         <entry>
          Der Parameter muss ein Exemplar (&instanceof;) der selben Klasse sein für die die
          Methode definiert ist. Dies kann nur für Klassen- und Objektmethoden
          verwendet werden.
         </entry>
         <entry>PHP 5.0.0</entry>
        </row>
        <row>
         <entry><type>array</type></entry>
         <entry>
          Der Parameter muss ein <type>Array</type> sein.
         </entry>
         <entry>PHP 5.1.0</entry>
        </row>
        <row>
         <entry><type>callable</type></entry>
         <entry>
          Der Parameter muss ein gültiges <type>Callable</type> sein.
         </entry>
         <entry>PHP 5.4.0</entry>
        </row>
        <row>
         <entry><type>bool</type></entry>
         <entry>
          Der Parameter muss ein Boolescher Wert (<type>boolean</type>) sein.
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
        <row>
         <entry><type>float</type></entry>
         <entry>
          Der Parameter muss eine Gleitkommazahl (<type>float</type>) sein.
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
        <row>
         <entry><type>int</type></entry>
         <entry>
          Der Parameter muss eine Ganzzahl (<type>integer</type>) sein.
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
        <row>
         <entry><type>string</type></entry>
         <entry>
          Der Parameter muss ein <type>String</type> sein.
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
     <warning>
      <para>
       Aliase der oben genannten skalaren Typen werden nicht unterstützt.
       Statt dessen werden sie als Klassen- oder Schnittstellennamen angesehen.
       Zum Beispiel erfordert die Verwendung von <literal>boolean</literal>
       als Parameter oder Rückgabetyp ein Argument oder einen Rückgabewert, der
       ein Exemplar (&instanceof;) der Klasse oder Schnittstelle <literal>boolean</literal>
       ist, anstatt vom Typ <type>bool</type>:
      </para>
      <para>
       <example>
        <programlisting role="php">
 <![CDATA[
 <?php
 function test(boolean $param) {}
 test(true);
 ?>
 ]]>
        </programlisting>
        &example.outputs;
        <screen>
 <![CDATA[
 Fatal error: Uncaught TypeError: Argument 1 passed to test() must be an instance of boolean, boolean given, called in - on line 1 and defined in -:1
 ]]>
        </screen>
       </example>
      </para>
     </warning>
    </sect3>

    <sect3 xml:id="functions.arguments.type-declaration.examples">
     &reftitle.examples;
     <example>
      <title>Grundlegende Klassen-Typdeklaration</title>
      <programlisting role="php">
<![CDATA[
<?php
class C {}
class D extends C {}

// Dies erweitert C nicht.
class E {}

function f(C $c) {
    echo get_class($c)."\n";
}

f(new C);
f(new D);
f(new E);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
C
D

Fatal error: Uncaught TypeError: Argument 1 passed to f() must be an instance of C, instance of E given, called in - on line 14 and defined in -:8
Stack trace:
#0 -(14): f(Object(E))
#1 {main}
  thrown in - on line 8
]]>
      </screen>
     </example>

     <example>
      <title>Grundlegende Interface-Typdeklaration</title>
      <programlisting role="php">
<![CDATA[
<?php
interface I { public function f(); }
class C implements I { public function f() {} }

// Dies implementiert I nicht.
class E {}

function f(I $i) {
    echo get_class($i)."\n";
}

f(new C);
f(new E);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
C

Fatal error: Uncaught TypeError: Argument 1 passed to f() must implement interface I, instance of E given, called in - on line 13 and defined in -:8
Stack trace:
#0 -(13): f(Object(E))
#1 {main}
  thrown in - on line 8
]]>
      </screen>
     </example>

     <example>
      <title>Nullable Typdeklaration</title>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

function f(C $c = null) {
    var_dump($c);
}

f(new C);
f(null);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
object(C)#1 (0) {
}
NULL
]]>
      </screen>
     </example>
    </sect3>

    <sect3 xml:id="functions.arguments.type-declaration.strict">
     <title>Strenge Typisierung</title>

     <para>
      Standardmäßig erzwingt PHP die Umwandlung von Wertem des falschen Typs in den erwarteten
      skalaren Typ, falls möglich. Zum Beispiel erhält eine Funktion, der ein <type>Integer</type>
      für einen Parameter, der einen <type>String</type> erwartet, übergeben wurde, eine Variable
      vom Typ <type>String</type>.
     </para>

     <para>
      Es ist möglich die strenge Typsierung für einzelne Dateien zu aktivieren. Im strengem
      Typisierungsmodus werden nur Variablen von genau dem Typ der Typdeklaration akzeptiert,
      oder ein <classname>TypeError</classname> wird ausgelöst. Die einzige Ausnahme dieser
      Regel ist, dass ein <type>Integer</type> an eine Funktion, die ein <type>Float</type>
      erwartet, übergeben werden darf. Funktionsaufrufe innerhalb von internen Funktionen sind
      nicht von der <literal>strict_types</literal>-Deklaration betroffen. 
     </para>

     <para>
      Um die strenge Typisierung zu aktivieren, wird die &declare;-Anweisung mit der
      <literal>strict_types</literal>-Deklaration verwendet:
     </para>

     <caution>
      <para>
       Das Aktivieren der strengen Typisierung betrifft ebenfalls
       <link linkend="functions.returning-values.type-declaration">Rückgabe-Typdeklarationen</link>.
      </para>
     </caution>

     <note>
      <para>
       Strenge Typisierung gilt für Funktionsaufrufe, die <emphasis>innerhalb</emphasis> einer
       Datei im strengen Typisierungsmodus durchgeführt werden, nicht für Funktionen, die
       innerhalb dieser Datei deklariert wurden. Ruft eine Datei, für die strenge Typisierung
       nicht aktiviert ist, eine Funktion, die in einer Datei im strengen Typisierungsmodus
       definiert wurde, auf, wird die Präferenz des Aufrufers (schwache Typsierung) beachtet,
       und die Konvertierung des Werts wird erzwungen.
      </para>
     </note>

     <note>
      <para>
       Strenge Typsierung ist nur für skalare Typdeklarationen gültig, und erfodert folglich
       PHP 7.0.0 oder höher, da skalare Typdeklarationen erst in dieser Version hinzugefügt
       wurden.
      </para>
     </note>

     <example>
      <title>Strenge Typisierung</title>
      <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1.5, 2.5));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)

Fatal error: Uncaught TypeError: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 9 and defined in -:4
Stack trace:
#0 -(9): sum(1.5, 2.5)
#1 {main}
  thrown in - on line 4
]]>
      </screen>
     </example>

     <example>
      <title>Schwache Typisierung</title>
      <programlisting role="php">
<![CDATA[
<?php
function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));

// Die Konvertierung nach Integer wird erzwungen: beachten Sie die Ausgabe weiter unten!
var_dump(sum(1.5, 2.5));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)
int(3)
]]>
      </screen>
     </example>

     <example>
      <title>Abfangen von <classname>TypeError</classname></title>
      <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

try {
    var_dump(sum(1, 2));
    var_dump(sum(1.5, 2.5));
} catch (TypeError $e) {
    echo 'Fehler: '.$e->getMessage();
}
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)
Fehler: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 10
]]>
      </screen>
     </example>
    </sect3>
   </sect2>
   
   <sect2 xml:id="functions.variable-arg-list">
    <title>Variable Anzahl von Parametern</title>

    <simpara>
     PHP unterstützt eine variable Anzahl an Parametern für benutzerdefinierte
     Funktionen. Dies wird seit PHP 5.6 durch das Token <literal>...</literal>
     umgesetzt. Für ältere Versionen von PHP stehen die Funktionen 
     <function>func_num_args</function>, <function>func_get_arg</function>, und
     <function>func_get_args</function> bereit.
    </simpara>

    <sect3 xml:id="functions.variable-arg-list.new">
     <title><literal>...</literal> in PHP 5.6+</title>

     <para>
      Ab PHP 5.6 kann eine Liste von Parametern das Token <literal>...</literal>
      enthalten, um anzugeben, dass die Funktion eine variable Anzahl von
      Parametern akzeptiert. Die zusätzlichen Werte werden als Array an die entsprechende Variable übergeben.
      Zum Beispiel:
      <example>
       <title>Verwendung von <literal>...</literal> für den Zugriff auf
       variable Parameter</title>
       <programlisting role="php">
<![CDATA[
<?php
function sum(...$numbers) {
    $acc = 0;
    foreach ($numbers as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
10
]]>
       </screen>
      </example>
     </para>

     <para>
      Das Token <literal>...</literal> kann ebenfalls dazu verwendet werden, um
      ein <type>Array</type> oder <classname>Traversable</classname>-Objekt als
      Liste von Parametern zu übergeben:
      <example>
       <title>Verwendung von <literal>...</literal> zur Übergabe einer Parameterliste</title>
       <programlisting role="php">
<![CDATA[
<?php
function add($a, $b) {
    return $a + $b;
}

echo add(...[1, 2])."\n";

$a = [1, 2];
echo add(...$a);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
3
3
]]>
       </screen>
      </example>
     </para>

     <para>
      Die Definition von regulären, positionierten Parametern vor dem <literal>...</literal>
      ist natürlich weiterhin möglich. In einem solchen Fall werden dann nur die
      zusätzlichen Werte, die zu keinem positionierten Parameter gehören, in
      das durch <literal>...</literal> erzeugte Array übernommen.
     </para>

     <para>
      Es ist zudem ebenfalls möglich dem <literal>...</literal> Token eine
      <link linkend="language.oop5.typehinting">Typangabe</link> voran zu
      stellen. Ist dies der Fall, müssen alle Werte, die für <literal>...</literal>
      relevant sind, vom entsprechenden Typ sein.
      
      <example>
       <title>Variable Parameter mit Vorgabe des Typs</title>
       <programlisting role="php">
<![CDATA[
<?php
function total_intervals($unit, DateInterval ...$intervals) {
    $time = 0;
    foreach ($intervals as $interval) {
        $time += $interval->$unit;
    }
    return $time;
}

$a = new DateInterval('P1D');
$b = new DateInterval('P2D');
echo total_intervals('d', $a, $b).' days';

// Dieser Aufruf wird scheitern, da null keine Instanz von DateInterval ist
echo total_intervals('d', null);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
3 days
Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2
]]>
       </screen>
      </example>
     </para>

     <para>
      Durch ein voran gestelltes <literal>&amp;</literal> ist auch die Übergabe von variablen Parametern
      <link linkend="functions.arguments.by-reference">als Referenz</link>
      möglich.
     </para>
    </sect3>

    <sect3 xml:id="functions.variable-arg-list.old">
     <title>Ältere Versionen von PHP</title>

     <para>
      Eine spezielle Syntax ist zur Definition von variablen Parametern nicht
      notwendig. Um auf die übergebenen Werte zugreifen zu können, stehen
      die Funktionen <function>func_num_args</function>,
      <function>func_get_arg</function> und <function>func_get_args</function>
      bereit.
     </para>

     <para>
      Das erste Beispiel von weiter oben würde in PHP 5.5 und davor so
      umgesetzt werden können:
      
      <example>
       <title>Zugriff auf variable Parameter in PHP 5.5 und davor</title>
       <programlisting role="php">
<![CDATA[
<?php
function sum() {
    $acc = 0;
    foreach (func_get_args() as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
10
]]>
       </screen>
      </example>
     </para>
    </sect3>

   </sect2>

  </sect1>

  <sect1 xml:id="functions.returning-values">
   <title>Rückgabewerte</title>

   <para>
    Sie können Werte mit der optionalen return-Anweisung zurückgeben.
    Es können Variablen jeden Typs zurückgegeben werden, auch Arrays
    oder Objekte. Dies beendet sofort die Funktion und die Kontrolle
    wird wieder an die aufrufende Zeile zurückgegeben. Weitere
    Informationen finden Sie unter <function>return</function>.
   </para>

   <note>
    <para>
     Wird <function>return</function> ausgelassen, dann wird der Wert &null;
     zurückgegeben.
    </para>
   </note>
   
   <sect2>
    <title>Einsatz von return</title>
   <para>
    <example>
     <title>Einsatz von <function>return</function></title>
     <programlisting role="php">
<![CDATA[
<?php
function quadrat($zahl)
{
    return $zahl * $zahl;
}
echo quadrat(4);   // gibt '16' aus.

?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Es ist nicht möglich, mehrere Werte von einer Funktion zurückzugeben.
    Ein ähnliches Resultat kann man aber durch die Rückgabe eines Arrays
    erreichen.
   </para>

   <para>
    <example>
    <title>Rückgabe mehrerer Werte als Array</title>
     <programlisting role="php">
<![CDATA[
<?php
function kleine_zahlen()
{
   return array (0, 1, 2);
}
list ($null, $eins, $zwei) = kleine_zahlen();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Um von einer Funktion eine Referenz zurückzugeben, müssen Sie
    den Referenz-Operator &amp; sowohl in der Funktionsdeklaration,
    als auch bei der Zuweisung des zurückgegebenen Wertes verwenden:
   </para>

   <para>
    <example>
     <title>Rückgabe von Referenzen aus Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function &returniere_referenz()
{
    return $einereferenz;
}

$neuereferenz =& returniere_referenz();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Weitere Informationen über Referenzen finden Sie im Kapitel
    <link linkend="language.references">Referenzen in PHP</link>.
   </simpara>
  </sect2>

  <sect2 xml:id="functions.returning-values.type-declaration">
   <title>Rückgabe-Typdeklarationen</title>

   <para>
    PHP 7 führt die Unterstützung von Rückgabe-Typdeklarationen ein. Ähnlich wie
    <link linkend="functions.arguments.type-declaration">Parameter-Typdeklarationen</link>
    geben Rückgabe-Typdeklarationen den Typ des Wertes, der von einer Funktion zurückgegeben
    wird, an. Die gleichen <link linkend="functions.arguments.type-declaration.types">Typen</link>,
    die für Parameter-Typdeklarationen verfügbar sind, sind auch für Rückgabe-Typdeklarationen
    erlaubt.
   </para>

   <para>
    <link linkend="functions.arguments.type-declaration.strict">Strenge Typsierung</link>
    hat ebenfalls Auswirkungen auf Rückgabe-Typdeklarationen. Im normalen schwachen Typisierungsmodus werden zurückgegebene Werte in den korrekten Typ konvertiert, wenn sie
    nicht bereits diesen Typ haben. Im strengen Modus muss der zurückgegebene Wert den
    korrekten Typ haben; andernfalls wird ein <classname>TypeError</classname> ausgelöst.
   </para>

   <note>
    <para>
     Wird eine Elternmethode überschrieben, muss die Rückgabe-Typdeklaration der Kindmethode
     mit der Elternmethode übereinstimmen. Definiert die Elternmethode keinen Rückgabetyp,
     dann darf die Kindmethode das tun. 
    </para>
   </note>

   <sect3 xml:id="functions.returning-values.type-declaration.examples">
    &reftitle.examples;

    <example>
     <title>Grundlegende Rückgabe-Typdeklaration</title>
     <programlisting role="php">
<![CDATA[
<?php
function sum($a, $b): float {
    return $a + $b;
}

// Beachten Sie, dass eine Gleitkommazahl zurückgegeben wird.
var_dump(sum(1, 2));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
float(3)
]]>
      </screen>
     </example>

     <example>
      <title>Einsatz des strengen Typisierungsmodus</title>
      <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum($a, $b): int {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1, 2.5));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)

Fatal error: Uncaught TypeError: Return value of sum() must be of the type integer, float returned in - on line 5 in -:5
Stack trace:
#0 -(9): sum(1, 2.5)
#1 {main}
  thrown in - on line 5
]]>
      </screen>
     </example>

     <example>
      <title>Rückgabe eines Objekts</title>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

function getC(): C {
    return new C;
}

var_dump(getC());
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
object(C)#1 (0) {
}
]]>
      </screen>
     </example>
    </sect3>
   </sect2>
  </sect1>
 
  <sect1 xml:id="functions.variable-functions">
   <title>Variablenfunktionen</title>

   <para>
    PHP unterstützt das Konzept der Variablenfunktionen. Wenn Sie an
    das Ende einer Variablen Klammern hängen, versucht PHP eine
    Funktion aufzurufen, deren Name der aktuelle Wert der Variablen
    ist. Dies kann unter anderem für Callbacks, Funktionstabellen,
    usw. genutzt werden.
   </para>
   <para>
    Variablenfunktionen funktionieren nicht mit Sprachkonstrukten
    wie <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function> und
    <function>require</function>. Sie müssen Ihre eigenen Wrapperfunktionen
    verwenden, um diese Konstrukte als Variablenfunktionen benutzen zu
    können.
   </para>
   <para>
    <example>
     <title>Beispiel für Variablenfunktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
    echo "In foo()<br />\n";
}

function bar($arg = '')
{
    echo "In bar(); der Parameter ist '$arg'.<br />\n";
}

// Dies ist eine Wrapperfunkiton für echo
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // Dies ruft foo() auf

$func = 'bar';
$func('test');  // Dies ruft bar() auf

$func = 'echoit';
$func('test');  // Dies ruft echoit() auf
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Sie können auch die Methode eines Objektes mittels der variablen
    Funktionen aufrufen.
    <example>
     <title>Variable Methode</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // Dies ruft die Bar() Methode auf
    }

    function Bar()
    {
        echo "Das ist Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();   // Dies ruft $foo->Variable() auf

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Werden statische Methoden aufgerufen, ist der Funktionsaufruf stärker als der statische Eigenschaftsoperator:
    <example>
     <title>Beispiel für variable Methoden mit statischen Eigenschaften</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static $variable = 'statische Eigenschaft';
    static function Variable()
    {
        echo 'Method Variable called';
    }
}

echo Foo::$variable; // Dies gibt 'statische Eigenschaft' aus. Es bräuchte eine $variable im aktuellen Geltungsbereich.
$variable = "Variable";
Foo::$variable();  // Dies ruft $foo->Variable() auf, da $variable im aktuellen Geltungbereich vorliegt.

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
     Ab PHP 5.4.0 können beliebige <type>Callables</type>s, die in einer Variable
     gespeichert sind, aufgerufen werden.
    <example>
     <title>Komplexe Callables</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static function bar()
    {
        echo "bar\n";
    }
    function baz()
    {
        echo "baz\n";
    }
}

$func = array("Foo", "bar");
$func(); // gibt "bar" aus
$func = array(new Foo, "baz");
$func(); // gibt "baz" aus
$func = "Foo::bar";
$func(); // gibt ab PHP 7.0.0 "bar" aus; vorher wurde ein fataler Fehler ausgelöst
?>
]]>
     </programlisting>
    </example>
   </para>
      
   <para>
    Siehe auch <function>is_callable</function>,
    <function>call_user_func</function>,
    <link linkend="language.variables.variable">Variable Variablen</link> und
    <function>function_exists</function>.
   </para>
   
   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>7.0.0</entry>
         <entry>
          'Klassenname::Methodenname' ist als Variablenfunktion erlaubt.
         </entry>
        </row>
        <row>
         <entry>5.4.0</entry>
         <entry>
          Array, die gültige Callables sind, sind als Variablenfunktion erlaubt.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="functions.internal">
   <title>Interne (eingebaute) Funktionen</title>

   <para>
    PHP enthält standmäßig viele Funktionen und Konstrukte, weiterhin
    gibt es viele Funktionen die vorausssetzen, dass bestimmte PHP-Extensions
    einkompiliert wurden, anderenfalls erhalten Sie beim
    Aufruf "undefined function"-Fehlermeldungen.
    Um z.B. <link linkend="ref.image">Grafik-Funktionen</link> wie
    <function>imagecreatetruecolor</function> zu nutzen, müssen Sie PHP mit
    <productname>GD</productname>-Unterstützung kompilieren, oder um
    <function>mysql_connect</function> zu nutzen, muss Ihr PHP mit <link
    linkend="ref.mysql">MySQL</link>-Unterstützung kompiliert sein.
    Viele Kernfunktionen wie z.B. die <link
    linkend="ref.strings">String</link>- und <link
    linkend="ref.var">Variablen</link>-Funktionen sind bereits in
    jeder PHP-Version enthalten. Ein Aufruf von <function>phpinfo</function>
    oder <function>get_loaded_extensions</function> zeigt Ihnen, welche
    Extensions in Ihrer PHP-Installation verfügbar sind.
    Beachten Sie weiterhin, dass viele Extensions bereits standardmäßig
    aktiviert sind und das PHP-Manual nach Extensions unterteilt ist.
    Weitere Informationen zur Einrichtung von PHP finden Sie in den
    Kapiteln <link linkend="configuration">Konfiguration</link>,
    <link linkend="install">Installation</link> und den Kapiteln
    zu den einzelnen Extensions.
   </para>
   <para>
    Wie Funktionsprototypen zu lesen und zu verstehen sind, ist im
    Kapitel '<link linkend="about.prototypes">Wie man eine Funktionsdefinition
    (Prototyp) liest'</link> erklärt.
    Es ist wichtig zu erkennen, was eine Funktion zurückgibt und ob
    die übergebenen Parameter verändert werden. So gibt z.B.
    <function>str_replace</function> den bearbeiteten String zurück,
    während <function>usort</function> direkt auf der übergebenen
    Variablen arbeitet.
    Jede Handbuchseite enthält spezifische Informationen für jede
    Funktion wie ihre Parameter, die Rückgabewerte sowohl bei Erfolg
    als auch im Fehlerfall, Änderungen des Verhaltens und die Verfügbarkeit.
    Die Kenntnis dieser wichtigen (aber oft subtilen) Unterschiede ist
    von entscheidender Bedeutung für das Schreiben korrekten PHP-Codes.
   </para>
   <note>
    <simpara>
     Wenn Funktionen andere Parameter erhalten als erwartet, d.h. wenn z.B.
     ein <type>Array</type> übergeben wird obwohl ein <type>String</type>
     erwartet wird, so ist der Rückgabewert undefiniert. In solchen Fällen
     ist es üblich, dass &null; zurückgegeben wird. Dies ist aber nur eine
     Konvention, auf die Sie sich nicht unbedingt verlassen können.
    </simpara>
   </note>
   <para>
    Siehe auch <function>function_exists</function>,
    <link linkend="funcref">die Funktionsreferenz</link>,
    <function>get_extension_funcs</function> und
    <function>dl</function>.
   </para>
  </sect1>

  <sect1 xml:id="functions.anonymous">
   <title>Anonyme Funktionen</title>

   <simpara>
    Anonyme Funktionen, auch bekannt als  <literal>Closures</literal>, ermöglichen es Funktionen
    ohne Funktionsnamen zu schreiben. Sie sind am wertvollsten als Werte von <link
    linkend="language.types.callback">Callback</link>-Parametern,
    haben aber noch viele andere Verwendungsmöglichkeiten.
   </simpara>
   <simpara>
    Anonyme Funktionen werden unter Verwendung der <link linkend="class.closure">
    <classname>Closure</classname></link>-Klasse implementiert.
   </simpara>

   <example>
    <title>Beispiel für eine anonyme Funktion</title>
    <programlisting role="php">
<![CDATA[
<?php
echo preg_replace_callback('~-([a-z])~', function ($match) {
    return strtoupper($match[1]);
}, 'hallo-welt');
// gibt halloWelt aus
?>
]]>
    </programlisting>
   </example>

   <simpara>
    Closures können auch als Werte von Variablen verwendet werden;
    PHP konvertiert solche Ausdrücke automatisch in Instanzen der internen Klasse <classname>Closure</classname>.
    Die Zuweisung einer Closure an eine Variable verwendet die selbe Syntax wie andere
    Zuweisungen, einschließlich des abschließenden Semikolon:
   </simpara>

   <example>
    <title>Beispiel für die Zuweisung einer anonymen Funktion</title>
    <programlisting role="php">
<![CDATA[
<?php
$greet = function($name)
{
    printf("Hallo %s\r\n", $name);
};

$greet('Welt');
$greet('PHP');
?>
]]>
    </programlisting>
   </example>
   
   <simpara>
    Closures können ebenfalls Variablen aus dem Eltern-Gültigkeitsbereich erben.
    Jede solche Variable muss an das <literal>use</literal>-Sprachkonstrukt übergeben werden. 
   </simpara>

   <example>
    <title>Erben von Variablen aus dem Eltern-Scope</title>
    <programlisting role="php">
<![CDATA[
<?php
$message = 'hallo';

// Kein "use"
$example = function () {
    var_dump($message);
};
$example();

// $message vererben
$example = function () use ($message) {
    var_dump($message);
};
$example();

// der Wert einer geerbten Variable ist der zum Zeitpunkt
// der Funktionsdefinition, nicht des Funktionsaufrufs
$message = 'welt';
$example();

// $message wieder herstellen
$message = 'hallo';

// vererben per Referenz
$example = function () use (&$message) {
    var_dump($message);
};
$example();

// Der geänderte Wert im Eltern-Gültigkeitsbereich
// wird in der aufgerufenen Funktion reflektiert
$message = 'welt';
$example();

// Closures können ebenfalls reguläre Parameter akzeptieren
$example = function ($arg) use ($message) {
    var_dump($arg . ' ' . $message);
};
$example("hallo");
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
Notice: Undefined variable: message in /example.php on line 6
NULL
string(5) "hallo"
string(5) "hallo"
string(5) "hallo"
string(4) "welt"
string(10) "hallo welt"
]]>
    </screen>
   </example>

   <simpara>
    Das Erben von Variablen aus dem Eltern-Gültigkeitsbereich ist <emphasis>nicht</emphasis>
    das gleiche wie die Verwendung von globalen Variablen.
    Globale Variablen existieren im globalen Gültigkeitsbereich, der immer der gleiche ist,
    unabhängig davon welche Funktion ausgeführt wird. Der Eltern-Gültigkeitsbereich einer
    Closure ist die Funktion, in der die Closure deklariert wurde (nicht notwendigerweise
    die Funktion, aus der sie aufgerufen wurde). Betrachten Sie das folgende Beispiel:
   </simpara>

   <example>
    <title>Closures und Gültigkeitsbereiche</title>
    <programlisting role="php">
<![CDATA[
<?php
// Ein einfacher Einkaufswagen, der eine Liste von hinzugefügten Produkten
// enthält, und die Menge jedes Produkts. Enthält eine Methode, die den
// Gesamtpreise der Waren im Einkaufswagen unter Verwendung einer Closure
// als Callback berechnet.
class Cart
{
    const PRICE_BUTTER  = 1.00;
    const PRICE_MILK    = 3.00;
    const PRICE_EGGS    = 6.95;

    protected $products = array();
    
    public function add($product, $quantity)
    {
        $this->products[$product] = $quantity;
    }
    
    public function getQuantity($product)
    {
        return isset($this->products[$product]) ? $this->products[$product] :
               FALSE;
    }
    
    public function getTotal($tax)
    {
        $total = 0.00;
        
        $callback =
            function ($quantity, $product) use ($tax, &$total)
            {
                $pricePerItem = constant(__CLASS__ . "::PRICE_" .
                    strtoupper($product));
                $total += ($pricePerItem * $quantity) * ($tax + 1.0);
            };
        
        array_walk($this->products, $callback);
        return round($total, 2);
    }
}

$my_cart = new Cart;

// Lege ein paar Waren in den Einkaufskorb
$my_cart->add('butter', 1);
$my_cart->add('milk', 3);
$my_cart->add('eggs', 6);

// Gib die Gesamtsumme mit einer Mehrwertsteuer von 5% aus
print $my_cart->getTotal(0.05) . "\n";
// Das Ergebnis ist 54.29
?>
]]>
    </programlisting>
   </example>
   
   <example>
    <title>Automatisches Binden von <literal>$this</literal></title>
    <programlisting role="php">
<![CDATA[
<?php

class Test
{
    public function testing()
    {
        return function() {
            var_dump($this);
        };
    }
}

$object = new Test;
$function = $object->testing();
$function();
    
?>
]]>
    </programlisting>
    &example.outputs.53;
    <screen>
<![CDATA[
Notice: Undefined variable: this in script.php on line 8
NULL
]]>
    </screen>
   </example>

   <para>
    Wird ab PHP 5.4.0 eine anonyme Funktion im Kontext einer Klasse deklariert, so wird diese
    Klasse automatisch an jene gebunden, was <literal>$this</literal> innerhalb des
    Geltungbereichs verfügbar macht. Ist diese automatische Bindung der aktuellen
    Klasse nicht erwünscht, dann können statt dessen <link
    linkend="functions.anonymous-functions.static">statische anonyme Funktionen</link>
    verwendet werden.
   </para>

   <sect2 xml:id="functions.anonymous-functions.static">
    <title>Statische anonyme Funktionen</title>
    <para>
     Ab PHP 5.4 können anonyme Funktionen statisch deklariert werden. Dies verhindert,
     dass automatisch die aktuelle Klasse an sie gebunden wird. Objekte können zur Laufzeit
     ebenfalls nicht an sie gebunden werden.
    </para>
    <para>
     <example>
      <title>Versuch der Verwendung von <literal>$this</literal> innerhalb einer statischen anonymen Funktion</title>
      <programlisting role="php">
<![CDATA[
<?php

new class {
    function __construct()
    {
        (static function() {
            var_dump($this);
        })();
    }
};
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Notice: Undefined variable: this in %s on line %d
NULL
]]>
      </screen>
     </example>
    </para>

    <para>
     <example>
      <title>Versuch ein Objekt an eine statische anonyme Funktion zu binden</title>
      <programlisting role="php">
<![CDATA[
<?php

(static function() {
    // function body
})->call(new StdClass);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Warning: Cannot bind an instance to a static closure in /in/sLLS9 on line 5
]]>
      </screen>
     </example>
    </para>
   </sect2>
   
   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>5.4.0</entry>
         <entry>
          Anonyme Funktionen können sowohl <varname>$this</varname> verwenden
          als auch statisch deklariert werden.
         </entry>
        </row>
        <row>
         <entry>5.3.0</entry>
         <entry>
          Anonyme Funktionen wurde eingeführt.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>

   <sect2 role="notes">
    &reftitle.notes;
    <note>
     <simpara>
      Es ist möglich <function>func_num_args</function>,
      <function>func_get_arg</function> und <function>func_get_args</function>
      innerhalb einer Closure zu verwenden.
     </simpara>
    </note>
   </sect2>

  </sect1>

 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"~/.phpdoc/manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
