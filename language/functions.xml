<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.22 $ -->
<!-- EN-Revision: 1.69 Maintainer: hholzgra Status: ready -->
<!-- Credits: tom -->

 <chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook">
  <title>Funktionen</title>

  <sect1 xml:id="functions.user-defined">
   <title>Vom Nutzer definierte Funktionen</title>

   <para>
    Eine Funktion kann wie folgt definiert werden:
   </para>

   <para>
    <example>
     <title>Pseudokode zur Demonstration der Nutzung von Variablen</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo ($arg_1, $arg_2, ..., $arg_n)
{
    echo "Beispielfunktion.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <simpara>
    Jeder beliebige korrekte PHP-Code kann in einer Funktion
    vorkommen, sogar andere Funktionen und <link
    linkend="keyword.class">Klassen</link>-Definitionen.
   </simpara>
   <para>
    FÃ¼r Funktionsnamen gelten in PHP die gleichen Regeln wie fÃ¼r
    andere Bezeichner. Ein gÃ¼ltiger Funktionsname beginnt mit
    einem Buchstaben oder Unterstrich gefolgt von einer beliebigen
    Anzahl von Buchstaben, Ziffern und Unterstrichen. Als
    regulÃ¤rer Ausdruck wird dies so ausgedrÃ¼ckt:
    <literal>[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*</literal>.
   </para>
   &tip.userlandnaming;
   <simpara>
    Es ist nicht erforderlich, dass Funktionen bereits definiert sein
    mÃ¼ssen, wenn auf sie verviesen wird,
    <emphasis>auÃer</emphasis> wenn eine Funktion nur bedingt definiert
    wird, wie in den beiden untenstehenden Beispielen gezeigt.
   </simpara>
   <para>
    Wenn eine Funktion nur unter bestimmten Bedingungen definiert wird,
    muss die Definition dieser Funktion noch <emphasis>vor</emphasis>
    deren Aufruf abgearbeitet werden.
    <example>
     <title>Bedingte Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Wir kÃ¶nnen foo() von hier aus nicht
   aufrufen, da sie noch nicht existiert,
   aber wir kÃ¶nnen bar() aufrufen */

bar();

if ($makefoo) {
  function foo ()
  {
    echo "Ich existiere nicht, bis mich die ProgrammausfÃ¼hrung erreicht hat.\n";
  }
}

/* Nun kÃ¶nnen wir foo() sicher aufrufen,
   da $makefoo als true ausgewertet wurde */

if ($makefoo) foo();

function bar()
{
  echo "Ich existiere sofort nach Programmstart.\n";
}

?>
]]>
     </programlisting>
    </example>
    <example>
     <title>Funktionen innerhalb von Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
  function bar()
  {
    echo "Ich existiere nicht, bis foo() aufgerufen wurde.\n";
  }
}

/* Wir kÃ¶nnen bar() noch nicht
   aufrufen, da es nicht existiert */

foo();

/* Nun kÃ¶nnen wir auch bar() aufrufen,
   da sie durch die Abarbeitung von
   foo() verfÃ¼gbar gemacht wurde */

bar();

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Alle Funktionen und Klassen in PHP existieren im globalen Namensraum -
    sie kÃ¶nnen auÃerhalb von Funktionen aufgerufen werden, selbst wenn sie
    innerhalb einer Funktion definiert wurden und umgekehrt.
   </para>
   <simpara>
    PHP unterstÃ¼tzt weder das Ãberladen von Funktionen, noch ist es
    mÃ¶glich, zuvor deklarierte Funktionen neu zu definieren oder die
    Definition zu lÃ¶schen.
   </simpara>
   <note>
    <simpara>
     GroÃ- und Kleinschreibung spielt zwar bei Funktionsnamen keine
     Rolle, es empfiehlt sich aber trotzdem bei Funktionsaufrufen
     die gleiche Schreibweise wie in der Deklaration zu benutzen.
    </simpara>
   </note>
   <simpara>
    PHP 3 unterstÃ¼tzt keine variable Anzahl von Parametern,
    obwohl Vorgabewerte fÃ¼r Parameter unterstÃ¼tzt werden
    (weitere Informationen finden Sie unter
    <link linkend="functions.arguments.default">Vorgabewerte
    fÃ¼r Parameter</link>). Beginnend mit PHP 4 wird beides
    unterstÃ¼tzt.
    Sowohl <link linkend="functions.variable-arg-list">eine
    variable Anzahl Parameter</link> als auch
    <link linkend="functions.arguments.default">Vorgabewerte
    fÃ¼r Parameter</link> werden in Funktionen unterstÃ¼tzt.
    Siehe auch die Funktionsreferenzen fÃ¼r
    <function>func_num_args</function>,
    <function>func_get_arg</function> und
    <function>func_get_args</function> fÃ¼r weitere Informationen.
   </simpara>

   <para>
    Es ist in PHP mÃ¶glich, Funktionen rekursiv aufzurufen.
    Sie sollten aber rekursive Aufrufe mit einer Rekursionstiefe
    von mehr als 100-200 vermeiden, da diese zu einem StackÃ¼berlauf
    und damit zum Programmabbruch fÃ¼hren kÃ¶nnen.
    <example>
     <title>Rekursive Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>

  <sect1 xml:id="functions.arguments">
   <title>Funktionsparameter</title>

   <simpara>
    Mit einer Parameterliste kann man Informationen an eine Funktion
    Ã¼bergeben. Die Parameterliste ist eine durch Kommas getrennte
    Liste von AusdrÃ¼cken.
   </simpara>
   <para>
    PHP unterstÃ¼tzt die Weitergabe von Parametern als Werte (das ist
    der Standard), als <link
    linkend="functions.arguments.by-reference">Verweise</link> und
    als <link linkend="functions.arguments.default">Vorgabewerte</link>.
    <link linkend="functions.variable-arg-list">Eine variable Anzahl
    von Parametern</link> wird ebenfalls unterstÃ¼tzt, siehe auch die
    Funktionsreferenzen fÃ¼r
    <function>func_num_args</function>,
    <function>func_get_arg</function> und
    <function>func_get_args</function> fÃ¼r weitere Informationen.
   </para>

   <para>
    <example>
     <title>Arrays an Funktionen Ã¼bergeben</title>
     <programlisting role="php">
<![CDATA[
<?php
function rechne_array($eingabe)
{
    echo "$eingabe[0] + $eingabe[1] = ", $eingabe[0]+$eingabe[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 xml:id="functions.arguments.by-reference">
    <title>Verweise als Parameter Ã¼bergeben</title>

    <simpara>
     Normalerweise werden den Funktionen Werte als Parameter
     Ã¼bermittelt. Wenn man den Wert dieses Parameters innerhalb der
     Funktion Ã¤ndert, bleibt der Parameter auÃerhalb der Funktion
     unverÃ¤ndert. Wollen Sie aber erreichen, dass die Ãnderung auch auÃerhalb
     der Funktion sichtbar wird, mÃ¼ssen Sie die Parameter als Verweise
     (Referenzen) Ã¼bergeben.
    </simpara>

    <para>
     Wenn eine Funktion einen Parameter generell als Verweis behandeln
     soll, setzt man in der Funktionsdefinition ein kaufmÃ¤nnisches Und
     (&amp;) vor den Parameternamen:
    </para>

    <para>
     <example>
      <title>Ãbergeben von Funktionsparametern als Verweis</title>
      <programlisting role="php">
<![CDATA[
<?php
function fuege_etwas_anderes_an (&$string)
{
    $string .= 'und nun zu etwas anderem.';
}
$str = 'Dies ist ein String, ';
fuege_etwas_anderes_an ($str);
echo $str; // Ausgabe: 'Dies ist ein String, und nun zu etwas anderem.'
?>
]]>
      </programlisting>
     </example>
    </para>

   </sect2>

   <sect2 xml:id="functions.arguments.default">
    <title>Vorgabewerte fÃ¼r Parameter</title>

    <para>
     Eine Funktion kann C++-artige Vorgabewerte fÃ¼r skalare Parameter
     wie folgt definieren:
    </para>

    <para>
     <example>
      <title>Einsatz von Vorgabeparametern</title>
      <programlisting role="php">
<![CDATA[
<?php
function machkaffee ($typ = "Cappucino")
{
    return "Ich mache eine Tasse $typ.\n";
}
echo machkaffee ();
echo machkaffee (null);
echo machkaffee ("Espresso");
?>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     Die Ausgabe von diesem kleinen Skript ist:

     <screen>
Ich mache eine Tasse Cappucino.
Ich mache eine Tasse.
Ich mache eine Tasse Espresso.
     </screen>
    </para>
    <para>
     PHP gestattet es, Arrays und den speziellen Typ &null; als
     Vorgabewert zu nutzen, zum Beispiel:
    </para>
    <para>
     <example>
      <title>Nichtskalare Typen als Vorgabewert</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee ($types = array("cappuccino"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "hands" : $coffeeMaker;
    return "Ich mache eine Tasse ".join(", ", $types)." mit $device.\n";
}
echo makecoffee ();
echo makecoffee (array("cappuccino", "lavazza"), "teapot");
?>
]]>
      </programlisting>
     </example>
    </para>

    <simpara>
     Der Vorgabewert muss ein konstanter Ausdruck sein, darf also zum
     Beispiel keine Variable, Eigenschaft einer Klasse oder ein
     Funktionsaufruf sein.
    </simpara>
    <para>
     Bitte beachten Sie, dass alle Vorgabewerte rechts von den
     Nicht-Vorgabeparametern stehen sollten - sonst wird es nicht
     funktionieren. Betrachten Sie folgendes Beispiel:
    </para>

    <para>
     <example>
      <title>UngÃ¼ltige Anwendung von Vorgabewerten</title>
      <programlisting role="php">
<![CDATA[
<?php
function mach_joghurt ($typ = "rechtsdrehendes", $geschmack)
{
    return "Mache einen Becher $typ $geschmack-joghurt.\n";
}

echo mach_joghurt ("Brombeer");   // arbeitet nicht wie erwartet
?>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     Die Ausgabe dieses Beispiels ist:
    </para>

    <para>
     <screen>
Warning: Missing argument 2 in call to mach_joghurt() in
/usr/local/etc/httpd/htdocs/phptest/functest.html on line 41
Mache einen Becher Brombeer-joghurt.
     </screen>
    </para>

    <para>
     Nun vergleichen Sie bitte oberes Beispiel mit folgendem:
    </para>

    <para>
     <example>
     <title>Richtiger Einsatz von Vorgabewerten</title>
      <programlisting role="php">
<![CDATA[
<?php
function mach_joghurt ($geschmack, $typ = "rechtsdrehendes")
{
    return "Mache einen Becher $typ $geschmack-joghurt.\n";
}

echo mach_joghurt ("Brombeer");   // arbeitet wie erwartet.
?>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     ... und jetzt ist die Ausgabe:

     <screen>
Mache einen Becher rechtsdrehendes Brombeer-Joghurt.
     </screen>
    </para>

    <para>
     Das Setzen von Standardwerten fÃ¼r Argumente, die als Verweis Ã¼bergeben
     werden ("passed by reference") wird seit PHP 5 unterstÃ¼tzt.
    </para>

   </sect2>

   <sect2 xml:id="functions.variable-arg-list">
    <title>Variable Anzahl von Parametern</title>

    <simpara>
     Beginnend mit PHP 4 wird eine variable Anzahl von Parametern in
     benutzerdefinierten Funktionen unterstÃ¼tzt. Das Handling dieser Parameter
     fÃ¤llt mittels der Funktionen <function>func_num_args</function>,
     <function>func_get_arg</function> und
     <function>func_get_args</function> sehr leicht.
    </simpara>

    <simpara>
     Es ist keine spezielle Syntax erforderlich. Die Parameter kÃ¶nnen
     wie gehabt explizit in den Funktionsdeklarationen angegeben
     werden und werden sich wie gewohnt verhalten.
    </simpara>

   </sect2>

  </sect1>

  <sect1 xml:id="functions.returning-values">
   <title>RÃ¼ckgabewerte</title>

   <para>
    Sie kÃ¶nnen Werte mit dem optionalen Befehl "return" zurÃ¼ckgeben.
    Es kÃ¶nnen Variablen jeden Typs zurÃ¼ckgegeben werden, auch Arrays
    oder Objekte. Dies beendet sofort die Funktion und die Kontrolle
    wird wieder an die aufrufende Zeile zurÃ¼ckgegeben. Weitere
    Informationen finden Sie unter <function>return</function>.
   </para>

   <para>
    <example>
     <title>Einsatz von <function>return</function></title>
     <programlisting role="php">
<![CDATA[
<?php
function quadrat ($zahl)
{
    return $zahl * $zahl;
}
echo quadrat (4);   // gibt '16' aus.

?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Es ist nicht mÃ¶glich, mehrere Werte von einer Funktion zurÃ¼ckzugeben.
    Ein Ã¤hnliches Resultat kann man aber durch die RÃ¼ckgabe von Arrays
    erreichen.
   </para>

   <para>
    <example>
    <title>RÃ¼ckgabe mehrere Werte in Arrays</title>
     <programlisting role="php">
<![CDATA[
<?php
function kleine_zahlen()
{
   return array (0, 1, 2);
}
list ($null, $eins, $zwei) = kleine_zahlen();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Um von einer Funktion eine Referenz zurÃ¼ckzugeben, mÃ¼ssen Sie
    den Referenz-Operator &amp; sowohl in der Funktionsdeklaration,
    als auch bei der Zuweisung des zurÃ¼ckgegebenen Wertes verwenden:
   </para>

   <para>
    <example>
     <title>RÃ¼ckgabe von Referenzen</title>
     <programlisting role="php">
<![CDATA[
<?php
function &returniere_referenz()
{
    return $einereferenz;
}

$neuereferenz =& returniere_referenz();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Weitere Informationen Ã¼ber Referenzen finden Sie im Kapitel
    <link linkend="language.references">Referenzen in PHP</link>.
   </simpara>
  </sect1>

  <sect1 xml:id="functions.variable-functions">
   <title>Variablenfunktionen</title>

   <para>
    PHP unterstÃ¼tzt das Konzept der Variablenfunktionen. Wenn Sie an
    das Ende einer Variablen Klammern hÃ¤ngen, versucht PHP eine
    Funktion aufzurufen, deren Name der aktuelle Wert der Variablen
    ist. Dies kann unter anderem fÃ¼r Callbacks, Funktionstabellen,
    usw. genutzt werden.
   </para>
   <para>
    Variablenfunktionen funktionieren nicht mit Sprachkonstrukten
    wie <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function> und
    <function>require</function>. Sie mÃ¼ssen Ihre eigenen Wrapperfunktionen
    verwenden, um diese Konstrukte als variable Funktionen benutzen zu
    kÃ¶nnen.
   </para>
   <para>
    <example>
     <title>Beispiel fÃ¼r Variablenfunktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
    echo "In foo()<br />\n";
}

function bar($arg = '')
{
    echo "In bar(); der Parameter ist '$arg'.<br />\n";
}

// Dies ist eine Wrapperfunkiton fÃ¼r echo
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // Dies ruft foo() auf

$func = 'bar';
$func('test');  // Dies ruft bar() auf

$func = 'echoit';
$func('test');  // Dies ruft echoit() auf
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Sie kÃ¶nnen auch die Methode eines Objektes mittels der variablen
    Funktionen aufrufen.
    <example>
     <title>Variable Methode</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // Dies ruft die Bar() Methode auf
    }

    function Bar()
    {
        echo "Das ist Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();   // Dies ruft $foo->Variable() auf

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Siehe auch
    <function>call_user_func</function>,
    <link linkend="language.variables.variable">Variable Variablen</link> und
    <function>function_exists</function>.
   </para>
  </sect1>

  <sect1 xml:id="functions.internal">
   <title>Interne (eingebaute) Funktionen</title>

   <para>
    PHP enthÃ¤lt standmÃ¤Ãig viele Funktionen und Konstrukte, weiterhin
    gibt es viele Funktionen die vorausssetzen, dass bestimmte PHP-Extensions
    einkompiliert wurden, anderenfalls erhalten Sie beim
    Aufruf "undefined function"-Fehlermeldungen.
    Um z.B. <link linkend="ref.image">Grafik-Funktionen</link> wie
    <function>imagecreatetruecolor</function> zu nutzen, mÃ¼ssen Sie PHP mit
    <productname>GD</productname>-UnterstÃ¼tzung kompilieren, oder um
    <function>mysql_connect</function> zu nutzen, muss Ihr PHP mit <link
    linkend="ref.mysql">MySQL</link>-UnterstÃ¼tzung kompiliert sein.
    Viele Kernfunktionen wie z.B. die <link
    linkend="ref.strings">String</link>- und <link
    linkend="language.variables">Variablen</link>-Funktionen sind bereits in
    jeder PHP-Version enthalten. Ein Aufruf von <function>phpinfo</function>
    oder <function>get_loaded_extensions</function> zeigt Ihnen, welche
    Extensions in Ihrer PHP-Installation verfÃ¼gbar sind.
    Beachten Sie weiterhin, dass viele Extensions bereits standardmÃ¤Ãig
    aktiviert sind und das PHP-Manual nach Extensions unterteilt ist.
    Weitere Informationen zur Einrichtung von PHP finden Sie in den
    Kapiteln <link linkend="configuration">Konfiguration</link>,
    <link linkend="install">Installation</link> und den Kapiteln
    zu den einzelnen Extensions.
   </para>
   <para>
    Wie Funktionsprototypen zu lesen und zu verstehen sind, ist im
    Kapitel '<link linkend="about.prototypes">Wie man eine Funktionsdefinition
    (Prototyp) liest'</link> erklÃ¤rt.
    Es ist wichtig zu erkennen, was eine Funktion zurÃ¼ckgibt und ob
    die Ã¼bergebenen Parameter verÃ¤ndert werden. So gibt z.B.
    <function>str_replace</function> den bearbeiteten String zurÃ¼ck,
    wÃ¤hrend <function>usort</function> direkt auf der Ã¼bergebenen
    Variablen arbeitet.
    Jede Handbuchseite enthÃ¤lt spezifische Informationen fÃ¼r jede
    Funktion wie ihre Parameter, die RÃ¼ckgabewerte sowohl bei Erfolg
    als auch im Fehlerfall, Ãnderungen des Verhaltens und die VerfÃ¼gbarkeit.
    Die Kenntnis dieser wichtigen (und oft subtilen) Unterschiede ist
    von entscheidender Bedeutung fÃ¼r das Schreiben korrekten PHP-Codes.
   </para>
   <note>
    <simpara>
     Wenn Funktionen andere Parameter erhalten als erwartet, d.h. wenn z.B.
     ein <type>array</type> Ã¼bergeben wird obwohl ein <type>string</type>
     erwartet wird, so ist der RÃ¼ckgabewert undefiniert. In solchen FÃ¤llen
     ist es Ã¼blich, dass &null; zurÃ¼ckgegeben wird, dies ist aber nur eine
     Konvention, auf die Sie sich nicht unbedingt verlassen kÃ¶nnen.
    </simpara>
   </note>
   <para>
    Siehe auch <function>function_exists</function>,
    <link linkend="funcref">the function reference</link>,
    <function>get_extension_funcs</function> und
    <function>dl</function>.
   </para>
  </sect1>
 </chapter>

 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
