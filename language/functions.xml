<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 14e006b4eea529ce9c3df9e550b27fb507aaa44c Maintainer: cmb Status: ready -->
<!-- Reviewed: yes -->
<!-- Rev-Revision: b95e76e41de2ffe5c75e04be1b187d80ca745359 Reviewer: samesch -->
<!-- Credits: hholzgra, tom, updated to fix build by theseer -->
 <chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook">
  <title>Funktionen</title>

  <sect1 xml:id="functions.user-defined">
   <title>Benutzerdefinierte Funktionen</title>
   <para>
    Eine Funktion kann wie folgt definiert werden:
   </para>
   <para>
    <example>
     <title>Pseudocode zur Demonstration der Nutzung von Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, ..., $arg_n)
{
    echo "Beispielfunktion.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Jeder beliebige korrekte PHP-Code kann in einer Funktion
    vorkommen, sogar andere Funktionen und
    <link linkend="language.oop5.basic.class">Klassen</link>-Definitionen.
   </simpara>
   <para>
    Für Funktionsnamen gelten in PHP die gleichen Regeln wie für andere
    Bezeichner. Ein gültiger Funktionsname beginnt mit einem Buchstaben oder
    Unterstrich gefolgt von einer beliebigen Anzahl von Buchstaben, Ziffern
    und Unterstrichen. Als regulärer Ausdruck wird dies so ausgedrückt:
    <code>^[a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*$</code>.
   </para>
   &tip.userlandnaming;
   <simpara>
    Es ist nicht erforderlich, dass Funktionen bereits definiert sein müssen,
    wenn auf sie verwiesen wird, <emphasis>außer</emphasis> wenn eine Funktion
    nur bedingt definiert wird, wie in den beiden untenstehenden Beispielen
    gezeigt.
   </simpara>
   <para>
    Wenn eine Funktion nur unter bestimmten Bedingungen definiert wird, wie in
    den beiden folgenden Beispielen, muss die Definition dieser Funktion noch
    <emphasis>vor</emphasis> deren Aufruf abgearbeitet werden.
   </para>
   <para>
    <example>
     <title>Bedingte Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Wir können foo() von hier aus nicht aufrufen, da sie
   noch nicht existiert, aber wir können bar() aufrufen */

bar();

if ($makefoo) {
  function foo()
  {
    echo "Ich existiere nicht, bis mich die Programmausführung erreicht hat.\n";
  }
}

/* Nun können wir foo() sicher aufrufen,
   da $makefoo als true ausgewertet wurde */

if ($makefoo) foo();

function bar()
{
  echo "Ich existiere sofort nach Programmstart.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Funktionen innerhalb von Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
  function bar()
  {
    echo "Ich existiere nicht, bis foo() aufgerufen wurde.\n";
  }
}

/* Wir können bar() noch nicht
   aufrufen, da es nicht existiert */

foo();

/* Nun können wir auch bar() aufrufen, da sie durch die
   Abarbeitung von foo() verfügbar gemacht wurde */

bar();

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Alle Funktionen und Klassen in PHP existieren im globalen Namensraum -
    sie können außerhalb von Funktionen aufgerufen werden, selbst wenn sie
    innerhalb einer Funktion definiert wurden und umgekehrt.
   </para>
   <simpara>
    PHP unterstützt weder das Überladen von Funktionen, noch ist es möglich,
    zuvor deklarierte Funktionen neu zu definieren oder die Definition zu
    löschen.
   </simpara>
   <note>
    <simpara>
     Groß- und Kleinschreibung spielt zwar bei Funktionsnamen keine Rolle für
     die ASCII-Zeichen <literal>A</literal> bis <literal>Z</literal>, es
     empfiehlt sich aber trotzdem, bei Funktionsaufrufen die gleiche
     Schreibweise wie in der Deklaration zu benutzen.
    </simpara>
   </note>
   <simpara>
    Sowohl
    <link linkend="functions.variable-arg-list">eine variable Anzahl Parameter</link>
    als auch
    <link linkend="functions.arguments.default">Vorgabewerte für Parameter</link>
    werden in Funktionen unterstützt. Siehe auch die Funktionsreferenzen für
    <function>func_num_args</function>, <function>func_get_arg</function> und
    <function>func_get_args</function> für weitere Informationen.
   </simpara>
   <para>
    Es ist in PHP möglich, Funktionen rekursiv aufzurufen.
    <example>
     <title>Rekursive Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
     </programlisting>
    </example>
   <note>
    <simpara>
     Rekursive Funktions-/Methodenaufrufe mit einer Tiefe von über 100-200
     können zu einem Stacküberlauf und damit zum Programmabbruch führen.
     Insbesondere wird eine unbegrenzte Rekursion als Programmierfehler
     erachtet.
    </simpara>
   </note>
   </para>
  </sect1>

  <sect1 xml:id="functions.arguments">
   <title>Funktionsparameter</title>
   <simpara>
    Mit einer Parameterliste kann man Informationen an eine Funktion
    übergeben. Die Parameterliste ist eine durch Kommas getrennte Liste von
    Ausdrücken. Die Parameter werden von links nach rechts ausgewertet, bevor
    die eigentliche Funktion aufgerufen wird, d. h. mit der sog.
    <emphasis>eager</emphasis> Evaluation (dt. eifrige Auswertung).
   </simpara>
   <para>
    PHP unterstützt die Weitergabe von Parametern als Werte (das ist der
    Standard), als
    <link linkend="functions.arguments.by-reference">Verweise</link> und als
    <link linkend="functions.arguments.default">Vorgabewerte</link>. Eine
    <link linkend="functions.variable-arg-list">variable Anzahl von Parametern</link>
    und <link linkend="functions.named-arguments">benannte Parameter</link> werden
    ebenfalls unterstützt.
   </para>
   <para>
    <example>
     <title>Arrays an Funktionen übergeben</title>
     <programlisting role="php">
<![CDATA[
<?php
function nimm_array($eingabe)
{
    echo "$eingabe[0] + $eingabe[1] = ", $eingabe[0]+$eingabe[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Seit PHP 8.0.0 kann die Liste der Funktionsparameter ein nachgestelltes
    Komma enthalten, das ignoriert wird. Das ist besonders nützlich in Fällen,
    in denen die Liste der Parameter lang ist oder lange Variablennamen
    enthält, sodass es praktisch ist, die Parameter vertikal aufzulisten.
   </para>
   <example>
    <title>Liste von Funktionsparametern mit nachgestelltem Komma</title>
    <programlisting role="php">
<![CDATA[
<?php
function takes_many_args(
    $first_arg,
    $second_arg,
    $a_very_long_argument_name,
    $arg_with_default = 5,
    $again = 'a default string', // Dieses nachgestellte Komma war vor 8.0.0
                                 // nicht erlaubt.
)
{
    // ...
}
?>
]]>
    </programlisting>
   </example>
   <para>
    Seit PHP 8.0.0 wird die Übergabe von obligatorischen Parametern nach
    optionalen Parametern missbilligt. Dies kann im Allgemeinen durch das
    Weglassen des Standardwertes gelöst werden. Eine Ausnahme von dieser Regel
    sind Parameter der Form <code>Type $param = null</code>, wobei der
    Standardwert &null; den Typ implizit nullbar macht. Diese Verwendung
    bleibt erlaubt, obwohl empfohlen wird, stattdessen einen Typ zu verwenden,
    der explizit nullable ist.
   </para>
   <example>
    <title>Übergabe von optionalen Parametern nach obligatorischen Parametern</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo($a = [], $b) {} // vorher
function foo($a, $b) {}      // nachher

function bar(A $a = null, $b) {} // noch erlaubt
function bar(?A $a, $b) {}       // empfohlen
?>
]]>
    </programlisting>
   </example>

   <sect2 xml:id="functions.arguments.by-reference">
    <title>Parameter als Verweise übergeben</title>

    <simpara>
     Normalerweise werden den Funktionen Werte als Parameter übermittelt. Wenn
     man also den Wert dieser Parameter innerhalb der Funktion ändert, bleiben
     sie außerhalb der Funktion unverändert. Wollen Sie aber erreichen, dass
     die Änderung auch außerhalb der Funktion sichtbar wird, müssen Sie die
     Parameter als Verweise (Referenzen) übergeben.
    </simpara>
    <para>
     Wenn eine Funktion einen Parameter generell als Verweis behandeln soll,
     setzt man in der Funktionsdefinition ein kaufmännisches Und (&amp;) vor
     den Parameternamen:
    </para>
    <para>
     <example>
      <title>Übergeben von Funktionsparametern als Verweis</title>
      <programlisting role="php">
<![CDATA[
<?php
function fuege_etwas_an(&$string)
{
    $string .= 'und etwas mehr.';
}
$str = 'Dies ist ein String, ';
fuege_etwas_an($str);
echo $str; // Ausgabe: 'Dies ist ein String, und etwas mehr.'
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Es ist ein Fehler, einen Wert als Parameter zu übergeben, der eigentlich
     als Referenz übergeben werden müsste.
    </para>
   </sect2>
   <sect2 xml:id="functions.arguments.default">
    <title>Vorgabewerte für Parameter</title>

    <para>
     Eine Funktion kann C++-artige Vorgabewerte für skalare Parameter
     wie folgt definieren:
    </para>
    <para>
     <example>
      <title>Einsatz von Vorgabeparametern in Funktionen</title>
      <programlisting role="php">
<![CDATA[
<?php
function machkaffee($typ = "Cappuccino")
{
    return "Ich mache eine Tasse $typ.\n";
}
echo machkaffee();
echo machkaffee(null);
echo machkaffee("Espresso");
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Ich mache eine Tasse Cappuccino.
Ich mache eine Tasse .
Ich mache eine Tasse Espresso.
]]>
      </screen>
     </example>
    </para>
    <para>
     PHP gestattet es, <type>&array;</type>s und den speziellen Typ &null; als
     Vorgabewert zu nutzen, zum Beispiel:
    </para>
    <para>
     <example>
      <title>Nichtskalare Typen als Vorgabewert</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($types = array("cappuccino"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "hands" : $coffeeMaker;
    return "Ich mache eine Tasse ".join(", ", $types)." mit $device.\n";
}
echo makecoffee();
echo makecoffee(array("cappuccino", "lavazza"), "teapot");
?>
]]>
      </programlisting>
     </example>
    </para>
    <simpara>
     Der Vorgabewert muss ein konstanter Ausdruck sein, darf also zum Beispiel
     keine Variable, keine Eigenschaft einer Klasse und kein Funktionsaufruf
     sein.
    </simpara>
    <para>
     Zu beachten ist, dass alle Parameter mit Vorgabewert rechts von den
     Parametern ohne Vorgabewert stehen müssen - sonst wird es nicht
     funktionieren. Das nachfolgende Beispiel verdeutlicht dies:
    </para>
    <para>
     <example>
      <title>Ungültige Verwendung von Vorgabewerten</title>
      <programlisting role="php">
<![CDATA[
<?php
function mach_joghurt($typ = "rechtsdrehendes", $geschmack)
{
    return "Mache einen Becher $typ $geschmack-joghurt.\n";
}

echo mach_joghurt("Brombeer");   // funktioniert nicht wie erwartet
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Warning: Missing argument 2 in call to mach_joghurt() in
/usr/local/etc/httpd/htdocs/phptest/functest.html on line 41
Mache einen Becher Brombeer -joghurt.
]]>
      </screen>
     </example>
    </para>
    <para>
     Zum Vergleich mit obigem Beispiel::
    </para>
    <para>
     <example>
     <title>Richtiger Einsatz von Vorgabewerten</title>
      <programlisting role="php">
<![CDATA[
<?php
function mach_joghurt($geschmack, $typ = "rechtsdrehendes")
{
    return "Mache einen Becher $typ $geschmack-Joghurt.\n";
}

echo mach_joghurt("Brombeer");   // funktioniert wie erwartet.
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Mache einen Becher rechtsdrehendes Brombeer-Joghurt.
]]>
      </screen>
     </example>
    </para>
    <note>
     <simpara>
      Parameter, die per Verweis übergeben werden, dürfen einen Standardwert
      haben.
     </simpara>
    </note>
   </sect2>

   <sect2 xml:id="functions.variable-arg-list">
    <title>Variable Anzahl von Parametern</title>
    <simpara>
     PHP unterstützt eine variable Anzahl an Parametern in benutzerdefinierten
     Funktionen durch Verwendung des <literal>...</literal>-Tokens.
    </simpara>
    <note>
     <simpara>
      Es ist außerdem möglich eine variable Anzahl an Parametern durch
      Verwendung von <function>func_num_args</function>,
      <function>func_get_arg</function>, und
      <function>func_get_args</function> zu realisieren. Diese Technik wird
      nicht empfohlen, da sie vor der Einführung des
      <literal>...</literal>-Tokens verwendet wurde.
     </simpara>
    </note>
    <para>
     Eine Liste von Parametern kann das Token <literal>...</literal>
     enthalten, um anzugeben, dass die Funktion eine variable Anzahl von
     Parametern akzeptiert. Die zusätzlichen Werte werden als Array an die
     entsprechende Variable übergeben. Zum Beispiel:
     <example>
      <title>Verwendung von <literal>...</literal> für den Zugriff auf variable Parameter</title>
      <programlisting role="php">
<![CDATA[
<?php
function sum(...$numbers) {
    $acc = 0;
    foreach ($numbers as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
10
]]>
      </screen>
     </example>
    </para>
    <para>
     Das Token <literal>...</literal> kann auch dazu verwendet werden, um ein
     <type>&array;</type> oder ein <classname>Traversable</classname>-Objekt als
     Liste von Parametern zu übergeben:
     <example>
      <title>Verwendung von <literal>...</literal> zur Übergabe einer Parameterliste</title>
      <programlisting role="php">
<![CDATA[
<?php
function add($a, $b) {
    return $a + $b;
}

echo add(...[1, 2])."\n";

$a = [1, 2];
echo add(...$a);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
3
3
]]>
      </screen>
     </example>
    </para>
    <para>
     Die Definition von regulären, positionierten Parametern vor dem
     <literal>...</literal> ist natürlich weiterhin möglich. In einem solchen
     Fall werden dann nur die zusätzlichen Werte, die zu keinem positionierten
     Parameter gehören, in das durch <literal>...</literal> erzeugte Array
     übernommen.
    </para>
    <para>
     Es ist zudem auch möglich, dem <literal>...</literal>-Token eine
     <link linkend="language.types.declarations">Typdeklaration</link>
     voranzustellen. Ist dies der Fall, dann müssen alle Parameter, die von
     <literal>...</literal> erfasst werden, vom entsprechenden Typ sein.
     <example>
      <title>Variable Parameter mit Typdeklaration</title>
      <programlisting role="php">
<![CDATA[
<?php
function total_intervals($unit, DateInterval ...$intervals) {
    $time = 0;
    foreach ($intervals as $interval) {
        $time += $interval->$unit;
    }
    return $time;
}

$a = new DateInterval('P1D');
$b = new DateInterval('P2D');
echo total_intervals('d', $a, $b).' days';

// Dieser Aufruf wird scheitern, da null keine Instanz von DateInterval ist
echo total_intervals('d', null);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
3 days
Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2
]]>
      </screen>
     </example>
    </para>
    <para>
     Durch ein voran gestelltes <literal>&amp;</literal> ist auch die Übergabe
     von variablen Parametern
     <link linkend="functions.arguments.by-reference">als Referenz</link>
     möglich.
    </para>

    <sect3 xml:id="functions.variable-arg-list.old">
     <title>Ältere Versionen von PHP</title>
     <para>
      Eine spezielle Syntax ist zur Definition von variablen Parametern nicht
      notwendig. Allerdings müssen die Funktionen
      <function>func_num_args</function>, <function>func_get_arg</function>
      und <function>func_get_args</function> verwendet werden, um auf die
      übergebenen Werte zugreifen zu können.
     </para>
     <para>
      Das erste Beispiel von weiter oben würde in alten PHP-Versionen so
      umgesetzt werden können:
      <example>
       <title>Zugriff auf variable Parameter in alten PHP-Versionen</title>
       <programlisting role="php">
<![CDATA[
<?php
function sum() {
    $acc = 0;
    foreach (func_get_args() as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
10
]]>
       </screen>
      </example>
     </para>
    </sect3>
   </sect2>

   <sect2 xml:id="functions.named-arguments">
    <title>Benannte Parameter</title>
    <para>
     PHP 8.0.0 führt benannte Parameter als eine Erweiterung der bestehenden
     Positionsparameter ein. Benannte Parameter ermöglichen die Übergabe von
     Parametern an eine Funktion basierend auf dem Parameternamen und nicht
     auf der Position des Parameters. Das macht die Bedeutung von Parametern
     selbsterklärend, macht die Parameter unabhängig von der Reihenfolge und
     ermöglicht das willkürliche Überspringen von Standardwerten.
    </para>
    <para>
     Benannte Parameter werden übergeben, indem dem Wert der Parametername
     gefolgt von einem Doppelpunkt vorangestellt wird. Reservierte
     Schlüsselwörter dürfen als Parameternamen verwendet werden. Der
     Parametername muss ein Bezeichner sein; eine dynamische Angabe ist nicht
     erlaubt.
    </para>
    <example>
     <title>Syntax benannter Parameter</title>
     <programlisting role="php">
      <![CDATA[
<?php
myFunction(paramName: $value);
array_foobar(array: $value);

// Wird NICHT unterstützt
function_name($variableStoringParamName: $value);
?>
]]>
     </programlisting>
    </example>
    <example>
     <title>Positionsparameter im Vergleich zu benannten Parametern</title>
     <programlisting role="php">
      <![CDATA[
<?php
// Verwendung von Positionsparametern:
array_fill(0, 100, 50);

// Verwendung von benannten Parametern:
array_fill(start_index: 0, count: 100, value: 50);
?>
]]>
     </programlisting>
    </example>
    <para>
     Die Reihenfolge, in der die benannten Parameter übergeben werden, spielt
     keine Rolle.
    </para>
    <example>
     <title>Das gleiche Beispiel wie oben mit einer anderen Reihenfolge der Parameter</title>
     <programlisting role="php">
      <![CDATA[
<?php
array_fill(value: 50, count: 100, start_index: 0);
?>
]]>
     </programlisting>
    </example>
    <para>
     Benannte Parameter können mit Positionsparametern kombiniert werden. In
     diesem Fall müssen die benannten Parameter nach den Positionsparametern
     kommen. Es ist auch möglich, nur einige der optionalen Parameter einer
     Funktion anzugeben, unabhängig von ihrer Reihenfolge.
    </para>
    <example>
     <title>Kombinieren von benannten Parametern mit Positionsparametern</title>
     <programlisting role="php">
      <![CDATA[
<?php
htmlspecialchars($string, double_encode: false);
// Ist das Gleiche wie
htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML401, 'UTF-8', false);
?>
]]>
     </programlisting>
    </example>
    <para>
     Die mehrfache Übergabe desselben Parameters führt zu einer Error-Exception.
    </para>
    <example>
     <title>Error-Exception bei mehrfacher Übergabe desselben Parameters</title>
     <programlisting role="php">
      <![CDATA[
<?php
function foo($param) { ... }

foo(param: 1, param: 2);
// Error: Named parameter $param overwrites previous argument
foo(1, param: 2);
// Error: Named parameter $param overwrites previous argument
?>
]]>
     </programlisting>
    </example>

   </sect2>
  </sect1>

  <sect1 xml:id="functions.returning-values">
   <title>Rückgabewerte</title>
   <para>
    Werte können mit der optionalen return-Anweisung zurückgegeben werden. Es
    können Variablen jeden Typs zurückgegeben werden, auch Arrays oder
    Objekte. Dies beendet die Funktion sofort und die Kontrolle wird wieder an
    die aufrufende Zeile zurückgegeben. Für weitere Informationen siehe
    <function>return</function>.
   </para>
   <note>
    <para>
     Wird <function>return</function> weggelassen, dann wird der Wert &null;
     zurückgegeben.
    </para>
   </note>

   <sect2>
    <title>Einsatz von return</title>
    <para>
     <example>
      <title>Einsatz von <function>return</function></title>
      <programlisting role="php">
<![CDATA[
<?php
function quadrat($zahl)
{
    return $zahl * $zahl;
}
echo quadrat(4);   // gibt '16' aus.

?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Es ist nicht möglich, mehrere Werte von einer Funktion zurückzugeben. Ein
     ähnliches Resultat kann man aber durch die Rückgabe eines Arrays
     erreichen.
    </para>
    <para>
     <example>
      <title>Rückgabe mehrerer Werte als Array</title>
      <programlisting role="php">
<![CDATA[
<?php
function kleine_zahlen()
{
   return [0, 1, 2];
}
// Bei der Umstrukturierung von Arrays wird jedes Element des Arrays
// einzeln erfasst.
[$null, $eins, $zwei] = kleine_zahlen();

// Vor 7.1.0 ist die einzige gleichwertige Alternative die Verwendung
// des list()-Konstrukts
list($null, $eins, $zwei) = kleine_zahlen();

?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Um aus einer Funktion eine Referenz zurückzugeben, muss der
     Referenz-Operator &amp; sowohl in der Funktionsdeklaration, als auch bei
     der Zuweisung des zurückgegebenen Wertes verwendet werden:
    </para>
    <para>
     <example>
      <title>Rückgabe von Referenzen aus Funktionen</title>
      <programlisting role="php">
<![CDATA[
<?php
function &returniere_referenz()
{
    return $einereferenz;
}

$neuereferenz =& returniere_referenz();
?>
]]>
      </programlisting>
     </example>
    </para>
    <simpara>
     Weitere Informationen über Referenzen sind im Kapitel
     <link linkend="language.references">Referenzen in PHP</link> zu finden.
    </simpara>
   </sect2>
  </sect1>

  <sect1 xml:id="functions.variable-functions">
   <title>Variablenfunktionen</title>
   <para>
    PHP unterstützt das Konzept der Variablenfunktionen. Wenn Sie an das Ende
    einer Variablen Klammern hängen, versucht PHP eine Funktion aufzurufen,
    deren Name der aktuelle Wert der Variablen ist. Dies kann unter anderem
    für Callbacks, Funktionstabellen usw. genutzt werden.
   </para>
   <para>
    Variablenfunktionen funktionieren nicht mit Sprachkonstrukten wie
    <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function> und
    <function>require</function>. Um diese Konstrukte als Variablenfunktionen
    benutzen zu können, müssen Sie Ihre eigenen Wrapperfunktionen verwenden.
   </para>
   <para>
    <example>
     <title>Beispiel für Variablenfunktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "In foo()<br />\n";
}

function bar($arg = '')
{
    echo "In bar(); der Parameter ist '$arg'.<br />\n";
}

// Dies ist eine Wrapperfunktion für echo
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // Dies ruft foo() auf

$func = 'bar';
$func('test');  // Dies ruft bar() auf

$func = 'echoit';
$func('test');  // Dies ruft echoit() auf
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Sie können auch die Methode eines Objektes mittels der Variablenfunktionen
    aufrufen.
    <example>
     <title>Beispiel für eine Variablenmethode</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // Dies ruft die Methode Bar() auf
    }

    function Bar()
    {
        echo "Das ist Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();  // Dies ruft $foo->Variable() auf

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Werden statische Methoden aufgerufen, ist der Funktionsaufruf stärker als
    der statische Eigenschaftsoperator:
    <example>
     <title>Beispiel für Variablenmethoden mit statischen Eigenschaften</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static $variable = 'statische Eigenschaft';
    static function Variable()
    {
        echo 'Method Variable called';
    }
}

echo Foo::$variable; // Dies gibt 'statische Eigenschaft' aus. Es bräuchte
                     // eine $variable im aktuellen Geltungsbereich.
$variable = "Variable";
Foo::$variable();  // Dies ruft $foo->Variable() auf, da $variable im
                   // aktuellen Geltungsbereich vorliegt.

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Komplexe Callables</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static function bar()
    {
        echo "bar\n";
    }
    function baz()
    {
        echo "baz\n";
    }
}

$func = array("Foo", "bar");
$func(); // gibt "bar" aus
$func = array(new Foo, "baz");
$func(); // gibt "baz" aus
$func = "Foo::bar";
$func(); // gibt "bar" aus
?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>is_callable</function></member>
      <member><function>call_user_func</function></member>
      <member><function>function_exists</function></member>
      <member><link linkend="language.variables.variable">Variable Variablen</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="functions.internal">
   <title>Interne (eingebaute) Funktionen</title>
   <para>
    PHP enthält standardmäßig viele Funktionen und Konstrukte. Außerdem gibt
    es viele Funktionen die voraussetzen, dass bestimmte PHP-Erweiterungen
    einkompiliert wurden, andernfalls erhalten Sie beim Aufruf "undefined
    function"-Fehlermeldungen. Um z. B.
    <link linkend="ref.image">Grafik-Funktionen</link> wie
    <function>imagecreatetruecolor</function> nutzen zu können, müssen Sie PHP
    mit <productname>GD</productname>-Unterstützung kompilieren, oder um
    <function>mysqli_connect</function> nutzen zu können, muss Ihr PHP mit
    <link linkend="book.mysqli">MySQLi</link>-Unterstützung kompiliert sein.
    Viele Kernfunktionen, z. B. die
    <link linkend="ref.strings">String</link>- und
    <link linkend="ref.var">Variablen</link>-Funktionen sind bereits in jeder
    PHP-Version enthalten. Ein Aufruf von <function>phpinfo</function> oder
    <function>get_loaded_extensions</function> zeigt Ihnen, welche
    Erweiterungen in Ihrer PHP-Installation verfügbar sind. Beachten Sie
    außerdem, dass viele Erweiterungen bereits standardmäßig aktiviert sind
    und das PHP-Handbuch nach Erweiterungen unterteilt ist. Weitere
    Informationen zur Einrichtung von PHP finden Sie in den Kapiteln
    <link linkend="configuration">Konfiguration</link>,
    <link linkend="install">Installation</link> und den Kapiteln zu den
    einzelnen Erweiterungen.
   </para>
   <para>
    Wie Funktionsprototypen zu lesen und zu verstehen sind, wird im Kapitel
    <link linkend="about.prototypes">Wie man eine Funktionsdefinition (Prototyp) liest</link>
    erklärt. Es ist wichtig zu erkennen, was eine Funktion zurückgibt und ob
    die übergebenen Parameter verändert werden. So gibt z. B.
    <function>str_replace</function> den bearbeiteten String zurück, während
    <function>usort</function> die übergebene Variable direkt bearbeitet. Jede
    Handbuchseite enthält auch spezifische Informationen zu jeder Funktion, wie
    Informationen über ihre Parameter, die Rückgabewerte sowohl bei Erfolg als
    auch im Fehlerfall, Änderungen des Verhaltens und die Verfügbarkeit. Die
    Kenntnis dieser wichtigen (aber oft subtilen) Unterschiede ist von
    entscheidender Bedeutung für das Schreiben korrekten PHP-Codes.
   </para>
   <note>
    <simpara>
     Wenn Funktionen andere Parameter erhalten als erwartet, d. h. wenn z. B.
     ein <type>&array;</type> übergeben wird, obwohl ein <type>&string;</type>
     erwartet wird, so ist der Rückgabewert undefiniert. In solchen Fällen ist
     es üblich, dass &null; zurückgegeben wird. Dies ist aber nur eine
     Konvention, auf die Sie sich nicht unbedingt verlassen können. Seit
     PHP 8.0.0 sollte in diesem Fall eine
     <classname>TypeError</classname>-Exception ausgelöst werden.

    </simpara>
   </note>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>function_exists</function></member>
      <member><link linkend="funcref">die Funktionsreferenz</link></member>
      <member><function>get_extension_funcs</function></member>
      <member><function>dl</function></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="functions.anonymous">
   <title>Anonyme Funktionen</title>
   <simpara>
    Anonyme Funktionen, auch bekannt als  <literal>Closures</literal>,
    ermöglichen es, Funktionen ohne Funktionsnamen zu schreiben. Sie sind am
    nützlichsten als Werte von <type>callable</type>-Parametern, haben aber
    noch viele andere Verwendungsmöglichkeiten.
   </simpara>
   <simpara>
    Anonyme Funktionen werden unter Verwendung der Klasse
    <link linkend="class.closure"><classname>Closure</classname></link>
    implementiert.
   </simpara>
   <example>
    <title>Beispiel für eine anonyme Funktion</title>
    <programlisting role="php">
<![CDATA[
<?php
echo preg_replace_callback('~-([a-z])~', function ($match) {
    return strtoupper($match[1]);
}, 'hallo-welt');
// gibt halloWelt aus
?>
]]>
    </programlisting>
   </example>
   <simpara>
    Closures können auch als Werte von Variablen verwendet werden; PHP
    konvertiert solche Ausdrücke automatisch in Instanzen der internen Klasse
    <classname>Closure</classname>. Die Zuweisung einer Closure an eine
    Variable verwendet die selbe Syntax wie andere Zuweisungen, einschließlich
    des abschließenden Semikolons:
   </simpara>
   <example>
    <title>Beispiel für die Zuweisung einer anonymen Funktion</title>
    <programlisting role="php">
<![CDATA[
<?php
$greet = function($name)
{
    printf("Hallo %s\r\n", $name);
};

$greet('Welt');
$greet('PHP');
?>
]]>
    </programlisting>
   </example>
   <simpara>
    Closures können auch Variablen aus dem Eltern-Gültigkeitsbereich erben.
    Jede solche Variable muss an das <literal>use</literal>-Sprachkonstrukt
    übergeben werden. Von PHP 7.1 an dürfen diese Variablen keine
    &link.superglobals;, <varname>$this</varname> oder Variablen mit dem
    gleichen Name wie ein Parameter sein. Die Deklaration des Rückgabetyps der
    Funktion muss <emphasis>nach</emphasis> der <literal>use</literal>-Klausel
    erfolgen.
   </simpara>
   <example>
    <title>Erben von Variablen aus dem Eltern-Gültigkeitsbereich</title>
    <programlisting role="php">
<![CDATA[
<?php
$message = 'hallo';

// Kein "use"
$example = function () {
    var_dump($message);
};
$example();

// $message vererben
$example = function () use ($message) {
    var_dump($message);
};
$example();

// Der Wert einer geerbten Variable ist der Wert zum Zeitpunkt
// der Funktionsdefinition, nicht des Funktionsaufrufs
$message = 'welt';
$example();

// $message wiederherstellen
$message = 'hallo';

// Vererben per Referenz
$example = function () use (&$message) {
    var_dump($message);
};
$example();

// Der geänderte Wert im Eltern-Gültigkeitsbereich
// wird in der aufgerufenen Funktion übernommen
$message = 'welt';
$example();

// Closures können auch reguläre Parameter akzeptieren
$example = function ($arg) use ($message) {
    var_dump($arg . ' ' . $message);
};
$example("hallo");

// Die Deklaration des Rückgabetyps erfolgt nach der use-Klausel
$example = function () use ($message): string {
    return "hallo $message";
};
var_dump($example());
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
Notice: Undefined variable: message in /example.php on line 10
NULL
string(5) "hallo"
string(5) "hallo"
string(5) "hallo"
string(4) "welt"
string(10) "hallo welt"
string(10) "hallo welt"
]]>
    </screen>
   </example>
   <para>
    Seit PHP 8.0.0 darf die Liste der geerbten Variablen ein nachgestelltes
    Komma enthalten, das ignoriert wird.
   </para>
   <simpara>
    Das Erben von Variablen aus dem Eltern-Gültigkeitsbereich ist
    <emphasis>nicht</emphasis> das gleiche wie die Verwendung von globalen
    Variablen. Globale Variablen existieren im globalen Gültigkeitsbereich,
    der immer der gleiche ist, unabhängig davon, welche Funktion ausgeführt
    wird. Der Eltern-Gültigkeitsbereich einer Closure ist die Funktion, in der
    die Closure deklariert wurde (nicht notwendigerweise die Funktion, aus der
    sie aufgerufen wurde). Betrachten Sie das folgende Beispiel:
   </simpara>
   <example>
    <title>Closures und Gültigkeitsbereiche</title>
    <programlisting role="php">
<![CDATA[
<?php
// Ein einfacher Einkaufswagen, der eine Liste von hinzugefügten Produkten
// und die Menge jedes Produkts enthält. Er enthält eine Methode, die den
// Gesamtpreis der Waren im Einkaufswagen unter Verwendung einer Closure
// als Callback berechnet.
class Einkaufswagen
{
    const PREIS_BUTTER  = 1.00;
    const PREIS_MILCH    = 3.00;
    const PREIS_EIER    = 6.95;

    protected $produkte = array();

    public function addiere($produkt, $menge)
    {
        $this->produkte[$produkt] = $menge;
    }

    public function ermittleMenge($produkt)
    {
        return isset($this->produkte[$produkt]) ? $this->produkte[$produkt] :
               FALSE;
    }

    public function ermittleGesamt($steuer)
    {
        $gesamt = 0.00;

        $callback =
            function ($menge, $produkt) use ($steuer, &$gesamt)
            {
                $preisProStueck = constant(__CLASS__ . "::PREIS_" .
                    strtoupper($produkt));
                $gesamt += ($preisProStueck * $menge) * ($steuer + 1.0);
            };

        array_walk($this->produkte, $callback);
        return round($gesamt, 2);
    }
}

$mein_einkaufswagen = new Einkaufswagen;

// Lege ein paar Waren in den Einkaufskorb
$mein_einkaufswagen->addiere('butter', 1);
$mein_einkaufswagen->addiere('milch', 3);
$mein_einkaufswagen->addiere('eier', 6);

// Gib die Gesamtsumme mit einer Mehrwertsteuer von 5% aus
print $mein_einkaufswagen->ermittleGesamt(0.05) . "\n";
// Das Ergebnis ist 54.29
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>Automatisches Binden von <literal>$this</literal></title>
    <programlisting role="php">
<![CDATA[
<?php

class Test
{
    public function testing()
    {
        return function() {
            var_dump($this);
        };
    }
}

$object = new Test;
$function = $object->testing();
$function();

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
object(Test)#1 (0) {
}
]]>
    </screen>
   </example>
   <para>
    Wird eine anonyme Funktion im Kontext einer Klasse deklariert, so wird
    diese Klasse automatisch an jene gebunden, was <literal>$this</literal>
    innerhalb des Geltungsbereichs verfügbar macht. Ist diese automatische
    Bindung der aktuellen Klasse nicht erwünscht, dann können stattdessen
    <link linkend="functions.anonymous-functions.static">statische anonyme Funktionen</link>
    verwendet werden.
   </para>

   <sect2 xml:id="functions.anonymous-functions.static">
    <title>Statische anonyme Funktionen</title>
    <para>
     Anonyme Funktionen können statisch deklariert werden. Dies verhindert,
     dass die aktuelle Klasse automatisch an sie gebunden wird. Objekte können
     zur Laufzeit ebenfalls nicht an sie gebunden werden.
    </para>
    <para>
     <example>
      <title>Versuch der Verwendung von <literal>$this</literal> innerhalb einer statischen anonymen Funktion</title>
      <programlisting role="php">
<![CDATA[
<?php

class Foo
{
    function __construct()
    {
        $func = static function() {
            var_dump($this);
        };
        $func();
    }
};
new Foo();

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Notice: Undefined variable: this in %s on line %d
NULL
]]>
      </screen>
     </example>
    </para>
    <para>
     <example>
      <title>Versuch, ein Objekt an eine statische anonyme Funktion zu binden</title>
      <programlisting role="php">
<![CDATA[
<?php

$func = static function() {
    // function body
};
$func = $func->bindTo(new StdClass);
$func();

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Warning: Cannot bind an instance to a static closure in %s on line %d
]]>
      </screen>
     </example>
    </para>
   </sect2>

   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>7.1.0</entry>
         <entry>
          Anonyme Funktionen dürfen &link.superglobals;,
          <varname>$this</varname> und alle Variablen mit dem gleichen Namen
          wie Parameter nicht als freie Variablen verwenden.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>

   <sect2 role="notes">
    &reftitle.notes;
    <note>
     <simpara>
      Es ist möglich, <function>func_num_args</function>,
      <function>func_get_arg</function> und <function>func_get_args</function>
      innerhalb einer Closure zu verwenden.
     </simpara>
    </note>
   </sect2>

  </sect1>

  <sect1 xml:id="functions.arrow">
   <title>Pfeilfunktionen</title>
   <simpara>
    Pfeilfunktionen wurden in PHP 7.4 als prägnantere Syntax für
    <link linkend="functions.anonymous">anonyme Funktionen</link> eingeführt.
   </simpara>
   <simpara>
    Sowohl anonyme Funktionen als auch Pfeilfunktionen sind unter Verwendung der
    <link linkend="class.closure"><classname>Closure</classname></link>-Klasse
    implementiert.
   </simpara>
   <simpara>
    Pfeilfunktionen haben die grundsätzliche Form
    <code>fn (argument_list) =&gt; expr</code>.
   </simpara>
   <simpara>
    Pfeilfunktionen unterstützen dieselbe Funktionalität wie
    <link linkend="functions.anonymous">anonyme Funktionen</link>,
    außer, dass die Verwendung von Variablen des Eltern-Gültigkeitsbereichs
    immer automatisch erfolgt.
   </simpara>
   <simpara>
    Wenn eine Variable, die im Ausdruck verwendet wird, im
    Eltern-Gültigkeitsbereich definiert ist, wird sie implizit per Wertübergabe
    gebunden. Im folgenden Beispiel verhalten sich die Funktionen
    <varname>$fn1</varname> und <varname>$fn2</varname> auf die gleiche Weise.
   </simpara>
   <para>
    <example>
     <title>Pfeilfunktionen binden Variablen automatisch per Wertübergabe</title>
     <programlisting role="php">
<![CDATA[
<?php

$y = 1;

$fn1 = fn($x) => $x + $y;
// gleichwertig zur Verwendung von $y per Wertübergabe:
$fn2 = function ($x) use ($y) {
    return $x + $y;
};

var_export($fn1(3));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
4
]]>
      </screen>
    </example>
   </para>
   <simpara>
    Dies funktioniert auch, wenn Pfeilfunktionen verschachtelt werden:
   </simpara>
   <para>
    <example>
     <title>Pfeilfunktionen binden Variablen automatisch per Wertübergabe, selbst wenn sie verschachtelt sind</title>
     <programlisting role="php">
<![CDATA[
<?php

$z = 1;
$fn = fn($x) => fn($y) => $x * $y + $z;
// gibt 51 aus
var_export($fn(5)(10));
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Ähnlich wie bei anonymen Funktion erlaubt die Pfeilfunktionssyntax
    beliebige Funktionssignaturen, einschließlich Parameter- und
    Rückgabetypen, Defaultwerte, variadische Parameter sowie Referenzübergabe
    und -rückgabe. Alle folgenden sind gültige Beispiele von Pfeilfunktionen:
   </simpara>
   <para>
    <example>
     <title>Beispiele von Pfeilfunktionen</title>
     <programlisting role="php">
<![CDATA[
<?php

fn(array $x) => $x;
static fn(): int => $x;
fn($x = 42) => $x;
fn(&$x) => $x;
fn&($x) => $x;
fn($x, ...$rest) => $rest;

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Pfeilfunktionen verwenden die Wertübergabe-Bindung. Dies entspricht in
    etwa der Verwendung von <code>use($x)</code> für jede Variable
    <varname>$x</varname>, die in der Pfeilfunktion verwendet wird.
    Wertübergabe-Bindung bedeutet, dass es nicht möglich ist, Werte aus dem
    äußeren Geltungsbereich zu ändern.
    <link linkend="functions.anonymous">Anonyme Funktionen</link> können statt
    dessen für Referenzübergabe-Bindungen verwendet werden.
   </simpara>
   <para>
    <example>
     <title>Werte aus dem äußeren Geltungsbereich können nicht durch Pfeilfunktionen geändert werden</title>
     <programlisting role="php">
<![CDATA[
<?php

$x = 1;
$fn = fn() => $x++; // hat keine Wirkung
$fn();
var_export($x);  // gibt 1 aus

?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>7.4.0</entry>
         <entry>
          Pfeilfunktionen sind verfügbar.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>

   <sect2 role="notes">
    &reftitle.notes;
    <note>
     <simpara>
      Es ist möglich <function>func_num_args</function>,
      <function>func_get_arg</function> und <function>func_get_args</function>
      innerhalb einer Pfeilfunktion zu verwenden.
     </simpara>
    </note>
   </sect2>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
