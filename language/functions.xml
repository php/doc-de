<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: e296d2443b197fce63a9752dc6d58c0fdcf0c5cc Maintainer: cmb Status: in progress -->
<!-- Credits: hholzgra, tom, updated to fix build by theseer -->
<!-- r351733 and r351885 have not been translated -->

 <chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook">
  <title>Funktionen</title>

  <sect1 xml:id="functions.user-defined">
   <title>Benutzerdefinierte Funktionen</title>

   <para>
    Eine Funktion kann wie folgt definiert werden:
   </para>

   <para>
    <example>
     <title>Pseudocode zur Demonstration der Nutzung von Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, ..., $arg_n)
{
    echo "Beispielfunktion.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <simpara>
    Jeder beliebige korrekte PHP-Code kann in einer Funktion
    vorkommen, sogar andere Funktionen und <link
    linkend="language.oop5.basic.class">Klassen</link>-Definitionen.
   </simpara>
   <para>
    Für Funktionsnamen gelten in PHP die gleichen Regeln wie für
    andere Bezeichner. Ein gültiger Funktionsname beginnt mit
    einem Buchstaben oder Unterstrich gefolgt von einer beliebigen
    Anzahl von Buchstaben, Ziffern und Unterstrichen. Als
    regulärer Ausdruck wird dies so ausgedrückt:
    <code>^[a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*$</code>.
   </para>
   &tip.userlandnaming;
   <simpara>
    Es ist nicht erforderlich, dass Funktionen bereits definiert sein
    müssen, wenn auf sie verwiesen wird,
    <emphasis>außer</emphasis> wenn eine Funktion nur bedingt definiert
    wird, wie in den beiden untenstehenden Beispielen gezeigt.
   </simpara>
   <para>
    Wenn eine Funktion nur unter bestimmten Bedingungen definiert wird,
    wie in den beiden folgenden Beispielen,
    muss die Definition dieser Funktion noch <emphasis>vor</emphasis>
    deren Aufruf abgearbeitet werden.
   </para>
   <para>
    <example>
     <title>Bedingte Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Wir können foo() von hier aus nicht
   aufrufen, da sie noch nicht existiert,
   aber wir können bar() aufrufen */

bar();

if ($makefoo) {
  function foo ()
  {
    echo "Ich existiere nicht, bis mich die Programmausführung erreicht hat.\n";
  }
}

/* Nun können wir foo() sicher aufrufen,
   da $makefoo als true ausgewertet wurde */

if ($makefoo) foo();

function bar()
{
  echo "Ich existiere sofort nach Programmstart.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Funktionen innerhalb von Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
  function bar()
  {
    echo "Ich existiere nicht, bis foo() aufgerufen wurde.\n";
  }
}

/* Wir können bar() noch nicht
   aufrufen, da es nicht existiert */

foo();

/* Nun können wir auch bar() aufrufen,
   da sie durch die Abarbeitung von
   foo() verfügbar gemacht wurde */

bar();

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Alle Funktionen und Klassen in PHP existieren im globalen Namensraum -
    sie können außerhalb von Funktionen aufgerufen werden, selbst wenn sie
    innerhalb einer Funktion definiert wurden und umgekehrt.
   </para>
   <simpara>
    PHP unterstützt weder das Überladen von Funktionen, noch ist es
    möglich, zuvor deklarierte Funktionen neu zu definieren oder die
    Definition zu löschen.
   </simpara>
   <note>
    <simpara>
     Groß- und Kleinschreibung spielt zwar bei Funktionsnamen keine
     Rolle für die ASCII-Zeichen <literal>A</literal> bis <literal>Z</literal>,
     es empfiehlt sich aber trotzdem bei Funktionsaufrufen
     die gleiche Schreibweise wie in der Deklaration zu benutzen.
    </simpara>
   </note>
   <simpara>
    Sowohl <link linkend="functions.variable-arg-list">eine
    variable Anzahl Parameter</link> als auch
    <link linkend="functions.arguments.default">Vorgabewerte
    für Parameter</link> werden in Funktionen unterstützt.
    Siehe auch die Funktionsreferenzen für
    <function>func_num_args</function>,
    <function>func_get_arg</function> und
    <function>func_get_args</function> für weitere Informationen.
   </simpara>

   <para>
    Es ist in PHP möglich, Funktionen rekursiv aufzurufen.
    <example>
     <title>Rekursive Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
     </programlisting>
    </example>
   <note>
    <simpara>
     Rekursive Funktions-/Methodenaufrufe mit einer Tiefe von über 100-200
     können zu einem Stacküberlauf und damit zum Programmabbruch führen.
     Besonders unbegrenzte Rekursion wird als Programmierfehler erachtet.
    </simpara>
   </note>
   </para>
  </sect1>

  <sect1 xml:id="functions.arguments">
   <title>Funktionsparameter</title>

   <simpara>
    Mit einer Parameterliste kann man Informationen an eine Funktion
    übergeben. Die Parameterliste ist eine durch Kommas getrennte
    Liste von Ausdrücken. 
    Die Parameter werden von links nach rechts ausgewertet.
   </simpara>
   <para>
    PHP unterstützt die Weitergabe von Parametern als Werte (das ist
    der Standard), als <link
    linkend="functions.arguments.by-reference">Verweise</link> und
    als <link linkend="functions.arguments.default">Vorgabewerte</link>.
    <link linkend="functions.variable-arg-list">Eine variable Anzahl
    von Parametern</link> wird ebenfalls unterstützt.
   </para>

   <para>
    <example>
     <title>Arrays an Funktionen übergeben</title>
     <programlisting role="php">
<![CDATA[
<?php
function nimm_array($eingabe)
{
    echo "$eingabe[0] + $eingabe[1] = ", $eingabe[0]+$eingabe[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    As of PHP 8.0.0, the list of function arguments may include a trailing comma, which
    will be ignored.  That is particularly useful in cases where the list of arguments is
    long or contains long variable names, making it convenient to list arguments vertically.
   </para>
   <example>
    <title>Function Argument List with trailing Comma</title>
    <programlisting role="php">
<![CDATA[
<?php
function takes_many_args(
    $first_arg,
    $second_arg,
    $a_very_long_argument_name,
    $arg_with_default = 5,
    $again = 'a default string', // This trailing comma was not permitted before 8.0.0.
)
{
    // ...
}
?>
]]>
    </programlisting>
   </example>
   <para>
    As of PHP 8.0.0, passing mandatory arguments after optional arguments
    is deprecated. This can generally be resolved by dropping the default value.
    One exception to this rule are arguments of the form
    <code>Type $param = null</code>, where the &null; default makes the type implicitly
    nullable. This usage remains allowed, though it is recommended to use an
    explicit nullable type instead.
   </para>
   <example>
    <title>Passing optional arguments after mandatory arguments</title>
    <programlisting role="php">
<![CDATA[
<?php
function foo($a = [], $b) {} // Before
function foo($a, $b) {}      // After

function bar(A $a = null, $b) {} // Still allowed
function bar(?A $a, $b) {}       // Recommended
?>
]]>
    </programlisting>
   </example>

   <sect2 xml:id="functions.arguments.by-reference">
    <title>Parameter als Verweise übergeben</title>

    <simpara>
     Normalerweise werden den Funktionen Werte als Parameter
     übermittelt. Wenn man den Wert dieses Parameters innerhalb der
     Funktion ändert, bleibt der Parameter außerhalb der Funktion
     unverändert. Wollen Sie aber erreichen, dass die Änderung auch außerhalb
     der Funktion sichtbar wird, müssen Sie die Parameter als Verweise
     (Referenzen) übergeben.
    </simpara>

    <para>
     Wenn eine Funktion einen Parameter generell als Verweis behandeln
     soll, setzt man in der Funktionsdefinition ein kaufmännisches Und
     (&amp;) vor den Parameternamen:
    </para>

    <para>
     <example>
      <title>Übergeben von Funktionsparametern als Verweis</title>
      <programlisting role="php">
<![CDATA[
<?php
function fuege_etwas_an(&$string)
{
    $string .= 'und etwas mehr.';
}
$str = 'Dies ist ein String, ';
fuege_etwas_an($str);
echo $str; // Ausgabe: 'Dies ist ein String, und etwas mehr.'
?>
]]>
      </programlisting>
     </example>
    </para>

   </sect2>

   <sect2 xml:id="functions.arguments.default">
    <title>Vorgabewerte für Parameter</title>

    <para>
     Eine Funktion kann C++-artige Vorgabewerte für skalare Parameter
     wie folgt definieren:
    </para>

    <para>
     <example>
      <title>Einsatz von Vorgabeparametern in Funktionen</title>
      <programlisting role="php">
<![CDATA[
<?php
function machkaffee($typ = "Cappuccino")
{
    return "Ich mache eine Tasse $typ.\n";
}
echo machkaffee();
echo machkaffee(null);
echo machkaffee("Espresso");
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Ich mache eine Tasse Cappuccino.
Ich mache eine Tasse .
Ich mache eine Tasse Espresso.
]]>
      </screen>
     </example>
    </para>

    <para>
     PHP gestattet es, <type>Array</type>s und den speziellen Typ &null; als
     Vorgabewert zu nutzen, zum Beispiel:
    </para>
    <para>
     <example>
      <title>Nichtskalare Typen als Vorgabewert</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($types = array("cappuccino"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "hands" : $coffeeMaker;
    return "Ich mache eine Tasse ".join(", ", $types)." mit $device.\n";
}
echo makecoffee();
echo makecoffee(array("cappuccino", "lavazza"), "teapot");
?>
]]>
      </programlisting>
     </example>
    </para>

    <simpara>
     Der Vorgabewert muss ein konstanter Ausdruck sein, darf also zum
     Beispiel keine Variable, Eigenschaft einer Klasse oder ein
     Funktionsaufruf sein.
    </simpara>
    <para>
     Bitte beachten Sie, dass alle Parameter mit Vorgabewert rechts von den
     Parametern ohne Vorgabewert stehen müssen - sonst wird es nicht
     funktionieren. Betrachten Sie folgendes Beispiel:
    </para>

    <para>
     <example>
      <title>Ungültige Anwendung von Vorgabewerten</title>
      <programlisting role="php">
<![CDATA[
<?php
function mach_joghurt($typ = "rechtsdrehendes", $geschmack)
{
    return "Mache einen Becher $typ $geschmack-joghurt.\n";
}

echo mach_joghurt("Brombeer");   // arbeitet nicht wie erwartet
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Warning: Missing argument 2 in call to mach_joghurt() in
/usr/local/etc/httpd/htdocs/phptest/functest.html on line 41
Mache einen Becher Brombeer -joghurt.
]]>
      </screen>
     </example>
    </para>

    <para>
     Nun vergleichen Sie bitte obiges Beispiel mit folgendem:
    </para>

    <para>
     <example>
     <title>Richtiger Einsatz von Vorgabewerten</title>
      <programlisting role="php">
<![CDATA[
<?php
function mach_joghurt($geschmack, $typ = "rechtsdrehendes")
{
    return "Mache einen Becher $typ $geschmack-Joghurt.\n";
}

echo mach_joghurt("Brombeer");   // arbeitet wie erwartet.
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Mache einen Becher rechtsdrehendes Brombeer-Joghurt.
]]>
      </screen>
     </example>
    </para>

    <note>
     <simpara>
      Das Setzen von Standardwerten für Argumente, die als Referenz
      übergeben werden ("passed by reference") wird
      unterstützt.
     </simpara>
    </note>

   </sect2>

   <sect2 xml:id="functions.variable-arg-list">
    <title>Variable Anzahl von Parametern</title>

    <simpara>
     PHP unterstützt eine variable Anzahl an Parametern für benutzerdefinierte
     Funktionen durch Verwendung des Token <literal>...</literal>.
    </simpara>
    <note>
     <simpara>
      Es ist ebenfalls möglich eine variable Anzahl an Parametern durch Verwendung von
      <function>func_num_args</function>, <function>func_get_arg</function>, und
      <function>func_get_args</function> zu realisieren.
      Diese Technik wird nicht empfohlen, da sie vor der Einführung des <literal>...</literal>
      Tokens verwendet wurde.
     </simpara>
    </note>

     <para>
      Eine Liste von Parametern kann das Token <literal>...</literal>
      enthalten, um anzugeben, dass die Funktion eine variable Anzahl von
      Parametern akzeptiert. Die zusätzlichen Werte werden als Array an die entsprechende Variable übergeben.
      Zum Beispiel:
      <example>
       <title>Verwendung von <literal>...</literal> für den Zugriff auf
       variable Parameter</title>
       <programlisting role="php">
<![CDATA[
<?php
function sum(...$numbers) {
    $acc = 0;
    foreach ($numbers as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
10
]]>
       </screen>
      </example>
     </para>

     <para>
      Das Token <literal>...</literal> kann ebenfalls dazu verwendet werden, um
      ein <type>Array</type> oder <classname>Traversable</classname>-Objekt als
      Liste von Parametern zu übergeben:
      <example>
       <title>Verwendung von <literal>...</literal> zur Übergabe einer Parameterliste</title>
       <programlisting role="php">
<![CDATA[
<?php
function add($a, $b) {
    return $a + $b;
}

echo add(...[1, 2])."\n";

$a = [1, 2];
echo add(...$a);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
3
3
]]>
       </screen>
      </example>
     </para>

     <para>
      Die Definition von regulären, positionierten Parametern vor dem <literal>...</literal>
      ist natürlich weiterhin möglich. In einem solchen Fall werden dann nur die
      zusätzlichen Werte, die zu keinem positionierten Parameter gehören, in
      das durch <literal>...</literal> erzeugte Array übernommen.
     </para>

     <para>
      Es ist zudem ebenfalls möglich dem <literal>...</literal> Token eine
      <link linkend="language.types.declarations">Typdeklaration</link> voran zu
      stellen. Ist dies der Fall, müssen alle Werte, die für <literal>...</literal>
      relevant sind, vom entsprechenden Typ sein.
      
      <example>
       <title>Variable Parameter mit Typdeklaration</title>
       <programlisting role="php">
<![CDATA[
<?php
function total_intervals($unit, DateInterval ...$intervals) {
    $time = 0;
    foreach ($intervals as $interval) {
        $time += $interval->$unit;
    }
    return $time;
}

$a = new DateInterval('P1D');
$b = new DateInterval('P2D');
echo total_intervals('d', $a, $b).' days';

// Dieser Aufruf wird scheitern, da null keine Instanz von DateInterval ist
echo total_intervals('d', null);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
3 days
Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2
]]>
       </screen>
      </example>
     </para>

     <para>
      Durch ein voran gestelltes <literal>&amp;</literal> ist auch die Übergabe von variablen Parametern
      <link linkend="functions.arguments.by-reference">als Referenz</link>
      möglich.
     </para>

    <sect3 xml:id="functions.variable-arg-list.old">
     <title>Ältere Versionen von PHP</title>

     <para>
      Eine spezielle Syntax ist zur Definition von variablen Parametern nicht
      notwendig. Um auf die übergebenen Werte zugreifen zu können, stehen
      die Funktionen <function>func_num_args</function>,
      <function>func_get_arg</function> und <function>func_get_args</function>
      bereit.
     </para>

     <para>
      Das erste Beispiel von weiter oben würde in alten PHP-Versionen so
      umgesetzt werden können:
      
      <example>
       <title>Zugriff auf variable Parameter in alten PHP-Versionen</title>
       <programlisting role="php">
<![CDATA[
<?php
function sum() {
    $acc = 0;
    foreach (func_get_args() as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
10
]]>
       </screen>
      </example>
     </para>
    </sect3>

   </sect2>

   <sect2 xml:id="functions.named-arguments">
    <title>Named Arguments</title>

    <para>
     PHP 8.0.0 introduced named arguments as an extension of the existing
     positional parameters. Named arguments allow passing arguments to a
     function based on the parameter name, rather than the parameter position.
     This makes the meaning of the argument self-documenting, makes the
     arguments order-independent and allows skipping default values arbitrarily.
    </para>

    <para>
     Named arguments are passed by prefixing the value with the parameter name
     followed by a colon. Using reserved keywords as parameter names is allowed.
     The parameter name must be an identifier, specifying dynamically
     is not allowed.
    </para>

    <example>
     <title>Named argument syntax</title>
     <programlisting role="php">
      <![CDATA[
<?php
myFunction(paramName: $value);
array_foobar(array: $value);

// NOT supported.
function_name($variableStoringParamName: $value);
?>
]]>
     </programlisting>
    </example>

    <example>
     <title>Positional arguments versus named arguments</title>
     <programlisting role="php">
      <![CDATA[
<?php
// Using positional arguments:
array_fill(0, 100, 50);

// Using named arguments:
array_fill(start_index: 0, num: 100, value: 50);
?>
]]>
     </programlisting>
    </example>

    <para>
     The order in which the named arguments are passed does not matter.
    </para>

    <example>
     <title>Same example as above with a different order of parameters</title>
     <programlisting role="php">
      <![CDATA[
<?php
array_fill(value: 50, num: 100, start_index: 0);
?>
]]>
     </programlisting>
    </example>

    <para>
     Named arguments can be combined with positional arguments. In this case,
     the named arguments must come after the positional arguments.
     It is also possible to specify only some of the optional arguments of a
     function, regardless of their order.
    </para>

    <example>
     <title>Combining named arguments with positional arguments</title>
     <programlisting role="php">
      <![CDATA[
<?php
htmlspecialchars($string, double_encode: false);
// Same as
htmlspecialchars($string, ENT_COMPAT | ENT_HTML401, 'UTF-8', false);
?>
]]>
     </programlisting>
    </example>

    <para>
     Passing the same parameter multiple times results in an Error exception.
    </para>

    <example>
     <title>Error exception when passing the same parameter multiple times</title>
     <programlisting role="php">
      <![CDATA[
<?php
function foo($param) { ... }

foo(param: 1, param: 2);
// Error: Named parameter $param overwrites previous argument
foo(1, param: 2);
// Error: Named parameter $param overwrites previous argument
?>
]]>
     </programlisting>
    </example>

   </sect2>

  </sect1>

  <sect1 xml:id="functions.returning-values">
   <title>Rückgabewerte</title>

   <para>
    Sie können Werte mit der optionalen return-Anweisung zurückgeben.
    Es können Variablen jeden Typs zurückgegeben werden, auch Arrays
    oder Objekte. Dies beendet sofort die Funktion und die Kontrolle
    wird wieder an die aufrufende Zeile zurückgegeben. Weitere
    Informationen finden Sie unter <function>return</function>.
   </para>

   <note>
    <para>
     Wird <function>return</function> ausgelassen, dann wird der Wert &null;
     zurückgegeben.
    </para>
   </note>
   
   <sect2>
    <title>Einsatz von return</title>
   <para>
    <example>
     <title>Einsatz von <function>return</function></title>
     <programlisting role="php">
<![CDATA[
<?php
function quadrat($zahl)
{
    return $zahl * $zahl;
}
echo quadrat(4);   // gibt '16' aus.

?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Es ist nicht möglich, mehrere Werte von einer Funktion zurückzugeben.
    Ein ähnliches Resultat kann man aber durch die Rückgabe eines Arrays
    erreichen.
   </para>

   <para>
    <example>
    <title>Rückgabe mehrerer Werte als Array</title>
     <programlisting role="php">
<![CDATA[
<?php
function kleine_zahlen()
{
   return array (0, 1, 2);
}
list ($null, $eins, $zwei) = kleine_zahlen();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Um von einer Funktion eine Referenz zurückzugeben, müssen Sie
    den Referenz-Operator &amp; sowohl in der Funktionsdeklaration,
    als auch bei der Zuweisung des zurückgegebenen Wertes verwenden:
   </para>

   <para>
    <example>
     <title>Rückgabe von Referenzen aus Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function &returniere_referenz()
{
    return $einereferenz;
}

$neuereferenz =& returniere_referenz();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Weitere Informationen über Referenzen finden Sie im Kapitel
    <link linkend="language.references">Referenzen in PHP</link>.
   </simpara>
  </sect2>
  </sect1>
 
  <sect1 xml:id="functions.variable-functions">
   <title>Variablenfunktionen</title>

   <para>
    PHP unterstützt das Konzept der Variablenfunktionen. Wenn Sie an
    das Ende einer Variablen Klammern hängen, versucht PHP eine
    Funktion aufzurufen, deren Name der aktuelle Wert der Variablen
    ist. Dies kann unter anderem für Callbacks, Funktionstabellen,
    usw. genutzt werden.
   </para>
   <para>
    Variablenfunktionen funktionieren nicht mit Sprachkonstrukten
    wie <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function> und
    <function>require</function>. Sie müssen Ihre eigenen Wrapperfunktionen
    verwenden, um diese Konstrukte als Variablenfunktionen benutzen zu
    können.
   </para>
   <para>
    <example>
     <title>Beispiel für Variablenfunktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
    echo "In foo()<br />\n";
}

function bar($arg = '')
{
    echo "In bar(); der Parameter ist '$arg'.<br />\n";
}

// Dies ist eine Wrapperfunktion für echo
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // Dies ruft foo() auf

$func = 'bar';
$func('test');  // Dies ruft bar() auf

$func = 'echoit';
$func('test');  // Dies ruft echoit() auf
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Sie können auch die Methode eines Objektes mittels der variablen
    Funktionen aufrufen.
    <example>
     <title>Variable Methode</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // Dies ruft die Bar() Methode auf
    }

    function Bar()
    {
        echo "Das ist Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();   // Dies ruft $foo->Variable() auf

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Werden statische Methoden aufgerufen, ist der Funktionsaufruf stärker als der statische Eigenschaftsoperator:
    <example>
     <title>Beispiel für variable Methoden mit statischen Eigenschaften</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static $variable = 'statische Eigenschaft';
    static function Variable()
    {
        echo 'Method Variable called';
    }
}

echo Foo::$variable; // Dies gibt 'statische Eigenschaft' aus. Es bräuchte eine $variable im aktuellen Geltungsbereich.
$variable = "Variable";
Foo::$variable();  // Dies ruft $foo->Variable() auf, da $variable im aktuellen Geltungsbereich vorliegt.

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Komplexe Callables</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static function bar()
    {
        echo "bar\n";
    }
    function baz()
    {
        echo "baz\n";
    }
}

$func = array("Foo", "bar");
$func(); // gibt "bar" aus
$func = array(new Foo, "baz");
$func(); // gibt "baz" aus
$func = "Foo::bar";
$func(); // gibt "bar" aus
?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>is_callable</function></member>
      <member><function>call_user_func</function></member>
      <member><function>function_exists</function></member>
      <member><link linkend="language.variables.variable">Variable Variablen</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="functions.internal">
   <title>Interne (eingebaute) Funktionen</title>

   <para>
    PHP enthält standardmäßig viele Funktionen und Konstrukte, weiterhin
    gibt es viele Funktionen die voraussetzen, dass bestimmte PHP-Extensions
    einkompiliert wurden, anderenfalls erhalten Sie beim
    Aufruf "undefined function"-Fehlermeldungen.
    Um z. B. <link linkend="ref.image">Grafik-Funktionen</link> wie
    <function>imagecreatetruecolor</function> zu nutzen, müssen Sie PHP mit
    <productname>GD</productname>-Unterstützung kompilieren, oder um
    <function>mysqli_connect</function> zu nutzen, muss Ihr PHP mit <link
    linkend="book.mysqli">MySQLi</link>-Unterstützung kompiliert sein.
    Viele Kernfunktionen wie z.B. die <link
    linkend="ref.strings">String</link>- und <link
    linkend="ref.var">Variablen</link>-Funktionen sind bereits in
    jeder PHP-Version enthalten. Ein Aufruf von <function>phpinfo</function>
    oder <function>get_loaded_extensions</function> zeigt Ihnen, welche
    Extensions in Ihrer PHP-Installation verfügbar sind.
    Beachten Sie weiterhin, dass viele Extensions bereits standardmäßig
    aktiviert sind und das PHP-Manual nach Extensions unterteilt ist.
    Weitere Informationen zur Einrichtung von PHP finden Sie in den
    Kapiteln <link linkend="configuration">Konfiguration</link>,
    <link linkend="install">Installation</link> und den Kapiteln
    zu den einzelnen Extensions.
   </para>
   <para>
    Wie Funktionsprototypen zu lesen und zu verstehen sind, ist im
    Kapitel '<link linkend="about.prototypes">Wie man eine Funktionsdefinition
    (Prototyp) liest'</link> erklärt.
    Es ist wichtig zu erkennen, was eine Funktion zurückgibt und ob
    die übergebenen Parameter verändert werden. So gibt z.B.
    <function>str_replace</function> den bearbeiteten String zurück,
    während <function>usort</function> direkt auf der übergebenen
    Variablen arbeitet.
    Jede Handbuchseite enthält spezifische Informationen für jede
    Funktion wie ihre Parameter, die Rückgabewerte sowohl bei Erfolg
    als auch im Fehlerfall, Änderungen des Verhaltens und die Verfügbarkeit.
    Die Kenntnis dieser wichtigen (aber oft subtilen) Unterschiede ist
    von entscheidender Bedeutung für das Schreiben korrekten PHP-Codes.
   </para>
   <note>
    <simpara>
     Wenn Funktionen andere Parameter erhalten als erwartet, d.h. wenn z.B.
     ein <type>Array</type> übergeben wird obwohl ein <type>String</type>
     erwartet wird, so ist der Rückgabewert undefiniert. In solchen Fällen
     ist es üblich, dass &null; zurückgegeben wird. Dies ist aber nur eine
     Konvention, auf die Sie sich nicht unbedingt verlassen können.
    </simpara>
   </note>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>function_exists</function></member>
      <member><link linkend="funcref">die Funktionsreferenz</link></member>
      <member><function>get_extension_funcs</function></member>
      <member><function>dl</function></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="functions.anonymous">
   <title>Anonyme Funktionen</title>

   <simpara>
    Anonyme Funktionen, auch bekannt als  <literal>Closures</literal>, ermöglichen es Funktionen
    ohne Funktionsnamen zu schreiben. Sie sind am wertvollsten als Werte von <type>callable</type>-Parametern,
    haben aber noch viele andere Verwendungsmöglichkeiten.
   </simpara>
   <simpara>
    Anonyme Funktionen werden unter Verwendung der <link linkend="class.closure">
    <classname>Closure</classname></link>-Klasse implementiert.
   </simpara>

   <example>
    <title>Beispiel für eine anonyme Funktion</title>
    <programlisting role="php">
<![CDATA[
<?php
echo preg_replace_callback('~-([a-z])~', function ($match) {
    return strtoupper($match[1]);
}, 'hallo-welt');
// gibt halloWelt aus
?>
]]>
    </programlisting>
   </example>

   <simpara>
    Closures können auch als Werte von Variablen verwendet werden;
    PHP konvertiert solche Ausdrücke automatisch in Instanzen der internen Klasse <classname>Closure</classname>.
    Die Zuweisung einer Closure an eine Variable verwendet die selbe Syntax wie andere
    Zuweisungen, einschließlich des abschließenden Semikolon:
   </simpara>

   <example>
    <title>Beispiel für die Zuweisung einer anonymen Funktion</title>
    <programlisting role="php">
<![CDATA[
<?php
$greet = function($name)
{
    printf("Hallo %s\r\n", $name);
};

$greet('Welt');
$greet('PHP');
?>
]]>
    </programlisting>
   </example>
   
   <simpara>
    Closures können ebenfalls Variablen aus dem Eltern-Gültigkeitsbereich erben.
    Jede solche Variable muss an das <literal>use</literal>-Sprachkonstrukt übergeben werden. 
    Von PHP 7.1 an dürfen diese Variablen keine &link.superglobals;,
    <varname>$this</varname> oder Variablen mit dem gleichen Name wie ein
    Parameter sein.
   </simpara>

   <example>
    <title>Erben von Variablen aus dem Eltern-Scope</title>
    <programlisting role="php">
<![CDATA[
<?php
$message = 'hallo';

// Kein "use"
$example = function () {
    var_dump($message);
};
$example();

// $message vererben
$example = function () use ($message) {
    var_dump($message);
};
$example();

// der Wert einer geerbten Variable ist der zum Zeitpunkt
// der Funktionsdefinition, nicht des Funktionsaufrufs
$message = 'welt';
$example();

// $message wieder herstellen
$message = 'hallo';

// vererben per Referenz
$example = function () use (&$message) {
    var_dump($message);
};
$example();

// Der geänderte Wert im Eltern-Gültigkeitsbereich
// wird in der aufgerufenen Funktion reflektiert
$message = 'welt';
$example();

// Closures können ebenfalls reguläre Parameter akzeptieren
$example = function ($arg) use ($message) {
    var_dump($arg . ' ' . $message);
};
$example("hallo");
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
Notice: Undefined variable: message in /example.php on line 6
NULL
string(5) "hallo"
string(5) "hallo"
string(5) "hallo"
string(4) "welt"
string(10) "hallo welt"
]]>
    </screen>
   </example>

   <para>
    As of PHP 8.0.0, the list of scope-inherited variables may include a trailing
    comma, which will be ignored.
   </para>
   <simpara>
    Das Erben von Variablen aus dem Eltern-Gültigkeitsbereich ist <emphasis>nicht</emphasis>
    das gleiche wie die Verwendung von globalen Variablen.
    Globale Variablen existieren im globalen Gültigkeitsbereich, der immer der gleiche ist,
    unabhängig davon welche Funktion ausgeführt wird. Der Eltern-Gültigkeitsbereich einer
    Closure ist die Funktion, in der die Closure deklariert wurde (nicht notwendigerweise
    die Funktion, aus der sie aufgerufen wurde). Betrachten Sie das folgende Beispiel:
   </simpara>

   <example>
    <title>Closures und Gültigkeitsbereiche</title>
    <programlisting role="php">
<![CDATA[
<?php
// Ein einfacher Einkaufswagen, der eine Liste von hinzugefügten Produkten
// enthält, und die Menge jedes Produkts. Enthält eine Methode, die den
// Gesamtpreise der Waren im Einkaufswagen unter Verwendung einer Closure
// als Callback berechnet.
class Cart
{
    const PRICE_BUTTER  = 1.00;
    const PRICE_MILK    = 3.00;
    const PRICE_EGGS    = 6.95;

    protected $products = array();
    
    public function add($product, $quantity)
    {
        $this->products[$product] = $quantity;
    }
    
    public function getQuantity($product)
    {
        return isset($this->products[$product]) ? $this->products[$product] :
               FALSE;
    }
    
    public function getTotal($tax)
    {
        $total = 0.00;
        
        $callback =
            function ($quantity, $product) use ($tax, &$total)
            {
                $pricePerItem = constant(__CLASS__ . "::PRICE_" .
                    strtoupper($product));
                $total += ($pricePerItem * $quantity) * ($tax + 1.0);
            };
        
        array_walk($this->products, $callback);
        return round($total, 2);
    }
}

$my_cart = new Cart;

// Lege ein paar Waren in den Einkaufskorb
$my_cart->add('butter', 1);
$my_cart->add('milk', 3);
$my_cart->add('eggs', 6);

// Gib die Gesamtsumme mit einer Mehrwertsteuer von 5% aus
print $my_cart->getTotal(0.05) . "\n";
// Das Ergebnis ist 54.29
?>
]]>
    </programlisting>
   </example>
   
   <example>
    <title>Automatisches Binden von <literal>$this</literal></title>
    <programlisting role="php">
<![CDATA[
<?php

class Test
{
    public function testing()
    {
        return function() {
            var_dump($this);
        };
    }
}

$object = new Test;
$function = $object->testing();
$function();
    
?>
]]>
    </programlisting>
   </example>

   <para>
    Wird eine anonyme Funktion im Kontext einer Klasse deklariert, so wird diese
    Klasse automatisch an jene gebunden, was <literal>$this</literal> innerhalb des
    Geltungsbereichs verfügbar macht. Ist diese automatische Bindung der aktuellen
    Klasse nicht erwünscht, dann können stattdessen <link
    linkend="functions.anonymous-functions.static">statische anonyme Funktionen</link>
    verwendet werden.
   </para>

   <sect2 xml:id="functions.anonymous-functions.static">
    <title>Statische anonyme Funktionen</title>
    <para>
     Anonyme Funktionen können statisch deklariert werden. Dies verhindert,
     dass automatisch die aktuelle Klasse an sie gebunden wird. Objekte können zur Laufzeit
     ebenfalls nicht an sie gebunden werden.
    </para>
    <para>
     <example>
      <title>Versuch der Verwendung von <literal>$this</literal> innerhalb einer statischen anonymen Funktion</title>
      <programlisting role="php">
<![CDATA[
<?php

class Foo
{
    function __construct()
    {
        $func = static function() {
            var_dump($this);
        };
        $func();
    }
};
new Foo();

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Notice: Undefined variable: this in %s on line %d
NULL
]]>
      </screen>
     </example>
    </para>

    <para>
     <example>
      <title>Versuch ein Objekt an eine statische anonyme Funktion zu binden</title>
      <programlisting role="php">
<![CDATA[
<?php

$func = static function() {
    // function body
};
$func = $func->bindTo(new StdClass);
$func();

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Warning: Cannot bind an instance to a static closure in %s on line %d
]]>
      </screen>
     </example>
    </para>
   </sect2>
   
   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>7.1.0</entry>
         <entry>
          Anonyme Funktionen dürfen &link.superglobals;, <varname>$this</varname>
          und alle Variablen mit dem gleichen Namen wie Parameter nicht als freie
          Variablen verwenden.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>

   <sect2 role="notes">
    &reftitle.notes;
    <note>
     <simpara>
      Es ist möglich <function>func_num_args</function>,
      <function>func_get_arg</function> und <function>func_get_args</function>
      innerhalb einer Closure zu verwenden.
     </simpara>
    </note>
   </sect2>

  </sect1>

  <sect1 xml:id="functions.arrow">
   <title>Pfeilfunktionen</title>

   <simpara>
    Pfeilfunktionen wurden in PHP 7.4 als prägnantere Syntax für
    <link linkend="functions.anonymous">anonyme Funktionen</link> eingeführt.
   </simpara>
   <simpara>
    Sowohl anonyme Funktionen wie Pfeilfunktionen sind unter Verwendung der
    <link linkend="class.closure"><classname>Closure</classname></link>-Klasse implementiert.
   </simpara>

   <simpara>
    Pfeilfunktionen haben die grundsätzliche Form
    <code>fn (argument_list) =&gt; expr</code>.
   </simpara>

   <simpara>
    Pfeilfunktionen unterstützen dieselben Features wie
    <link linkend="functions.anonymous">anonyme Funktionen</link>,
    außer, dass die Verwendung von Variablen des Elterngültigkeitsbereichs immer automatisch erfolgt.
   </simpara>

   <simpara>
    Wenn eine Variable, die im Ausdruck verwendet wird, im Elterngültigkeitsbereich
    definiert ist, wird sie implizit per Wertübergabe gebunden.
    Im folgenden Beispiel verhalten sich die Funktionen <varname>$fn1</varname> und
    <varname>$fn2</varname> auf die gleiche Weise.
   </simpara>

   <para>
    <example>
     <title>Pfeilfunktionen binden Variablen automatisch per Wertübergabe</title>
     <programlisting role="php">
<![CDATA[
<?php

$y = 1;
 
$fn1 = fn($x) => $x + $y;
// gleichwertig zur Verwendung von $y per Wertübergabe:
$fn2 = function ($x) use ($y) {
    return $x + $y;
};

var_export($fn1(3));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
4
]]>
      </screen>
    </example>
   </para>
   <simpara>
    Die funktioniert ebenfalls, wenn Pfeilfunktionen verschachtelt werden:
   </simpara>
   <para>
    <example>
     <title>Pfeilfunktionen binden Variablen automatisch per Wertübergabe, selbst wenn sie verschachtelt sind</title>
     <programlisting role="php">
<![CDATA[
<?php

$z = 1;
$fn = fn($x) => fn($y) => $x * $y + $z;
// gibt 51 aus
var_export($fn(5)(10));
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Ähnlich wie bei anonymen Funktion, erlaubt die Pfeilfunktionssyntax beliebige Funktionssignaturen,
    einschließlich Parameter- und Rückgabetypen, Defaultwerten, variadischen Parametern,
    sowie Referenzübergabe und -rückgabe.
    Alle folgenden sind gültige Beispiele von Pfeilfunktionen:
   </simpara>
   <para>
    <example>
     <title>Beispiele von Pfeilfunktionen</title>
     <programlisting role="php">
<![CDATA[
<?php

fn(array $x) => $x;
static fn(): int => $x;
fn($x = 42) => $x;
fn(&$x) => $x;
fn&($x) => $x;
fn($x, ...$rest) => $rest;

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Pfeilfunktionen verwenden Wertübergabe-Bindung.
    Dies entspricht in etwa der Verwendung von <code>use($x)</code> für jede Variable
    <varname>$x</varname>, die in der Pfeilfunktion verwendet wird.
    Wertübergabe-Bindung bedeutet, dass es nicht möglich ist Werte aus dem äußeren
    Geltungsbereich zu ändern.
    <link linkend="functions.anonymous">Anonyme Funktionen</link> können statt dessen
    für Referenzübergabe-Bindungen verwendet werden.
   </simpara>
   <para>
    <example>
     <title>Werte aus dem äußeren Geltungsbereich können nicht durch Pfeilfunktionen geändert werden</title>
     <programlisting role="php">
<![CDATA[
<?php

$x = 1;
$fn = fn() => $x++; // hat keine Wirkung
$fn();
var_export($x);  // gibt 1 aus

?>
]]>
     </programlisting>
    </example>
   </para>
   
   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>7.4.0</entry>
         <entry>
          Pfeilfunktionen sind verfügbar.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>

   <sect2 role="notes">
    &reftitle.notes;
    <note>
     <simpara>
      Es ist möglich <function>func_num_args</function>,
      <function>func_get_arg</function> und <function>func_get_args</function>
      innerhalb einer Pfeilfunktion zu verwenden.
     </simpara>
    </note>
   </sect2>
  </sect1>

 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"~/.phpdoc/manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
