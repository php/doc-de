<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 339195 Maintainer: cmb Status: working -->
<!-- Credits: hholzgra, tom, updated to fix build by theseer -->

 <chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook">
  <title>Funktionen</title>

  <sect1 xml:id="functions.user-defined">
   <title>Vom Nutzer definierte Funktionen</title>

   <para>
    Eine Funktion kann wie folgt definiert werden:
   </para>

   <para>
    <example>
     <title>Pseudocode zur Demonstration der Nutzung von Variablen</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo ($arg_1, $arg_2, ..., $arg_n)
{
    echo "Beispielfunktion.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <simpara>
    Jeder beliebige korrekte PHP-Code kann in einer Funktion
    vorkommen, sogar andere Funktionen und <link
    linkend="keyword.class">Klassen</link>-Definitionen.
   </simpara>
   <para>
    Für Funktionsnamen gelten in PHP die gleichen Regeln wie für
    andere Bezeichner. Ein gültiger Funktionsname beginnt mit
    einem Buchstaben oder Unterstrich gefolgt von einer beliebigen
    Anzahl von Buchstaben, Ziffern und Unterstrichen. Als
    regulärer Ausdruck wird dies so ausgedrückt:
    <literal>[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*</literal>.
   </para>
   &tip.userlandnaming;
   <simpara>
    Es ist nicht erforderlich, dass Funktionen bereits definiert sein
    müssen, wenn auf sie verwiesen wird,
    <emphasis>außer</emphasis> wenn eine Funktion nur bedingt definiert
    wird, wie in den beiden untenstehenden Beispielen gezeigt.
   </simpara>
   <para>
    Wenn eine Funktion nur unter bestimmten Bedingungen definiert wird,
    muss die Definition dieser Funktion noch <emphasis>vor</emphasis>
    deren Aufruf abgearbeitet werden.
   </para>
   <para>
    <example>
     <title>Bedingte Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Wir können foo() von hier aus nicht
   aufrufen, da sie noch nicht existiert,
   aber wir können bar() aufrufen */

bar();

if ($makefoo) {
  function foo ()
  {
    echo "Ich existiere nicht, bis mich die Programmausführung erreicht hat.\n";
  }
}

/* Nun können wir foo() sicher aufrufen,
   da $makefoo als true ausgewertet wurde */

if ($makefoo) foo();

function bar()
{
  echo "Ich existiere sofort nach Programmstart.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Funktionen innerhalb von Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
  function bar()
  {
    echo "Ich existiere nicht, bis foo() aufgerufen wurde.\n";
  }
}

/* Wir können bar() noch nicht
   aufrufen, da es nicht existiert */

foo();

/* Nun können wir auch bar() aufrufen,
   da sie durch die Abarbeitung von
   foo() verfügbar gemacht wurde */

bar();

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Alle Funktionen und Klassen in PHP existieren im globalen Namensraum -
    sie können außerhalb von Funktionen aufgerufen werden, selbst wenn sie
    innerhalb einer Funktion definiert wurden und umgekehrt.
   </para>
   <simpara>
    PHP unterstützt weder das Überladen von Funktionen, noch ist es
    möglich, zuvor deklarierte Funktionen neu zu definieren oder die
    Definition zu löschen.
   </simpara>
   <note>
    <simpara>
     Groß- und Kleinschreibung spielt zwar bei Funktionsnamen keine
     Rolle, es empfiehlt sich aber trotzdem bei Funktionsaufrufen
     die gleiche Schreibweise wie in der Deklaration zu benutzen.
    </simpara>
   </note>
   <simpara>
    Sowohl <link linkend="functions.variable-arg-list">eine
    variable Anzahl Parameter</link> als auch
    <link linkend="functions.arguments.default">Vorgabewerte
    für Parameter</link> werden in Funktionen unterstützt.
    Siehe auch die Funktionsreferenzen für
    <function>func_num_args</function>,
    <function>func_get_arg</function> und
    <function>func_get_args</function> für weitere Informationen.
   </simpara>

   <para>
    Es ist in PHP möglich, Funktionen rekursiv aufzurufen.
    <example>
     <title>Rekursive Funktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
     </programlisting>
    </example>
   <note>
    <simpara>
     Rekursive Funktions-/Methodenaufrufe mit einer Tiefe von über 100-200
     können zu einem Stacküberlauf und damit zum Programmabbruch führen.
     Besonders unbegrenzte Rekursion wird als Programmierfehler erachtet.
    </simpara>
   </note>
   </para>
  </sect1>

  <sect1 xml:id="functions.arguments">
   <title>Funktionsparameter</title>

   <simpara>
    Mit einer Parameterliste kann man Informationen an eine Funktion
    übergeben. Die Parameterliste ist eine durch Kommas getrennte
    Liste von Ausdrücken.
   </simpara>
   <para>
    PHP unterstützt die Weitergabe von Parametern als Werte (das ist
    der Standard), als <link
    linkend="functions.arguments.by-reference">Verweise</link> und
    als <link linkend="functions.arguments.default">Vorgabewerte</link>.
    <link linkend="functions.variable-arg-list">Eine variable Anzahl
    von Parametern</link> wird ebenfalls unterstützt.
   </para>

   <para>
    <example>
     <title>Arrays an Funktionen übergeben</title>
     <programlisting role="php">
<![CDATA[
<?php
function rechne_array($eingabe)
{
    echo "$eingabe[0] + $eingabe[1] = ", $eingabe[0]+$eingabe[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 xml:id="functions.arguments.by-reference">
    <title>Verweise als Parameter übergeben</title>

    <simpara>
     Normalerweise werden den Funktionen Werte als Parameter
     übermittelt. Wenn man den Wert dieses Parameters innerhalb der
     Funktion ändert, bleibt der Parameter außerhalb der Funktion
     unverändert. Wollen Sie aber erreichen, dass die Änderung auch außerhalb
     der Funktion sichtbar wird, müssen Sie die Parameter als Verweise
     (Referenzen) übergeben.
    </simpara>

    <para>
     Wenn eine Funktion einen Parameter generell als Verweis behandeln
     soll, setzt man in der Funktionsdefinition ein kaufmännisches Und
     (&amp;) vor den Parameternamen:
    </para>

    <para>
     <example>
      <title>Übergeben von Funktionsparametern als Verweis</title>
      <programlisting role="php">
<![CDATA[
<?php
function fuege_etwas_anderes_an(&$string)
{
    $string .= 'und nun zu etwas anderem.';
}
$str = 'Dies ist ein String, ';
fuege_etwas_anderes_an($str);
echo $str; // Ausgabe: 'Dies ist ein String, und nun zu etwas anderem.'
?>
]]>
      </programlisting>
     </example>
    </para>

   </sect2>

   <sect2 xml:id="functions.arguments.default">
    <title>Vorgabewerte für Parameter</title>

    <para>
     Eine Funktion kann C++-artige Vorgabewerte für skalare Parameter
     wie folgt definieren:
    </para>

    <para>
     <example>
      <title>Einsatz von Vorgabeparametern</title>
      <programlisting role="php">
<![CDATA[
<?php
function machkaffee($typ = "Cappucino")
{
    return "Ich mache eine Tasse $typ.\n";
}
echo machkaffee();
echo machkaffee(null);
echo machkaffee("Espresso");
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Ich mache eine Tasse Cappucino.
Ich mache eine Tasse .
Ich mache eine Tasse Espresso.
]]>
      </screen>
     </example>
    </para>

    <para>
     PHP gestattet es, Arrays und den speziellen Typ &null; als
     Vorgabewert zu nutzen, zum Beispiel:
    </para>
    <para>
     <example>
      <title>Nichtskalare Typen als Vorgabewert</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($types = array("cappuccino"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "hands" : $coffeeMaker;
    return "Ich mache eine Tasse ".join(", ", $types)." mit $device.\n";
}
echo makecoffee();
echo makecoffee(array("cappuccino", "lavazza"), "teapot");
?>
]]>
      </programlisting>
     </example>
    </para>

    <simpara>
     Der Vorgabewert muss ein konstanter Ausdruck sein, darf also zum
     Beispiel keine Variable, Eigenschaft einer Klasse oder ein
     Funktionsaufruf sein.
    </simpara>
    <para>
     Bitte beachten Sie, dass alle Parameter mit Vorgabewert rechts von den
     Parametern ohne Vorgabewert stehen müssen - sonst wird es nicht
     funktionieren. Betrachten Sie folgendes Beispiel:
    </para>

    <para>
     <example>
      <title>Ungültige Anwendung von Vorgabewerten</title>
      <programlisting role="php">
<![CDATA[
<?php
function mach_joghurt($typ = "rechtsdrehendes", $geschmack)
{
    return "Mache einen Becher $typ $geschmack-joghurt.\n";
}

echo mach_joghurt("Brombeer");   // arbeitet nicht wie erwartet
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Warning: Missing argument 2 in call to mach_joghurt() in
/usr/local/etc/httpd/htdocs/phptest/functest.html on line 41
Mache einen Becher Brombeer-joghurt.
]]>
      </screen>
     </example>
    </para>

    <para>
     Nun vergleichen Sie bitte oberes Beispiel mit folgendem:
    </para>

    <para>
     <example>
     <title>Richtiger Einsatz von Vorgabewerten</title>
      <programlisting role="php">
<![CDATA[
<?php
function mach_joghurt($geschmack, $typ = "rechtsdrehendes")
{
    return "Mache einen Becher $typ $geschmack-Joghurt.\n";
}

echo mach_joghurt("Brombeer");   // arbeitet wie erwartet.
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Mache einen Becher rechtsdrehendes Brombeer-Joghurt.
]]>
      </screen>
     </example>
    </para>

    <note>
     <simpara>
      Das Setzen von Standardwerten für Argumente, die als Referenz
      übergeben werden ("passed by reference") wird seit PHP 5
      unterstützt.
     </simpara>
    </note>

   </sect2>
   
   <sect2 xml:id="functions.arguments.type-declaration">
    <title>Type declarations</title>

    <note>
     <para>
      Type declarations were also known as type hints in PHP 5.
     </para>
    </note>

    <para>
     Type declarations allow functions to require that parameters are of a certain type at call time.
     If the given value is of the incorrect type,
     then an error is generated: in PHP 5, this will be a recoverable fatal
     error, while PHP 7 will throw a <classname>TypeError</classname>
     exception.
    </para>

    <para>
     To specify a type declaration, the type name should be added before the
     parameter name. The declaration can be made to accept &null; values if
     the default value of the parameter is set to &null;.
    </para>

    <sect3 xml:id="functions.arguments.type-declaration.types">
     <title>Valid types</title>
     <informaltable>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Type</entry>
         <entry>Description</entry>
         <entry>Minimum PHP version</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>Class/interface name</entry>
         <entry>
          The parameter must be an &instanceof; the given class or interface
          name.
         </entry>
         <entry>PHP 5.0.0</entry>
        </row>
        <row>
         <entry><literal>self</literal></entry>
         <entry>
          Der Parameter muss ein &instanceof; der selben Klasse sein für die die
          Methode definiert ist. Dies kann nur für Klassen- und Objektmethoden
          verwendet werden.
         </entry>
         <entry>PHP 5.0.0</entry>
        </row>
        <row>
         <entry><type>array</type></entry>
         <entry>
          The parameter must be an <type>array</type>.
         </entry>
         <entry>PHP 5.1.0</entry>
        </row>
        <row>
         <entry><type>callable</type></entry>
         <entry>
          The parameter must be a valid <type>callable</type>.
         </entry>
         <entry>PHP 5.4.0</entry>
        </row>
        <row>
         <entry><type>bool</type></entry>
         <entry>
          The parameter must be a <type>boolean</type> value.
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
        <row>
         <entry><type>float</type></entry>
         <entry>
          The parameter must be a <type>float</type>ing point number.
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
        <row>
         <entry><type>int</type></entry>
         <entry>
          The parameter must be an <type>integer</type>.
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
        <row>
         <entry><type>string</type></entry>
         <entry>
          The parameter must be a <type>string</type>.
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
     <warning>
      <para>
       Aliase der oben genannten skalaren Typen werden nicht unterstützt.
       Statt dessen werden sie als Klassen- oder Schnittstellennamen angesehen.
       Zum Beispiel erfordert die Verwendung von <literal>boolean</literal>
       als Parameter oder Rückgabetyp ein Argument oder einen Rückgabewert, der
       ein &instanceof; der Klasse oder Schnittstelle <literal>boolean</literal>
       ist, anstatt vom Typ <type>bool</type>:
      </para>
      <para>
       <example>
        <programlisting role="php">
 <![CDATA[
 <?php
 function test(boolean $param) {}
 test(true);
 ?>
 ]]>
        </programlisting>
        &example.outputs;
        <screen>
 <![CDATA[
 Fatal error: Uncaught TypeError: Argument 1 passed to test() must be an instance of boolean, boolean given, called in - on line 1 and defined in -:1
 ]]>
        </screen>
       </example>
      </para>
     </warning>
    </sect3>

    <sect3 xml:id="functions.arguments.type-declaration.examples">
     &reftitle.examples;
     <example>
      <title>Basic class type declaration</title>
      <programlisting role="php">
<![CDATA[
<?php
class C {}
class D extends C {}

// This doesn't extend C.
class E {}

function f(C $c) {
    echo get_class($c)."\n";
}

f(new C);
f(new D);
f(new E);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
C
D

Fatal error: Uncaught TypeError: Argument 1 passed to f() must be an instance of C, instance of E given, called in - on line 14 and defined in -:8
Stack trace:
#0 -(14): f(Object(E))
#1 {main}
  thrown in - on line 8
]]>
      </screen>
     </example>

     <example>
      <title>Basic interface type declaration</title>
      <programlisting role="php">
<![CDATA[
<?php
interface I { public function f(); }
class C implements I { public function f() {} }

// This doesn't implement I.
class E {}

function f(I $i) {
    echo get_class($i)."\n";
}

f(new C);
f(new E);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
C

Fatal error: Uncaught TypeError: Argument 1 passed to f() must implement interface I, instance of E given, called in - on line 13 and defined in -:8
Stack trace:
#0 -(13): f(Object(E))
#1 {main}
  thrown in - on line 8
]]>
      </screen>
     </example>

     <example>
      <title>Nullable type declaration</title>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

function f(C $c = null) {
    var_dump($c);
}

f(new C);
f(null);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
object(C)#1 (0) {
}
NULL
]]>
      </screen>
     </example>
    </sect3>

    <sect3 xml:id="functions.arguments.type-declaration.strict">
     <title>Strict typing</title>

     <para>
      By default, PHP will coerce values of the wrong type into the expected
      scalar type if possible. For example, a function that is given an
      <type>integer</type> for a parameter that expects a <type>string</type>
      will get a variable of type <type>string</type>.
     </para>

     <para>
      It is possible to enable strict mode on a per-file basis. In strict
      mode, only a variable of exact type of the type declaration will be
      accepted, or a <classname>TypeError</classname> will be thrown. The
      only exception to this rule is that an <type>integer</type> may be given
      to a function expecting a <type>float</type>. Function calls from within
      internal functions will not be affected by the <literal>strict_types</literal>
      declaration.
     </para>

     <para>
      To enable strict mode, the &declare; statement is used with the
      <literal>strict_types</literal> declaration:
     </para>

     <caution>
      <para>
       Enabling strict mode will also affect
       <link linkend="functions.returning-values.type-declaration">return type declarations</link>.
      </para>
     </caution>

     <note>
      <para>
       Strict typing applies to function calls made from
       <emphasis>within</emphasis> the file with strict typing enabled, not to
       the functions declared within that file. If a file without strict
       typing enabled makes a call to a function that was defined in a file
       with strict typing, the caller's preference (weak typing) will be
       respected, and the value will be coerced.
      </para>
     </note>

     <note>
      <para>
       Strict typing is only defined for scalar type declarations, and as
       such, requires PHP 7.0.0 or later, as scalar type declarations were
       added in that version.
      </para>
     </note>

     <example>
      <title>Strict typing</title>
      <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1.5, 2.5));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)

Fatal error: Uncaught TypeError: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 9 and defined in -:4
Stack trace:
#0 -(9): sum(1.5, 2.5)
#1 {main}
  thrown in - on line 4
]]>
      </screen>
     </example>

     <example>
      <title>Weak typing</title>
      <programlisting role="php">
<![CDATA[
<?php
function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));

// These will be coerced to integers: note the output below!
var_dump(sum(1.5, 2.5));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)
int(3)
]]>
      </screen>
     </example>

     <example>
      <title>Catching <classname>TypeError</classname></title>
      <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

try {
    var_dump(sum(1, 2));
    var_dump(sum(1.5, 2.5));
} catch (TypeError $e) {
    echo 'Error: '.$e->getMessage();
}
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)
Error: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 10
]]>
      </screen>
     </example>
    </sect3>
   </sect2>
   
   <sect2 xml:id="functions.variable-arg-list">
    <title>Variable Anzahl von Parametern</title>

    <simpara>
     PHP unterstützt eine variable Anzahl an Parametern für benutzerdefinierte
     Funktionen. Dies wird seit PHP 5.6 durch das Token <literal>...</literal>
     umgesetzt. Für ältere Versionen von PHP stehen die Funktionen 
     <function>func_num_args</function>, <function>func_get_arg</function>, und
     <function>func_get_args</function> bereit.
    </simpara>

    <sect3 xml:id="functions.variable-arg-list.new">
     <title><literal>...</literal> in PHP 5.6+</title>

     <para>
      Ab PHP 5.6 kann eine Liste von Parametern das Token <literal>...</literal>
      enthalten um anzugeben, dass die Funktion eine variable Anzahl von
      Paramtern akzeptiert. Die zusätzlichen Werte werden als Array übergeben.
      Zum Beispiel:
      <example>
       <title>Verwendung von <literal>...</literal> für den Zugriff auf
       variable Parameter</title>
       <programlisting role="php">
<![CDATA[
<?php
function sum(...$numbers) {
    $acc = 0;
    foreach ($numbers as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
10
]]>
       </screen>
      </example>
     </para>

     <para>
      Das Token <literal>...</literal> kann ebenfalls dazu verwendet werden, um
      ein <type>array</type> oder <classname>Traversable</classname> Objekt als
      Liste von Parametern zu übergeben:
      <example>
       <title>Verwendung von <literal>...</literal> zur Übergabe einer Parameterliste</title>
       <programlisting role="php">
<![CDATA[
<?php
function add($a, $b) {
    return $a + $b;
}

echo add(...[1, 2])."\n";

$a = [1, 2];
echo add(...$a);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
3
3
]]>
       </screen>
      </example>
     </para>

     <para>
      Die Definition von regulären, positionierten Parametern vor dem <literal>...</literal>
      ist natürlich weiterhin möglich. In einem solchen Fall werden dann nur die
      zusätzlichen Werte, die zu keinem positionierten Parameter gehören, in
      das durch <literal>...</literal> erzeugte Array übernommen.
     </para>

     <para>
      Es ist zudem ebenfalls möglich dem <literal>...</literal> Token eine
      <link linkend="language.oop5.typehinting">Typangabe</link> voran zu
      stellen. Ist dies der Fall, müssen alle Werte, die für <literal>...</literal>
      relevant sind, vom entsprechenden Typ sein.
      
      <example>
       <title>Variable Paramter mit Vorgabe des Typs</title>
       <programlisting role="php">
<![CDATA[
<?php
function total_intervals($unit, DateInterval ...$intervals) {
    $time = 0;
    foreach ($intervals as $interval) {
        $time += $interval->$unit;
    }
    return $time;
}

$a = new DateInterval('P1D');
$b = new DateInterval('P2D');
echo total_intervals('d', $a, $b).' days';

// Dieser Aufruf wird scheitern, da null keine Instanz von DateInterval ist
echo total_intervals('d', null);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
3 days
Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2
]]>
       </screen>
      </example>
     </para>

     <para>
      Durch ein voran gestelltes <literal>&amp;</literal> ist auch die Übergabe
      <link linkend="functions.arguments.by-reference">als Referenz</link>
      möglich.
     </para>
    </sect3>

    <sect3 xml:id="functions.variable-arg-list.old">
     <title>Ältere Versionen von PHP</title>

     <para>
      Eine spezielle Syntax ist zur Definition von variablen Paramtern nicht
      notwendig. Um auf die übergebenen Werte zugreifen zu können, stehen
      die Funktionen <function>func_num_args</function>,
      <function>func_get_arg</function> und <function>func_get_args</function>
      bereit.
     </para>

     <para>
      Das erste Beispiel von weiter oben würde in PHP 5.5 und früher so
      umgesetzt werden können:
      
      <example>
       <title>Zugriff auf variable Parameter in PHP 5.5 und früher</title>
       <programlisting role="php">
<![CDATA[
<?php
function sum() {
    $acc = 0;
    foreach (func_get_args() as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
10
]]>
       </screen>
      </example>
     </para>
    </sect3>

   </sect2>

  </sect1>

  <sect1 xml:id="functions.returning-values">
   <title>Rückgabewerte</title>

   <para>
    Sie können Werte mit dem optionalen Befehl "return" zurückgeben.
    Es können Variablen jeden Typs zurückgegeben werden, auch Arrays
    oder Objekte. Dies beendet sofort die Funktion und die Kontrolle
    wird wieder an die aufrufende Zeile zurückgegeben. Weitere
    Informationen finden Sie unter <function>return</function>.
   </para>

   <note>
    <para>
     Wird <function>return</function> ausgelassen, dann wird der Wert &null;
     zurückgegeben.
    </para>
   </note>
   
   <sect2>
    <title>Einsatz von return</title>
   <para>
    <example>
     <title>Einsatz von <function>return</function></title>
     <programlisting role="php">
<![CDATA[
<?php
function quadrat($zahl)
{
    return $zahl * $zahl;
}
echo quadrat(4);   // gibt '16' aus.

?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Es ist nicht möglich, mehrere Werte von einer Funktion zurückzugeben.
    Ein ähnliches Resultat kann man aber durch die Rückgabe eines Arrays
    erreichen.
   </para>

   <para>
    <example>
    <title>Rückgabe mehrere Werte in Arrays</title>
     <programlisting role="php">
<![CDATA[
<?php
function kleine_zahlen()
{
   return array (0, 1, 2);
}
list ($null, $eins, $zwei) = kleine_zahlen();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Um von einer Funktion eine Referenz zurückzugeben, müssen Sie
    den Referenz-Operator &amp; sowohl in der Funktionsdeklaration,
    als auch bei der Zuweisung des zurückgegebenen Wertes verwenden:
   </para>

   <para>
    <example>
     <title>Rückgabe von Referenzen</title>
     <programlisting role="php">
<![CDATA[
<?php
function &returniere_referenz()
{
    return $einereferenz;
}

$neuereferenz =& returniere_referenz();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Weitere Informationen über Referenzen finden Sie im Kapitel
    <link linkend="language.references">Referenzen in PHP</link>.
   </simpara>
  </sect2>

  <sect2 xml:id="functions.returning-values.type-declaration">
   <title>Return type declarations</title>

   <para>
    PHP 7 adds support for return type declarations. Similarly to
    <link linkend="functions.arguments.type-declaration">argument type declarations</link>,
    return type declarations specify the type of the value that will be
    returned from a function. The same
    <link linkend="functions.arguments.type-declaration.types">types</link>
    are available for return type declarations as are available for argument
    type declarations.
   </para>

   <para>
    <link linkend="functions.arguments.type-declaration.strict">Strict typing</link>
    also has an effect on return type declarations. In the default weak mode,
    returned values will be coerced to the correct type if they are not
    already of that type. In strong mode, the returned value must be of the
    correct type, otherwise a <classname>TypeError</classname> will be thrown.
   </para>

   <note>
    <para>
     When overriding a parent method, the child's method must match any return
     type declaration on the parent. If the parent doesn't define a return
     type, then the child method may do so.
    </para>
   </note>

   <sect3 xml:id="functions.returning-values.type-declaration.examples">
    &reftitle.examples;

    <example>
     <title>Basic return type declaration</title>
     <programlisting role="php">
<![CDATA[
<?php
function sum($a, $b): float {
    return $a + $b;
}

// Note that a float will be returned.
var_dump(sum(1, 2));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
float(3)
]]>
      </screen>
     </example>

     <example>
      <title>Strict mode in action</title>
      <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum($a, $b): int {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1, 2.5));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)

Fatal error: Uncaught TypeError: Return value of sum() must be of the type integer, float returned in - on line 5 in -:5
Stack trace:
#0 -(9): sum(1, 2.5)
#1 {main}
  thrown in - on line 5
]]>
      </screen>
     </example>

     <example>
      <title>Returning an object</title>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

function getC(): C {
    return new C;
}

var_dump(getC());
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
object(C)#1 (0) {
}
]]>
      </screen>
     </example>
    </sect3>
   </sect2>
  </sect1>
 
  <sect1 xml:id="functions.variable-functions">
   <title>Variablenfunktionen</title>

   <para>
    PHP unterstützt das Konzept der Variablenfunktionen. Wenn Sie an
    das Ende einer Variablen Klammern hängen, versucht PHP eine
    Funktion aufzurufen, deren Name der aktuelle Wert der Variablen
    ist. Dies kann unter anderem für Callbacks, Funktionstabellen,
    usw. genutzt werden.
   </para>
   <para>
    Variablenfunktionen funktionieren nicht mit Sprachkonstrukten
    wie <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function> und
    <function>require</function>. Sie müssen Ihre eigenen Wrapperfunktionen
    verwenden, um diese Konstrukte als variable Funktionen benutzen zu
    können.
   </para>
   <para>
    <example>
     <title>Beispiel für Variablenfunktionen</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
    echo "In foo()<br />\n";
}

function bar($arg = '')
{
    echo "In bar(); der Parameter ist '$arg'.<br />\n";
}

// Dies ist eine Wrapperfunkiton für echo
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // Dies ruft foo() auf

$func = 'bar';
$func('test');  // Dies ruft bar() auf

$func = 'echoit';
$func('test');  // Dies ruft echoit() auf
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Sie können auch die Methode eines Objektes mittels der variablen
    Funktionen aufrufen.
    <example>
     <title>Variable Methode</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // Dies ruft die Bar() Methode auf
    }

    function Bar()
    {
        echo "Das ist Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();   // Dies ruft $foo->Variable() auf

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    When calling static methods, the function call is stronger than the static property operator:
    <example>
     <title>Variable method example with static properties</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static $variable = 'static property';
    static function Variable()
    {
        echo 'Method Variable called';
    }
}

echo Foo::$variable; // This prints 'static property'. It does need a $variable in this scope.
$variable = "Variable";
Foo::$variable();  // This calls $foo->Variable() reading $variable in this scope.

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
     As of PHP 5.4.0, you can call any <type>callable</type> stored in a variable.
    <example>
     <title>Complex callables</title>
     <programlisting role="php">
<![CDATA[
class Foo
{
    static function bar()
    {
        echo "bar\n";
    }
    function baz()
    {
        echo "baz\n";
    }
}

$func = array("Foo", "bar");
$func(); // prints "bar"
$f = array(new Foo, "baz");
$func(); // prints "baz"
$f = "Foo::bar";
$func(); // prints "bar" as of PHP 7.0.0; prior, it raised a fatal error
]]>
     </programlisting>
    </example>
   </para>
      
   <para>
    Siehe auch <function>is_callable</function>,
    <function>call_user_func</function>,
    <link linkend="language.variables.variable">Variable Variablen</link> und
    <function>function_exists</function>.
   </para>
   
   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>7.0.0</entry>
         <entry>
          'ClassName::methodName' is allowed as variable function.
         </entry>
        </row>
        <row>
         <entry>5.4.0</entry>
         <entry>
          Arrays, which are valid callables, are allowed as variable functions.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="functions.internal">
   <title>Interne (eingebaute) Funktionen</title>

   <para>
    PHP enthält standmäßig viele Funktionen und Konstrukte, weiterhin
    gibt es viele Funktionen die vorausssetzen, dass bestimmte PHP-Extensions
    einkompiliert wurden, anderenfalls erhalten Sie beim
    Aufruf "undefined function"-Fehlermeldungen.
    Um z.B. <link linkend="ref.image">Grafik-Funktionen</link> wie
    <function>imagecreatetruecolor</function> zu nutzen, müssen Sie PHP mit
    <productname>GD</productname>-Unterstützung kompilieren, oder um
    <function>mysql_connect</function> zu nutzen, muss Ihr PHP mit <link
    linkend="ref.mysql">MySQL</link>-Unterstützung kompiliert sein.
    Viele Kernfunktionen wie z.B. die <link
    linkend="ref.strings">String</link>- und <link
    linkend="ref.var">Variablen</link>-Funktionen sind bereits in
    jeder PHP-Version enthalten. Ein Aufruf von <function>phpinfo</function>
    oder <function>get_loaded_extensions</function> zeigt Ihnen, welche
    Extensions in Ihrer PHP-Installation verfügbar sind.
    Beachten Sie weiterhin, dass viele Extensions bereits standardmäßig
    aktiviert sind und das PHP-Manual nach Extensions unterteilt ist.
    Weitere Informationen zur Einrichtung von PHP finden Sie in den
    Kapiteln <link linkend="configuration">Konfiguration</link>,
    <link linkend="install">Installation</link> und den Kapiteln
    zu den einzelnen Extensions.
   </para>
   <para>
    Wie Funktionsprototypen zu lesen und zu verstehen sind, ist im
    Kapitel '<link linkend="about.prototypes">Wie man eine Funktionsdefinition
    (Prototyp) liest'</link> erklärt.
    Es ist wichtig zu erkennen, was eine Funktion zurückgibt und ob
    die übergebenen Parameter verändert werden. So gibt z.B.
    <function>str_replace</function> den bearbeiteten String zurück,
    während <function>usort</function> direkt auf der übergebenen
    Variablen arbeitet.
    Jede Handbuchseite enthält spezifische Informationen für jede
    Funktion wie ihre Parameter, die Rückgabewerte sowohl bei Erfolg
    als auch im Fehlerfall, Änderungen des Verhaltens und die Verfügbarkeit.
    Die Kenntnis dieser wichtigen (und oft subtilen) Unterschiede ist
    von entscheidender Bedeutung für das Schreiben korrekten PHP-Codes.
   </para>
   <note>
    <simpara>
     Wenn Funktionen andere Parameter erhalten als erwartet, d.h. wenn z.B.
     ein <type>array</type> übergeben wird obwohl ein <type>string</type>
     erwartet wird, so ist der Rückgabewert undefiniert. In solchen Fällen
     ist es üblich, dass &null; zurückgegeben wird, dies ist aber nur eine
     Konvention, auf die Sie sich nicht unbedingt verlassen können.
    </simpara>
   </note>
   <para>
    Siehe auch <function>function_exists</function>,
    <link linkend="funcref">the function reference</link>,
    <function>get_extension_funcs</function> und
    <function>dl</function>.
   </para>
  </sect1>

  <sect1 xml:id="functions.anonymous">
   <title>Anonymous functions</title>

   <simpara>
    Anonyme Funktionen, auch bekannt als  <literal>closures</literal>, ermöglichen es Funktionen ohne Funktionsnamen zu schreiben. Sie sind am wertvollsten als Callback <link linkend="language.types.callback">callback</link>
    Parameter, haben aber noch viele andere Verwendungsmöglichkeiten.
   </simpara>

   <example>
    <title>Beispiel für eine anonyme Funktion</title>
    <programlisting role="php">
<![CDATA[
<?php
echo preg_replace_callback('~-([a-z])~', function ($match) {
    return strtoupper($match[1]);
}, 'hello-world');
// outputs helloWorld
?>
]]>
    </programlisting>
   </example>

   <simpara>
    Closures können auch als Werte von Variablen verwendet werden;
    PHP konvertiert solche Ausdrücke automatisch in Instanzen der internen Klasse <classname>Closure</classname>.
    Assigning a closure to a
    variable uses the same syntax as any other assignment, including the
    trailing semicolon:
   </simpara>

   <example>
    <title>Anonymous function variable assignment example</title>
    <programlisting role="php">
<![CDATA[
<?php
$greet = function($name)
{
    printf("Hello %s\r\n", $name);
};

$greet('World');
$greet('PHP');
?>
]]>
    </programlisting>
   </example>
   
   <simpara>
    Closures may also inherit variables from the parent scope. 
    Any such variables must be passed to the <literal>use</literal> language construct. 
   </simpara>

   <example>
    <title>Inheriting variables from the parent scope</title>
    <programlisting role="php">
<![CDATA[
<?php
$message = 'hello';

// No "use"
$example = function () {
    var_dump($message);
};
$example();

// Inherit $message
$example = function () use ($message) {
    var_dump($message);
};
$example();

// Inherited variable's value is from when the function
// is defined, not when called
$message = 'world';
$example();

// Reset message
$message = 'hello';

// Inherit by-reference
$example = function () use (&$message) {
    var_dump($message);
};
$example();

// The changed value in the parent scope
// is reflected inside the function call
$message = 'world';
$example();

// Closures can also accept regular arguments
$example = function ($arg) use ($message) {
    var_dump($arg . ' ' . $message);
};
$example("hello");
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
Notice: Undefined variable: message in /example.php on line 6
NULL
string(5) "hello"
string(5) "hello"
string(5) "hello"
string(5) "world"
string(11) "hello world"
]]>
    </screen>
   </example>

   <simpara>
    Inheriting variables from the parent scope is <emphasis>not</emphasis> 
    the same as using global variables. 
    Global variables exist in the global scope, which is the same no
    matter what function is executing. The parent scope of a closure is the
    function in which the closure was declared (not necessarily the function it
    was called from). See the following example:
   </simpara>

   <example>
    <title>Closures and scoping</title>
    <programlisting role="php">
<![CDATA[
<?php
// A basic shopping cart which contains a list of added products
// and the quantity of each product. Includes a method which
// calculates the total price of the items in the cart using a
// closure as a callback.
class Cart
{
    const PRICE_BUTTER  = 1.00;
    const PRICE_MILK    = 3.00;
    const PRICE_EGGS    = 6.95;

    protected $products = array();
    
    public function add($product, $quantity)
    {
        $this->products[$product] = $quantity;
    }
    
    public function getQuantity($product)
    {
        return isset($this->products[$product]) ? $this->products[$product] :
               FALSE;
    }
    
    public function getTotal($tax)
    {
        $total = 0.00;
        
        $callback =
            function ($quantity, $product) use ($tax, &$total)
            {
                $pricePerItem = constant(__CLASS__ . "::PRICE_" .
                    strtoupper($product));
                $total += ($pricePerItem * $quantity) * ($tax + 1.0);
            };
        
        array_walk($this->products, $callback);
        return round($total, 2);
    }
}

$my_cart = new Cart;

// Add some items to the cart
$my_cart->add('butter', 1);
$my_cart->add('milk', 3);
$my_cart->add('eggs', 6);

// Print the total with a 5% sales tax.
print $my_cart->getTotal(0.05) . "\n";
// The result is 54.29
?>
]]>
    </programlisting>
   </example>
   
   <simpara>
    Anonymous functions are implemented using the <link linkend="class.closure">
    <classname>Closure</classname></link> class.
   </simpara>
   
   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>5.4.0</entry>
         <entry>
          <varname>$this</varname> can be used in anonymous functions.
         </entry>
        </row>
        <row>
         <entry>5.3.0</entry>
         <entry>
          Anonymous functions become available.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>

   <sect2 role="notes">
    &reftitle.notes;
    <note>
     <simpara>
      It is possible to use <function>func_num_args</function>,
      <function>func_get_arg</function>, and <function>func_get_args</function>
      from within a closure.
     </simpara>
    </note>
   </sect2>

  </sect1>

 </chapter>
 
 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"~/.phpdoc/manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 -->
